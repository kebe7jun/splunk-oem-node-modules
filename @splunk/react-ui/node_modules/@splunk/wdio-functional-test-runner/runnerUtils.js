'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.guessNonInternalAddress = guessNonInternalAddress;
exports.getSpecList = getSpecList;
exports.specToFixture = specToFixture;
exports.runWebpackCompilation = runWebpackCompilation;
exports.getState = getState;

var _findUp = require('find-up');

var _findUp2 = _interopRequireDefault(_findUp);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _intel = require('intel');

var _intel2 = _interopRequireDefault(_intel);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function guessNonInternalAddress() {
    var firstNonInternal4 = (0, _lodash2.default)(_os2.default.networkInterfaces()).values().flatten().reject(function (i) {
        return i.internal || i.family !== 'IPv4';
    }).first();

    return firstNonInternal4 ? firstNonInternal4.address : '127.0.0.1';
}

function getSpecList(settings) {
    var specList = void 0;
    var globOptions = { ignore: '**/node_modules/**' };

    if (_lodash2.default.isEmpty(settings.filter)) {
        specList = _glob2.default.sync('**/*' + settings.specExtension, _extends({}, globOptions, {
            cwd: settings.sourcePath
        }));
    } else {
        specList = (0, _lodash2.default)(settings.filter).map(function (filter) {
            return (/^[a-z0-9]+$/i.test(filter) ? '**/' + filter + '/**' : filter
            );
        }).map(function (filter) {
            return _glob2.default.sync(filter, _extends({}, globOptions, { cwd: settings.sourcePath }));
        }).flatten().filter(function (spec) {
            return _lodash2.default.endsWith(spec, settings.specExtension);
        }).value();
    }

    return specList;
}

// a.b.c => ['a.b.c', 'a.b', 'a']
var fixtureMutations = function fixtureMutations(fixtureName) {
    var mutations = [fixtureName];
    var mutation = fixtureName;
    while (mutation.includes('.')) {
        mutation = mutation.slice(0, mutation.lastIndexOf('.'));
        mutations.push(mutation);
    }
    return mutations;
};

function specToFixture(spec, settings) {
    var specPath = _path2.default.join(settings.sourcePath, spec);

    var fixtureName = _path2.default.basename(specPath, settings.specExtension);
    var possibleNames = fixtureMutations(fixtureName).map(function (name) {
        return '' + name + settings.fixtureExtension;
    });

    var result = null;
    possibleNames.find(function (name) {
        var candidate = _findUp2.default.sync(name, { cwd: specPath });
        result = candidate !== null && !_path2.default.relative(settings.sourcePath, candidate).startsWith('..') ? candidate : null;
        return result;
    });

    if (result === null) {
        throw new Error('No matching fixture found for spec: ' + spec);
    }

    return _path2.default.relative(settings.sourcePath, result);
}

function runWebpackCompilation(webpackConfig) {
    return new Promise(function (f, r) {
        (0, _webpack2.default)(webpackConfig).run(function (err, stats) {
            if (err || stats.hasErrors()) {
                _intel2.default.error(stats.toString());
                r('Error during webpack compilation');
            } else {
                var statsLevel = stats.hasWarnings() ? 'warn' : 'debug';
                _intel2.default[statsLevel](stats.toString(statsLevel === 'warn' ? 'normal' : 'minimal'));
                f();
            }
        });
    });
}

function getState(config, component) {
    var stateFile = _path2.default.join(config.suiOutputPath, 'state_' + component + '.json');

    return {
        getValue: function getValue(valuePath) {
            return _lodash2.default.get(_fsExtra2.default.readJsonSync(stateFile), valuePath);
        },


        // this function does -not- lock. setting state from multiple processes can be dangerous,
        // only use this if you can guarantee component-level exclusivity (e.g. wdio's onPrepare())
        setValue: function setValue(valuePath, value) {
            var state = _fsExtra2.default.readJsonSync(stateFile, { throws: false }) || {};
            _lodash2.default.set(state, valuePath, value);
            _fsExtra2.default.writeJsonSync(stateFile, state);
        }
    };
}