'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global browser */

var _execa = require('execa');

var _execa2 = _interopRequireDefault(_execa);

var _fs = require('fs');

var _intel = require('intel');

var _intel2 = _interopRequireDefault(_intel);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _tar = require('tar');

var _tar2 = _interopRequireDefault(_tar);

var _runnerUtils = require('./runnerUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OrcaService = function () {
    function OrcaService(settings, state) {
        _classCallCheck(this, OrcaService);

        this.state = state;
        this.settings = settings;
        if (this.settings.when === 'global') {
            this.onComplete = this.destroyDeploment;
        } else {
            this.afterSession = this.destroyDeploment;
        }
    }

    _createClass(OrcaService, [{
        key: 'before',
        value: function before() {
            var _this = this;

            if (this.settings.exposeSplunkInfo) {
                browser.addCommand('getSplunkInfo', function () {
                    return _this.splunkInfo;
                });
            }
        }
    }, {
        key: 'beforeSession',
        value: function beforeSession(config) {
            var _this2 = this;

            // in global mode the deployment url is retrieved from shared state, in
            // session mode a new deployment is created for every session
            if (this.settings.when === 'global') {
                this.splunkInfo = this.state.getValue(['orca', 'splunkInfo']);
                config.baseUrl = this.splunkInfo.splunkweb + '/app/';
                return null;
            }
            return this.createDeployment().then(function (splunkInfo) {
                _this2.splunkInfo = splunkInfo;
                config.baseUrl = _this2.splunkInfo.splunkweb + '/app/';
            });
        }
    }, {
        key: 'onPrepare',
        value: function onPrepare() {
            var _this3 = this;

            var preparePromise = Promise.resolve();
            if (this.settings.appPath) {
                _intel2.default.debug('Creating tgz for app ' + this.settings.appName + ', path: ' + this.settings.appDir);

                var tarOptions = {
                    portable: true,
                    gzip: true,
                    cwd: this.settings.appDir,
                    file: this.settings.appName + '.tgz'
                };

                preparePromise = _tar2.default.create(tarOptions, [this.settings.appName]).then(function () {
                    _intel2.default.debug('Created app archive ' + _this3.settings.appName + '.tgz');
                });
            }
            return preparePromise.then(function () {
                return (
                    // in global mode only one deployment exists, and its url has to be passed to workers
                    // using shared state - updating the config object doesn't work (webdriverio #1687)
                    _this3.settings.when === 'global' ? _this3.createDeployment().then(function (splunkInfo) {
                        _this3.state.setValue(['orca', 'splunkInfo'], splunkInfo);
                    }) : null
                );
            });
        }
    }, {
        key: 'createDeployment',
        value: function createDeployment() {
            var _this4 = this;

            _intel2.default.debug('Creating Splunk deployment using orca');

            var runArgs = ['--printer', 'json', 'create', '--scenario', this.settings.scenario];

            if (this.settings.appPath) {
                // python orca requires an absolute path to the app tgz, docker requires a relative one
                // note that for docker this works because the working directory is mounted (as /orca-home)
                var tgz = this.settings.appName + '.tgz';
                var tgzPath = this.settings.use === 'docker' ? tgz : _path2.default.resolve(tgz);

                runArgs.push('--local-apps', tgzPath);
            }

            var execArgs = this.settings.spawnArgs.concat(runArgs);
            _intel2.default.debug('Executing cmd: ' + this.settings.spawnCommand + ', args: ' + execArgs.join(' '));
            return (0, _execa2.default)(this.settings.spawnCommand, execArgs).then(function (result) {
                var orcaResponse = void 0;
                try {
                    orcaResponse = JSON.parse(result.stdout);
                } catch (parseError) {
                    _intel2.default.error('Unable to parse ORCA response as JSON, output was:');
                    _intel2.default.error('stdout', result.stdout);
                    _intel2.default.error('stderr', result.stderr);
                    throw parseError;
                }
                // assumption: the response is always keyed by user
                var userDeployment = (0, _lodash.values)(orcaResponse)[0];

                // assumption: there's never more than one deployment
                _this4.deploymentId = Object.keys(userDeployment)[0];
                _intel2.default.debug('Orca deployment id is ' + _this4.deploymentId);

                // complex scenarios can have more than one container. for now, just find the first
                // container with role 'standalone'
                var containers = userDeployment[_this4.deploymentId].containers;
                var testContainer = (0, _lodash.find)(containers, function (container) {
                    return container.role === 'standalone';
                });
                if (testContainer) {
                    _intel2.default.debug('Orca splunkweb url is: ' + testContainer.splunk_address);
                    _intel2.default.debug('Orca splunkd url is: ' + testContainer.splunkd_address);
                    return {
                        splunkweb: testContainer.splunk_address,
                        splunkd: testContainer.splunkd_address,
                        splunkUser: 'admin',
                        splunkPassword: testContainer.splunk_password
                    };
                }
                throw new Error('Unable to find standalone container in output. This might be an unsupported scenario.');
            });
        }
    }, {
        key: 'destroyDeploment',
        value: function destroyDeploment() {
            if (this.deploymentId) {
                _intel2.default.debug('Destroying orca deployment with id ' + this.deploymentId);

                var runArgs = ['destroy', this.deploymentId];
                var execArgs = this.settings.spawnArgs.concat(runArgs);
                _intel2.default.debug('Executing cmd: ' + this.settings.spawnCommand + ', args: ' + execArgs.join(' '));
                return (0, _execa2.default)(this.settings.spawnCommand, execArgs).then(function () {
                    _intel2.default.debug('Orca deployment destroyed');
                });
            }

            _intel2.default.debug('No orca deployment to destroy');
            return null;
        }
    }]);

    return OrcaService;
}();

exports.default = function (config, incomingSettings) {
    var settings = _extends({
        use: 'docker',
        when: 'session',
        version: null, // we don't pin to a specific orca image version by default
        local: false,
        scenario: 'standalone_generic',
        exposeSplunkInfo: false
    }, incomingSettings);

    if (settings.appPath) {
        settings.appDir = _path2.default.dirname(settings.appPath);
        settings.appName = _path2.default.basename(settings.appPath);
    } else if (incomingSettings.scenario === undefined) {
        throw new Error('Orca settings must include appPath or scenario');
    }

    if (settings.use === 'docker') {
        settings.spawnCommand = 'docker';
        var versionSuffix = settings.version ? ':' + settings.version : '';
        settings.spawnArgs = ['run', '--rm', '-e', 'USER=' + process.env.USER, '-v', '/var/run/docker.sock:/var/run/docker.sock', '-v', process.env.HOME + '/.orca:/root/.orca', '-v', process.env.HOME + '/.ssh:/root/.ssh', '-v', process.env.HOME + '/.docker:/root/.docker', '-v', (0, _fs.realpathSync)(process.cwd()) + ':/orca-home', 'repo.splunk.com/splunk/products/orca' + versionSuffix];
    } else {
        settings.spawnCommand = 'python';
        settings.spawnArgs = ['-m', 'splunk_orca'];
    }

    if (settings.local) {
        settings.spawnArgs.push('--local');
    }

    config.services = config.services ? (0, _lodash.castArray)(config.services) : [];
    config.services.push(new OrcaService(settings, (0, _runnerUtils.getState)(config, 'orca')));

    return config;
};