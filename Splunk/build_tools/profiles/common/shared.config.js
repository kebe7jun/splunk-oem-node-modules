var fs = require('fs');
var path = require('path');
var webpack = require('webpack');
var SplunkNameModuleIdsPlugin = require('../../plugins/SplunkNameModuleIdsPlugin');
var coreAliases = require('./coreAliases.config');
var mergeConfigs = require('../../util/mergeConfigs');
var createBabelLoader = require('../../util/createBabelLoader');
var getNodeModulesPath = require('../../util/getNodeModulesPath');
var resolveLoader = require('./resolve_loader.config.js');

var exposedJsDir = path.resolve(__dirname, '../../../search_mrsparkle/exposed/js');
var utilModulePath = getNodeModulesPath('util', __dirname, path.join(process.env.SPLUNK_HOME || '', 'lib/node_modules'));

/**
 * Config settings that are likely to be shared by most (if not all) profiles
 * @type {Object}
 */
module.exports = mergeConfigs(coreAliases, resolveLoader, {
    plugins: [
        // Sets module ids to strings similar to what was generated by requirejs
        new SplunkNameModuleIdsPlugin({ context: exposedJsDir }),

        // tldr: These plugins fix require path issues in moment.
        // We have moved moment.js relative to the lang directory it depends on. These plugins point
        // moment to its lang files and vice versa. This has not been an issue because we inject
        // the moment locale in i18n.py rather than using the moment api. But, webpack complains
        // that the path cannot be resolved, so we will point it to the correct path here.
        new webpack.ContextReplacementPlugin(/^\.\/locale$/, 'contrib/moment/lang'),
        new webpack.NormalModuleReplacementPlugin(/^\.\.\/moment$/, 'moment'),

        // We use a css loader (below) to build our css files. This conflicts with the inline
        // loaders we used with requirejs. This plugin strips the inline plugin.
        // TODO: If/when we fully move to webpack with no looking back to require, we should remove
        // the inline loaders and remove this plugin.
        new webpack.NormalModuleReplacementPlugin(/css\!/, function (module) {
            module.request = module.request.replace('css!', '');
            if (!/\.css$/.test(module.request)) {
                module.request += '.css';
            }
        }),

        // Squelch other webpack loaders when the requirejs contrib/text loader
        // is used. This prevents using the loader twice.
        new webpack.NormalModuleReplacementPlugin(/contrib\/text\!/, function (module) {
            module.request = '!!' + module.request;
        }),

        // add polyfills for IE11
        new webpack.ProvidePlugin({
            'fetch': 'imports?this=>global!exports?global.fetch!whatwg-fetch'
        }),
    ].concat(utilModulePath ? [
        // node_modules/util conflicts with search_mrsparkle/exposed/js/util - by default
        // every module importing 'util' will get Splunk's util (resolve.root has
        // precedence over node_modules). This breaks external modules, so make sure
        // they use the node_modules/util package.
        new webpack.NormalModuleReplacementPlugin(/^util$/, function (module) {
            if (!module.context.includes('/search_mrsparkle/')) {
                module.request = utilModulePath;
            }
        })
    ] : []),
    module: {
        // Loader order matters - Webpack executes loaders right to left
        loaders: [
            // This help to fix issue SPL-144317 and SUI-1042. Leaks lodash out to global
            // The issue caused by https://github.com/lodash/lodash/issues/1798
            // So, opting out of AMD parsing for lodash
            {
                test: /lodash/,
                loader: 'imports?define=>false'
            },
            {
                test: /\.css$/,
                loader: 'style-loader!css-loader'
            },
            {
                test: /\.less$/,
                loader: 'style-loader!css-loader!less-loader'
            },
            {
                test: /\.json$/,
                loader: 'json-loader'
            },
            {
                test: /\.(jpe?g|png|gif)$/i,
                loaders: [
                    'url-loader?name=../images/[name].[ext]&limit=130000'
                ]
            },
            {
                test: /\.svg$/,
                loaders: [
                    'url-loader?name=../images/[name].[ext]&limit=20000'
                ]
            },
            {
                test: /\.(woff|ttf)$/,
                loader: 'url-loader?name=../fonts/[name].[ext]&limit=20000'
            },
            // Inject an import for the ES6 global polyfills into .es/.jsx files.
            {
                test: /(\.es$|\.jsx$)/,
                loader: 'splunk-es6-polyfill'
            },
            createBabelLoader({
                test: /\.es$/,
                include: /search_mrsparkle/,
                presets: ['babel-preset-es2015']
            }),
            createBabelLoader({
                test: /\.jsx$/,
                include: /search_mrsparkle/,
                presets: ['babel-preset-es2015', 'babel-preset-react']
            })
        ]
    },
    resolveLoader: {
        alias: {
            'contrib/text': 'raw-loader'
        }
    },
    resolve: {
        root: [ exposedJsDir ],
        extensions: ['', '.js', '.es', '.jsx'],

        // For apps located outside 'web' to be able to resolve babel-runtime:
        //  (related? https://github.com/webpack/webpack/issues/784)
        fallback: [
            path.join(__dirname, '../../../node_modules'),
            path.join(process.env.SPLUNK_HOME || '', 'lib', 'node_modules')
        ]
    }
});
