/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {\n    // webpack doesn't make things globabl by default\n    // promoting this to globabl for backwards compatability\n    window.$ = __webpack_require__(\"shim/jquery\");\n    window.$C = window.$C || {};\n    window.$C.INDEPENDENT_MODE = false;\n    var define = __webpack_require__(\"shim/requirejsDefine\");\n    var _ = __webpack_require__(\"require/underscore\");\n\n    var exposedModules = __webpack_require__(261);\n\n    _.forEach(exposedModules, function(mod, key) {\n        define(key, function() {\n            return mod;\n        });\n    });\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvYnVpbGRfdG9vbHMvcHJvZmlsZXMvc2luZ2xlX3ZhbHVlL2luZGV4LmpzPzA5NDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImtDQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuICAgIC8vIHdlYnBhY2sgZG9lc24ndCBtYWtlIHRoaW5ncyBnbG9iYWJsIGJ5IGRlZmF1bHRcbiAgICAvLyBwcm9tb3RpbmcgdGhpcyB0byBnbG9iYWJsIGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eVxuICAgIHdpbmRvdy4kID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG4gICAgd2luZG93LiRDID0gd2luZG93LiRDIHx8IHt9O1xuICAgIHdpbmRvdy4kQy5JTkRFUEVOREVOVF9NT0RFID0gZmFsc2U7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ3NoaW0vcmVxdWlyZWpzRGVmaW5lJyk7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbiAgICB2YXIgZXhwb3NlZE1vZHVsZXMgPSByZXF1aXJlKCcuL2V4cG9zZWRNb2R1bGVzJyk7XG5cbiAgICBfLmZvckVhY2goZXhwb3NlZE1vZHVsZXMsIGZ1bmN0aW9uKG1vZCwga2V5KSB7XG4gICAgICAgIGRlZmluZShrZXksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL2J1aWxkX3Rvb2xzL3Byb2ZpbGVzL3NpbmdsZV92YWx1ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/jg_lib/utils/NumberUtil":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, function(NumberUtil)\n\t{\n\n\t\t// Public Static Constants\n\n\t\tNumberUtil.PRECISION = (function()\n\t\t{\n\t\t\tvar prec = 0;\n\t\t\tvar test = 9;\n\t\t\tvar loops = 0;\n\t\t\twhile ((test % 10) === 9)\n\t\t\t{\n\t\t\t\tprec++;\n\t\t\t\ttest = test * 10 + 9;\n\t\t\t\tif (++loops > 100)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn prec;\n\t\t})();\n\n\t\tNumberUtil.EPSILON = (function()\n\t\t{\n\t\t\tvar eps = 1;\n\t\t\tvar test = 1;\n\t\t\tvar loops = 0;\n\t\t\twhile ((1 + test) > 1)\n\t\t\t{\n\t\t\t\teps = test;\n\t\t\t\ttest /= 2;\n\t\t\t\tif (++loops > 100)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn eps;\n\t\t})();\n\n\t\t// Public Static Methods\n\n\t\tNumberUtil.interpolate = function(num1, num2, ratio)\n\t\t{\n\t\t\treturn num1 * (1 - ratio) + num2 * ratio;\n\t\t};\n\n\t\tNumberUtil.minMax = function(num, min, max)\n\t\t{\n\t\t\tnum = +num;\n\t\t\tmin = +min;\n\t\t\tmax = +max;\n\n\t\t\tif (num < min)\n\t\t\t\tnum = min;\n\t\t\tif (num > max)\n\t\t\t\tnum = max;\n\n\t\t\treturn num;\n\t\t};\n\n\t\tNumberUtil.maxMin = function(num, max, min)\n\t\t{\n\t\t\tnum = +num;\n\t\t\tmax = +max;\n\t\t\tmin = +min;\n\n\t\t\tif (num > max)\n\t\t\t\tnum = max;\n\t\t\tif (num < min)\n\t\t\t\tnum = min;\n\n\t\t\treturn num;\n\t\t};\n\n\t\tNumberUtil.roundTo = function(num, units)\n\t\t{\n\t\t\tnum = +num;\n\t\t\tunits = (units != null) ? +units : 1;\n\n\t\t\tif (units > 0)\n\t\t\t\tnum = Math.round(num / units) * units;\n\n\t\t\treturn NumberUtil.toPrecision(num);\n\t\t};\n\n\t\tNumberUtil.floorTo = function(num, units)\n\t\t{\n\t\t\tnum = +num;\n\t\t\tunits = (units != null) ? +units : 1;\n\n\t\t\tif (units > 0)\n\t\t\t\tnum = Math.floor(num / units) * units;\n\n\t\t\treturn NumberUtil.toPrecision(num);\n\t\t};\n\n\t\tNumberUtil.ceilTo = function(num, units)\n\t\t{\n\t\t\tnum = +num;\n\t\t\tunits = (units != null) ? +units : 1;\n\n\t\t\tif (units > 0)\n\t\t\t\tnum = Math.ceil(num / units) * units;\n\n\t\t\treturn NumberUtil.toPrecision(num);\n\t\t};\n\n\t\tNumberUtil.toPrecision = function(num, digits)\n\t\t{\n\t\t\tnum = +num;\n\t\t\tdigits = (digits != null) ? +digits : 0;\n\n\t\t\tif (digits > 0)\n\t\t\t\tdigits = Math.floor(digits);\n\t\t\telse if (digits < 0)\n\t\t\t\tdigits = NumberUtil.PRECISION + Math.ceil(digits);\n\t\t\telse\n\t\t\t\tdigits = NumberUtil.PRECISION;\n\n\t\t\tif (digits < 1)\n\t\t\t\tdigits = 1;\n\t\t\telse if (digits > 21)\n\t\t\t\tdigits = 21;\n\n\t\t\treturn +(num.toPrecision(digits));\n\t\t};\n\n\t\tNumberUtil.approxZero = function(num, threshold)\n\t\t{\n\t\t\tnum = +num;\n\n\t\t\tif (num === 0)\n\t\t\t\treturn true;\n\n\t\t\tthreshold = (threshold != null) ? +threshold : NumberUtil.EPSILON;\n\n\t\t\treturn (num < 0) ? (-num < threshold) : (num < threshold);\n\t\t};\n\n\t\tNumberUtil.approxOne = function(num, threshold)\n\t\t{\n\t\t\tnum = +num;\n\n\t\t\tif (num === 1)\n\t\t\t\treturn true;\n\n\t\t\tthreshold = (threshold != null) ? +threshold : NumberUtil.EPSILON;\n\t\t\tnum -= 1;\n\n\t\t\treturn (num < 0) ? (-num < threshold) : (num < threshold);\n\t\t};\n\n\t\tNumberUtil.approxEqual = function(num1, num2, threshold)\n\t\t{\n\t\t\tnum1 = +num1;\n\t\t\tnum2 = +num2;\n\n\t\t\tif (num1 === num2)\n\t\t\t\treturn true;\n\n\t\t\tthreshold = (threshold != null) ? +threshold : NumberUtil.EPSILON;\n\t\t\tnum1 -= num2;\n\n\t\t\treturn (num1 < 0) ? (-num1 < threshold) : (num1 < threshold);\n\t\t};\n\n\t\tNumberUtil.approxLessThan = function(num1, num2, threshold)\n\t\t{\n\t\t\tnum1 = +num1;\n\t\t\tnum2 = +num2;\n\n\t\t\treturn ((num1 < num2) && !NumberUtil.approxEqual(num1, num2, threshold));\n\t\t};\n\n\t\tNumberUtil.approxLessThanOrEqual = function(num1, num2, threshold)\n\t\t{\n\t\t\tnum1 = +num1;\n\t\t\tnum2 = +num2;\n\n\t\t\treturn ((num1 < num2) || NumberUtil.approxEqual(num1, num2, threshold));\n\t\t};\n\n\t\tNumberUtil.approxGreaterThan = function(num1, num2, threshold)\n\t\t{\n\t\t\tnum1 = +num1;\n\t\t\tnum2 = +num2;\n\n\t\t\treturn ((num1 > num2) && !NumberUtil.approxEqual(num1, num2, threshold));\n\t\t};\n\n\t\tNumberUtil.approxGreaterThanOrEqual = function(num1, num2, threshold)\n\t\t{\n\t\t\tnum1 = +num1;\n\t\t\tnum2 = +num2;\n\n\t\t\treturn ((num1 > num2) || NumberUtil.approxEqual(num1, num2, threshold));\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL051bWJlclV0aWwuanM/ZjcwNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRixDQUFDIiwiZmlsZSI6ImNvbnRyaWIvamdfbGliL3V0aWxzL051bWJlclV0aWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAwNy0yMDE2IEphc29uIEdhdHRcbiAqIFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKVxue1xuXG5cdHZhciBDbGFzcyA9IHJlcXVpcmUoXCIuLi9DbGFzc1wiKTtcblxuXHRyZXR1cm4gQ2xhc3MobW9kdWxlLmlkLCBmdW5jdGlvbihOdW1iZXJVdGlsKVxuXHR7XG5cblx0XHQvLyBQdWJsaWMgU3RhdGljIENvbnN0YW50c1xuXG5cdFx0TnVtYmVyVXRpbC5QUkVDSVNJT04gPSAoZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHZhciBwcmVjID0gMDtcblx0XHRcdHZhciB0ZXN0ID0gOTtcblx0XHRcdHZhciBsb29wcyA9IDA7XG5cdFx0XHR3aGlsZSAoKHRlc3QgJSAxMCkgPT09IDkpXG5cdFx0XHR7XG5cdFx0XHRcdHByZWMrKztcblx0XHRcdFx0dGVzdCA9IHRlc3QgKiAxMCArIDk7XG5cdFx0XHRcdGlmICgrK2xvb3BzID4gMTAwKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZWM7XG5cdFx0fSkoKTtcblxuXHRcdE51bWJlclV0aWwuRVBTSUxPTiA9IChmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dmFyIGVwcyA9IDE7XG5cdFx0XHR2YXIgdGVzdCA9IDE7XG5cdFx0XHR2YXIgbG9vcHMgPSAwO1xuXHRcdFx0d2hpbGUgKCgxICsgdGVzdCkgPiAxKVxuXHRcdFx0e1xuXHRcdFx0XHRlcHMgPSB0ZXN0O1xuXHRcdFx0XHR0ZXN0IC89IDI7XG5cdFx0XHRcdGlmICgrK2xvb3BzID4gMTAwKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVwcztcblx0XHR9KSgpO1xuXG5cdFx0Ly8gUHVibGljIFN0YXRpYyBNZXRob2RzXG5cblx0XHROdW1iZXJVdGlsLmludGVycG9sYXRlID0gZnVuY3Rpb24obnVtMSwgbnVtMiwgcmF0aW8pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG51bTEgKiAoMSAtIHJhdGlvKSArIG51bTIgKiByYXRpbztcblx0XHR9O1xuXG5cdFx0TnVtYmVyVXRpbC5taW5NYXggPSBmdW5jdGlvbihudW0sIG1pbiwgbWF4KVxuXHRcdHtcblx0XHRcdG51bSA9ICtudW07XG5cdFx0XHRtaW4gPSArbWluO1xuXHRcdFx0bWF4ID0gK21heDtcblxuXHRcdFx0aWYgKG51bSA8IG1pbilcblx0XHRcdFx0bnVtID0gbWluO1xuXHRcdFx0aWYgKG51bSA+IG1heClcblx0XHRcdFx0bnVtID0gbWF4O1xuXG5cdFx0XHRyZXR1cm4gbnVtO1xuXHRcdH07XG5cblx0XHROdW1iZXJVdGlsLm1heE1pbiA9IGZ1bmN0aW9uKG51bSwgbWF4LCBtaW4pXG5cdFx0e1xuXHRcdFx0bnVtID0gK251bTtcblx0XHRcdG1heCA9ICttYXg7XG5cdFx0XHRtaW4gPSArbWluO1xuXG5cdFx0XHRpZiAobnVtID4gbWF4KVxuXHRcdFx0XHRudW0gPSBtYXg7XG5cdFx0XHRpZiAobnVtIDwgbWluKVxuXHRcdFx0XHRudW0gPSBtaW47XG5cblx0XHRcdHJldHVybiBudW07XG5cdFx0fTtcblxuXHRcdE51bWJlclV0aWwucm91bmRUbyA9IGZ1bmN0aW9uKG51bSwgdW5pdHMpXG5cdFx0e1xuXHRcdFx0bnVtID0gK251bTtcblx0XHRcdHVuaXRzID0gKHVuaXRzICE9IG51bGwpID8gK3VuaXRzIDogMTtcblxuXHRcdFx0aWYgKHVuaXRzID4gMClcblx0XHRcdFx0bnVtID0gTWF0aC5yb3VuZChudW0gLyB1bml0cykgKiB1bml0cztcblxuXHRcdFx0cmV0dXJuIE51bWJlclV0aWwudG9QcmVjaXNpb24obnVtKTtcblx0XHR9O1xuXG5cdFx0TnVtYmVyVXRpbC5mbG9vclRvID0gZnVuY3Rpb24obnVtLCB1bml0cylcblx0XHR7XG5cdFx0XHRudW0gPSArbnVtO1xuXHRcdFx0dW5pdHMgPSAodW5pdHMgIT0gbnVsbCkgPyArdW5pdHMgOiAxO1xuXG5cdFx0XHRpZiAodW5pdHMgPiAwKVxuXHRcdFx0XHRudW0gPSBNYXRoLmZsb29yKG51bSAvIHVuaXRzKSAqIHVuaXRzO1xuXG5cdFx0XHRyZXR1cm4gTnVtYmVyVXRpbC50b1ByZWNpc2lvbihudW0pO1xuXHRcdH07XG5cblx0XHROdW1iZXJVdGlsLmNlaWxUbyA9IGZ1bmN0aW9uKG51bSwgdW5pdHMpXG5cdFx0e1xuXHRcdFx0bnVtID0gK251bTtcblx0XHRcdHVuaXRzID0gKHVuaXRzICE9IG51bGwpID8gK3VuaXRzIDogMTtcblxuXHRcdFx0aWYgKHVuaXRzID4gMClcblx0XHRcdFx0bnVtID0gTWF0aC5jZWlsKG51bSAvIHVuaXRzKSAqIHVuaXRzO1xuXG5cdFx0XHRyZXR1cm4gTnVtYmVyVXRpbC50b1ByZWNpc2lvbihudW0pO1xuXHRcdH07XG5cblx0XHROdW1iZXJVdGlsLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24obnVtLCBkaWdpdHMpXG5cdFx0e1xuXHRcdFx0bnVtID0gK251bTtcblx0XHRcdGRpZ2l0cyA9IChkaWdpdHMgIT0gbnVsbCkgPyArZGlnaXRzIDogMDtcblxuXHRcdFx0aWYgKGRpZ2l0cyA+IDApXG5cdFx0XHRcdGRpZ2l0cyA9IE1hdGguZmxvb3IoZGlnaXRzKTtcblx0XHRcdGVsc2UgaWYgKGRpZ2l0cyA8IDApXG5cdFx0XHRcdGRpZ2l0cyA9IE51bWJlclV0aWwuUFJFQ0lTSU9OICsgTWF0aC5jZWlsKGRpZ2l0cyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGRpZ2l0cyA9IE51bWJlclV0aWwuUFJFQ0lTSU9OO1xuXG5cdFx0XHRpZiAoZGlnaXRzIDwgMSlcblx0XHRcdFx0ZGlnaXRzID0gMTtcblx0XHRcdGVsc2UgaWYgKGRpZ2l0cyA+IDIxKVxuXHRcdFx0XHRkaWdpdHMgPSAyMTtcblxuXHRcdFx0cmV0dXJuICsobnVtLnRvUHJlY2lzaW9uKGRpZ2l0cykpO1xuXHRcdH07XG5cblx0XHROdW1iZXJVdGlsLmFwcHJveFplcm8gPSBmdW5jdGlvbihudW0sIHRocmVzaG9sZClcblx0XHR7XG5cdFx0XHRudW0gPSArbnVtO1xuXG5cdFx0XHRpZiAobnVtID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0dGhyZXNob2xkID0gKHRocmVzaG9sZCAhPSBudWxsKSA/ICt0aHJlc2hvbGQgOiBOdW1iZXJVdGlsLkVQU0lMT047XG5cblx0XHRcdHJldHVybiAobnVtIDwgMCkgPyAoLW51bSA8IHRocmVzaG9sZCkgOiAobnVtIDwgdGhyZXNob2xkKTtcblx0XHR9O1xuXG5cdFx0TnVtYmVyVXRpbC5hcHByb3hPbmUgPSBmdW5jdGlvbihudW0sIHRocmVzaG9sZClcblx0XHR7XG5cdFx0XHRudW0gPSArbnVtO1xuXG5cdFx0XHRpZiAobnVtID09PSAxKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0dGhyZXNob2xkID0gKHRocmVzaG9sZCAhPSBudWxsKSA/ICt0aHJlc2hvbGQgOiBOdW1iZXJVdGlsLkVQU0lMT047XG5cdFx0XHRudW0gLT0gMTtcblxuXHRcdFx0cmV0dXJuIChudW0gPCAwKSA/ICgtbnVtIDwgdGhyZXNob2xkKSA6IChudW0gPCB0aHJlc2hvbGQpO1xuXHRcdH07XG5cblx0XHROdW1iZXJVdGlsLmFwcHJveEVxdWFsID0gZnVuY3Rpb24obnVtMSwgbnVtMiwgdGhyZXNob2xkKVxuXHRcdHtcblx0XHRcdG51bTEgPSArbnVtMTtcblx0XHRcdG51bTIgPSArbnVtMjtcblxuXHRcdFx0aWYgKG51bTEgPT09IG51bTIpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR0aHJlc2hvbGQgPSAodGhyZXNob2xkICE9IG51bGwpID8gK3RocmVzaG9sZCA6IE51bWJlclV0aWwuRVBTSUxPTjtcblx0XHRcdG51bTEgLT0gbnVtMjtcblxuXHRcdFx0cmV0dXJuIChudW0xIDwgMCkgPyAoLW51bTEgPCB0aHJlc2hvbGQpIDogKG51bTEgPCB0aHJlc2hvbGQpO1xuXHRcdH07XG5cblx0XHROdW1iZXJVdGlsLmFwcHJveExlc3NUaGFuID0gZnVuY3Rpb24obnVtMSwgbnVtMiwgdGhyZXNob2xkKVxuXHRcdHtcblx0XHRcdG51bTEgPSArbnVtMTtcblx0XHRcdG51bTIgPSArbnVtMjtcblxuXHRcdFx0cmV0dXJuICgobnVtMSA8IG51bTIpICYmICFOdW1iZXJVdGlsLmFwcHJveEVxdWFsKG51bTEsIG51bTIsIHRocmVzaG9sZCkpO1xuXHRcdH07XG5cblx0XHROdW1iZXJVdGlsLmFwcHJveExlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uKG51bTEsIG51bTIsIHRocmVzaG9sZClcblx0XHR7XG5cdFx0XHRudW0xID0gK251bTE7XG5cdFx0XHRudW0yID0gK251bTI7XG5cblx0XHRcdHJldHVybiAoKG51bTEgPCBudW0yKSB8fCBOdW1iZXJVdGlsLmFwcHJveEVxdWFsKG51bTEsIG51bTIsIHRocmVzaG9sZCkpO1xuXHRcdH07XG5cblx0XHROdW1iZXJVdGlsLmFwcHJveEdyZWF0ZXJUaGFuID0gZnVuY3Rpb24obnVtMSwgbnVtMiwgdGhyZXNob2xkKVxuXHRcdHtcblx0XHRcdG51bTEgPSArbnVtMTtcblx0XHRcdG51bTIgPSArbnVtMjtcblxuXHRcdFx0cmV0dXJuICgobnVtMSA+IG51bTIpICYmICFOdW1iZXJVdGlsLmFwcHJveEVxdWFsKG51bTEsIG51bTIsIHRocmVzaG9sZCkpO1xuXHRcdH07XG5cblx0XHROdW1iZXJVdGlsLmFwcHJveEdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uKG51bTEsIG51bTIsIHRocmVzaG9sZClcblx0XHR7XG5cdFx0XHRudW0xID0gK251bTE7XG5cdFx0XHRudW0yID0gK251bTI7XG5cblx0XHRcdHJldHVybiAoKG51bTEgPiBudW0yKSB8fCBOdW1iZXJVdGlsLmFwcHJveEVxdWFsKG51bTEsIG51bTIsIHRocmVzaG9sZCkpO1xuXHRcdH07XG5cblx0fSk7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL051bWJlclV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IGNvbnRyaWIvamdfbGliL3V0aWxzL051bWJlclV0aWxcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jquery-2.1.0":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v2.1.0\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-01-23T21:10Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper window is present,\n\t\t// execute the factory and get jQuery\n\t\t// For environments that do not inherently posses a window with a document\n\t\t// (such as Node.js), expose a jQuery-making factory as module.exports\n\t\t// This accentuates the need for the creation of a real window\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\n\nvar arr = [];\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar trim = \"\".trim;\n\nvar support = {};\n\n\n\nvar\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\tversion = \"2.1.0\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return just the object\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\treturn obj - parseFloat( obj ) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Support: Firefox <20\n\t\t// The try/catch suppresses exceptions thrown when attempting to access\n\t\t// the \"constructor\" property of certain host objects, ie. |window.location|\n\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n\t\ttry {\n\t\t\tif ( obj.constructor &&\n\t\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\t// Support: Android < 4.0, iOS < 6 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\ttrim: function( text ) {\n\t\treturn text == null ? \"\" : trim.call( text );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v1.10.16\n * http://sizzlejs.com/\n *\n * Copyright 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-01-13\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\tcompile,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + -(new Date()),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tstrundefined = typeof undefined,\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf if we can't use a native one\n\tindexOf = arr.indexOf || function( elem ) {\n\t\tvar i = 0,\n\t\t\tlen = this.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( this[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\n\t\t\"*(?:([*^$|!~]?=)\" + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\n\t// Prefer arguments quoted,\n\t//   then not containing pseudos/brackets,\n\t//   then attribute selectors/non-parenthetical expressions,\n\t//   then anything else\n\t// These preferences are here to reduce the number of selectors\n\t//   needing tokenize in the PSEUDO preFilter\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\n\tif ( documentIsHTML && !seed ) {\n\n\t\t// Shortcuts\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType === 9 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== strundefined && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc,\n\t\tparent = doc.defaultView;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\n\t// Support tests\n\tdocumentIsHTML = !isXML( doc );\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", function() {\n\t\t\t\tsetDocument();\n\t\t\t}, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", function() {\n\t\t\t\tsetDocument();\n\t\t\t});\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Check if getElementsByClassName can be trusted\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {\n\t\tdiv.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\n\n\t\t// Support: Safari<4\n\t\t// Catch class over-caching\n\t\tdiv.firstChild.className = \"i\";\n\t\t// Support: Opera<10\n\t\t// Catch gEBCN failure to find non-leading classes\n\t\treturn div.getElementsByClassName(\"i\").length === 2;\n\t});\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\t\t\t}\n\t\t} :\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdiv.innerHTML = \"<select t=''><option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 10-12\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\tif ( div.querySelectorAll(\"[t^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch(e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [elem] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[5] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] && match[4] !== undefined ) {\n\t\t\t\tmatch[2] = match[4];\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\nfunction tokenize( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n}\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !group ) {\n\t\t\tgroup = tokenize( selector );\n\t\t}\n\t\ti = group.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( group[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t}\n\treturn cached;\n};\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction select( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tmatch = tokenize( selector );\n\n\tif ( !seed ) {\n\t\t// Try to minimize operations if there is only one group\n\t\tif ( match.length === 1 ) {\n\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t\t)) ) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\tcompile( selector, match )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n}\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome<14\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.trigger ) {\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\n\t\t}\n\t}\n});\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\twindow.removeEventListener( \"load\", completed, false );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n};\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\nfunction Data() {\n\t// Support: Android < 4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Math.random();\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android < 4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\nvar data_priv = new Data();\n\nvar data_user = new Data();\n\n\n\n/*\n\tImplementation Summary\n\n\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t2. Improve the module's maintainability by reducing the storage\n\t\tpaths to a single mechanism.\n\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n*/\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend({\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tname = attrs[ i ].name;\n\n\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) );\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tdiv.innerHTML = \"<input type='radio' checked='checked' name='t'/>\";\n\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t// old WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t// Support: IE9-IE11+\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n})();\nvar strundefined = typeof undefined;\n\n\n\nsupport.focusinBubbles = \"onfocusin\" in window;\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome < 28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\t// Support: Android < 4.0\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\tsrc.getPreventDefault && src.getPreventDefault() ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Create \"bubbling\" focus and blur events\n// Support: Firefox, Chrome, Safari\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdata_priv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE 9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE 9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Support: IE >= 9\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Support: IE >= 9\n\t\t// Fix Cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Fixes #12346\n\t\t\t\t\t// Support: Webkit, IE\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, events, type, key, j,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tevents = Object.keys( data.events || {} );\n\t\t\t\t\tif ( events.length ) {\n\t\t\t\t\t\tfor ( j = 0; (type = events[j]) !== undefined; j++ ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle ?\n\n\t\t\t// Use of this method is a temporary fix (more like optmization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\twindow.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t};\n\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t}\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: iOS < 6\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\t\t\t\t// Hook not needed (or it's not possible to use it due to missing dependency),\n\t\t\t\t// remove it.\n\t\t\t\t// Since there are no other hooks for marginRight, remove the whole object.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\tvar pixelPositionVal, boxSizingReliableVal,\n\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\tdivReset = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;\" +\n\t\t\t\"-moz-box-sizing:content-box;box-sizing:content-box\",\n\t\tdocElem = document.documentElement,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;\" +\n\t\t\"margin-top:1px\";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\tdiv.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\"box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;\" +\n\t\t\t\"position:absolute;top:1%\";\n\t\tdocElem.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\tdocElem.removeChild( container );\n\t}\n\n\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\tif ( window.getComputedStyle ) {\n\t\tjQuery.extend(support, {\n\t\t\tpixelPosition: function() {\n\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\treliableMarginRight: function() {\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\tvar ret,\n\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\t\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\tdocElem.appendChild( container );\n\n\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n\t\t\t\tdocElem.removeChild( container );\n\n\t\t\t\t// Clean up the div for other support tests.\n\t\t\t\tdiv.innerHTML = \"\";\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t});\n\t}\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: 0,\n\t\tfontWeight: 400\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\n\t\t\tif ( !values[ index ] ) {\n\t\t\t\thidden = isHidden( elem );\n\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set. See: #7116\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\t// Support: Chrome, Safari\n\t\t\t\t// Setting style to blank string required to delete \"style: x !important;\"\n\t\t\t\tstyle[ name ] = \"\";\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// we're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t// Get default display if display is currently \"none\"\n\t\tif ( display === \"none\" ) {\n\t\t\tdisplay = defaultDisplay( elem.nodeName );\n\t\t}\n\t\tif ( display === \"inline\" &&\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: iOS 5.1, Android 4.x, Android 2.3\n\t// Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Must access the parent to make an option select properly\n\t// Support: IE9, IE10\n\tsupport.optSelected = opt.selected;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Check if an input maintains its value after becoming a radio\n\t// Support: IE9, IE10\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n})();\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n});\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Support: IE9+\n// Selectedness for an option in an optgroup can be inaccurate\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t// Support: Webkit\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + \"\" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\ttmp = new DOMParser();\n\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n};\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE9\n// Open requests must be manually aborted on unload (#5280)\nif ( window.ActiveXObject ) {\n\tjQuery( window ).on( \"unload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t});\n}\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[ id ] = callback(\"abort\");\n\n\t\t\t\t// Do send the request\n\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = url.slice( off );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t// BlackBerry 5, iOS 3 (original iPhone)\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// We assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// getComputedStyle returns percent when specified for top/left/bottom/right\n// rather than make the css module depend on the offset module, we just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\treturn jQuery;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in\n// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvanF1ZXJ5LTIuMS4wLmpzPzJiYjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsWUFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVEsc0NBQXNDO0FBQzlDLFFBQVE7QUFDUixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8seUVBQXlFO0FBQ2hGOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFVBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLFNBQVMsR0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQix1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQ0FBb0M7QUFDOUM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUF3RDtBQUM5RTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxPQUFPO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxtQ0FBbUM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDJCQUEyQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDBCQUEwQjtBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVMsU0FBUyxjQUFjLCtCQUErQjtBQUN2RixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsUUFBUSxTQUFTLGtCQUFrQixNQUFNLGFBQWE7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCwyQkFBMkI7QUFDaEYsMEJBQTBCLFlBQVksV0FBVyxjQUFjLFVBQVUsY0FBYztBQUN2RixzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsK0JBQStCLGtCQUFrQixFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakMsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixXQUFXLGtCQUFrQjtBQUM3QixjQUFjO0FBQ2QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxvQ0FBb0M7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ04sTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQiw0REFBNEQsZUFBZTtBQUMzRTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQSxDQUFDIiwiZmlsZSI6ImNvbnRyaWIvanF1ZXJ5LTIuMS4wLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYyLjEuMFxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDA1LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTQtMDEtMjNUMjE6MTBaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIHdpbmRvdyBpcyBwcmVzZW50LFxuXHRcdC8vIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnlcblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGluaGVyZW50bHkgcG9zc2VzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBqUXVlcnktbWFraW5nIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHNcblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIHdpbmRvd1xuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gQ2FuJ3QgZG8gdGhpcyBiZWNhdXNlIHNldmVyYWwgYXBwcyBpbmNsdWRpbmcgQVNQLk5FVCB0cmFjZVxuLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4vLyBTdXBwb3J0OiBGaXJlZm94IDE4K1xuLy9cblxudmFyIGFyciA9IFtdO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHRyaW0gPSBcIlwiLnRyaW07XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG52YXJcblx0Ly8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxuXHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblxuXHR2ZXJzaW9uID0gXCIyLjEuMFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIlwiLFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtICE9IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4gYSAnY2xlYW4nIGFycmF5XG5cdFx0XHQoIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF0gKSA6XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvYmplY3Rcblx0XHRcdHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cdFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0Ly8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXNcblx0Ly8gb25seSB1c2VkIGludGVybmFsbHkuKVxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjaywgYXJncyApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSkpO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbal0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IobnVsbCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbih0YXJnZXQpICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSkgIT0gbnVsbCApIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSApICkge1xuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHQvLyBTZWUgdGVzdC91bml0L2NvcmUuanMgZm9yIGRldGFpbHMgY29uY2VybmluZyBpc0Z1bmN0aW9uLlxuXHQvLyBTaW5jZSB2ZXJzaW9uIDEuMywgRE9NIG1ldGhvZHMgYW5kIGZ1bmN0aW9ucyBsaWtlIGFsZXJ0XG5cdC8vIGFyZW4ndCBzdXBwb3J0ZWQuIFRoZXkgcmV0dXJuIGZhbHNlIG9uIElFICgjMjk2OCkuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0cmV0dXJuIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApID49IDA7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHQvLyBOb3QgcGxhaW4gb2JqZWN0czpcblx0XHQvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXG5cdFx0Ly8gLSBET00gbm9kZXNcblx0XHQvLyAtIHdpbmRvd1xuXHRcdGlmICggalF1ZXJ5LnR5cGUoIG9iaiApICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPDIwXG5cdFx0Ly8gVGhlIHRyeS9jYXRjaCBzdXBwcmVzc2VzIGV4Y2VwdGlvbnMgdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhY2Nlc3Ncblx0XHQvLyB0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IG9mIGNlcnRhaW4gaG9zdCBvYmplY3RzLCBpZS4gfHdpbmRvdy5sb2NhdGlvbnxcblx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04MTQ2MjJcblx0XHR0cnkge1xuXHRcdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgZnVuY3Rpb24gaGFzbid0IHJldHVybmVkIGFscmVhZHksIHdlJ3JlIGNvbmZpZGVudCB0aGF0XG5cdFx0Ly8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPCA0LjAsIGlPUyA8IDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdHZhciBzY3JpcHQsXG5cdFx0XHRpbmRpcmVjdCA9IGV2YWw7XG5cblx0XHRjb2RlID0galF1ZXJ5LnRyaW0oIGNvZGUgKTtcblxuXHRcdGlmICggY29kZSApIHtcblx0XHRcdC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXG5cdFx0XHQvLyBzdHJpY3QgbW9kZSBwcmFnbWEsIGV4ZWN1dGUgY29kZSBieSBpbmplY3RpbmcgYVxuXHRcdFx0Ly8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cblx0XHRcdGlmICggY29kZS5pbmRleE9mKFwidXNlIHN0cmljdFwiKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblx0XHRcdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHQvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxuXHRcdFx0XHRpbmRpcmVjdCggY29kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHQvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aCxcblx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZSggb2JqICk7XG5cblx0XHRpZiAoIGFyZ3MgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID8gXCJcIiA6IHRyaW0uY2FsbCggdGV4dCApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheWxpa2UoIE9iamVjdChhcnIpICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZSggZWxlbXMgKSxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59KTtcblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59KTtcblxuZnVuY3Rpb24gaXNBcnJheWxpa2UoIG9iaiApIHtcblx0dmFyIGxlbmd0aCA9IG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggb2JqLm5vZGVUeXBlID09PSAxICYmIGxlbmd0aCApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2MS4xMC4xNlxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMyBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE0LTAxLTEzXG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdGNvbXBpbGUsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgLShuZXcgRGF0ZSgpKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0c3RydW5kZWZpbmVkID0gdHlwZW9mIHVuZGVmaW5lZCxcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgaWYgd2UgY2FuJ3QgdXNlIGEgbmF0aXZlIG9uZVxuXHRpbmRleE9mID0gYXJyLmluZGV4T2YgfHwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIHRoaXNbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIFdoaXRlc3BhY2UgY2hhcmFjdGVycyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jY2hhcmFjdGVyc1xuXHRjaGFyYWN0ZXJFbmNvZGluZyA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gTG9vc2VseSBtb2RlbGVkIG9uIENTUyBpZGVudGlmaWVyIGNoYXJhY3RlcnNcblx0Ly8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0Ly8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3I1wiICksXG5cblx0Ly8gQWNjZXB0YWJsZSBvcGVyYXRvcnMgaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKig/OihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbJ1xcXCJdKSgoPzpcXFxcXFxcXC58W15cXFxcXFxcXF0pKj8pXFxcXDN8KFwiICsgaWRlbnRpZmllciArIFwiKXwpfClcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuXG5cdC8vIFByZWZlciBhcmd1bWVudHMgcXVvdGVkLFxuXHQvLyAgIHRoZW4gbm90IGNvbnRhaW5pbmcgcHNldWRvcy9icmFja2V0cyxcblx0Ly8gICB0aGVuIGF0dHJpYnV0ZSBzZWxlY3RvcnMvbm9uLXBhcmVudGhldGljYWwgZXhwcmVzc2lvbnMsXG5cdC8vICAgdGhlbiBhbnl0aGluZyBlbHNlXG5cdC8vIFRoZXNlIHByZWZlcmVuY2VzIGFyZSBoZXJlIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9yc1xuXHQvLyAgIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIFBTRVVETyBwcmVGaWx0ZXJcblx0cHNldWRvcyA9IFwiOihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpKD86XFxcXCgoKFsnXFxcIl0pKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXSkqPylcXFxcM3woKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzLnJlcGxhY2UoIDMsIDggKSArIFwiKSopfC4qKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncqXCIgKSArIFwiKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbWF0Y2gsIGVsZW0sIG0sIG5vZGVUeXBlLFxuXHRcdC8vIFFTQSB2YXJzXG5cdFx0aSwgZ3JvdXBzLCBvbGQsIG5pZCwgbmV3Q29udGV4dCwgbmV3U2VsZWN0b3I7XG5cblx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdGlmICggIXNlbGVjdG9yIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdGlmICggKG5vZGVUeXBlID0gY29udGV4dC5ub2RlVHlwZSkgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0aWYgKCBkb2N1bWVudElzSFRNTCAmJiAhc2VlZCApIHtcblxuXHRcdC8vIFNob3J0Y3V0c1xuXHRcdGlmICggKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcblx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTtcblx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKGpRdWVyeSAjNjk2Mylcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFLCBPcGVyYSwgYW5kIFdlYmtpdCByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBDb250ZXh0IGlzIG5vdCBhIGRvY3VtZW50XG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiYgZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJUQUdcIilcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBRU0EgcGF0aFxuXHRcdGlmICggc3VwcG9ydC5xc2EgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblx0XHRcdG5pZCA9IG9sZCA9IGV4cGFuZG87XG5cdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdG5ld1NlbGVjdG9yID0gbm9kZVR5cGUgPT09IDkgJiYgc2VsZWN0b3I7XG5cblx0XHRcdC8vIHFTQSB3b3JrcyBzdHJhbmdlbHkgb24gRWxlbWVudC1yb290ZWQgcXVlcmllc1xuXHRcdFx0Ly8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxuXHRcdFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXG5cdFx0XHQvLyBJRSA4IGRvZXNuJ3Qgd29yayBvbiBvYmplY3QgZWxlbWVudHNcblx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblxuXHRcdFx0XHRpZiAoIChvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSApIHtcblx0XHRcdFx0XHRuaWQgPSBvbGQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIG5pZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5pZCA9IFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCI7XG5cblx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZCArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0O1xuXHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaChxc2FFcnJvcikge1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggIW9sZCApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbihzdHJpbmcsIE9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGF0dHJzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHQoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC1cblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBzdHJ1bmRlZmluZWQgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2MsXG5cdFx0cGFyZW50ID0gZG9jLmRlZmF1bHRWaWV3O1xuXG5cdC8vIElmIG5vIGRvY3VtZW50IGFuZCBkb2N1bWVudEVsZW1lbnQgaXMgYXZhaWxhYmxlLCByZXR1cm5cblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBTZXQgb3VyIGRvY3VtZW50XG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBTdXBwb3J0IHRlc3RzXG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2MgKTtcblxuXHQvLyBTdXBwb3J0OiBJRT44XG5cdC8vIElmIGlmcmFtZSBkb2N1bWVudCBpcyBhc3NpZ25lZCB0byBcImRvY3VtZW50XCIgdmFyaWFibGUgYW5kIGlmIGlmcmFtZSBoYXMgYmVlbiByZWxvYWRlZCxcblx0Ly8gSUUgd2lsbCB0aHJvdyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBhY2Nlc3NpbmcgXCJkb2N1bWVudFwiIHZhcmlhYmxlLCBzZWUgalF1ZXJ5ICMxMzkzNlxuXHQvLyBJRTYtOCBkbyBub3Qgc3VwcG9ydCB0aGUgZGVmYXVsdFZpZXcgcHJvcGVydHkgc28gcGFyZW50IHdpbGwgYmUgdW5kZWZpbmVkXG5cdGlmICggcGFyZW50ICYmIHBhcmVudCAhPT0gcGFyZW50LnRvcCApIHtcblx0XHQvLyBJRTExIGRvZXMgbm90IGhhdmUgYXR0YWNoRXZlbnQsIHNvIGFsbCBtdXN0IHN1ZmZlclxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNldERvY3VtZW50KCk7XG5cdFx0XHR9LCBmYWxzZSApO1xuXHRcdH0gZWxzZSBpZiAoIHBhcmVudC5hdHRhY2hFdmVudCApIHtcblx0XHRcdHBhcmVudC5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2V0RG9jdW1lbnQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBjYW4gYmUgdHJ1c3RlZFxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkgJiYgYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nYSc+PC9kaXY+PGRpdiBjbGFzcz0nYSBpJz48L2Rpdj5cIjtcblxuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaTw0XG5cdFx0Ly8gQ2F0Y2ggY2xhc3Mgb3Zlci1jYWNoaW5nXG5cdFx0ZGl2LmZpcnN0Q2hpbGQuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0Ly8gU3VwcG9ydDogT3BlcmE8MTBcblx0XHQvLyBDYXRjaCBnRUJDTiBmYWlsdXJlIHRvIGZpbmQgbm9uLWxlYWRpbmcgY2xhc3Nlc1xuXHRcdHJldHVybiBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImlcIikubGVuZ3RoID09PSAyO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvYy5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jLmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBzdHJ1bmRlZmluZWQgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRyZXR1cm4gbSAmJiBtLnBhcmVudE5vZGUgPyBbbV0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IHN0cnVuZGVmaW5lZCAmJiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IHN0cnVuZGVmaW5lZCAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jLnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiPHNlbGVjdCB0PScnPjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTAtMTJcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbdF49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBkaXYsIFwiZGl2XCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50XG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvYyB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvYyB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBhICkgLSBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvYyA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvYztcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFtlbGVtXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs1XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gJiYgbWF0Y2hbNF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XTtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IHN0cnVuZGVmaW5lZCAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdCArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBkaWZmLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IHBhcmVudFsgZXhwYW5kbyBdIHx8IChwYXJlbnRbIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMl07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdXNlQ2FjaGUgJiYgKGNhY2hlID0gKGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdKSAmJiBjYWNoZVswXSA9PT0gZGlycnVucyApIHtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGNhY2hlWzFdO1xuXG5cdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApICYmICsrZGlmZiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdChub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YuY2FsbCggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0XCJkaXNhYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxuZnVuY3Rpb24gdG9rZW5pemUoIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufVxuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBkaXIgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cdFx0XHRcdFx0XHRpZiAoIChvbGRDYWNoZSA9IG91dGVyQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyBkaXIgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YuY2FsbCggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRyZXR1cm4gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ICE9PSBkb2N1bWVudCAmJiBjb250ZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gS2VlcCBgaWAgYSBzdHJpbmcgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHNvIGBtYXRjaGVkQ291bnRgIHdpbGwgYmUgXCIwMFwiIGJlbG93XG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgZ3JvdXAgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFncm91cCApIHtcblx0XHRcdGdyb3VwID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBncm91cC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggZ3JvdXBbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdCggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cblx0aWYgKCAhc2VlZCApIHtcblx0XHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBncm91cFxuXHRcdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHQvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb25cblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHRjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0cnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lPDE0XG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZGl2MSApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbXCI6XCJdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9KTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+PSAwICkgIT09IG5vdDtcblx0fSk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0pKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59KTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbMF0gPT09IFwiPFwiICYmIHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmIHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsxXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbMV0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbMV0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbMl0gKTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1swXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHJvb3RqUXVlcnkucmVhZHkgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRyb290alF1ZXJ5LnJlYWR5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXHQvLyBtZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0ZGlyOiBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fSxcblxuXHRzaWJsaW5nOiBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHBvcyA/XG5cdFx0XHRcdFx0cG9zLmluZGV4KGN1cikgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW5cblx0Ly8gdGhlIG1hdGNoZWQgc2V0IG9mIGVsZW1lbnRzXG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBpbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWUoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3Rvcilcblx0XHQpO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCh7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0pO1xudmFyIHJub3R3aGl0ZSA9ICgvXFxTKy9nKTtcblxuXG5cbi8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGVcbnZhciBvcHRpb25zQ2FjaGUgPSB7fTtcblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0gb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdCggb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gfHwgY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcblx0XHRtZW1vcnksXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXHRcdC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxuXHRcdGZpcmluZ1N0YXJ0LFxuXHRcdC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuXHRcdGZpcmluZ0xlbmd0aCxcblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4LFxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXHRcdC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhO1xuXHRcdFx0ZmlyZWQgPSB0cnVlO1xuXHRcdFx0ZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwO1xuXHRcdFx0ZmlyaW5nU3RhcnQgPSAwO1xuXHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGRhdGFbIDAgXSwgZGF0YVsgMSBdICkgPT09IGZhbHNlICYmIG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7IC8vIFRvIHByZXZlbnQgZnVydGhlciBjYWxscyB1c2luZyBhZGRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggc3RhY2sgKSB7XG5cdFx0XHRcdFx0aWYgKCBzdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBzdGFjay5zaGlmdCgpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0Ly8gRmlyc3QsIHdlIHNhdmUgdGhlIGN1cnJlbnQgbGVuZ3RoXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KSggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcblx0XHRcdFx0XHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0XHRcdGZpcmUoIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nTGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoLS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDogISEoIGxpc3QgJiYgbGlzdC5sZW5ndGggKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gc3RhY2sgPSBtZW1vcnkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGRpc2FibGVkP1xuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gTG9jayB0aGUgbGlzdCBpbiBpdHMgY3VycmVudCBzdGF0ZVxuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN0YWNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgbG9ja2VkP1xuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFzdGFjaztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggbGlzdCAmJiAoICFmaXJlZCB8fCBzdGFjayApICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcmUoIGFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiIF0sXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzFdIF0oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLCBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdHByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDMgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWzFdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHwgKCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cblx0XHRcdGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpLCBjb250ZXh0cywgdmFsdWVzICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG5cdFx0Ly8gYWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuXHRcdGlmICggbGVuZ3RoID4gMSApIHtcblx0XHRcdHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApXG5cdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIHVwZGF0ZUZ1bmMoIGksIHByb2dyZXNzQ29udGV4dHMsIHByb2dyZXNzVmFsdWVzICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLXJlbWFpbmluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGlmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcblx0XHRpZiAoICFyZW1haW5pbmcgKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0fVxufSk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cdC8vIEFkZCB0aGUgY2FsbGJhY2tcblx0alF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblxuXHRcdC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuXHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlcihcInJlYWR5XCIpLm9mZihcInJlYWR5XCIpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcblx0aWYgKCAhcmVhZHlMaXN0ICkge1xuXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0XHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyB3ZSBvbmNlIHRyaWVkIHRvIHVzZSByZWFkeVN0YXRlIFwiaW50ZXJhY3RpdmVcIiBoZXJlLCBidXQgaXQgY2F1c2VkIGlzc3VlcyBsaWtlIHRoZSBvbmVcblx0XHQvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1XG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGpRdWVyeS5hY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGpRdWVyeS5hY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5W2ldLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbiggZWxlbXNbaV0sIGtleSwgcmF3ID8gdmFsdWUgOiB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW4gPyBmbiggZWxlbXNbMF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIG9iamVjdCBjYW4gaGF2ZSBkYXRhXG4gKi9cbmpRdWVyeS5hY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0LyoganNoaW50IC1XMDE4ICovXG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8IDQsXG5cdC8vIE9sZCBXZWJLaXQgZG9lcyBub3QgaGF2ZSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMvZnJlZXplIG1ldGhvZCxcblx0Ly8gcmV0dXJuIG5ldyBlbXB0eSBvYmplY3QgaW5zdGVhZCB3aXRoIG5vIFtbc2V0XV0gYWNjZXNzb3Jcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLmNhY2hlID0ge30sIDAsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblx0fSk7XG5cblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBNYXRoLnJhbmRvbSgpO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5EYXRhLmFjY2VwdHMgPSBqUXVlcnkuYWNjZXB0RGF0YTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cdGtleTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0Ly8gQWx3YXlzIHJldHVybiB0aGUga2V5IGZvciBhIGZyb3plbiBvYmplY3QuXG5cdFx0aWYgKCAhRGF0YS5hY2NlcHRzKCBvd25lciApICkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGRlc2NyaXB0b3IgPSB7fSxcblx0XHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZSBrZXlcblx0XHRcdHVubG9jayA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXVubG9jayApIHtcblx0XHRcdHVubG9jayA9IERhdGEudWlkKys7XG5cblx0XHRcdC8vIFNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRlc2NyaXB0b3JbIHRoaXMuZXhwYW5kbyBdID0geyB2YWx1ZTogdW5sb2NrIH07XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBvd25lciwgZGVzY3JpcHRvciApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDwgNFxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gYSBsZXNzIHNlY3VyZSBkZWZpbml0aW9uXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0ZGVzY3JpcHRvclsgdGhpcy5leHBhbmRvIF0gPSB1bmxvY2s7XG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIG93bmVyLCBkZXNjcmlwdG9yICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRpZiAoICF0aGlzLmNhY2hlWyB1bmxvY2sgXSApIHtcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVubG9jaztcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Ly8gVGhlcmUgbWF5IGJlIGFuIHVubG9jayBhc3NpZ25lZCB0byB0aGlzIG5vZGUsXG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBcIm93bmVyXCIsIGNyZWF0ZSBvbmUgaW5saW5lXG5cdFx0XHQvLyBhbmQgc2V0IHRoZSB1bmxvY2sgYXMgdGhvdWdoIGFuIG93bmVyIGVudHJ5IGhhZCBhbHdheXMgZXhpc3RlZFxuXHRcdFx0dW5sb2NrID0gdGhpcy5rZXkoIG93bmVyICksXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGVbIHVubG9jayBdO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBGcmVzaCBhc3NpZ25tZW50cyBieSBvYmplY3QgYXJlIHNoYWxsb3cgY29waWVkXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLmNhY2hlWyB1bmxvY2sgXSwgZGF0YSApO1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdC8vIEVpdGhlciBhIHZhbGlkIGNhY2hlIGlzIGZvdW5kLCBvciB3aWxsIGJlIGNyZWF0ZWQuXG5cdFx0Ly8gTmV3IGNhY2hlcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSB1bmxvY2sgcmV0dXJuZWQsXG5cdFx0Ly8gYWxsb3dpbmcgZGlyZWN0IGFjY2VzcyB0byB0aGUgbmV3bHkgY3JlYXRlZFxuXHRcdC8vIGVtcHR5IGRhdGEgb2JqZWN0LiBBIHZhbGlkIG93bmVyIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkLlxuXHRcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGVbIHRoaXMua2V5KCBvd25lciApIF07XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0Y2FjaGUgOiBjYWNoZVsga2V5IF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBzdG9yZWQ7XG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KChrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgKSB7XG5cblx0XHRcdHN0b3JlZCA9IHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cblx0XHRcdHJldHVybiBzdG9yZWQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHN0b3JlZCA6IHRoaXMuZ2V0KCBvd25lciwgalF1ZXJ5LmNhbWVsQ2FzZShrZXkpICk7XG5cdFx0fVxuXG5cdFx0Ly8gWypdV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLCBuYW1lLCBjYW1lbCxcblx0XHRcdHVubG9jayA9IHRoaXMua2V5KCBvd25lciApLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlWyB1bmxvY2sgXTtcblxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLmNhY2hlWyB1bmxvY2sgXSA9IHt9O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblx0XHRcdFx0Ly8gSWYgXCJuYW1lXCIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxuXHRcdFx0XHQvLyBrZXlzIHdpbGwgYmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZS5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgX2hvd18gYSBrZXkgd2FzIGFkZGVkLCByZW1vdmVcblx0XHRcdFx0Ly8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgb25seSBwZW5hbGl6ZSB0aGUgYXJyYXkgYXJndW1lbnQgcGF0aC5cblx0XHRcdFx0bmFtZSA9IGtleS5jb25jYXQoIGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FtZWwgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblx0XHRcdFx0Ly8gVHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cblx0XHRcdFx0aWYgKCBrZXkgaW4gY2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsga2V5LCBjYW1lbCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBuYW1lWyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KFxuXHRcdFx0dGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF0gfHwge31cblx0XHQpO1xuXHR9LFxuXHRkaXNjYXJkOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0aWYgKCBvd25lclsgdGhpcy5leHBhbmRvIF0gKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF07XG5cdFx0fVxuXHR9XG59O1xudmFyIGRhdGFfcHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhX3VzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLypcblx0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuXG5cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcblx0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG5cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG5cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcbiovXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gLyhbQS1aXSkvZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhX3VzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YV91c2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhX3ByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3VzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YV91c2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFfcHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cblx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoNSkgKTtcblx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLFxuXHRcdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBjYW1lbGl6ZWRcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIEZpcnN0LCBhdHRlbXB0IHRvIHN0b3JlIGEgY29weSBvciByZWZlcmVuY2Ugb2YgYW55XG5cdFx0XHRcdC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cblx0XHRcdFx0dmFyIGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGNhbWVsS2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRcdC8vICouLi4gSW4gdGhlIGNhc2Ugb2YgcHJvcGVydGllcyB0aGF0IG1pZ2h0IF9hY3R1YWxseV9cblx0XHRcdFx0Ly8gaGF2ZSBkYXNoZXMsIHdlIG5lZWQgdG8gYWxzbyBzdG9yZSBhIGNvcHkgb2YgdGhhdFxuXHRcdFx0XHQvLyB1bmNoYW5nZWQgcHJvcGVydHkuXG5cdFx0XHRcdGlmICgga2V5LmluZGV4T2YoXCItXCIpICE9PSAtMSAmJiBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhX3VzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBub3QgaW50ZW5kZWQgZm9yIHB1YmxpYyBjb25zdW1wdGlvbiAtIGdlbmVyYXRlcyBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm5zIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YV9wcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YV9wcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSlcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1swXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIGVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59KTtcbnZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8ICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoL14oPzpjaGVja2JveHxyYWRpbykkL2kpO1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdC8vICMxMTIxNyAtIFdlYktpdCBsb3NlcyBjaGVjayB3aGVuIHRoZSBuYW1lIGlzIGFmdGVyIHRoZSBjaGVja2VkIGF0dHJpYnV0ZVxuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQgdHlwZT0ncmFkaW8nIGNoZWNrZWQ9J2NoZWNrZWQnIG5hbWU9J3QnLz5cIjtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgNS4xLCBpT1MgNS4xLCBBbmRyb2lkIDQueCwgQW5kcm9pZCAyLjNcblx0Ly8gb2xkIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0Ly8gU3VwcG9ydDogSUU5LUlFMTErXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59KSgpO1xudmFyIHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQ7XG5cblxuXG5zdXBwb3J0LmZvY3VzaW5CdWJibGVzID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfGNvbnRleHRtZW51KXxjbGljay8sXG5cdHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KSQvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggIShldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBzdHJ1bmRlZmluZWQgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbMl0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCh7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKFwiLlwiKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggIShoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fCBzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhX3ByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFfcHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbMl0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWzJdICYmIG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHwgc3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGVsZXRlIGVsZW1EYXRhLmhhbmRsZTtcblx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFwiZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KFwiLlwiKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZihcIi5cIikgPj0gMCApIHtcblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKFwiOlwiKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKFwiLlwiKTtcblx0XHRldmVudC5uYW1lc3BhY2VfcmUgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoY3VyID0gZXZlbnRQYXRoW2krK10pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhX3ByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiYgZGF0YV9wcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGpRdWVyeS5hY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoIXNwZWNpYWwuX2RlZmF1bHQgfHwgc3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlKSAmJlxuXHRcdFx0XHRqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhX3ByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbMF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdKSAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yXG5cdFx0XHRcdC8vIDIpIGhhdmUgbmFtZXNwYWNlKHMpIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5uYW1lc3BhY2VfcmUgfHwgZXZlbnQubmFtZXNwYWNlX3JlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoIChqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30pLmhhbmRsZSB8fCBoYW5kbGVPYmouaGFuZGxlciApXG5cdFx0XHRcdFx0XHRcdC5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZXZlbnQucmVzdWx0ID0gcmV0KSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBtYXRjaGVzLCBzZWwsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcblx0XHQvLyBBdm9pZCBub24tbGVmdC1jbGljayBidWJibGluZyBpbiBGaXJlZm94ICgjMzg2MSlcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmICghZXZlbnQuYnV0dG9uIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIikgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPj0gMCA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogdGhpcywgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksXG5cblx0Zml4SG9va3M6IHt9LFxuXG5cdGtleUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiBcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFwiLnNwbGl0KFwiIFwiKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cdFx0XHR2YXIgZXZlbnREb2MsIGRvYywgYm9keSxcblx0XHRcdFx0YnV0dG9uID0gb3JpZ2luYWwuYnV0dG9uO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGV2ZW50LnBhZ2VYID09IG51bGwgJiYgb3JpZ2luYWwuY2xpZW50WCAhPSBudWxsICkge1xuXHRcdFx0XHRldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXHRcdFx0XHRkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRcdGJvZHkgPSBldmVudERvYy5ib2R5O1xuXG5cdFx0XHRcdGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArICggZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICsgKCBkb2MgJiYgZG9jLnNjcm9sbFRvcCAgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCAgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudFRvcCAgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCAgfHwgMCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0XHQvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxuXHRcdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllc1xuXHRcdHZhciBpLCBwcm9wLCBjb3B5LFxuXHRcdFx0dHlwZSA9IGV2ZW50LnR5cGUsXG5cdFx0XHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG5cdFx0XHRmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCAhZml4SG9vayApIHtcblx0XHRcdHRoaXMuZml4SG9va3NbIHR5cGUgXSA9IGZpeEhvb2sgPVxuXHRcdFx0XHRybW91c2VFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLm1vdXNlSG9va3MgOlxuXHRcdFx0XHRya2V5RXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5rZXlIb29rcyA6XG5cdFx0XHRcdHt9O1xuXHRcdH1cblx0XHRjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KCBmaXhIb29rLnByb3BzICkgOiB0aGlzLnByb3BzO1xuXG5cdFx0ZXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cblx0XHRpID0gY29weS5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRwcm9wID0gY29weVsgaSBdO1xuXHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBDb3Jkb3ZhIDIuNSAoV2ViS2l0KSAoIzEzMjU1KVxuXHRcdC8vIEFsbCBldmVudHMgc2hvdWxkIGhhdmUgYSB0YXJnZXQ7IENvcmRvdmEgZGV2aWNlcmVhZHkgZG9lc24ndFxuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGRvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjArLCBDaHJvbWUgPCAyOFxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0aWYgKCBldmVudC50YXJnZXQubm9kZVR5cGUgPT09IDMgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXIgPyBmaXhIb29rLmZpbHRlciggZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSA6IGV2ZW50O1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCwgYnViYmxlICkge1xuXHRcdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZS5cblx0XHQvLyBGYWtlIG9yaWdpbmFsRXZlbnQgdG8gYXZvaWQgZG9ub3IncyBzdG9wUHJvcGFnYXRpb24sIGJ1dCBpZiB0aGVcblx0XHQvLyBzaW11bGF0ZWQgZXZlbnQgcHJldmVudHMgZGVmYXVsdCB0aGVuIHdlIGRvIHRoZSBzYW1lIG9uIHRoZSBkb25vci5cblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWUsXG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IHt9XG5cdFx0XHR9XG5cdFx0KTtcblx0XHRpZiAoIGJ1YmJsZSApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5jYWxsKCBlbGVtLCBlICk7XG5cdFx0fVxuXHRcdGlmICggZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSwgZmFsc2UgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8IDQuMFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdHNyYy5nZXRQcmV2ZW50RGVmYXVsdCAmJiBzcmMuZ2V0UHJldmVudERlZmF1bHQoKSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTUrXG5qUXVlcnkuZWFjaCh7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59KTtcblxuLy8gQ3JlYXRlIFwiYnViYmxpbmdcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcbi8vIFN1cHBvcnQ6IEZpcmVmb3gsIENocm9tZSwgU2FmYXJpXG5pZiAoICFzdXBwb3J0LmZvY3VzaW5CdWJibGVzICkge1xuXHRqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApLCB0cnVlICk7XG5cdFx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAvKklOVEVSTkFMKi8gb25lICkge1xuXHRcdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0XHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9uKCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXHRcdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0XHRvcmlnRm4gPSBmbjtcblx0XHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH07XG5cdFx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgPyBoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOiBoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9KTtcblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9KTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1swXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cbnZhclxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vZ2ksXG5cdHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxuXHRyaHRtbCA9IC88fCYjP1xcdys7Lyxcblx0cm5vSW5uZXJodG1sID0gLzwoPzpzY3JpcHR8c3R5bGV8bGluaykvaSxcblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGUgPSAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csXG5cblx0Ly8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcblx0d3JhcE1hcCA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDlcblx0XHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHRcdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0XHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHRcdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0XHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cblx0fTtcblxuLy8gU3VwcG9ydDogSUUgOVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IDEueCBjb21wYXRpYmlsaXR5XG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09IG51bGwpICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFfcHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLCBcImdsb2JhbEV2YWxcIiwgIXJlZkVsZW1lbnRzIHx8IGRhdGFfcHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFfcHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFfcHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YV9wcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YV91c2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YV91c2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFfdXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cdHZhciByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRbXTtcblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApIDpcblx0XHRyZXQ7XG59XG5cbi8vIFN1cHBvcnQ6IElFID49IDlcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA+PSA5XG5cdFx0Ly8gRml4IENsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRidWlsZEZyYWdtZW50OiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiApIHtcblx0XHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRcdG5vZGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxuXHRcdFx0XHRcdC8vIGpRdWVyeS5tZXJnZSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Ncblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKTtcblxuXHRcdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgZWxlbS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHRcdFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0XHQvLyBGaXhlcyAjMTIzNDZcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBXZWJraXQsIElFXG5cdFx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0XHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChlbGVtID0gbm9kZXNbIGkrKyBdKSApIHtcblxuXHRcdFx0Ly8gIzQwODcgLSBJZiBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGVsZW1lbnRzIGFyZSB0aGUgc2FtZSwgYW5kIHRoaXMgaXNcblx0XHRcdC8vIHRoYXQgZWxlbWVudCwgZG8gbm90IGRvIGFueXRoaW5nXG5cdFx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgIT09IC0xICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHRtcFsgaisrIF0pICkge1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmcmFnbWVudDtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgZXZlbnRzLCB0eXBlLCBrZXksIGosXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1sgaSBdKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGtleSA9IGVsZW1bIGRhdGFfcHJpdi5leHBhbmRvIF07XG5cblx0XHRcdFx0aWYgKCBrZXkgJiYgKGRhdGEgPSBkYXRhX3ByaXYuY2FjaGVbIGtleSBdKSApIHtcblx0XHRcdFx0XHRldmVudHMgPSBPYmplY3Qua2V5cyggZGF0YS5ldmVudHMgfHwge30gKTtcblx0XHRcdFx0XHRpZiAoIGV2ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgKHR5cGUgPSBldmVudHNbal0pICE9PSB1bmRlZmluZWQ7IGorKyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBkYXRhX3ByaXYuY2FjaGVbIGtleSBdICkge1xuXHRcdFx0XHRcdFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGBwcml2YXRlYCBkYXRhXG5cdFx0XHRcdFx0XHRkZWxldGUgZGF0YV9wcml2LmNhY2hlWyBrZXkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIERpc2NhcmQgYW55IHJlbWFpbmluZyBgdXNlcmAgZGF0YVxuXHRcdFx0ZGVsZXRlIGRhdGFfdXNlci5jYWNoZVsgZWxlbVsgZGF0YV91c2VyLmV4cGFuZG8gXSBdO1xuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3Rvciwga2VlcERhdGEgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRlbGVtcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKSA6IHRoaXMsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCAha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9KTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnID0gYXJndW1lbnRzWyAwIF07XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHR0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0YXJnID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXG5cdFx0XHRpZiAoIGFyZyApIHtcblx0XHRcdFx0YXJnLnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRm9yY2UgcmVtb3ZhbCBpZiB0aGVyZSB3YXMgbm8gbmV3IGNvbnRlbnQgKGUuZy4sIGZyb20gZW1wdHkgYXJndW1lbnRzKVxuXHRcdHJldHVybiBhcmcgJiYgKGFyZy5sZW5ndGggfHwgYXJnLm5vZGVUeXBlKSA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRkb21NYW5pcDogZnVuY3Rpb24oIGFyZ3MsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0XHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNldCA9IHRoaXMsXG5cdFx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0XHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHNldC5lcSggaW5kZXggKTtcblx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuZG9tTWFuaXAoIGFyZ3MsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGwgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBhcmdzLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIHRoaXMgKTtcblx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmaXJzdCApIHtcblx0XHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdFx0XHRcdFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggdGhpc1sgaSBdLCBub2RlLCBpICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHRcdCFkYXRhX3ByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmIGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCh7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0pO1xuXG5cbnZhciBpZnJhbWUsXG5cdGVsZW1kaXNwbGF5ID0ge307XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFjdHVhbCBkaXNwbGF5IG9mIGEgZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgRG9jdW1lbnQgb2JqZWN0XG4gKi9cbi8vIENhbGxlZCBvbmx5IGZyb20gd2l0aGluIGRlZmF1bHREaXNwbGF5XG5mdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XG5cdHZhciBlbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksXG5cblx0XHQvLyBnZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSBtaWdodCBiZSByZWxpYWJseSB1c2VkIG9ubHkgb24gYXR0YWNoZWQgZWxlbWVudFxuXHRcdGRpc3BsYXkgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgP1xuXG5cdFx0XHQvLyBVc2Ugb2YgdGhpcyBtZXRob2QgaXMgYSB0ZW1wb3JhcnkgZml4IChtb3JlIGxpa2Ugb3B0bWl6YXRpb24pIHVudGlsIHNvbWV0aGluZyBiZXR0ZXIgY29tZXMgYWxvbmcsXG5cdFx0XHQvLyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBmcm9tIHNwZWNpZmljYXRpb24gYW5kIHN1cHBvcnRlZCBvbmx5IGluIEZGXG5cdFx0XHR3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUoIGVsZW1bIDAgXSApLmRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtWyAwIF0sIFwiZGlzcGxheVwiICk7XG5cblx0Ly8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXG5cdC8vIHNvIHVzZSBcImRldGFjaFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XG5cdGVsZW0uZGV0YWNoKCk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbi8qKlxuICogVHJ5IHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSggbm9kZU5hbWUgKSB7XG5cdHZhciBkb2MgPSBkb2N1bWVudCxcblx0XHRkaXNwbGF5ID0gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG5cblx0aWYgKCAhZGlzcGxheSApIHtcblx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXG5cdFx0Ly8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsIHJlYWQgZnJvbSBpbnNpZGUgYW4gaWZyYW1lXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhZGlzcGxheSApIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXG5cdFx0XHRpZnJhbWUgPSAoaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSkuYXBwZW5kVG8oIGRvYy5kb2N1bWVudEVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXG5cdFx0XHRkb2MgPSBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQ7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0XHRkb2Mud3JpdGUoKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXG5cdFx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXHRcdFx0aWZyYW1lLmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuXHRcdGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcblx0fVxuXG5cdHJldHVybiBkaXNwbGF5O1xufVxudmFyIHJtYXJnaW4gPSAoL15tYXJnaW4vKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSBpbiBJRTksIHNlZSAjMTI1Mzdcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblx0fVxuXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA8IDZcblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gaU9TIDwgNiAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuXHRcdC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWUgdG8gbWlzc2luZyBkZXBlbmRlbmN5KSxcblx0XHRcdFx0Ly8gcmVtb3ZlIGl0LlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBhcmUgbm8gb3RoZXIgaG9va3MgZm9yIG1hcmdpblJpZ2h0LCByZW1vdmUgdGhlIHdob2xlIG9iamVjdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXG5cdFx0XHRyZXR1cm4gKHRoaXMuZ2V0ID0gaG9va0ZuKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3gsIEFuZHJvaWQgMi4zIChQcmVmaXhlZCBib3gtc2l6aW5nIHZlcnNpb25zKS5cblx0XHRkaXZSZXNldCA9IFwicGFkZGluZzowO21hcmdpbjowO2JvcmRlcjowO2Rpc3BsYXk6YmxvY2s7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFwiLW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3hcIixcblx0XHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJtYXJnaW4tdG9wOjFweFwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCkge1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3gsIEFuZHJvaWQgMi4zIChQcmVmaXhlZCBib3gtc2l6aW5nIHZlcnNpb25zKS5cblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9IFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzoxcHg7Ym9yZGVyOjFweDtkaXNwbGF5OmJsb2NrO3dpZHRoOjRweDttYXJnaW4tdG9wOjElO1wiICtcblx0XHRcdFwicG9zaXRpb246YWJzb2x1dGU7dG9wOjElXCI7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0fVxuXG5cdC8vIFVzZSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSBiZWNhdXNlIGpzZG9tIG9uIG5vZGUuanMgd2lsbCBicmVhayB3aXRob3V0IGl0LlxuXHRpZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRcdGpRdWVyeS5leHRlbmQoc3VwcG9ydCwge1xuXHRcdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFRoaXMgdGVzdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UgYnV0IHdlIHN0aWxsIGRvIG1lbW9pemluZ1xuXHRcdFx0XHQvLyBzaW5jZSB3ZSBjYW4gdXNlIHRoZSBib3hTaXppbmdSZWxpYWJsZSBwcmUtY29tcHV0aW5nLlxuXHRcdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0XHRjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XG5cdFx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdFx0fSxcblx0XHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRcdGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0XHR9LFxuXHRcdFx0cmVsaWFibGVNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXG5cdFx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHRcdHZhciByZXQsXG5cdFx0XHRcdFx0bWFyZ2luRGl2ID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblx0XHRcdFx0bWFyZ2luRGl2LnN0eWxlLmNzc1RleHQgPSBkaXYuc3R5bGUuY3NzVGV4dCA9IGRpdlJlc2V0O1xuXHRcdFx0XHRtYXJnaW5EaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBtYXJnaW5EaXYuc3R5bGUud2lkdGggPSBcIjBcIjtcblx0XHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblx0XHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdFx0cmV0ID0gIXBhcnNlRmxvYXQoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBtYXJnaW5EaXYsIG51bGwgKS5tYXJnaW5SaWdodCApO1xuXG5cdFx0XHRcdGRvY0VsZW0ucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0XHRcdC8vIENsZWFuIHVwIHRoZSBkaXYgZm9yIG90aGVyIHN1cHBvcnQgdGVzdHMuXG5cdFx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pKCk7XG5cblxuLy8gQSBtZXRob2QgZm9yIHF1aWNrbHkgc3dhcHBpbmcgaW4vb3V0IENTUyBwcm9wZXJ0aWVzIHRvIGdldCBjb3JyZWN0IGNhbGN1bGF0aW9ucy5cbmpRdWVyeS5zd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyXG5cdC8vIHN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGUgZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIHNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJudW1zcGxpdCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoLiopJFwiLCBcImlcIiApLFxuXHRycmVsTnVtID0gbmV3IFJlZ0V4cCggXCJeKFsrLV0pPShcIiArIHBudW0gKyBcIilcIiwgXCJpXCIgKSxcblxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IDAsXG5cdFx0Zm9udFdlaWdodDogNDAwXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXTtcblxuLy8gcmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBuYW1lICkge1xuXG5cdC8vIHNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIGNoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuXHRcdG9yaWdOYW1lID0gbmFtZSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3JpZ05hbWU7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cdHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAxIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAyIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cdFx0Ly8gYm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gc29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QodmFsKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgbmVlZCB0aGUgY2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyB1c2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0aGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGRpc3BsYXkgJiYgZGlzcGxheSAhPT0gXCJub25lXCIgfHwgIWhpZGRlbiApIHtcblx0XHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgaGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdC8vIG5vcm1hbGl6ZSBmbG9hdCBjc3MgcHJvcGVydHlcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBnZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uXG5cdFx0Ly8gZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gY29udmVydCByZWxhdGl2ZSBudW1iZXIgc3RyaW5ncyAoKz0gb3IgLT0pIHRvIHJlbGF0aXZlIG51bWJlcnMuICM3MzQ1XG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHJldCA9IHJyZWxOdW0uZXhlYyggdmFsdWUgKSkgKSB7XG5cdFx0XHRcdHZhbHVlID0gKCByZXRbMV0gKyAxICkgKiByZXRbMl0gKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTtcblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTZcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7XG5cdFx0XHRcdHZhbHVlICs9IFwicHhcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRml4ZXMgIzg5MDgsIGl0IGNhbiBiZSBkb25lIG1vcmUgY29ycmVjdGx5IGJ5IHNwZWNpZnlpbmcgc2V0dGVycyBpbiBjc3NIb29rcyxcblx0XHRcdC8vIGJ1dCBpdCB3b3VsZCBtZWFuIHRvIGRlZmluZSBlaWdodCAoZm9yIGV2ZXJ5IHByb2JsZW1hdGljIHByb3BlcnR5KSBpZGVudGljYWwgZnVuY3Rpb25zXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8ICh2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSwgU2FmYXJpXG5cdFx0XHRcdC8vIFNldHRpbmcgc3R5bGUgdG8gYmxhbmsgc3RyaW5nIHJlcXVpcmVkIHRvIGRlbGV0ZSBcInN0eWxlOiB4ICFpbXBvcnRhbnQ7XCJcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiXCI7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggZWxlbS5zdHlsZSwgb3JpZ05hbWUgKSApO1xuXG5cdFx0Ly8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxuXHRcdC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly9jb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiwgY29udmVydGluZyB0byBudW1iZXIgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgalF1ZXJ5LmlzTnVtZXJpYyggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHQvLyBjZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gaG93ZXZlciwgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdCBmcm9tIHRoaXNcblx0XHRcdFx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgJiYgcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5LnN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIGV4dHJhID9cblx0XHRcdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCkgOiAwXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBXb3JrIGFyb3VuZCBieSB0ZW1wb3JhcmlseSBzZXR0aW5nIGVsZW1lbnQgZGlzcGxheSB0byBpbmxpbmUtYmxvY2tcblx0XHRcdHJldHVybiBqUXVlcnkuc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LFxuXHRcdFx0XHRjdXJDU1MsIFsgZWxlbSwgXCJtYXJnaW5SaWdodFwiIF0gKTtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIGFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KFwiIFwiKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbiggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBcInN3aW5nXCI7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmXG5cdFx0XHRcdCghdHdlZW4uZWxlbS5zdHlsZSB8fCB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCkgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlsc1xuXHRcdFx0Ly8gc28sIHNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0LlxuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcyBpcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdC8vIHVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0IC0gdXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlIC0gdXNlIC5zdHlsZSBpZiBpdHNcblx0XHRcdC8vIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLnN0eWxlICYmICggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8IGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblxuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH1cbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cmZ4bnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKSxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC8sXG5cdGFuaW1hdGlvblByZWZpbHRlcnMgPSBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblx0dHdlZW5lcnMgPSB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKSxcblx0XHRcdFx0dGFyZ2V0ID0gdHdlZW4uY3VyKCksXG5cdFx0XHRcdHBhcnRzID0gcmZ4bnVtLmV4ZWMoIHZhbHVlICksXG5cdFx0XHRcdHVuaXQgPSBwYXJ0cyAmJiBwYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0XHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0XHRcdHN0YXJ0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICt0YXJnZXQgKSAmJlxuXHRcdFx0XHRcdHJmeG51bS5leGVjKCBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCBwcm9wICkgKSxcblx0XHRcdFx0c2NhbGUgPSAxLFxuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMjA7XG5cblx0XHRcdGlmICggc3RhcnQgJiYgc3RhcnRbIDMgXSAhPT0gdW5pdCApIHtcblx0XHRcdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdFx0XHR1bml0ID0gdW5pdCB8fCBzdGFydFsgMyBdO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHRcdFx0cGFydHMgPSBwYXJ0cyB8fCBbXTtcblxuXHRcdFx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdFx0XHRzdGFydCA9ICt0YXJnZXQgfHwgMTtcblxuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZypcblx0XHRcdFx0XHQvLyBVc2UgYSBzdHJpbmcgZm9yIGRvdWJsaW5nIGZhY3RvciBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQgLyBzY2FsZTtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHByb3AsIHN0YXJ0ICsgdW5pdCApO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0XHRcdC8vIEFuZCBicmVha2luZyB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoXG5cdFx0XHRcdH0gd2hpbGUgKCBzY2FsZSAhPT0gKHNjYWxlID0gdHdlZW4uY3VyKCkgLyB0YXJnZXQpICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9ucyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdHdlZW4gcHJvcGVydGllc1xuXHRcdFx0aWYgKCBwYXJ0cyApIHtcblx0XHRcdFx0c3RhcnQgPSB0d2Vlbi5zdGFydCA9ICtzdGFydCB8fCArdGFyZ2V0IHx8IDA7XG5cdFx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0XHQvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cblx0XHRcdFx0dHdlZW4uZW5kID0gcGFydHNbIDEgXSA/XG5cdFx0XHRcdFx0c3RhcnQgKyAoIHBhcnRzWyAxIF0gKyAxICkgKiBwYXJ0c1sgMiBdIDpcblx0XHRcdFx0XHQrcGFydHNbIDIgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9O1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIGlmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gaWYgd2UgZG9uJ3QgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCB0d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICh0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApKSApIHtcblxuXHRcdFx0Ly8gd2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIHR3ZWVuLCBob29rcywgb2xkZmlyZSwgZGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBoYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdC8vIGRvaW5nIHRoaXMgbWFrZXMgc3VyZSB0aGF0IHRoZSBjb21wbGV0ZSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkXG5cdFx0XHQvLyBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gaGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0Ly8gR2V0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93IGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIHN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblxuXHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdHR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gbm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbnQgb3ZlcndyaXRlIGtleXMgYWxyZWFkeSBwcmVzZW50LlxuXHRcdFx0Ly8gYWxzbyAtIHJldXNpbmcgJ2luZGV4JyBmcm9tIGFib3ZlIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gYW5pbWF0aW9uUHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0pLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXHRcdFx0XHQvLyBhcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgMSAtICggMC41IHx8IDAgKSAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXHRcdFx0XHRcdC8vIGlmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWVcblx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0pLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gYW5pbWF0aW9uUHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0pXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLnNwbGl0KFwiIFwiKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXSA9IHR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHR0d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbWF0aW9uUHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID8gb3B0LmR1cmF0aW9uIDpcblx0XHRvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHQvLyBub3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBzaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBhbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YV9wcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YV9wcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUpICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkXG5cdFx0XHQvLyB0aW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoIHdpbGwgZGVxdWV1ZVxuXHRcdFx0Ly8gYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmRcblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YV9wcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBlbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIGVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKHtcblx0c2xpZGVEb3duOiBnZW5GeChcInNob3dcIiksXG5cdHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5cbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSBzZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRjbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSk7XG59O1xuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1MgNS4xLCBBbmRyb2lkIDQueCwgQW5kcm9pZCAyLjNcblx0Ly8gQ2hlY2sgdGhlIGRlZmF1bHQgY2hlY2tib3gvcmFkaW8gdmFsdWUgKFwiXCIgb24gb2xkIFdlYktpdDsgXCJvblwiIGVsc2V3aGVyZSlcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gTXVzdCBhY2Nlc3MgdGhlIHBhcmVudCB0byBtYWtlIGFuIG9wdGlvbiBzZWxlY3QgcHJvcGVybHlcblx0Ly8gU3VwcG9ydDogSUU5LCBJRTEwXG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIG9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlbid0IG1hcmtlZCBhcyBkaXNhYmxlZFxuXHQvLyAoV2ViS2l0IG1hcmtzIHRoZW0gYXMgZGlzYWJsZWQpXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIENoZWNrIGlmIGFuIGlucHV0IG1haW50YWlucyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHQvLyBTdXBwb3J0OiBJRTksIElFMTBcblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSkoKTtcblxuXG52YXIgbm9kZUhvb2ssIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2Vcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/XG5cdFx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRcdHJldDtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLCBwcm9wTmFtZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0XHQvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZVxuXHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0Ly8gU2V0dGluZyB0aGUgdHlwZSBvbiBhIHJhZGlvIGJ1dHRvbiBhZnRlciB0aGUgdmFsdWUgcmVzZXRzIHRoZSB2YWx1ZSBpbiBJRTYtOVxuXHRcdFx0XHRcdC8vIFJlc2V0IHZhbHVlIHRvIGRlZmF1bHQgaW4gY2FzZSB0eXBlIGlzIHNldCBhZnRlciB2YWx1ZSBkdXJpbmcgY3JlYXRpb25cblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBuYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59KTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsIG5vdHhtbCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIGRvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuXHRcdGlmICggbm90eG1sICkge1xuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHQoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCA/XG5cdFx0XHRcdHJldCA6XG5cdFx0XHRcdGVsZW1bIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmhhc0F0dHJpYnV0ZSggXCJ0YWJpbmRleFwiICkgfHwgcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRlbGVtLnRhYkluZGV4IDpcblx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTkrXG4vLyBTZWxlY3RlZG5lc3MgZm9yIGFuIG9wdGlvbiBpbiBhbiBvcHRncm91cCBjYW4gYmUgaW5hY2N1cmF0ZVxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaChbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRwcm9jZWVkID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9jZWVkICkge1xuXHRcdFx0Ly8gVGhlIGRpc2p1bmN0aW9uIGhlcmUgaXMgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSByZW1vdmVDbGFzcylcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIiBcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdHByb2NlZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID49IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gdmFsdWUgPyBqUXVlcnkudHJpbSggY3VyICkgOiBcIlwiO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gdG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoIChjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSkgKSB7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHN0cnVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHQvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBcImZhbHNlXCIsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogZGF0YV9wcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggdGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoIGNsYXNzTmFtZSApID49IDAgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1swXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0Ly8gaGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKHJyZXR1cm4sIFwiXCIpIDpcblx0XHRcdFx0XHQvLyBoYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0dmFsSG9va3M6IHtcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIElFNi05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCAob3B0aW9uLnNlbGVjdGVkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeShvcHRpb24pLnZhbCgpLCB2YWx1ZXMgKSA+PSAwKSApIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeShlbGVtKS52YWwoKSwgdmFsdWUgKSA+PSAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBTdXBwb3J0OiBXZWJraXRcblx0XHRcdC8vIFwiXCIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBcIm9uXCIgaWYgYSB2YWx1ZSBpc24ndCBzcGVjaWZpZWRcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbmpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIikuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9LFxuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6IHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59KTtcblxuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoL1xcPy8pO1xuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbi8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xufTtcblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbCwgdG1wO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0dG1wID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdHhtbCA9IHRtcC5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0Ly8gRG9jdW1lbnQgbG9jYXRpb25cblx0YWpheExvY1BhcnRzLFxuXHRhamF4TG9jYXRpb24sXG5cblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblx0cnVybCA9IC9eKFtcXHcuKy1dKzopKD86XFwvXFwvKD86W15cXC8/I10qQHwpKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoXCIqXCIpO1xuXG4vLyAjODEzOCwgSUUgbWF5IHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZ1xuLy8gYSBmaWVsZCBmcm9tIHdpbmRvdy5sb2NhdGlvbiBpZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gc2V0XG50cnkge1xuXHRhamF4TG9jYXRpb24gPSBsb2NhdGlvbi5ocmVmO1xufSBjYXRjaCggZSApIHtcblx0Ly8gVXNlIHRoZSBocmVmIGF0dHJpYnV0ZSBvZiBhbiBBIGVsZW1lbnRcblx0Ly8gc2luY2UgSUUgd2lsbCBtb2RpZnkgaXQgZ2l2ZW4gZG9jdW1lbnQubG9jYXRpb25cblx0YWpheExvY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0YWpheExvY2F0aW9uLmhyZWYgPSBcIlwiO1xuXHRhamF4TG9jYXRpb24gPSBhamF4TG9jYXRpb24uaHJlZjtcbn1cblxuLy8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG5hamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoIGFqYXhMb2NhdGlvbi50b0xvd2VyQ2FzZSgpICkgfHwgW107XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoIChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSApIHtcblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVswXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJiAhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8IChkZWVwID0ge30pICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbMF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzWyBcInRocm93c1wiIF0gKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4geyBzdGF0ZTogXCJwYXJzZXJlcnJvclwiLCBlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnQgfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGFqYXhMb2NhdGlvbixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGFqYXhMb2NQYXJ0c1sgMSBdICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAveG1sLyxcblx0XHRcdGh0bWw6IC9odG1sLyxcblx0XHRcdGpzb246IC9qc29uL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cdFx0XHQvLyBDcm9zcy1kb21haW4gZGV0ZWN0aW9uIHZhcnNcblx0XHRcdHBhcnRzLFxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJiAoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUgPT09IDIgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBhamF4TG9jYXRpb24gKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBhamF4TG9jUGFydHNbIDEgXSArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gd2UgaGF2ZSBhIHByb3RvY29sOmhvc3Q6cG9ydCBtaXNtYXRjaFxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0cGFydHMgPSBydXJsLmV4ZWMoIHMudXJsLnRvTG93ZXJDYXNlKCkgKTtcblx0XHRcdHMuY3Jvc3NEb21haW4gPSAhISggcGFydHMgJiZcblx0XHRcdFx0KCBwYXJ0c1sgMSBdICE9PSBhamF4TG9jUGFydHNbIDEgXSB8fCBwYXJ0c1sgMiBdICE9PSBhamF4TG9jUGFydHNbIDIgXSB8fFxuXHRcdFx0XHRcdCggcGFydHNbIDMgXSB8fCAoIHBhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IFwiODBcIiA6IFwiNDQzXCIgKSApICE9PVxuXHRcdFx0XHRcdFx0KCBhamF4TG9jUGFydHNbIDMgXSB8fCAoIGFqYXhMb2NQYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSApXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0ZmlyZUdsb2JhbHMgPSBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGFudGktY2FjaGUgaW4gdXJsIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0cy51cmwgPSBydHMudGVzdCggY2FjaGVVUkwgKSA/XG5cblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxuXHRcdFx0XHRcdGNhY2hlVVJMLnJlcGxhY2UoIHJ0cywgXCIkMV89XCIgKyBub25jZSsrICkgOlxuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFkZCBvbmUgdG8gdGhlIGVuZFxuXHRcdFx0XHRcdGNhY2hlVVJMICsgKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArIG5vbmNlKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSArICggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmICggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gYWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRmb3IgKCBpIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0gKSB7XG5cdFx0XHRqcVhIUlsgaSBdKCBzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c3RhdGUgPSAxO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIik7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIik7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXZSBleHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dFxuXHRcdFx0XHQvLyB0aGVuIG5vcm1hbGl6ZSBzdGF0dXNUZXh0IGFuZCBzdGF0dXMgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblx0XHQvLyBzaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0pO1xuXHR9O1xufSk7XG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggWyBcImFqYXhTdGFydFwiLCBcImFqYXhTdG9wXCIsIFwiYWpheENvbXBsZXRlXCIsIFwiYWpheEVycm9yXCIsIFwiYWpheFN1Y2Nlc3NcIiwgXCJhamF4U2VuZFwiIF0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0pO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0dXJsOiB1cmwsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0pO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0pLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwgKTtcblx0XHR9KTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiYm9keVwiICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHRcdH1cblx0XHR9KS5lbmQoKTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHRyZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA8PSAwICYmIGVsZW0ub2Zmc2V0SGVpZ2h0IDw9IDA7XG59O1xualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oIGVsZW0gKTtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IGkgOiBcIlwiICkgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuXHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiAoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuXHRpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzICYmIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSk7XG5cblx0fSBlbHNlIHtcblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9KVxuXHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0pXG5cdFx0Lm1hcChmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0pLmdldCgpO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCggZSApIHt9XG59O1xuXG52YXIgeGhySWQgPSAwLFxuXHR4aHJDYWxsYmFja3MgPSB7fSxcblx0eGhyU3VjY2Vzc1N0YXR1cyA9IHtcblx0XHQvLyBmaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBPcGVuIHJlcXVlc3RzIG11c3QgYmUgbWFudWFsbHkgYWJvcnRlZCBvbiB1bmxvYWQgKCM1MjgwKVxuaWYgKCB3aW5kb3cuQWN0aXZlWE9iamVjdCApIHtcblx0alF1ZXJ5KCB3aW5kb3cgKS5vbiggXCJ1bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICggdmFyIGtleSBpbiB4aHJDYWxsYmFja3MgKSB7XG5cdFx0XHR4aHJDYWxsYmFja3NbIGtleSBdKCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKSxcblx0XHRcdFx0XHRpZCA9ICsreGhySWQ7XG5cblx0XHRcdFx0eGhyLm9wZW4oIG9wdGlvbnMudHlwZSwgb3B0aW9ucy51cmwsIG9wdGlvbnMuYXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQgKTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHhockNhbGxiYWNrc1sgaWQgXTtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSB4aHIub25sb2FkID0geGhyLm9uZXJyb3IgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBmaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gKCMxMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSBcInN0cmluZ1wiID8ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0OiB4aHIucmVzcG9uc2VUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHR9IDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0eGhyLm9uZXJyb3IgPSBjYWxsYmFjayhcImVycm9yXCIpO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSB4aHJDYWxsYmFja3NbIGlkIF0gPSBjYWxsYmFjayhcImFib3J0XCIpO1xuXG5cdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3Rcblx0XHRcdFx0Ly8gVGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uIHdoaWNoIGlzIGFjdHVhbGx5XG5cdFx0XHRcdC8vIGhhbmRsZWQgaW4galF1ZXJ5LmFqYXggKHNvIG5vIHRyeS9jYXRjaCBoZXJlKVxuXHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogLyg/OmphdmF8ZWNtYSlzY3JpcHQvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59KTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpLnByb3Aoe1xuXHRcdFx0XHRcdGFzeW5jOiB0cnVlLFxuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0pLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59KTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gUmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBkYXRhOiBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbMV0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xuXG5cdGlmICggb2ZmID49IDAgKSB7XG5cdFx0c2VsZWN0b3IgPSB1cmwuc2xpY2UoIG9mZiApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBpZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSkuZG9uZShmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeShcIjxkaXY+XCIpLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdH0pLmNvbXBsZXRlKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggY2FsbGJhY2ssIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9KS5sZW5ndGg7XG59O1xuXG5cblxuXG52YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoXCJhdXRvXCIpID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBnQkNSLCBqdXN0IHVzZSAwLDAgcmF0aGVyIHRoYW4gZXJyb3Jcblx0XHQvLyBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fVxuXHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0bGVmdDogYm94LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LCBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHQvLyBXZSBhc3N1bWUgdGhhdCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgYXZhaWxhYmxlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudCwgXCJodG1sXCIgKSAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgsIG51bGwgKTtcblx0fTtcbn0pO1xuXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwgd2UganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblx0XHRcdFx0Ly8gaWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59KTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblx0XHQvLyBtYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0Ly8gQXMgb2YgNS84LzIwMTIgdGhpcyB3aWxsIHlpZWxkIGluY29ycmVjdCByZXN1bHRzIGZvciBNb2JpbGUgU2FmYXJpLCBidXQgdGhlcmVcblx0XHRcdFx0XHQvLyBpc24ndCBhIHdob2xlIGxvdCB3ZSBjYW4gZG8uIFNlZSBwdWxsIHJlcXVlc3QgYXQgdGhpcyBVUkwgZm9yIGRpc2N1c3Npb246XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC83NjRcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG5cdFx0fTtcblx0fSk7XG59KTtcblxuXG4vLyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldFxualF1ZXJ5LmZuLnNpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxualF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjaztcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9KTtcbn1cblxuXG5cblxudmFyXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpblxuLy8gQU1EICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBzdHJ1bmRlZmluZWQgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL2pxdWVyeS0yLjEuMC5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9qcXVlcnktMi4xLjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "shim/requirejsDefine":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/requirejs\")], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n    return window.define;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vcmVxdWlyZWpzRGVmaW5lLmpzP2YxYzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InNoaW0vcmVxdWlyZWpzRGVmaW5lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFsncmVxdWlyZWpzJ10sIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGVmaW5lO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vcmVxdWlyZWpzRGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSBzaGltL3JlcXVpcmVqc0RlZmluZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "shim/requirejs":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(1),\n    __webpack_require__(4),\n    __webpack_require__(\"util/console\"),\n    __webpack_require__(\"shim/splunk.util\"),\n    __webpack_require__(\"require/underscore\"),\n    __webpack_require__(9),\n    __webpack_require__(\"util/env\")], __WEBPACK_AMD_DEFINE_RESULT__ = function(nada, blada, console, splunkUtil, _, coreAliases, env) {\n    coreAliases = coreAliases.resolve.alias;\n    var requirejsRequire = window.requirejs;\n    var requirejsDefine = window.define;\n     /* globals __webpack_require__: false */\n    var webpackModules = __webpack_require__.c;\n\n    // This is a 'Set' of the webpack modules that have already been exposed to\n    // requirejs.\n    var requirejsModulesLoaded = {};\n\n    // This is a 'Set' of modules that are considered public and ok to require.\n    // All other core modules will show a warning when being required.\n    // Note: It is prepopulated with the modules that can be auto-injected by\n    // requirejs.\n    var whiteList = {\n        require: true,\n        exports: true,\n        module: true\n    };\n\n    var url = splunkUtil.make_url('static/js');\n    requirejsRequire.config({\n        baseUrl: url\n    });\n\n    if (env.PRODUCTION) {\n        requirejsRequire.config({\n            waitSeconds: 0\n        });\n    }\n\n    /**\n     * A shim for requirejs require calls that calls `exposeModules` on the\n     * array of dependencies before delegating to the requirejs function.\n     */\n    function shimmedRequirejsRequire(modules) {\n        if (_.isArray(modules)) {\n            exposeModules(modules);\n        }\n        warnOnPrivateModuleRequests(modules);\n        return requirejsRequire.apply(null, arguments);\n    }\n\n    /**\n     * A shim for requirejs define calls that calls `exposedModules` on the\n     * array of dependencies before delegating to the requirejs function.\n     */\n    function shimmedRequirejsDefine(name, deps, callback) {\n        var modulesToExpose = _.isArray(name) ? name :\n            _.isArray(deps) ? deps :\n            parseDeps(name);\n        exposeModules(modulesToExpose);\n        warnOnPrivateModuleRequests(modulesToExpose);\n        requirejsDefine.apply(null, arguments);\n    }\n\n    /**\n    * This function enables sharing of modules between webpack and requirejs.\n    * If a module has already been loaded by webpack, it will expose it to\n    * requirejs using the requirejs, preventing double loading of the module.\n    *\n    * @param {Object|String[]} modules - Either a map with module ids as keys\n    * and the modules as values or an Array of module ids. If an array is\n    * passed, the ids will be used to look up the modules in the webpack module\n    * cache, after applying the webpack alias logic to the id.\n    * @param {Boolean} [isWhiteList = false] - True if the modules should be\n    * added to the whiteList. Requests for modules not in the whiteList will\n    * produce a warning.\n    */\n    function exposeModules(modules, isWhiteList) {\n        if (!_.isArray(modules)) {\n            _.forEach(modules, function(webpackModule, moduleId) {\n                if (isWhiteList) {\n                    whiteList[moduleId] = true;\n                }\n                exposeModule(moduleId, webpackModule);\n            });\n        } else {\n            modules.forEach(function(requirejsId) {\n                if (isWhiteList) {\n                    whiteList[requirejsId] = true;\n                }\n\n                // Early exit if the module has already been defined in requirejs.\n                if (requirejsModulesLoaded[requirejsId]) {\n                    return;\n                }\n\n                // For each module in the request we apply the webpack alias logic\n                // to obtain the moduleId used by webpack.\n                // The webpack alias logic is similar to a replace algorithm but a\n                // but more clever:\n                //  - If the the key ends with $ only the exact match (without the\n                // $) will be replaced.\n                //  - If the value is a relative path it will be relative to the\n                // file containing the require. (THIS IS NOT IMPLEMENTED HERE and is\n                // not currently used by any of our aliases in coreAliases.config).\n                //\n                // See https://webpack.github.io/docs/configuration.html#resolve-alias\n                var webpackId = requirejsId;\n                _.forEach(coreAliases, function(value, key) {\n                    if (/\\$$/.test(key)) {\n                        if (key.slice(0, -1) === webpackId) {\n                            webpackId = value;\n                        }\n                    } else {\n                        webpackId = webpackId.replace(key, value);\n                    }\n                });\n\n                // If the module has already been loaded by webpack, expose it to\n                // requirejs with define.\n                if (_.has(webpackModules, webpackId)) {\n                    exposeModule(requirejsId, webpackModules[webpackId].exports);\n                }\n            });\n        }\n    }\n\n    function exposeModule(requirejsId, exportedMod) {\n        if (requirejsModulesLoaded[requirejsId]) {\n            return;\n        }\n        requirejsModulesLoaded[requirejsId] = true;\n        requirejsDefine(requirejsId, function () {\n            return exportedMod;\n        });\n        // Force the module to load by requiring it!\n        requirejsRequire([requirejsId]);\n    }\n\n    function warnOnPrivateModuleRequests(moduleIds) {\n        if (!_.isArray(moduleIds)) {\n            moduleIds = [moduleIds];\n        }\n        moduleIds.forEach(function(moduleId) {\n            moduleId = moduleId.substring(moduleId.indexOf('!') + 1);\n            if (moduleId &&\n                !_.has(whiteList, moduleId) &&\n                !/^\\.\\.\\/app\\/|^app\\//.test(moduleId) &&\n                !/^api\\//.test(moduleId)) {\n                console.warn('Warning: ' + moduleId +\n                    ' is a private module and may not be supported in the future.');\n            }\n        });\n    }\n\n    /**\n     * This function is copied from `contrib/require.js`. It parses commonjs\n     * style require statements from an amd module and returns an array of\n     * dependencies.\n     *\n     * @param {Function} factory\n     * @returns {String[]} An Array of dependencies\n     */\n    var commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg;\n    var cjsRequireRegExp = /[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g;\n    function parseDeps(factory) {\n        var deps = [];\n        if (factory.length) {\n            factory\n                .toString()\n                .replace(commentRegExp, '')\n                .replace(cjsRequireRegExp, function(match, dep) {\n                    deps.push(dep);\n                });\n        }\n        return deps;\n    }\n\n    shimmedRequirejsRequire.config = requirejsRequire.config;\n    shimmedRequirejsRequire.exposeModules = exposeModules;\n\n    // Override the requirejs globals with our shimmed versions.\n    window.requirejs = window.require = shimmedRequirejsRequire;\n    shimmedRequirejsDefine.amd = requirejsDefine.amd;\n    window.define = shimmedRequirejsDefine;\n    return shimmedRequirejsRequire;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vcmVxdWlyZWpzLmpzP2M0ZjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJzaGltL3JlcXVpcmVqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXG4gICAgJ3NjcmlwdCFjb250cmliL3JlcXVpcmUnLFxuICAgICdzY3JpcHQhcHJvZmlsZXMvc2hhcmVkJyxcbiAgICAndXRpbC9jb25zb2xlJyxcbiAgICAnc3BsdW5rLnV0aWwnLFxuICAgICd1bmRlcnNjb3JlJyxcbiAgICAnY29yZUFsaWFzZXMnLFxuICAgICd1dGlsL2VudiddLFxuZnVuY3Rpb24obmFkYSwgYmxhZGEsIGNvbnNvbGUsIHNwbHVua1V0aWwsIF8sIGNvcmVBbGlhc2VzLCBlbnYpIHtcbiAgICBjb3JlQWxpYXNlcyA9IGNvcmVBbGlhc2VzLnJlc29sdmUuYWxpYXM7XG4gICAgdmFyIHJlcXVpcmVqc1JlcXVpcmUgPSB3aW5kb3cucmVxdWlyZWpzO1xuICAgIHZhciByZXF1aXJlanNEZWZpbmUgPSB3aW5kb3cuZGVmaW5lO1xuICAgICAvKiBnbG9iYWxzIF9fd2VicGFja19yZXF1aXJlX186IGZhbHNlICovXG4gICAgdmFyIHdlYnBhY2tNb2R1bGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jO1xuXG4gICAgLy8gVGhpcyBpcyBhICdTZXQnIG9mIHRoZSB3ZWJwYWNrIG1vZHVsZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBleHBvc2VkIHRvXG4gICAgLy8gcmVxdWlyZWpzLlxuICAgIHZhciByZXF1aXJlanNNb2R1bGVzTG9hZGVkID0ge307XG5cbiAgICAvLyBUaGlzIGlzIGEgJ1NldCcgb2YgbW9kdWxlcyB0aGF0IGFyZSBjb25zaWRlcmVkIHB1YmxpYyBhbmQgb2sgdG8gcmVxdWlyZS5cbiAgICAvLyBBbGwgb3RoZXIgY29yZSBtb2R1bGVzIHdpbGwgc2hvdyBhIHdhcm5pbmcgd2hlbiBiZWluZyByZXF1aXJlZC5cbiAgICAvLyBOb3RlOiBJdCBpcyBwcmVwb3B1bGF0ZWQgd2l0aCB0aGUgbW9kdWxlcyB0aGF0IGNhbiBiZSBhdXRvLWluamVjdGVkIGJ5XG4gICAgLy8gcmVxdWlyZWpzLlxuICAgIHZhciB3aGl0ZUxpc3QgPSB7XG4gICAgICAgIHJlcXVpcmU6IHRydWUsXG4gICAgICAgIGV4cG9ydHM6IHRydWUsXG4gICAgICAgIG1vZHVsZTogdHJ1ZVxuICAgIH07XG5cbiAgICB2YXIgdXJsID0gc3BsdW5rVXRpbC5tYWtlX3VybCgnc3RhdGljL2pzJyk7XG4gICAgcmVxdWlyZWpzUmVxdWlyZS5jb25maWcoe1xuICAgICAgICBiYXNlVXJsOiB1cmxcbiAgICB9KTtcblxuICAgIGlmIChlbnYuUFJPRFVDVElPTikge1xuICAgICAgICByZXF1aXJlanNSZXF1aXJlLmNvbmZpZyh7XG4gICAgICAgICAgICB3YWl0U2Vjb25kczogMFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNoaW0gZm9yIHJlcXVpcmVqcyByZXF1aXJlIGNhbGxzIHRoYXQgY2FsbHMgYGV4cG9zZU1vZHVsZXNgIG9uIHRoZVxuICAgICAqIGFycmF5IG9mIGRlcGVuZGVuY2llcyBiZWZvcmUgZGVsZWdhdGluZyB0byB0aGUgcmVxdWlyZWpzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1tZWRSZXF1aXJlanNSZXF1aXJlKG1vZHVsZXMpIHtcbiAgICAgICAgaWYgKF8uaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgICAgICAgZXhwb3NlTW9kdWxlcyhtb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICB3YXJuT25Qcml2YXRlTW9kdWxlUmVxdWVzdHMobW9kdWxlcyk7XG4gICAgICAgIHJldHVybiByZXF1aXJlanNSZXF1aXJlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaGltIGZvciByZXF1aXJlanMgZGVmaW5lIGNhbGxzIHRoYXQgY2FsbHMgYGV4cG9zZWRNb2R1bGVzYCBvbiB0aGVcbiAgICAgKiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgYmVmb3JlIGRlbGVnYXRpbmcgdG8gdGhlIHJlcXVpcmVqcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltbWVkUmVxdWlyZWpzRGVmaW5lKG5hbWUsIGRlcHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBtb2R1bGVzVG9FeHBvc2UgPSBfLmlzQXJyYXkobmFtZSkgPyBuYW1lIDpcbiAgICAgICAgICAgIF8uaXNBcnJheShkZXBzKSA/IGRlcHMgOlxuICAgICAgICAgICAgcGFyc2VEZXBzKG5hbWUpO1xuICAgICAgICBleHBvc2VNb2R1bGVzKG1vZHVsZXNUb0V4cG9zZSk7XG4gICAgICAgIHdhcm5PblByaXZhdGVNb2R1bGVSZXF1ZXN0cyhtb2R1bGVzVG9FeHBvc2UpO1xuICAgICAgICByZXF1aXJlanNEZWZpbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFRoaXMgZnVuY3Rpb24gZW5hYmxlcyBzaGFyaW5nIG9mIG1vZHVsZXMgYmV0d2VlbiB3ZWJwYWNrIGFuZCByZXF1aXJlanMuXG4gICAgKiBJZiBhIG1vZHVsZSBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCBieSB3ZWJwYWNrLCBpdCB3aWxsIGV4cG9zZSBpdCB0b1xuICAgICogcmVxdWlyZWpzIHVzaW5nIHRoZSByZXF1aXJlanMsIHByZXZlbnRpbmcgZG91YmxlIGxvYWRpbmcgb2YgdGhlIG1vZHVsZS5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmdbXX0gbW9kdWxlcyAtIEVpdGhlciBhIG1hcCB3aXRoIG1vZHVsZSBpZHMgYXMga2V5c1xuICAgICogYW5kIHRoZSBtb2R1bGVzIGFzIHZhbHVlcyBvciBhbiBBcnJheSBvZiBtb2R1bGUgaWRzLiBJZiBhbiBhcnJheSBpc1xuICAgICogcGFzc2VkLCB0aGUgaWRzIHdpbGwgYmUgdXNlZCB0byBsb29rIHVwIHRoZSBtb2R1bGVzIGluIHRoZSB3ZWJwYWNrIG1vZHVsZVxuICAgICogY2FjaGUsIGFmdGVyIGFwcGx5aW5nIHRoZSB3ZWJwYWNrIGFsaWFzIGxvZ2ljIHRvIHRoZSBpZC5cbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzV2hpdGVMaXN0ID0gZmFsc2VdIC0gVHJ1ZSBpZiB0aGUgbW9kdWxlcyBzaG91bGQgYmVcbiAgICAqIGFkZGVkIHRvIHRoZSB3aGl0ZUxpc3QuIFJlcXVlc3RzIGZvciBtb2R1bGVzIG5vdCBpbiB0aGUgd2hpdGVMaXN0IHdpbGxcbiAgICAqIHByb2R1Y2UgYSB3YXJuaW5nLlxuICAgICovXG4gICAgZnVuY3Rpb24gZXhwb3NlTW9kdWxlcyhtb2R1bGVzLCBpc1doaXRlTGlzdCkge1xuICAgICAgICBpZiAoIV8uaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgICAgICAgXy5mb3JFYWNoKG1vZHVsZXMsIGZ1bmN0aW9uKHdlYnBhY2tNb2R1bGUsIG1vZHVsZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2hpdGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlTGlzdFttb2R1bGVJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBvc2VNb2R1bGUobW9kdWxlSWQsIHdlYnBhY2tNb2R1bGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGVzLmZvckVhY2goZnVuY3Rpb24ocmVxdWlyZWpzSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNXaGl0ZUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVMaXN0W3JlcXVpcmVqc0lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRWFybHkgZXhpdCBpZiB0aGUgbW9kdWxlIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBpbiByZXF1aXJlanMuXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVqc01vZHVsZXNMb2FkZWRbcmVxdWlyZWpzSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBtb2R1bGUgaW4gdGhlIHJlcXVlc3Qgd2UgYXBwbHkgdGhlIHdlYnBhY2sgYWxpYXMgbG9naWNcbiAgICAgICAgICAgICAgICAvLyB0byBvYnRhaW4gdGhlIG1vZHVsZUlkIHVzZWQgYnkgd2VicGFjay5cbiAgICAgICAgICAgICAgICAvLyBUaGUgd2VicGFjayBhbGlhcyBsb2dpYyBpcyBzaW1pbGFyIHRvIGEgcmVwbGFjZSBhbGdvcml0aG0gYnV0IGFcbiAgICAgICAgICAgICAgICAvLyBidXQgbW9yZSBjbGV2ZXI6XG4gICAgICAgICAgICAgICAgLy8gIC0gSWYgdGhlIHRoZSBrZXkgZW5kcyB3aXRoICQgb25seSB0aGUgZXhhY3QgbWF0Y2ggKHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gJCkgd2lsbCBiZSByZXBsYWNlZC5cbiAgICAgICAgICAgICAgICAvLyAgLSBJZiB0aGUgdmFsdWUgaXMgYSByZWxhdGl2ZSBwYXRoIGl0IHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gZmlsZSBjb250YWluaW5nIHRoZSByZXF1aXJlLiAoVEhJUyBJUyBOT1QgSU1QTEVNRU5URUQgSEVSRSBhbmQgaXNcbiAgICAgICAgICAgICAgICAvLyBub3QgY3VycmVudGx5IHVzZWQgYnkgYW55IG9mIG91ciBhbGlhc2VzIGluIGNvcmVBbGlhc2VzLmNvbmZpZykuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly93ZWJwYWNrLmdpdGh1Yi5pby9kb2NzL2NvbmZpZ3VyYXRpb24uaHRtbCNyZXNvbHZlLWFsaWFzXG4gICAgICAgICAgICAgICAgdmFyIHdlYnBhY2tJZCA9IHJlcXVpcmVqc0lkO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChjb3JlQWxpYXNlcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoL1xcJCQvLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zbGljZSgwLCAtMSkgPT09IHdlYnBhY2tJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYnBhY2tJZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VicGFja0lkID0gd2VicGFja0lkLnJlcGxhY2Uoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBtb2R1bGUgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgYnkgd2VicGFjaywgZXhwb3NlIGl0IHRvXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWpzIHdpdGggZGVmaW5lLlxuICAgICAgICAgICAgICAgIGlmIChfLmhhcyh3ZWJwYWNrTW9kdWxlcywgd2VicGFja0lkKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBvc2VNb2R1bGUocmVxdWlyZWpzSWQsIHdlYnBhY2tNb2R1bGVzW3dlYnBhY2tJZF0uZXhwb3J0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvc2VNb2R1bGUocmVxdWlyZWpzSWQsIGV4cG9ydGVkTW9kKSB7XG4gICAgICAgIGlmIChyZXF1aXJlanNNb2R1bGVzTG9hZGVkW3JlcXVpcmVqc0lkXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVpcmVqc01vZHVsZXNMb2FkZWRbcmVxdWlyZWpzSWRdID0gdHJ1ZTtcbiAgICAgICAgcmVxdWlyZWpzRGVmaW5lKHJlcXVpcmVqc0lkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0ZWRNb2Q7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGb3JjZSB0aGUgbW9kdWxlIHRvIGxvYWQgYnkgcmVxdWlyaW5nIGl0IVxuICAgICAgICByZXF1aXJlanNSZXF1aXJlKFtyZXF1aXJlanNJZF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm5PblByaXZhdGVNb2R1bGVSZXF1ZXN0cyhtb2R1bGVJZHMpIHtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkobW9kdWxlSWRzKSkge1xuICAgICAgICAgICAgbW9kdWxlSWRzID0gW21vZHVsZUlkc107XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlSWRzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcbiAgICAgICAgICAgIG1vZHVsZUlkID0gbW9kdWxlSWQuc3Vic3RyaW5nKG1vZHVsZUlkLmluZGV4T2YoJyEnKSArIDEpO1xuICAgICAgICAgICAgaWYgKG1vZHVsZUlkICYmXG4gICAgICAgICAgICAgICAgIV8uaGFzKHdoaXRlTGlzdCwgbW9kdWxlSWQpICYmXG4gICAgICAgICAgICAgICAgIS9eXFwuXFwuXFwvYXBwXFwvfF5hcHBcXC8vLnRlc3QobW9kdWxlSWQpICYmXG4gICAgICAgICAgICAgICAgIS9eYXBpXFwvLy50ZXN0KG1vZHVsZUlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogJyArIG1vZHVsZUlkICtcbiAgICAgICAgICAgICAgICAgICAgJyBpcyBhIHByaXZhdGUgbW9kdWxlIGFuZCBtYXkgbm90IGJlIHN1cHBvcnRlZCBpbiB0aGUgZnV0dXJlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBmcm9tIGBjb250cmliL3JlcXVpcmUuanNgLiBJdCBwYXJzZXMgY29tbW9uanNcbiAgICAgKiBzdHlsZSByZXF1aXJlIHN0YXRlbWVudHMgZnJvbSBhbiBhbWQgbW9kdWxlIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4gICAgICogZGVwZW5kZW5jaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmFjdG9yeVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gQW4gQXJyYXkgb2YgZGVwZW5kZW5jaWVzXG4gICAgICovXG4gICAgdmFyIGNvbW1lbnRSZWdFeHAgPSAvKFxcL1xcKihbXFxzXFxTXSo/KVxcKlxcL3woW146XXxeKVxcL1xcLyguKikkKS9tZztcbiAgICB2YXIgY2pzUmVxdWlyZVJlZ0V4cCA9IC9bXi5dXFxzKnJlcXVpcmVcXHMqXFwoXFxzKltcIiddKFteJ1wiXFxzXSspW1wiJ11cXHMqXFwpL2c7XG4gICAgZnVuY3Rpb24gcGFyc2VEZXBzKGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIGRlcHMgPSBbXTtcbiAgICAgICAgaWYgKGZhY3RvcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICBmYWN0b3J5XG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAucmVwbGFjZShjb21tZW50UmVnRXhwLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShjanNSZXF1aXJlUmVnRXhwLCBmdW5jdGlvbihtYXRjaCwgZGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXBzO1xuICAgIH1cblxuICAgIHNoaW1tZWRSZXF1aXJlanNSZXF1aXJlLmNvbmZpZyA9IHJlcXVpcmVqc1JlcXVpcmUuY29uZmlnO1xuICAgIHNoaW1tZWRSZXF1aXJlanNSZXF1aXJlLmV4cG9zZU1vZHVsZXMgPSBleHBvc2VNb2R1bGVzO1xuXG4gICAgLy8gT3ZlcnJpZGUgdGhlIHJlcXVpcmVqcyBnbG9iYWxzIHdpdGggb3VyIHNoaW1tZWQgdmVyc2lvbnMuXG4gICAgd2luZG93LnJlcXVpcmVqcyA9IHdpbmRvdy5yZXF1aXJlID0gc2hpbW1lZFJlcXVpcmVqc1JlcXVpcmU7XG4gICAgc2hpbW1lZFJlcXVpcmVqc0RlZmluZS5hbWQgPSByZXF1aXJlanNEZWZpbmUuYW1kO1xuICAgIHdpbmRvdy5kZWZpbmUgPSBzaGltbWVkUmVxdWlyZWpzRGVmaW5lO1xuICAgIHJldHVybiBzaGltbWVkUmVxdWlyZWpzUmVxdWlyZTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vcmVxdWlyZWpzLmpzXG4vLyBtb2R1bGUgaWQgPSBzaGltL3JlcXVpcmVqc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 1:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(3))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvcmVxdWlyZS5qcz84YjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvVXNlcnMvdml2aWFuL2Rhb2Nsb3VkL0RDRS9zcGx1bmsvb2VtLXN0YXJ0ZXIta2l0LW5ldy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL3Zpdmlhbi9kYW9jbG91ZC9EQ0Uvc3BsdW5rL29lbS1zdGFydGVyLWtpdC1uZXcvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL3Zpdmlhbi9kYW9jbG91ZC9EQ0Uvc3BsdW5rL29lbS1zdGFydGVyLWtpdC1uZXcvcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL3JlcXVpcmUuanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvcmVxdWlyZS5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 2:
/***/ (function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript === \"function\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzPzgxMDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XHJcblx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ID09PSBcImZ1bmN0aW9uXCIpXHJcblx0XHRleGVjU2NyaXB0KHNyYyk7XHJcblx0ZWxzZVxyXG5cdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 3:
/***/ (function(module, exports) {

	eval("module.exports = \"/** vim: et:ts=4:sw=4:sts=4\\n * @license RequireJS 2.1.15 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.\\n * Available via the MIT or new BSD license.\\n * see: http://github.com/jrburke/requirejs for details\\n */\\n//Not using strict: uneven strict support in browsers, #392, and causes\\n//problems with requirejs.exec()/transpiler plugins that may not be strict.\\n/*jslint regexp: true, nomen: true, sloppy: true */\\n/*global window, navigator, document, importScripts, setTimeout, opera */\\n\\nvar requirejs, require, define;\\n(function (global) {\\n    var req, s, head, baseElement, dataMain, src,\\n        interactiveScript, currentlyAddingScript, mainScript, subPath,\\n        version = '2.1.15',\\n        commentRegExp = /(\\\\/\\\\*([\\\\s\\\\S]*?)\\\\*\\\\/|([^:]|^)\\\\/\\\\/(.*)$)/mg,\\n        cjsRequireRegExp = /[^.]\\\\s*require\\\\s*\\\\(\\\\s*[\\\"']([^'\\\"\\\\s]+)[\\\"']\\\\s*\\\\)/g,\\n        jsSuffixRegExp = /\\\\.js$/,\\n        currDirRegExp = /^\\\\.\\\\//,\\n        op = Object.prototype,\\n        ostring = op.toString,\\n        hasOwn = op.hasOwnProperty,\\n        ap = Array.prototype,\\n        apsp = ap.splice,\\n        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),\\n        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',\\n        //PS3 indicates loaded and complete, but need to wait for complete\\n        //specifically. Sequence is 'loading', 'loaded', execution,\\n        // then 'complete'. The UA check is unfortunate, but not sure how\\n        //to feature test w/o causing perf issues.\\n        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?\\n                      /^complete$/ : /^(complete|loaded)$/,\\n        defContextName = '_',\\n        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.\\n        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',\\n        contexts = {},\\n        cfg = {},\\n        globalDefQueue = [],\\n        useInteractive = false;\\n\\n    function isFunction(it) {\\n        return ostring.call(it) === '[object Function]';\\n    }\\n\\n    function isArray(it) {\\n        return ostring.call(it) === '[object Array]';\\n    }\\n\\n    /**\\n     * Helper function for iterating over an array. If the func returns\\n     * a true value, it will break out of the loop.\\n     */\\n    function each(ary, func) {\\n        if (ary) {\\n            var i;\\n            for (i = 0; i < ary.length; i += 1) {\\n                if (ary[i] && func(ary[i], i, ary)) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Helper function for iterating over an array backwards. If the func\\n     * returns a true value, it will break out of the loop.\\n     */\\n    function eachReverse(ary, func) {\\n        if (ary) {\\n            var i;\\n            for (i = ary.length - 1; i > -1; i -= 1) {\\n                if (ary[i] && func(ary[i], i, ary)) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    function hasProp(obj, prop) {\\n        return hasOwn.call(obj, prop);\\n    }\\n\\n    function getOwn(obj, prop) {\\n        return hasProp(obj, prop) && obj[prop];\\n    }\\n\\n    /**\\n     * Cycles over properties in an object and calls a function for each\\n     * property value. If the function returns a truthy value, then the\\n     * iteration is stopped.\\n     */\\n    function eachProp(obj, func) {\\n        var prop;\\n        for (prop in obj) {\\n            if (hasProp(obj, prop)) {\\n                if (func(obj[prop], prop)) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Simple function to mix in properties from source into target,\\n     * but only if target does not already have a property of the same name.\\n     */\\n    function mixin(target, source, force, deepStringMixin) {\\n        if (source) {\\n            eachProp(source, function (value, prop) {\\n                if (force || !hasProp(target, prop)) {\\n                    if (deepStringMixin && typeof value === 'object' && value &&\\n                        !isArray(value) && !isFunction(value) &&\\n                        !(value instanceof RegExp)) {\\n\\n                        if (!target[prop]) {\\n                            target[prop] = {};\\n                        }\\n                        mixin(target[prop], value, force, deepStringMixin);\\n                    } else {\\n                        target[prop] = value;\\n                    }\\n                }\\n            });\\n        }\\n        return target;\\n    }\\n\\n    //Similar to Function.prototype.bind, but the 'this' object is specified\\n    //first, since it is easier to read/figure out what 'this' will be.\\n    function bind(obj, fn) {\\n        return function () {\\n            return fn.apply(obj, arguments);\\n        };\\n    }\\n\\n    function scripts() {\\n        return document.getElementsByTagName('script');\\n    }\\n\\n    function defaultOnError(err) {\\n        throw err;\\n    }\\n\\n    //Allow getting a global that is expressed in\\n    //dot notation, like 'a.b.c'.\\n    function getGlobal(value) {\\n        if (!value) {\\n            return value;\\n        }\\n        var g = global;\\n        each(value.split('.'), function (part) {\\n            g = g[part];\\n        });\\n        return g;\\n    }\\n\\n    /**\\n     * Constructs an error with a pointer to an URL with more information.\\n     * @param {String} id the error ID that maps to an ID on a web page.\\n     * @param {String} message human readable error.\\n     * @param {Error} [err] the original error, if there is one.\\n     *\\n     * @returns {Error}\\n     */\\n    function makeError(id, msg, err, requireModules) {\\n        var e = new Error(msg + '\\\\nhttp://requirejs.org/docs/errors.html#' + id);\\n        e.requireType = id;\\n        e.requireModules = requireModules;\\n        if (err) {\\n            e.originalError = err;\\n        }\\n        return e;\\n    }\\n\\n    if (typeof define !== 'undefined') {\\n        //If a define is already in play via another AMD loader,\\n        //do not overwrite.\\n        return;\\n    }\\n\\n    if (typeof requirejs !== 'undefined') {\\n        if (isFunction(requirejs)) {\\n            //Do not overwrite an existing requirejs instance.\\n            return;\\n        }\\n        cfg = requirejs;\\n        requirejs = undefined;\\n    }\\n\\n    //Allow for a require config object\\n    if (typeof require !== 'undefined' && !isFunction(require)) {\\n        //assume it is a config object.\\n        cfg = require;\\n        require = undefined;\\n    }\\n\\n    function newContext(contextName) {\\n        var inCheckLoaded, Module, context, handlers,\\n            checkLoadedTimeoutId,\\n            config = {\\n                //Defaults. Do not set a default for map\\n                //config to speed up normalize(), which\\n                //will run faster if there is no default.\\n                waitSeconds: 7,\\n                baseUrl: './',\\n                paths: {},\\n                bundles: {},\\n                pkgs: {},\\n                shim: {},\\n                config: {}\\n            },\\n            registry = {},\\n            //registry of just enabled modules, to speed\\n            //cycle breaking code when lots of modules\\n            //are registered, but not activated.\\n            enabledRegistry = {},\\n            undefEvents = {},\\n            defQueue = [],\\n            defined = {},\\n            urlFetched = {},\\n            bundlesMap = {},\\n            requireCounter = 1,\\n            unnormalizedCounter = 1;\\n\\n        /**\\n         * Trims the . and .. from an array of path segments.\\n         * It will keep a leading path segment if a .. will become\\n         * the first path segment, to help with module name lookups,\\n         * which act like paths, but can be remapped. But the end result,\\n         * all paths that use this function should look normalized.\\n         * NOTE: this method MODIFIES the input array.\\n         * @param {Array} ary the array of path segments.\\n         */\\n        function trimDots(ary) {\\n            var i, part;\\n            for (i = 0; i < ary.length; i++) {\\n                part = ary[i];\\n                if (part === '.') {\\n                    ary.splice(i, 1);\\n                    i -= 1;\\n                } else if (part === '..') {\\n                    // If at the start, or previous value is still ..,\\n                    // keep them so that when converted to a path it may\\n                    // still work when converted to a path, even though\\n                    // as an ID it is less than ideal. In larger point\\n                    // releases, may be better to just kick out an error.\\n                    if (i === 0 || (i == 1 && ary[2] === '..') || ary[i - 1] === '..') {\\n                        continue;\\n                    } else if (i > 0) {\\n                        ary.splice(i - 1, 2);\\n                        i -= 2;\\n                    }\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Given a relative module name, like ./something, normalize it to\\n         * a real name that can be mapped to a path.\\n         * @param {String} name the relative name\\n         * @param {String} baseName a real name that the name arg is relative\\n         * to.\\n         * @param {Boolean} applyMap apply the map config to the value. Should\\n         * only be done if this normalization is for a dependency ID.\\n         * @returns {String} normalized name\\n         */\\n        function normalize(name, baseName, applyMap) {\\n            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,\\n                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,\\n                baseParts = (baseName && baseName.split('/')),\\n                map = config.map,\\n                starMap = map && map['*'];\\n\\n            //Adjust any relative paths.\\n            if (name) {\\n                name = name.split('/');\\n                lastIndex = name.length - 1;\\n\\n                // If wanting node ID compatibility, strip .js from end\\n                // of IDs. Have to do this here, and not in nameToUrl\\n                // because node allows either .js or non .js to map\\n                // to same file.\\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\\n                }\\n\\n                // Starts with a '.' so need the baseName\\n                if (name[0].charAt(0) === '.' && baseParts) {\\n                    //Convert baseName to array, and lop off the last part,\\n                    //so that . matches that 'directory' and not name of the baseName's\\n                    //module. For instance, baseName of 'one/two/three', maps to\\n                    //'one/two/three.js', but we want the directory, 'one/two' for\\n                    //this normalization.\\n                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\\n                    name = normalizedBaseParts.concat(name);\\n                }\\n\\n                trimDots(name);\\n                name = name.join('/');\\n            }\\n\\n            //Apply map config if available.\\n            if (applyMap && map && (baseParts || starMap)) {\\n                nameParts = name.split('/');\\n\\n                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {\\n                    nameSegment = nameParts.slice(0, i).join('/');\\n\\n                    if (baseParts) {\\n                        //Find the longest baseName segment match in the config.\\n                        //So, do joins on the biggest to smallest lengths of baseParts.\\n                        for (j = baseParts.length; j > 0; j -= 1) {\\n                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));\\n\\n                            //baseName segment has config, find if it has one for\\n                            //this name.\\n                            if (mapValue) {\\n                                mapValue = getOwn(mapValue, nameSegment);\\n                                if (mapValue) {\\n                                    //Match, update name to the new value.\\n                                    foundMap = mapValue;\\n                                    foundI = i;\\n                                    break outerLoop;\\n                                }\\n                            }\\n                        }\\n                    }\\n\\n                    //Check for a star map match, but just hold on to it,\\n                    //if there is a shorter segment match later in a matching\\n                    //config, then favor over this star map.\\n                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {\\n                        foundStarMap = getOwn(starMap, nameSegment);\\n                        starI = i;\\n                    }\\n                }\\n\\n                if (!foundMap && foundStarMap) {\\n                    foundMap = foundStarMap;\\n                    foundI = starI;\\n                }\\n\\n                if (foundMap) {\\n                    nameParts.splice(0, foundI, foundMap);\\n                    name = nameParts.join('/');\\n                }\\n            }\\n\\n            // If the name points to a package's name, use\\n            // the package main instead.\\n            pkgMain = getOwn(config.pkgs, name);\\n\\n            return pkgMain ? pkgMain : name;\\n        }\\n\\n        function removeScript(name) {\\n            if (isBrowser) {\\n                each(scripts(), function (scriptNode) {\\n                    if (scriptNode.getAttribute('data-requiremodule') === name &&\\n                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {\\n                        scriptNode.parentNode.removeChild(scriptNode);\\n                        return true;\\n                    }\\n                });\\n            }\\n        }\\n\\n        function hasPathFallback(id) {\\n            var pathConfig = getOwn(config.paths, id);\\n            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {\\n                //Pop off the first array value, since it failed, and\\n                //retry\\n                pathConfig.shift();\\n                context.require.undef(id);\\n\\n                //Custom require that does not do map translation, since\\n                //ID is \\\"absolute\\\", already mapped/resolved.\\n                context.makeRequire(null, {\\n                    skipMap: true\\n                })([id]);\\n\\n                return true;\\n            }\\n        }\\n\\n        //Turns a plugin!resource to [plugin, resource]\\n        //with the plugin being undefined if the name\\n        //did not have a plugin prefix.\\n        function splitPrefix(name) {\\n            var prefix,\\n                index = name ? name.indexOf('!') : -1;\\n            if (index > -1) {\\n                prefix = name.substring(0, index);\\n                name = name.substring(index + 1, name.length);\\n            }\\n            return [prefix, name];\\n        }\\n\\n        /**\\n         * Creates a module mapping that includes plugin prefix, module\\n         * name, and path. If parentModuleMap is provided it will\\n         * also normalize the name via require.normalize()\\n         *\\n         * @param {String} name the module name\\n         * @param {String} [parentModuleMap] parent module map\\n         * for the module name, used to resolve relative names.\\n         * @param {Boolean} isNormalized: is the ID already normalized.\\n         * This is true if this call is done for a define() module ID.\\n         * @param {Boolean} applyMap: apply the map config to the ID.\\n         * Should only be true if this map is for a dependency.\\n         *\\n         * @returns {Object}\\n         */\\n        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {\\n            var url, pluginModule, suffix, nameParts,\\n                prefix = null,\\n                parentName = parentModuleMap ? parentModuleMap.name : null,\\n                originalName = name,\\n                isDefine = true,\\n                normalizedName = '';\\n\\n            //If no name, then it means it is a require call, generate an\\n            //internal name.\\n            if (!name) {\\n                isDefine = false;\\n                name = '_@r' + (requireCounter += 1);\\n            }\\n\\n            nameParts = splitPrefix(name);\\n            prefix = nameParts[0];\\n            name = nameParts[1];\\n\\n            if (prefix) {\\n                prefix = normalize(prefix, parentName, applyMap);\\n                pluginModule = getOwn(defined, prefix);\\n            }\\n\\n            //Account for relative paths if there is a base name.\\n            if (name) {\\n                if (prefix) {\\n                    if (pluginModule && pluginModule.normalize) {\\n                        //Plugin is loaded, use its normalize method.\\n                        normalizedName = pluginModule.normalize(name, function (name) {\\n                            return normalize(name, parentName, applyMap);\\n                        });\\n                    } else {\\n                        // If nested plugin references, then do not try to\\n                        // normalize, as it will not normalize correctly. This\\n                        // places a restriction on resourceIds, and the longer\\n                        // term solution is not to normalize until plugins are\\n                        // loaded and all normalizations to allow for async\\n                        // loading of a loader plugin. But for now, fixes the\\n                        // common uses. Details in #1131\\n                        normalizedName = name.indexOf('!') === -1 ?\\n                                         normalize(name, parentName, applyMap) :\\n                                         name;\\n                    }\\n                } else {\\n                    //A regular module.\\n                    normalizedName = normalize(name, parentName, applyMap);\\n\\n                    //Normalized name may be a plugin ID due to map config\\n                    //application in normalize. The map config values must\\n                    //already be normalized, so do not need to redo that part.\\n                    nameParts = splitPrefix(normalizedName);\\n                    prefix = nameParts[0];\\n                    normalizedName = nameParts[1];\\n                    isNormalized = true;\\n\\n                    url = context.nameToUrl(normalizedName);\\n                }\\n            }\\n\\n            //If the id is a plugin id that cannot be determined if it needs\\n            //normalization, stamp it with a unique ID so two matching relative\\n            //ids that may conflict can be separate.\\n            suffix = prefix && !pluginModule && !isNormalized ?\\n                     '_unnormalized' + (unnormalizedCounter += 1) :\\n                     '';\\n\\n            return {\\n                prefix: prefix,\\n                name: normalizedName,\\n                parentMap: parentModuleMap,\\n                unnormalized: !!suffix,\\n                url: url,\\n                originalName: originalName,\\n                isDefine: isDefine,\\n                id: (prefix ?\\n                        prefix + '!' + normalizedName :\\n                        normalizedName) + suffix\\n            };\\n        }\\n\\n        function getModule(depMap) {\\n            var id = depMap.id,\\n                mod = getOwn(registry, id);\\n\\n            if (!mod) {\\n                mod = registry[id] = new context.Module(depMap);\\n            }\\n\\n            return mod;\\n        }\\n\\n        function on(depMap, name, fn) {\\n            var id = depMap.id,\\n                mod = getOwn(registry, id);\\n\\n            if (hasProp(defined, id) &&\\n                    (!mod || mod.defineEmitComplete)) {\\n                if (name === 'defined') {\\n                    fn(defined[id]);\\n                }\\n            } else {\\n                mod = getModule(depMap);\\n                if (mod.error && name === 'error') {\\n                    fn(mod.error);\\n                } else {\\n                    mod.on(name, fn);\\n                }\\n            }\\n        }\\n\\n        function onError(err, errback) {\\n            var ids = err.requireModules,\\n                notified = false;\\n\\n            if (errback) {\\n                errback(err);\\n            } else {\\n                each(ids, function (id) {\\n                    var mod = getOwn(registry, id);\\n                    if (mod) {\\n                        //Set error on module, so it skips timeout checks.\\n                        mod.error = err;\\n                        if (mod.events.error) {\\n                            notified = true;\\n                            mod.emit('error', err);\\n                        }\\n                    }\\n                });\\n\\n                if (!notified) {\\n                    req.onError(err);\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Internal method to transfer globalQueue items to this context's\\n         * defQueue.\\n         */\\n        function takeGlobalQueue() {\\n            //Push all the globalDefQueue items into the context's defQueue\\n            if (globalDefQueue.length) {\\n                //Array splice in the values since the context code has a\\n                //local var ref to defQueue, so cannot just reassign the one\\n                //on context.\\n                apsp.apply(defQueue,\\n                           [defQueue.length, 0].concat(globalDefQueue));\\n                globalDefQueue = [];\\n            }\\n        }\\n\\n        handlers = {\\n            'require': function (mod) {\\n                if (mod.require) {\\n                    return mod.require;\\n                } else {\\n                    return (mod.require = context.makeRequire(mod.map));\\n                }\\n            },\\n            'exports': function (mod) {\\n                mod.usingExports = true;\\n                if (mod.map.isDefine) {\\n                    if (mod.exports) {\\n                        return (defined[mod.map.id] = mod.exports);\\n                    } else {\\n                        return (mod.exports = defined[mod.map.id] = {});\\n                    }\\n                }\\n            },\\n            'module': function (mod) {\\n                if (mod.module) {\\n                    return mod.module;\\n                } else {\\n                    return (mod.module = {\\n                        id: mod.map.id,\\n                        uri: mod.map.url,\\n                        config: function () {\\n                            return  getOwn(config.config, mod.map.id) || {};\\n                        },\\n                        exports: mod.exports || (mod.exports = {})\\n                    });\\n                }\\n            }\\n        };\\n\\n        function cleanRegistry(id) {\\n            //Clean up machinery used for waiting modules.\\n            delete registry[id];\\n            delete enabledRegistry[id];\\n        }\\n\\n        function breakCycle(mod, traced, processed) {\\n            var id = mod.map.id;\\n\\n            if (mod.error) {\\n                mod.emit('error', mod.error);\\n            } else {\\n                traced[id] = true;\\n                each(mod.depMaps, function (depMap, i) {\\n                    var depId = depMap.id,\\n                        dep = getOwn(registry, depId);\\n\\n                    //Only force things that have not completed\\n                    //being defined, so still in the registry,\\n                    //and only if it has not been matched up\\n                    //in the module already.\\n                    if (dep && !mod.depMatched[i] && !processed[depId]) {\\n                        if (getOwn(traced, depId)) {\\n                            mod.defineDep(i, defined[depId]);\\n                            mod.check(); //pass false?\\n                        } else {\\n                            breakCycle(dep, traced, processed);\\n                        }\\n                    }\\n                });\\n                processed[id] = true;\\n            }\\n        }\\n\\n        function checkLoaded() {\\n            var err, usingPathFallback,\\n                waitInterval = config.waitSeconds * 1000,\\n                //It is possible to disable the wait interval by using waitSeconds of 0.\\n                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),\\n                noLoads = [],\\n                reqCalls = [],\\n                stillLoading = false,\\n                needCycleCheck = true;\\n\\n            //Do not bother if this call was a result of a cycle break.\\n            if (inCheckLoaded) {\\n                return;\\n            }\\n\\n            inCheckLoaded = true;\\n\\n            //Figure out the state of all the modules.\\n            eachProp(enabledRegistry, function (mod) {\\n                var map = mod.map,\\n                    modId = map.id;\\n\\n                //Skip things that are not enabled or in error state.\\n                if (!mod.enabled) {\\n                    return;\\n                }\\n\\n                if (!map.isDefine) {\\n                    reqCalls.push(mod);\\n                }\\n\\n                if (!mod.error) {\\n                    //If the module should be executed, and it has not\\n                    //been inited and time is up, remember it.\\n                    if (!mod.inited && expired) {\\n                        if (hasPathFallback(modId)) {\\n                            usingPathFallback = true;\\n                            stillLoading = true;\\n                        } else {\\n                            noLoads.push(modId);\\n                            removeScript(modId);\\n                        }\\n                    } else if (!mod.inited && mod.fetched && map.isDefine) {\\n                        stillLoading = true;\\n                        if (!map.prefix) {\\n                            //No reason to keep looking for unfinished\\n                            //loading. If the only stillLoading is a\\n                            //plugin resource though, keep going,\\n                            //because it may be that a plugin resource\\n                            //is waiting on a non-plugin cycle.\\n                            return (needCycleCheck = false);\\n                        }\\n                    }\\n                }\\n            });\\n\\n            if (expired && noLoads.length) {\\n                //If wait time expired, throw error of unloaded modules.\\n                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);\\n                err.contextName = context.contextName;\\n                return onError(err);\\n            }\\n\\n            //Not expired, check for a cycle.\\n            if (needCycleCheck) {\\n                each(reqCalls, function (mod) {\\n                    breakCycle(mod, {}, {});\\n                });\\n            }\\n\\n            //If still waiting on loads, and the waiting load is something\\n            //other than a plugin resource, or there are still outstanding\\n            //scripts, then just try back later.\\n            if ((!expired || usingPathFallback) && stillLoading) {\\n                //Something is still waiting to load. Wait for it, but only\\n                //if a timeout is not already in effect.\\n                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {\\n                    checkLoadedTimeoutId = setTimeout(function () {\\n                        checkLoadedTimeoutId = 0;\\n                        checkLoaded();\\n                    }, 50);\\n                }\\n            }\\n\\n            inCheckLoaded = false;\\n        }\\n\\n        Module = function (map) {\\n            this.events = getOwn(undefEvents, map.id) || {};\\n            this.map = map;\\n            this.shim = getOwn(config.shim, map.id);\\n            this.depExports = [];\\n            this.depMaps = [];\\n            this.depMatched = [];\\n            this.pluginMaps = {};\\n            this.depCount = 0;\\n\\n            /* this.exports this.factory\\n               this.depMaps = [],\\n               this.enabled, this.fetched\\n            */\\n        };\\n\\n        Module.prototype = {\\n            init: function (depMaps, factory, errback, options) {\\n                options = options || {};\\n\\n                //Do not do more inits if already done. Can happen if there\\n                //are multiple define calls for the same module. That is not\\n                //a normal, common case, but it is also not unexpected.\\n                if (this.inited) {\\n                    return;\\n                }\\n\\n                this.factory = factory;\\n\\n                if (errback) {\\n                    //Register for errors on this module.\\n                    this.on('error', errback);\\n                } else if (this.events.error) {\\n                    //If no errback already, but there are error listeners\\n                    //on this module, set up an errback to pass to the deps.\\n                    errback = bind(this, function (err) {\\n                        this.emit('error', err);\\n                    });\\n                }\\n\\n                //Do a copy of the dependency array, so that\\n                //source inputs are not modified. For example\\n                //\\\"shim\\\" deps are passed in here directly, and\\n                //doing a direct modification of the depMaps array\\n                //would affect that config.\\n                this.depMaps = depMaps && depMaps.slice(0);\\n\\n                this.errback = errback;\\n\\n                //Indicate this module has be initialized\\n                this.inited = true;\\n\\n                this.ignore = options.ignore;\\n\\n                //Could have option to init this module in enabled mode,\\n                //or could have been previously marked as enabled. However,\\n                //the dependencies are not known until init is called. So\\n                //if enabled previously, now trigger dependencies as enabled.\\n                if (options.enabled || this.enabled) {\\n                    //Enable this module and dependencies.\\n                    //Will call this.check()\\n                    this.enable();\\n                } else {\\n                    this.check();\\n                }\\n            },\\n\\n            defineDep: function (i, depExports) {\\n                //Because of cycles, defined callback for a given\\n                //export can be called more than once.\\n                if (!this.depMatched[i]) {\\n                    this.depMatched[i] = true;\\n                    this.depCount -= 1;\\n                    this.depExports[i] = depExports;\\n                }\\n            },\\n\\n            fetch: function () {\\n                if (this.fetched) {\\n                    return;\\n                }\\n                this.fetched = true;\\n\\n                context.startTime = (new Date()).getTime();\\n\\n                var map = this.map;\\n\\n                //If the manager is for a plugin managed resource,\\n                //ask the plugin to load it now.\\n                if (this.shim) {\\n                    context.makeRequire(this.map, {\\n                        enableBuildCallback: true\\n                    })(this.shim.deps || [], bind(this, function () {\\n                        return map.prefix ? this.callPlugin() : this.load();\\n                    }));\\n                } else {\\n                    //Regular dependency.\\n                    return map.prefix ? this.callPlugin() : this.load();\\n                }\\n            },\\n\\n            load: function () {\\n                var url = this.map.url;\\n\\n                //Regular dependency.\\n                if (!urlFetched[url]) {\\n                    urlFetched[url] = true;\\n                    context.load(this.map.id, url);\\n                }\\n            },\\n\\n            /**\\n             * Checks if the module is ready to define itself, and if so,\\n             * define it.\\n             */\\n            check: function () {\\n                if (!this.enabled || this.enabling) {\\n                    return;\\n                }\\n\\n                var err, cjsModule,\\n                    id = this.map.id,\\n                    depExports = this.depExports,\\n                    exports = this.exports,\\n                    factory = this.factory;\\n\\n                if (!this.inited) {\\n                    this.fetch();\\n                } else if (this.error) {\\n                    this.emit('error', this.error);\\n                } else if (!this.defining) {\\n                    //The factory could trigger another require call\\n                    //that would result in checking this module to\\n                    //define itself again. If already in the process\\n                    //of doing that, skip this work.\\n                    this.defining = true;\\n\\n                    if (this.depCount < 1 && !this.defined) {\\n                        if (isFunction(factory)) {\\n                            //If there is an error listener, favor passing\\n                            //to that instead of throwing an error. However,\\n                            //only do it for define()'d  modules. require\\n                            //errbacks should not be called for failures in\\n                            //their callbacks (#699). However if a global\\n                            //onError is set, use that.\\n                            if ((this.events.error && this.map.isDefine) ||\\n                                req.onError !== defaultOnError) {\\n                                try {\\n                                    exports = context.execCb(id, factory, depExports, exports);\\n                                } catch (e) {\\n                                    err = e;\\n                                }\\n                            } else {\\n                                exports = context.execCb(id, factory, depExports, exports);\\n                            }\\n\\n                            // Favor return value over exports. If node/cjs in play,\\n                            // then will not have a return value anyway. Favor\\n                            // module.exports assignment over exports object.\\n                            if (this.map.isDefine && exports === undefined) {\\n                                cjsModule = this.module;\\n                                if (cjsModule) {\\n                                    exports = cjsModule.exports;\\n                                } else if (this.usingExports) {\\n                                    //exports already set the defined value.\\n                                    exports = this.exports;\\n                                }\\n                            }\\n\\n                            if (err) {\\n                                err.requireMap = this.map;\\n                                err.requireModules = this.map.isDefine ? [this.map.id] : null;\\n                                err.requireType = this.map.isDefine ? 'define' : 'require';\\n                                return onError((this.error = err));\\n                            }\\n\\n                        } else {\\n                            //Just a literal value\\n                            exports = factory;\\n                        }\\n\\n                        this.exports = exports;\\n\\n                        if (this.map.isDefine && !this.ignore) {\\n                            defined[id] = exports;\\n\\n                            if (req.onResourceLoad) {\\n                                req.onResourceLoad(context, this.map, this.depMaps);\\n                            }\\n                        }\\n\\n                        //Clean up\\n                        cleanRegistry(id);\\n\\n                        this.defined = true;\\n                    }\\n\\n                    //Finished the define stage. Allow calling check again\\n                    //to allow define notifications below in the case of a\\n                    //cycle.\\n                    this.defining = false;\\n\\n                    if (this.defined && !this.defineEmitted) {\\n                        this.defineEmitted = true;\\n                        this.emit('defined', this.exports);\\n                        this.defineEmitComplete = true;\\n                    }\\n\\n                }\\n            },\\n\\n            callPlugin: function () {\\n                var map = this.map,\\n                    id = map.id,\\n                    //Map already normalized the prefix.\\n                    pluginMap = makeModuleMap(map.prefix);\\n\\n                //Mark this as a dependency for this plugin, so it\\n                //can be traced for cycles.\\n                this.depMaps.push(pluginMap);\\n\\n                on(pluginMap, 'defined', bind(this, function (plugin) {\\n                    var load, normalizedMap, normalizedMod,\\n                        bundleId = getOwn(bundlesMap, this.map.id),\\n                        name = this.map.name,\\n                        parentName = this.map.parentMap ? this.map.parentMap.name : null,\\n                        localRequire = context.makeRequire(map.parentMap, {\\n                            enableBuildCallback: true\\n                        });\\n\\n                    //If current map is not normalized, wait for that\\n                    //normalized name to load instead of continuing.\\n                    if (this.map.unnormalized) {\\n                        //Normalize the ID if the plugin allows it.\\n                        if (plugin.normalize) {\\n                            name = plugin.normalize(name, function (name) {\\n                                return normalize(name, parentName, true);\\n                            }) || '';\\n                        }\\n\\n                        //prefix and name should already be normalized, no need\\n                        //for applying map config again either.\\n                        normalizedMap = makeModuleMap(map.prefix + '!' + name,\\n                                                      this.map.parentMap);\\n                        on(normalizedMap,\\n                            'defined', bind(this, function (value) {\\n                                this.init([], function () { return value; }, null, {\\n                                    enabled: true,\\n                                    ignore: true\\n                                });\\n                            }));\\n\\n                        normalizedMod = getOwn(registry, normalizedMap.id);\\n                        if (normalizedMod) {\\n                            //Mark this as a dependency for this plugin, so it\\n                            //can be traced for cycles.\\n                            this.depMaps.push(normalizedMap);\\n\\n                            if (this.events.error) {\\n                                normalizedMod.on('error', bind(this, function (err) {\\n                                    this.emit('error', err);\\n                                }));\\n                            }\\n                            normalizedMod.enable();\\n                        }\\n\\n                        return;\\n                    }\\n\\n                    //If a paths config, then just load that file instead to\\n                    //resolve the plugin, as it is built into that paths layer.\\n                    if (bundleId) {\\n                        this.map.url = context.nameToUrl(bundleId);\\n                        this.load();\\n                        return;\\n                    }\\n\\n                    load = bind(this, function (value) {\\n                        this.init([], function () { return value; }, null, {\\n                            enabled: true\\n                        });\\n                    });\\n\\n                    load.error = bind(this, function (err) {\\n                        this.inited = true;\\n                        this.error = err;\\n                        err.requireModules = [id];\\n\\n                        //Remove temp unnormalized modules for this module,\\n                        //since they will never be resolved otherwise now.\\n                        eachProp(registry, function (mod) {\\n                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {\\n                                cleanRegistry(mod.map.id);\\n                            }\\n                        });\\n\\n                        onError(err);\\n                    });\\n\\n                    //Allow plugins to load other code without having to know the\\n                    //context or how to 'complete' the load.\\n                    load.fromText = bind(this, function (text, textAlt) {\\n                        /*jslint evil: true */\\n                        var moduleName = map.name,\\n                            moduleMap = makeModuleMap(moduleName),\\n                            hasInteractive = useInteractive;\\n\\n                        //As of 2.1.0, support just passing the text, to reinforce\\n                        //fromText only being called once per resource. Still\\n                        //support old style of passing moduleName but discard\\n                        //that moduleName in favor of the internal ref.\\n                        if (textAlt) {\\n                            text = textAlt;\\n                        }\\n\\n                        //Turn off interactive script matching for IE for any define\\n                        //calls in the text, then turn it back on at the end.\\n                        if (hasInteractive) {\\n                            useInteractive = false;\\n                        }\\n\\n                        //Prime the system by creating a module instance for\\n                        //it.\\n                        getModule(moduleMap);\\n\\n                        //Transfer any config to this other module.\\n                        if (hasProp(config.config, id)) {\\n                            config.config[moduleName] = config.config[id];\\n                        }\\n\\n                        try {\\n                            req.exec(text);\\n                        } catch (e) {\\n                            return onError(makeError('fromtexteval',\\n                                             'fromText eval for ' + id +\\n                                            ' failed: ' + e,\\n                                             e,\\n                                             [id]));\\n                        }\\n\\n                        if (hasInteractive) {\\n                            useInteractive = true;\\n                        }\\n\\n                        //Mark this as a dependency for the plugin\\n                        //resource\\n                        this.depMaps.push(moduleMap);\\n\\n                        //Support anonymous modules.\\n                        context.completeLoad(moduleName);\\n\\n                        //Bind the value of that module to the value for this\\n                        //resource ID.\\n                        localRequire([moduleName], load);\\n                    });\\n\\n                    //Use parentName here since the plugin's name is not reliable,\\n                    //could be some weird string with no path that actually wants to\\n                    //reference the parentName's path.\\n                    plugin.load(map.name, localRequire, load, config);\\n                }));\\n\\n                context.enable(pluginMap, this);\\n                this.pluginMaps[pluginMap.id] = pluginMap;\\n            },\\n\\n            enable: function () {\\n                enabledRegistry[this.map.id] = this;\\n                this.enabled = true;\\n\\n                //Set flag mentioning that the module is enabling,\\n                //so that immediate calls to the defined callbacks\\n                //for dependencies do not trigger inadvertent load\\n                //with the depCount still being zero.\\n                this.enabling = true;\\n\\n                //Enable each dependency\\n                each(this.depMaps, bind(this, function (depMap, i) {\\n                    var id, mod, handler;\\n\\n                    if (typeof depMap === 'string') {\\n                        //Dependency needs to be converted to a depMap\\n                        //and wired up to this module.\\n                        depMap = makeModuleMap(depMap,\\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\\n                                               false,\\n                                               !this.skipMap);\\n                        this.depMaps[i] = depMap;\\n\\n                        handler = getOwn(handlers, depMap.id);\\n\\n                        if (handler) {\\n                            this.depExports[i] = handler(this);\\n                            return;\\n                        }\\n\\n                        this.depCount += 1;\\n\\n                        on(depMap, 'defined', bind(this, function (depExports) {\\n                            this.defineDep(i, depExports);\\n                            this.check();\\n                        }));\\n\\n                        if (this.errback) {\\n                            on(depMap, 'error', bind(this, this.errback));\\n                        }\\n                    }\\n\\n                    id = depMap.id;\\n                    mod = registry[id];\\n\\n                    //Skip special modules like 'require', 'exports', 'module'\\n                    //Also, don't call enable if it is already enabled,\\n                    //important in circular dependency cases.\\n                    if (!hasProp(handlers, id) && mod && !mod.enabled) {\\n                        context.enable(depMap, this);\\n                    }\\n                }));\\n\\n                //Enable each plugin that is used in\\n                //a dependency\\n                eachProp(this.pluginMaps, bind(this, function (pluginMap) {\\n                    var mod = getOwn(registry, pluginMap.id);\\n                    if (mod && !mod.enabled) {\\n                        context.enable(pluginMap, this);\\n                    }\\n                }));\\n\\n                this.enabling = false;\\n\\n                this.check();\\n            },\\n\\n            on: function (name, cb) {\\n                var cbs = this.events[name];\\n                if (!cbs) {\\n                    cbs = this.events[name] = [];\\n                }\\n                cbs.push(cb);\\n            },\\n\\n            emit: function (name, evt) {\\n                each(this.events[name], function (cb) {\\n                    cb(evt);\\n                });\\n                if (name === 'error') {\\n                    //Now that the error handler was triggered, remove\\n                    //the listeners, since this broken Module instance\\n                    //can stay around for a while in the registry.\\n                    delete this.events[name];\\n                }\\n            }\\n        };\\n\\n        function callGetModule(args) {\\n            //Skip modules already defined.\\n            if (!hasProp(defined, args[0])) {\\n                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);\\n            }\\n        }\\n\\n        function removeListener(node, func, name, ieName) {\\n            //Favor detachEvent because of IE9\\n            //issue, see attachEvent/addEventListener comment elsewhere\\n            //in this file.\\n            if (node.detachEvent && !isOpera) {\\n                //Probably IE. If not it will throw an error, which will be\\n                //useful to know.\\n                if (ieName) {\\n                    node.detachEvent(ieName, func);\\n                }\\n            } else {\\n                node.removeEventListener(name, func, false);\\n            }\\n        }\\n\\n        /**\\n         * Given an event from a script node, get the requirejs info from it,\\n         * and then removes the event listeners on the node.\\n         * @param {Event} evt\\n         * @returns {Object}\\n         */\\n        function getScriptData(evt) {\\n            //Using currentTarget instead of target for Firefox 2.0's sake. Not\\n            //all old browsers will be supported, but this one was easy enough\\n            //to support and still makes sense.\\n            var node = evt.currentTarget || evt.srcElement;\\n\\n            //Remove the listeners once here.\\n            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');\\n            removeListener(node, context.onScriptError, 'error');\\n\\n            return {\\n                node: node,\\n                id: node && node.getAttribute('data-requiremodule')\\n            };\\n        }\\n\\n        function intakeDefines() {\\n            var args;\\n\\n            //Any defined modules in the global queue, intake them now.\\n            takeGlobalQueue();\\n\\n            //Make sure any remaining defQueue items get properly processed.\\n            while (defQueue.length) {\\n                args = defQueue.shift();\\n                if (args[0] === null) {\\n                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));\\n                } else {\\n                    //args are id, deps, factory. Should be normalized by the\\n                    //define() function.\\n                    callGetModule(args);\\n                }\\n            }\\n        }\\n\\n        context = {\\n            config: config,\\n            contextName: contextName,\\n            registry: registry,\\n            defined: defined,\\n            urlFetched: urlFetched,\\n            defQueue: defQueue,\\n            Module: Module,\\n            makeModuleMap: makeModuleMap,\\n            nextTick: req.nextTick,\\n            onError: onError,\\n\\n            /**\\n             * Set a configuration for the context.\\n             * @param {Object} cfg config object to integrate.\\n             */\\n            configure: function (cfg) {\\n                //Make sure the baseUrl ends in a slash.\\n                if (cfg.baseUrl) {\\n                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {\\n                        cfg.baseUrl += '/';\\n                    }\\n                }\\n\\n                //Save off the paths since they require special processing,\\n                //they are additive.\\n                var shim = config.shim,\\n                    objs = {\\n                        paths: true,\\n                        bundles: true,\\n                        config: true,\\n                        map: true\\n                    };\\n\\n                eachProp(cfg, function (value, prop) {\\n                    if (objs[prop]) {\\n                        if (!config[prop]) {\\n                            config[prop] = {};\\n                        }\\n                        mixin(config[prop], value, true, true);\\n                    } else {\\n                        config[prop] = value;\\n                    }\\n                });\\n\\n                //Reverse map the bundles\\n                if (cfg.bundles) {\\n                    eachProp(cfg.bundles, function (value, prop) {\\n                        each(value, function (v) {\\n                            if (v !== prop) {\\n                                bundlesMap[v] = prop;\\n                            }\\n                        });\\n                    });\\n                }\\n\\n                //Merge shim\\n                if (cfg.shim) {\\n                    eachProp(cfg.shim, function (value, id) {\\n                        //Normalize the structure\\n                        if (isArray(value)) {\\n                            value = {\\n                                deps: value\\n                            };\\n                        }\\n                        if ((value.exports || value.init) && !value.exportsFn) {\\n                            value.exportsFn = context.makeShimExports(value);\\n                        }\\n                        shim[id] = value;\\n                    });\\n                    config.shim = shim;\\n                }\\n\\n                //Adjust packages if necessary.\\n                if (cfg.packages) {\\n                    each(cfg.packages, function (pkgObj) {\\n                        var location, name;\\n\\n                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;\\n\\n                        name = pkgObj.name;\\n                        location = pkgObj.location;\\n                        if (location) {\\n                            config.paths[name] = pkgObj.location;\\n                        }\\n\\n                        //Save pointer to main module ID for pkg name.\\n                        //Remove leading dot in main, so main paths are normalized,\\n                        //and remove any trailing .js, since different package\\n                        //envs have different conventions: some use a module name,\\n                        //some use a file name.\\n                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')\\n                                     .replace(currDirRegExp, '')\\n                                     .replace(jsSuffixRegExp, '');\\n                    });\\n                }\\n\\n                //If there are any \\\"waiting to execute\\\" modules in the registry,\\n                //update the maps for them, since their info, like URLs to load,\\n                //may have changed.\\n                eachProp(registry, function (mod, id) {\\n                    //If module already has init called, since it is too\\n                    //late to modify them, and ignore unnormalized ones\\n                    //since they are transient.\\n                    if (!mod.inited && !mod.map.unnormalized) {\\n                        mod.map = makeModuleMap(id);\\n                    }\\n                });\\n\\n                //If a deps array or a config callback is specified, then call\\n                //require with those args. This is useful when require is defined as a\\n                //config object before require.js is loaded.\\n                if (cfg.deps || cfg.callback) {\\n                    context.require(cfg.deps || [], cfg.callback);\\n                }\\n            },\\n\\n            makeShimExports: function (value) {\\n                function fn() {\\n                    var ret;\\n                    if (value.init) {\\n                        ret = value.init.apply(global, arguments);\\n                    }\\n                    return ret || (value.exports && getGlobal(value.exports));\\n                }\\n                return fn;\\n            },\\n\\n            makeRequire: function (relMap, options) {\\n                options = options || {};\\n\\n                function localRequire(deps, callback, errback) {\\n                    var id, map, requireMod;\\n\\n                    if (options.enableBuildCallback && callback && isFunction(callback)) {\\n                        callback.__requireJsBuild = true;\\n                    }\\n\\n                    if (typeof deps === 'string') {\\n                        if (isFunction(callback)) {\\n                            //Invalid call\\n                            return onError(makeError('requireargs', 'Invalid require call'), errback);\\n                        }\\n\\n                        //If require|exports|module are requested, get the\\n                        //value for them from the special handlers. Caveat:\\n                        //this only works while module is being defined.\\n                        if (relMap && hasProp(handlers, deps)) {\\n                            return handlers[deps](registry[relMap.id]);\\n                        }\\n\\n                        //Synchronous access to one module. If require.get is\\n                        //available (as in the Node adapter), prefer that.\\n                        if (req.get) {\\n                            return req.get(context, deps, relMap, localRequire);\\n                        }\\n\\n                        //Normalize module name, if it contains . or ..\\n                        map = makeModuleMap(deps, relMap, false, true);\\n                        id = map.id;\\n\\n                        if (!hasProp(defined, id)) {\\n                            return onError(makeError('notloaded', 'Module name \\\"' +\\n                                        id +\\n                                        '\\\" has not been loaded yet for context: ' +\\n                                        contextName +\\n                                        (relMap ? '' : '. Use require([])')));\\n                        }\\n                        return defined[id];\\n                    }\\n\\n                    //Grab defines waiting in the global queue.\\n                    intakeDefines();\\n\\n                    //Mark all the dependencies as needing to be loaded.\\n                    context.nextTick(function () {\\n                        //Some defines could have been added since the\\n                        //require call, collect them.\\n                        intakeDefines();\\n\\n                        requireMod = getModule(makeModuleMap(null, relMap));\\n\\n                        //Store if map config should be applied to this require\\n                        //call for dependencies.\\n                        requireMod.skipMap = options.skipMap;\\n\\n                        requireMod.init(deps, callback, errback, {\\n                            enabled: true\\n                        });\\n\\n                        checkLoaded();\\n                    });\\n\\n                    return localRequire;\\n                }\\n\\n                mixin(localRequire, {\\n                    isBrowser: isBrowser,\\n\\n                    /**\\n                     * Converts a module name + .extension into an URL path.\\n                     * *Requires* the use of a module name. It does not support using\\n                     * plain URLs like nameToUrl.\\n                     */\\n                    toUrl: function (moduleNamePlusExt) {\\n                        var ext,\\n                            index = moduleNamePlusExt.lastIndexOf('.'),\\n                            segment = moduleNamePlusExt.split('/')[0],\\n                            isRelative = segment === '.' || segment === '..';\\n\\n                        //Have a file extension alias, and it is not the\\n                        //dots from a relative path.\\n                        if (index !== -1 && (!isRelative || index > 1)) {\\n                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);\\n                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);\\n                        }\\n\\n                        return context.nameToUrl(normalize(moduleNamePlusExt,\\n                                                relMap && relMap.id, true), ext,  true);\\n                    },\\n\\n                    defined: function (id) {\\n                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);\\n                    },\\n\\n                    specified: function (id) {\\n                        id = makeModuleMap(id, relMap, false, true).id;\\n                        return hasProp(defined, id) || hasProp(registry, id);\\n                    }\\n                });\\n\\n                //Only allow undef on top level require calls\\n                if (!relMap) {\\n                    localRequire.undef = function (id) {\\n                        //Bind any waiting define() calls to this context,\\n                        //fix for #408\\n                        takeGlobalQueue();\\n\\n                        var map = makeModuleMap(id, relMap, true),\\n                            mod = getOwn(registry, id);\\n\\n                        removeScript(id);\\n\\n                        delete defined[id];\\n                        delete urlFetched[map.url];\\n                        delete undefEvents[id];\\n\\n                        //Clean queued defines too. Go backwards\\n                        //in array so that the splices do not\\n                        //mess up the iteration.\\n                        eachReverse(defQueue, function(args, i) {\\n                            if(args[0] === id) {\\n                                defQueue.splice(i, 1);\\n                            }\\n                        });\\n\\n                        if (mod) {\\n                            //Hold on to listeners in case the\\n                            //module will be attempted to be reloaded\\n                            //using a different config.\\n                            if (mod.events.defined) {\\n                                undefEvents[id] = mod.events;\\n                            }\\n\\n                            cleanRegistry(id);\\n                        }\\n                    };\\n                }\\n\\n                return localRequire;\\n            },\\n\\n            /**\\n             * Called to enable a module if it is still in the registry\\n             * awaiting enablement. A second arg, parent, the parent module,\\n             * is passed in for context, when this method is overridden by\\n             * the optimizer. Not shown here to keep code compact.\\n             */\\n            enable: function (depMap) {\\n                var mod = getOwn(registry, depMap.id);\\n                if (mod) {\\n                    getModule(depMap).enable();\\n                }\\n            },\\n\\n            /**\\n             * Internal method used by environment adapters to complete a load event.\\n             * A load event could be a script load or just a load pass from a synchronous\\n             * load call.\\n             * @param {String} moduleName the name of the module to potentially complete.\\n             */\\n            completeLoad: function (moduleName) {\\n                var found, args, mod,\\n                    shim = getOwn(config.shim, moduleName) || {},\\n                    shExports = shim.exports;\\n\\n                takeGlobalQueue();\\n\\n                while (defQueue.length) {\\n                    args = defQueue.shift();\\n                    if (args[0] === null) {\\n                        args[0] = moduleName;\\n                        //If already found an anonymous module and bound it\\n                        //to this name, then this is some other anon module\\n                        //waiting for its completeLoad to fire.\\n                        if (found) {\\n                            break;\\n                        }\\n                        found = true;\\n                    } else if (args[0] === moduleName) {\\n                        //Found matching define call for this script!\\n                        found = true;\\n                    }\\n\\n                    callGetModule(args);\\n                }\\n\\n                //Do this after the cycle of callGetModule in case the result\\n                //of those calls/init calls changes the registry.\\n                mod = getOwn(registry, moduleName);\\n\\n                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {\\n                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {\\n                        if (hasPathFallback(moduleName)) {\\n                            return;\\n                        } else {\\n                            return onError(makeError('nodefine',\\n                                             'No define call for ' + moduleName,\\n                                             null,\\n                                             [moduleName]));\\n                        }\\n                    } else {\\n                        //A script that does not call define(), so just simulate\\n                        //the call for it.\\n                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);\\n                    }\\n                }\\n\\n                checkLoaded();\\n            },\\n\\n            /**\\n             * Converts a module name to a file path. Supports cases where\\n             * moduleName may actually be just an URL.\\n             * Note that it **does not** call normalize on the moduleName,\\n             * it is assumed to have already been normalized. This is an\\n             * internal API, not a public one. Use toUrl for the public API.\\n             */\\n            nameToUrl: function (moduleName, ext, skipExt) {\\n                var paths, syms, i, parentModule, url,\\n                    parentPath, bundleId,\\n                    pkgMain = getOwn(config.pkgs, moduleName);\\n\\n                if (pkgMain) {\\n                    moduleName = pkgMain;\\n                }\\n\\n                bundleId = getOwn(bundlesMap, moduleName);\\n\\n                if (bundleId) {\\n                    return context.nameToUrl(bundleId, ext, skipExt);\\n                }\\n\\n                //If a colon is in the URL, it indicates a protocol is used and it is just\\n                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)\\n                //or ends with .js, then assume the user meant to use an url and not a module id.\\n                //The slash is important for protocol-less URLs as well as full paths.\\n                if (req.jsExtRegExp.test(moduleName)) {\\n                    //Just a plain path, not module name lookup, so just return it.\\n                    //Add extension if it is included. This is a bit wonky, only non-.js things pass\\n                    //an extension, this method probably needs to be reworked.\\n                    url = moduleName + (ext || '');\\n                } else {\\n                    //A module that needs to be converted to a path.\\n                    paths = config.paths;\\n\\n                    syms = moduleName.split('/');\\n                    //For each module name segment, see if there is a path\\n                    //registered for it. Start with most specific name\\n                    //and work up from it.\\n                    for (i = syms.length; i > 0; i -= 1) {\\n                        parentModule = syms.slice(0, i).join('/');\\n\\n                        parentPath = getOwn(paths, parentModule);\\n                        if (parentPath) {\\n                            //If an array, it means there are a few choices,\\n                            //Choose the one that is desired\\n                            if (isArray(parentPath)) {\\n                                parentPath = parentPath[0];\\n                            }\\n                            syms.splice(0, i, parentPath);\\n                            break;\\n                        }\\n                    }\\n\\n                    //Join the path parts together, then figure out if baseUrl is needed.\\n                    url = syms.join('/');\\n                    url += (ext || (/^data\\\\:|\\\\?/.test(url) || skipExt ? '' : '.js'));\\n                    url = (url.charAt(0) === '/' || url.match(/^[\\\\w\\\\+\\\\.\\\\-]+:/) ? '' : config.baseUrl) + url;\\n                }\\n\\n                return config.urlArgs ? url +\\n                                        ((url.indexOf('?') === -1 ? '?' : '&') +\\n                                         config.urlArgs) : url;\\n            },\\n\\n            //Delegates to req.load. Broken out as a separate function to\\n            //allow overriding in the optimizer.\\n            load: function (id, url) {\\n                req.load(context, id, url);\\n            },\\n\\n            /**\\n             * Executes a module callback function. Broken out as a separate function\\n             * solely to allow the build system to sequence the files in the built\\n             * layer in the right sequence.\\n             *\\n             * @private\\n             */\\n            execCb: function (name, callback, args, exports) {\\n                return callback.apply(exports, args);\\n            },\\n\\n            /**\\n             * callback for script loads, used to check status of loading.\\n             *\\n             * @param {Event} evt the event from the browser for the script\\n             * that was loaded.\\n             */\\n            onScriptLoad: function (evt) {\\n                //Using currentTarget instead of target for Firefox 2.0's sake. Not\\n                //all old browsers will be supported, but this one was easy enough\\n                //to support and still makes sense.\\n                if (evt.type === 'load' ||\\n                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {\\n                    //Reset interactive script so a script node is not held onto for\\n                    //to long.\\n                    interactiveScript = null;\\n\\n                    //Pull out the name of the module and the context.\\n                    var data = getScriptData(evt);\\n                    context.completeLoad(data.id);\\n                }\\n            },\\n\\n            /**\\n             * Callback for script errors.\\n             */\\n            onScriptError: function (evt) {\\n                var data = getScriptData(evt);\\n                if (!hasPathFallback(data.id)) {\\n                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));\\n                }\\n            }\\n        };\\n\\n        context.require = context.makeRequire();\\n        return context;\\n    }\\n\\n    /**\\n     * Main entry point.\\n     *\\n     * If the only argument to require is a string, then the module that\\n     * is represented by that string is fetched for the appropriate context.\\n     *\\n     * If the first argument is an array, then it will be treated as an array\\n     * of dependency string names to fetch. An optional function callback can\\n     * be specified to execute when all of those dependencies are available.\\n     *\\n     * Make a local req variable to help Caja compliance (it assumes things\\n     * on a require that are not standardized), and to give a short\\n     * name for minification/local scope use.\\n     */\\n    req = requirejs = function (deps, callback, errback, optional) {\\n\\n        //Find the right context, use default\\n        var context, config,\\n            contextName = defContextName;\\n\\n        // Determine if have config object in the call.\\n        if (!isArray(deps) && typeof deps !== 'string') {\\n            // deps is a config object\\n            config = deps;\\n            if (isArray(callback)) {\\n                // Adjust args if there are dependencies\\n                deps = callback;\\n                callback = errback;\\n                errback = optional;\\n            } else {\\n                deps = [];\\n            }\\n        }\\n\\n        if (config && config.context) {\\n            contextName = config.context;\\n        }\\n\\n        context = getOwn(contexts, contextName);\\n        if (!context) {\\n            context = contexts[contextName] = req.s.newContext(contextName);\\n        }\\n\\n        if (config) {\\n            context.configure(config);\\n        }\\n\\n        return context.require(deps, callback, errback);\\n    };\\n\\n    /**\\n     * Support require.config() to make it easier to cooperate with other\\n     * AMD loaders on globally agreed names.\\n     */\\n    req.config = function (config) {\\n        return req(config);\\n    };\\n\\n    /**\\n     * Execute something after the current tick\\n     * of the event loop. Override for other envs\\n     * that have a better solution than setTimeout.\\n     * @param  {Function} fn function to execute later.\\n     */\\n    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {\\n        setTimeout(fn, 4);\\n    } : function (fn) { fn(); };\\n\\n    /**\\n     * Export require as a global, but only if it does not already exist.\\n     */\\n    if (!require) {\\n        require = req;\\n    }\\n\\n    req.version = version;\\n\\n    //Used to filter out dependencies that are already paths.\\n    req.jsExtRegExp = /^\\\\/|:|\\\\?|\\\\.js$/;\\n    req.isBrowser = isBrowser;\\n    s = req.s = {\\n        contexts: contexts,\\n        newContext: newContext\\n    };\\n\\n    //Create default context.\\n    req({});\\n\\n    //Exports some context-sensitive methods on global require.\\n    each([\\n        'toUrl',\\n        'undef',\\n        'defined',\\n        'specified'\\n    ], function (prop) {\\n        //Reference from contexts instead of early binding to default context,\\n        //so that during builds, the latest instance of the default context\\n        //with its config gets used.\\n        req[prop] = function () {\\n            var ctx = contexts[defContextName];\\n            return ctx.require[prop].apply(ctx, arguments);\\n        };\\n    });\\n\\n    if (isBrowser) {\\n        head = s.head = document.getElementsByTagName('head')[0];\\n        //If BASE tag is in play, using appendChild is a problem for IE6.\\n        //When that browser dies, this can be removed. Details in this jQuery bug:\\n        //http://dev.jquery.com/ticket/2709\\n        baseElement = document.getElementsByTagName('base')[0];\\n        if (baseElement) {\\n            head = s.head = baseElement.parentNode;\\n        }\\n    }\\n\\n    /**\\n     * Any errors that require explicitly generates will be passed to this\\n     * function. Intercept/override it if you want custom error handling.\\n     * @param {Error} err the error object.\\n     */\\n    req.onError = defaultOnError;\\n\\n    /**\\n     * Creates the node for the load command. Only used in browser envs.\\n     */\\n    req.createNode = function (config, moduleName, url) {\\n        var node = config.xhtml ?\\n                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :\\n                document.createElement('script');\\n        node.type = config.scriptType || 'text/javascript';\\n        node.charset = 'utf-8';\\n        node.async = true;\\n        return node;\\n    };\\n\\n    /**\\n     * Does the request to load a module for the browser case.\\n     * Make this a separate function to allow other environments\\n     * to override it.\\n     *\\n     * @param {Object} context the require context to find state.\\n     * @param {String} moduleName the name of the module.\\n     * @param {Object} url the URL to the module.\\n     */\\n    req.load = function (context, moduleName, url) {\\n        var config = (context && context.config) || {},\\n            node;\\n        if (isBrowser) {\\n            //In the browser so use a script tag\\n            node = req.createNode(config, moduleName, url);\\n\\n            node.setAttribute('data-requirecontext', context.contextName);\\n            node.setAttribute('data-requiremodule', moduleName);\\n\\n            //Set up load listener. Test attachEvent first because IE9 has\\n            //a subtle issue in its addEventListener and script onload firings\\n            //that do not match the behavior of all other browsers with\\n            //addEventListener support, which fire the onload event for a\\n            //script right after the script execution. See:\\n            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution\\n            //UNFORTUNATELY Opera implements attachEvent but does not follow the script\\n            //script execution mode.\\n            if (node.attachEvent &&\\n                    //Check if node.attachEvent is artificially added by custom script or\\n                    //natively supported by browser\\n                    //read https://github.com/jrburke/requirejs/issues/187\\n                    //if we can NOT find [native code] then it must NOT natively supported.\\n                    //in IE8, node.attachEvent does not have toString()\\n                    //Note the test for \\\"[native code\\\" with no closing brace, see:\\n                    //https://github.com/jrburke/requirejs/issues/273\\n                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&\\n                    !isOpera) {\\n                //Probably IE. IE (at least 6-8) do not fire\\n                //script onload right after executing the script, so\\n                //we cannot tie the anonymous define call to a name.\\n                //However, IE reports the script as being in 'interactive'\\n                //readyState at the time of the define call.\\n                useInteractive = true;\\n\\n                node.attachEvent('onreadystatechange', context.onScriptLoad);\\n                //It would be great to add an error handler here to catch\\n                //404s in IE9+. However, onreadystatechange will fire before\\n                //the error handler, so that does not help. If addEventListener\\n                //is used, then IE will fire error before load, but we cannot\\n                //use that pathway given the connect.microsoft.com issue\\n                //mentioned above about not doing the 'script execute,\\n                //then fire the script load event listener before execute\\n                //next script' that other browsers do.\\n                //Best hope: IE10 fixes the issues,\\n                //and then destroys all installs of IE 6-9.\\n                //node.attachEvent('onerror', context.onScriptError);\\n            } else {\\n                node.addEventListener('load', context.onScriptLoad, false);\\n                node.addEventListener('error', context.onScriptError, false);\\n            }\\n            node.src = url;\\n\\n            //For some cache cases in IE 6-8, the script executes before the end\\n            //of the appendChild execution, so to tie an anonymous define\\n            //call to the module name (which is stored on the node), hold on\\n            //to a reference to this node, but clear after the DOM insertion.\\n            currentlyAddingScript = node;\\n            if (baseElement) {\\n                head.insertBefore(node, baseElement);\\n            } else {\\n                head.appendChild(node);\\n            }\\n            currentlyAddingScript = null;\\n\\n            return node;\\n        } else if (isWebWorker) {\\n            try {\\n                //In a web worker, use importScripts. This is not a very\\n                //efficient use of importScripts, importScripts will block until\\n                //its script is downloaded and evaluated. However, if web workers\\n                //are in play, the expectation that a build has been done so that\\n                //only one script needs to be loaded anyway. This may need to be\\n                //reevaluated if other use cases become common.\\n                importScripts(url);\\n\\n                //Account for anonymous modules\\n                context.completeLoad(moduleName);\\n            } catch (e) {\\n                context.onError(makeError('importscripts',\\n                                'importScripts failed for ' +\\n                                    moduleName + ' at ' + url,\\n                                e,\\n                                [moduleName]));\\n            }\\n        }\\n    };\\n\\n    function getInteractiveScript() {\\n        if (interactiveScript && interactiveScript.readyState === 'interactive') {\\n            return interactiveScript;\\n        }\\n\\n        eachReverse(scripts(), function (script) {\\n            if (script.readyState === 'interactive') {\\n                return (interactiveScript = script);\\n            }\\n        });\\n        return interactiveScript;\\n    }\\n\\n    //Look for a data-main script attribute, which could also adjust the baseUrl.\\n    if (isBrowser && !cfg.skipDataMain) {\\n        //Figure out baseUrl. Get it from the script tag with require.js in it.\\n        eachReverse(scripts(), function (script) {\\n            //Set the 'head' where we can append children by\\n            //using the script's parent.\\n            if (!head) {\\n                head = script.parentNode;\\n            }\\n\\n            //Look for a data-main attribute to set main script for the page\\n            //to load. If it is there, the path to data main becomes the\\n            //baseUrl, if it is not already set.\\n            dataMain = script.getAttribute('data-main');\\n            if (dataMain) {\\n                //Preserve dataMain in case it is a path (i.e. contains '?')\\n                mainScript = dataMain;\\n\\n                //Set final baseUrl if there is not already an explicit one.\\n                if (!cfg.baseUrl) {\\n                    //Pull off the directory of data-main for use as the\\n                    //baseUrl.\\n                    src = mainScript.split('/');\\n                    mainScript = src.pop();\\n                    subPath = src.length ? src.join('/')  + '/' : './';\\n\\n                    cfg.baseUrl = subPath;\\n                }\\n\\n                //Strip off any trailing .js since mainScript is now\\n                //like a module name.\\n                mainScript = mainScript.replace(jsSuffixRegExp, '');\\n\\n                 //If mainScript is still a path, fall back to dataMain\\n                if (req.jsExtRegExp.test(mainScript)) {\\n                    mainScript = dataMain;\\n                }\\n\\n                //Put the data-main script in the files to load.\\n                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];\\n\\n                return true;\\n            }\\n        });\\n    }\\n\\n    /**\\n     * The function that handles definitions of modules. Differs from\\n     * require() in that a string for the module should be the first argument,\\n     * and the function to execute after dependencies are loaded should\\n     * return a value to define the module corresponding to the first argument's\\n     * name.\\n     */\\n    define = function (name, deps, callback) {\\n        var node, context;\\n\\n        //Allow for anonymous modules\\n        if (typeof name !== 'string') {\\n            //Adjust args appropriately\\n            callback = deps;\\n            deps = name;\\n            name = null;\\n        }\\n\\n        //This module may not have dependencies\\n        if (!isArray(deps)) {\\n            callback = deps;\\n            deps = null;\\n        }\\n\\n        //If no name, and callback is a function, then figure out if it a\\n        //CommonJS thing with dependencies.\\n        if (!deps && isFunction(callback)) {\\n            deps = [];\\n            //Remove comments from the callback string,\\n            //look for require calls, and pull them into the dependencies,\\n            //but only if there are function args.\\n            if (callback.length) {\\n                callback\\n                    .toString()\\n                    .replace(commentRegExp, '')\\n                    .replace(cjsRequireRegExp, function (match, dep) {\\n                        deps.push(dep);\\n                    });\\n\\n                //May be a CommonJS thing even without require calls, but still\\n                //could use exports, and module. Avoid doing exports and module\\n                //work though if it just needs require.\\n                //REQUIRES the function to expect the CommonJS variables in the\\n                //order listed below.\\n                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);\\n            }\\n        }\\n\\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\\n        //work.\\n        if (useInteractive) {\\n            node = currentlyAddingScript || getInteractiveScript();\\n            if (node) {\\n                if (!name) {\\n                    name = node.getAttribute('data-requiremodule');\\n                }\\n                context = contexts[node.getAttribute('data-requirecontext')];\\n            }\\n        }\\n\\n        //Always save off evaluating the def call until the script onload handler.\\n        //This allows multiple modules to be in a file without prematurely\\n        //tracing dependencies, and allows for anonymous module support,\\n        //where the module name is not known until the script onload event\\n        //occurs. If no context, use the global queue, and get it processed\\n        //in the onscript load callback.\\n        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);\\n    };\\n\\n    define.amd = {\\n        jQuery: true\\n    };\\n\\n\\n    /**\\n     * Executes the text. Normally just uses eval, but can be modified\\n     * to use a better, environment-specific call. Only used for transpiling\\n     * loader plugins, not for plain JS modules.\\n     * @param {String} text the text to execute/evaluate.\\n     */\\n    req.exec = function (text) {\\n        /*jslint evil: true */\\n        return eval(text);\\n    };\\n\\n    //Set up with config info.\\n    req(cfg);\\n}(this));\\n\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvcmVxdWlyZS5qcz83NGY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtqQkFBa2pCLHNCQUFzQix5MUNBQXkxQyxtQkFBbUIsZ0VBQWdFLGlDQUFpQywwREFBMEQsT0FBTyw4QkFBOEIsdURBQXVELE9BQU8sa0xBQWtMLG9CQUFvQixvQkFBb0IseUJBQXlCLGdCQUFnQixVQUFVLHVEQUF1RCw0QkFBNEIsbUJBQW1CLGVBQWUsV0FBVyxPQUFPLG1NQUFtTSxvQkFBb0Isb0JBQW9CLHNDQUFzQyxRQUFRLFVBQVUsdURBQXVELDRCQUE0QixtQkFBbUIsZUFBZSxXQUFXLE9BQU8scUNBQXFDLHdDQUF3QyxPQUFPLG9DQUFvQyxpREFBaUQsT0FBTyx5T0FBeU8sbUJBQW1CLDZCQUE2Qix1Q0FBdUMsOENBQThDLDRCQUE0QixtQkFBbUIsZUFBZSxXQUFXLE9BQU8sc09BQXNPLHVCQUF1Qix1REFBdUQsd0RBQXdELDJNQUEyTSxnREFBZ0QsZ0RBQWdELDJCQUEyQiw2RUFBNkUsdUJBQXVCLE9BQU8sK0NBQStDLHVCQUF1QixtQkFBbUIsZUFBZSxFQUFFLFdBQVcsd0JBQXdCLE9BQU8sdUxBQXVMLDhCQUE4Qiw4Q0FBOEMsWUFBWSxPQUFPLDRCQUE0Qix5REFBeUQsT0FBTyxzQ0FBc0Msb0JBQW9CLE9BQU8seUhBQXlILHVCQUF1QiwyQkFBMkIsV0FBVyx5QkFBeUIsa0RBQWtELDBCQUEwQixXQUFXLEVBQUUsbUJBQW1CLE9BQU8sd0dBQXdHLE9BQU8sbUVBQW1FLE9BQU8sK0NBQStDLE1BQU0sc0VBQXNFLE1BQU0saUVBQWlFLG9GQUFvRiw2QkFBNkIsNENBQTRDLG9CQUFvQixvQ0FBb0MsV0FBVyxtQkFBbUIsT0FBTyw0Q0FBNEMsZ0hBQWdILE9BQU8sK0NBQStDLHNDQUFzQyxxRkFBcUYsV0FBVywwQkFBMEIsZ0NBQWdDLE9BQU8sOEdBQThHLGlFQUFpRSw4QkFBOEIsT0FBTywwQ0FBMEMsa0hBQWtILDBRQUEwUSw4QkFBOEIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsZUFBZSw0QkFBNEIsdU1BQXVNLCtCQUErQix1REFBdUQsOEJBQThCLDhCQUE4Qix3RUFBd0UscWJBQXFiLE1BQU0sK0VBQStFLDBCQUEwQix5QkFBeUIsZ0JBQWdCLE9BQU8sZ0NBQWdDLHFDQUFxQyx1Q0FBdUMsNkJBQTZCLG1CQUFtQiwwQkFBMEIsd2NBQXdjLG1DQUFtQyx1QkFBdUIsa0JBQWtCLCtDQUErQyxpQ0FBaUMsdUJBQXVCLG1CQUFtQixlQUFlLFdBQVcsc0tBQXNLLE9BQU8sNENBQTRDLE9BQU8sd0ZBQXdGLFFBQVEsaUpBQWlKLE9BQU8scUZBQXFGLHlTQUF5UyxxRUFBcUUseUNBQXlDLDhDQUE4Qyw2VUFBNlUsb0ZBQW9GLG1CQUFtQiw0SEFBNEgsNGNBQTRjLDhEQUE4RCxtQkFBbUIsbUNBQW1DLHdDQUF3QyxlQUFlLDhHQUE4Ryw4Q0FBOEMseURBQXlELE9BQU8sVUFBVSxvRUFBb0Usd0NBQXdDLCtOQUErTixPQUFPLFVBQVUsc0ZBQXNGLDRLQUE0SywyRUFBMkUsaURBQWlELHNJQUFzSSxpREFBaUQsc0RBQXNELG1DQUFtQywrQkFBK0IsMkJBQTJCLHVCQUF1QiwrU0FBK1Msc0VBQXNFLG9DQUFvQyx1QkFBdUIsbUJBQW1CLG9EQUFvRCw4Q0FBOEMscUNBQXFDLG1CQUFtQixtQ0FBbUMsNERBQTRELGlEQUFpRCxtQkFBbUIsZUFBZSwwSkFBMEosZ0RBQWdELFdBQVcseUNBQXlDLDhCQUE4Qix5REFBeUQsMExBQTBMLHdFQUF3RSxzQ0FBc0MsdUJBQXVCLG1CQUFtQixFQUFFLGVBQWUsV0FBVywwQ0FBMEMsd0RBQXdELCtFQUErRSxxSUFBcUksNENBQTRDLHlMQUF5TCxzREFBc0QsUUFBUSxnQ0FBZ0MsZUFBZSxXQUFXLGlNQUFpTSxpRkFBaUYsK0JBQStCLG9EQUFvRCxnRUFBZ0UsZUFBZSxvQ0FBb0MsV0FBVyx3UEFBd1AsT0FBTywwQ0FBMEMsT0FBTywwSEFBMEgsUUFBUSx5SUFBeUksUUFBUSw4SUFBOEksT0FBTyw4RkFBOEYsa1JBQWtSLHFJQUFxSSxtQ0FBbUMsdURBQXVELGVBQWUsOENBQThDLG9DQUFvQyxrQ0FBa0MsNkJBQTZCLG1FQUFtRSx5REFBeUQsZUFBZSw4RkFBOEYsK0JBQStCLG1FQUFtRSxnS0FBZ0ssMkVBQTJFLDJCQUEyQixFQUFFLHVCQUF1QixPQUFPLHl0QkFBeXRCLHVCQUF1QixtQkFBbUIsT0FBTyxzSEFBc0gsd1NBQXdTLDRDQUE0QyxvREFBb0QsMENBQTBDLGdFQUFnRSxtQkFBbUIsZUFBZSx1WEFBdVgsd0JBQXdCLHFhQUFxYSxXQUFXLHdDQUF3Qyw4RUFBOEUsMkJBQTJCLGtFQUFrRSxlQUFlLDJCQUEyQixXQUFXLDJDQUEyQyw4RUFBOEUsb0dBQW9HLDJDQUEyQyxzQ0FBc0MsbUJBQW1CLGVBQWUsT0FBTywwQ0FBMEMsc0RBQXNELG9DQUFvQyxtQkFBbUIsT0FBTyx1Q0FBdUMsbUJBQW1CLGVBQWUsV0FBVyw0Q0FBNEMsOEVBQThFLDhCQUE4QiwrQkFBK0IsZUFBZSxPQUFPLDJDQUEyQyxxREFBcUQsZ0NBQWdDLHNIQUFzSCxpREFBaUQsOENBQThDLHFEQUFxRCwyQkFBMkIsdUJBQXVCLG1CQUFtQixFQUFFLG9DQUFvQyx1Q0FBdUMsbUJBQW1CLGVBQWUsV0FBVyxvS0FBb0ssdUhBQXVILHdTQUF3UyxzQ0FBc0MsZUFBZSxXQUFXLHdCQUF3Qix5Q0FBeUMsb0NBQW9DLHlDQUF5QyxtQkFBbUIsT0FBTywwRUFBMEUsbUJBQW1CLGVBQWUsMENBQTBDLDBDQUEwQyx5Q0FBeUMsd0NBQXdDLHFFQUFxRSx1QkFBdUIsT0FBTyx3RUFBd0UsRUFBRSx1QkFBdUIsbUJBQW1CLGVBQWUseUNBQXlDLG1DQUFtQyx3Q0FBd0MsbUJBQW1CLE9BQU8sNENBQTRDLG1JQUFtSSw4RUFBOEUsMkJBQTJCLG9FQUFvRSx3QkFBd0IsRUFBRSxtQkFBbUIsZUFBZSxZQUFZLHdDQUF3Qyw4RkFBOEYseUNBQXlDLFdBQVcseURBQXlELGtDQUFrQyxnQ0FBZ0MsK0NBQStDLGVBQWUsT0FBTyxvQ0FBb0MsMERBQTBELG9HQUFvRywwVEFBMFQsc0RBQXNELCtEQUErRCwwQ0FBMEMseUNBQXlDLE9BQU8saUVBQWlFLDJCQUEyQix1QkFBdUIsbUJBQW1CLEVBQUUsdUNBQXVDLGVBQWUsV0FBVyxvQ0FBb0Msa2JBQWtiLDZHQUE2Ryx5QkFBeUIsZUFBZSxxQ0FBcUMsa0hBQWtILHlFQUF5RSw4R0FBOEcsNkJBQTZCLG1CQUFtQix3Q0FBd0MseUNBQXlDLG1CQUFtQixxQ0FBcUMsMkxBQTJMLHVEQUF1RCx1REFBdUQsa0RBQWtELDJCQUEyQixPQUFPLGtEQUFrRCxrREFBa0QsMkJBQTJCLHVCQUF1Qix1REFBdUQsOENBQThDLDRDQUE0Qyx3WkFBd1osMkJBQTJCLHVCQUF1QixtQkFBbUIsZUFBZSxFQUFFLGdEQUFnRCw4S0FBOEssd0RBQXdELHNDQUFzQyxlQUFlLG9GQUFvRixpREFBaUQsd0NBQXdDLElBQUksRUFBRSxtQkFBbUIsRUFBRSxlQUFlLGdSQUFnUixtTkFBbU4scUVBQXFFLG1EQUFtRCx3Q0FBd0MsdUJBQXVCLE1BQU0sbUJBQW1CLGVBQWUsc0NBQXNDLFdBQVcscUNBQXFDLDhEQUE4RCw2QkFBNkIsc0RBQXNELG1DQUFtQyxnQ0FBZ0MsbUNBQW1DLG1DQUFtQyxnQ0FBZ0Msc0pBQXNKLGdDQUFnQyxtRUFBbUUsMENBQTBDLDBRQUEwUSw2QkFBNkIsbUJBQW1CLDJDQUEyQyxrQ0FBa0MsMkdBQTJHLG1CQUFtQiw4QkFBOEIscU5BQXFOLGtEQUFrRCx1QkFBdUIsRUFBRSxtQkFBbUIsK1dBQStXLDJDQUEyQyxrR0FBa0csaURBQWlELDJXQUEyVyw4SUFBOEksbUJBQW1CLE9BQU8sbUNBQW1DLG1CQUFtQixlQUFlLHNEQUFzRCx1S0FBdUssZ0RBQWdELHlDQUF5QyxzREFBc0QsbUJBQW1CLGVBQWUscUNBQXFDLHFDQUFxQyw2QkFBNkIsbUJBQW1CLHNDQUFzQywrREFBK0QsdUNBQXVDLDBKQUEwSixxREFBcUQsMEVBQTBFLGdEQUFnRCw4RUFBOEUsdUJBQXVCLEdBQUcsbUJBQW1CLE9BQU8scUhBQXFILG1CQUFtQixlQUFlLG9DQUFvQyx5Q0FBeUMsa0ZBQWtGLDZDQUE2QyxxREFBcUQsbUJBQW1CLGVBQWUsNktBQTZLLHVEQUF1RCw2QkFBNkIsbUJBQW1CLDJOQUEyTix1Q0FBdUMsbUNBQW1DLG1CQUFtQix1QkFBdUIscURBQXFELG1CQUFtQiwyQkFBMkIsaVRBQWlULGlFQUFpRSxvREFBb0Qsc2tCQUFza0IsdUNBQXVDLGlHQUFpRyxtQ0FBbUMsWUFBWSw4Q0FBOEMsbUNBQW1DLCtCQUErQixPQUFPLDZGQUE2RiwrQkFBK0Isc1VBQXNVLDBEQUEwRCxrREFBa0Qsa0VBQWtFLG1DQUFtQyw4QkFBOEIsMklBQTJJLG1DQUFtQywrQkFBK0IsMENBQTBDLDREQUE0RCxnR0FBZ0csNkZBQTZGLHFFQUFxRSwrQkFBK0IsNkJBQTZCLE9BQU8sb0dBQW9HLDJCQUEyQixtREFBbUQsb0VBQW9FLG9EQUFvRCx5REFBeUQsc0ZBQXNGLCtCQUErQiwyQkFBMkIsa0ZBQWtGLGdEQUFnRCx1QkFBdUIsb09BQW9PLGtFQUFrRSxvREFBb0QsNkRBQTZELHlEQUF5RCx1QkFBdUIscUJBQXFCLGVBQWUsMENBQTBDLDZMQUE2TCxrS0FBa0ssMkVBQTJFLHlWQUF5VixrRkFBa0YsRUFBRSxpTUFBaU0sc0hBQXNILDZFQUE2RSwyRUFBMkUsK0JBQStCLFFBQVEsMkJBQTJCLGdUQUFnVCxpSEFBaUgsNkRBQTZELGNBQWMsRUFBRSxTQUFTLHlJQUF5SSxFQUFFLCtCQUErQixHQUFHLCtFQUErRSw4Q0FBOEMsd01BQXdNLHdEQUF3RCx1RkFBdUYsOERBQThELG1DQUFtQyxHQUFHLCtCQUErQixxREFBcUQsMkJBQTJCLG1DQUFtQyx1QkFBdUIsc01BQXNNLHFFQUFxRSxzQ0FBc0MsaUNBQWlDLHVCQUF1Qiw0REFBNEQscURBQXFELGNBQWMsRUFBRSxTQUFTLHNFQUFzRSxFQUFFLHVCQUF1QixFQUFFLGdFQUFnRSw2Q0FBNkMsMkNBQTJDLG9EQUFvRCx3TkFBd04sbUZBQW1GLDREQUE0RCwrQkFBK0IsMkJBQTJCLEVBQUUseUNBQXlDLHVCQUF1QixFQUFFLDhOQUE4TixzT0FBc08scVdBQXFXLDZDQUE2QywyQkFBMkIsc05BQXNOLHFEQUFxRCwyQkFBMkIsOEpBQThKLGtJQUFrSSw0RUFBNEUsMkJBQTJCLGlDQUFpQyw2Q0FBNkMsMkJBQTJCLFlBQVkscVRBQXFULDJCQUEyQixpREFBaUQsb0RBQW9ELDJCQUEyQixpS0FBaUssbUhBQW1ILG9MQUFvTCx1QkFBdUIsRUFBRSw0U0FBNFMsbUJBQW1CLEdBQUcsb0RBQW9ELDREQUE0RCxlQUFlLHNDQUFzQyxzREFBc0Qsc0NBQXNDLDRTQUE0UyxrSEFBa0gsMkNBQTJDLHlEQUF5RCxvWkFBb1osbURBQW1ELGtFQUFrRSwwQ0FBMEMsaUVBQWlFLHFDQUFxQywyQkFBMkIsK0NBQStDLG9GQUFvRiw0REFBNEQsMkNBQTJDLDJCQUEyQixHQUFHLCtDQUErQyw0RUFBNEUsMkJBQTJCLHVCQUF1Qix1Q0FBdUMseUNBQXlDLG9TQUFvUyx1REFBdUQsdUJBQXVCLG1CQUFtQixHQUFHLHFLQUFxSywrREFBK0QsZ0RBQWdELDBEQUEwRCx1QkFBdUIsbUJBQW1CLEdBQUcsMENBQTBDLGlDQUFpQyxlQUFlLDBDQUEwQyw4Q0FBOEMsNkJBQTZCLG1EQUFtRCxtQkFBbUIsK0JBQStCLGVBQWUsNkNBQTZDLHlEQUF5RCw4QkFBOEIsbUJBQW1CLEVBQUUseUNBQXlDLG1RQUFtUSxtQkFBbUIsZUFBZSxZQUFZLDBDQUEwQyw0RkFBNEYsdUZBQXVGLGVBQWUsV0FBVywrREFBK0QsdU1BQXVNLCtJQUErSSxxREFBcUQsbUJBQW1CLGVBQWUsT0FBTyw4REFBOEQsZUFBZSxXQUFXLGlMQUFpTCxNQUFNLDJCQUEyQixPQUFPLG9EQUFvRCwrUUFBK1Esd0lBQXdJLG1FQUFtRSx3QkFBd0Isa0hBQWtILFdBQVcsc0NBQXNDLHVCQUF1QiwyR0FBMkcsdUhBQXVILDBDQUEwQyx5Q0FBeUMsOEhBQThILG1CQUFtQixPQUFPLG1LQUFtSyxtQkFBbUIsZUFBZSxXQUFXLHVCQUF1Qix1YkFBdWIsT0FBTywwRkFBMEYsOEZBQThGLCtFQUErRSw2Q0FBNkMsdUJBQXVCLG1CQUFtQiw0TEFBNEwsZ0xBQWdMLDBEQUEwRCx1Q0FBdUMsOENBQThDLGdEQUFnRCwyQkFBMkIsaUVBQWlFLHVCQUF1QixPQUFPLCtDQUErQyx1QkFBdUIsbUJBQW1CLEVBQUUsaUZBQWlGLG9FQUFvRSxvREFBb0QsK0NBQStDLHVEQUF1RCwrQkFBK0IsMkJBQTJCLEVBQUUsdUJBQXVCLEVBQUUsbUJBQW1CLGlFQUFpRSwrREFBK0Qsa0dBQWtHLHVDQUF1Qyw2RUFBNkUsMkJBQTJCLGtGQUFrRiwrRUFBK0UsMkJBQTJCLDJDQUEyQyx1QkFBdUIsRUFBRSx5Q0FBeUMsbUJBQW1CLHdGQUF3Riw0REFBNEQsNkNBQTZDLG1FQUFtRSxlQUFlLFVBQVUsK0NBQStDLHFEQUFxRCx5Q0FBeUMsbUVBQW1FLDJCQUEyQixtbEJBQW1sQix1QkFBdUIsRUFBRSxtQkFBbUIsc1FBQXNRLHFRQUFxUSxzREFBc0QsdUJBQXVCLG1CQUFtQixFQUFFLHlSQUF5UixvRUFBb0UsbUJBQW1CLGVBQWUsb0RBQW9ELGlDQUFpQyw4QkFBOEIsdUNBQXVDLG9FQUFvRSx1QkFBdUIsZ0ZBQWdGLG1CQUFtQiw0QkFBNEIsZUFBZSwwREFBMEQsMENBQTBDLG9FQUFvRSw4Q0FBOEMsOEZBQThGLDJEQUEyRCx1QkFBdUIsdURBQXVELHFEQUFxRCxvSkFBb0osMkJBQTJCLHVTQUF1Uyx5RUFBeUUsMkJBQTJCLHFNQUFxTSxrRkFBa0YsMkJBQTJCLG9KQUFvSixzQ0FBc0Msd0RBQXdELGlXQUFpVywyQkFBMkIsNkNBQTZDLHVCQUF1Qix5R0FBeUcsZ0lBQWdJLHlLQUF5SyxnRkFBZ0Ysb01BQW9NLHNFQUFzRSxzRUFBc0UsRUFBRSwwQ0FBMEMsdUJBQXVCLEVBQUUsNENBQTRDLG1CQUFtQix5Q0FBeUMsa1hBQWtYLGtRQUFrUSw2TUFBNk0saUdBQWlHLHdGQUF3RiwyQkFBMkIsMktBQTJLLHVCQUF1QixpREFBaUQsNkZBQTZGLHVCQUF1QixtREFBbUQseUVBQXlFLCtFQUErRSx1QkFBdUIsbUJBQW1CLEVBQUUsaUdBQWlHLDBEQUEwRCxnS0FBZ0ssK0hBQStILDZDQUE2QywrQ0FBK0MscURBQXFELGlEQUFpRCx3UEFBd1Asa0RBQWtELHdEQUF3RCwrQkFBK0IsMkJBQTJCLEVBQUUsc0NBQXNDLHVQQUF1UCwrREFBK0QsK0JBQStCLGtEQUFrRCwyQkFBMkIsd0JBQXdCLG1CQUFtQix3Q0FBd0MsZUFBZSxxWEFBcVgsd0RBQXdELDRCQUE0QixpREFBaUQsbUJBQW1CLGVBQWUsMFBBQTBQLE9BQU8sK0hBQStILHlHQUF5RyxnREFBZ0Qsc0NBQXNDLDZDQUE2Qyw4Q0FBOEMsNkNBQTZDLCtDQUErQyxpUUFBaVEsb0NBQW9DLDJCQUEyQix1Q0FBdUMsdUJBQXVCLG1DQUFtQyw4R0FBOEcsdUJBQXVCLDRDQUE0QyxtQkFBbUIseU1BQXlNLHdGQUF3RiwwRkFBMEYsNERBQTRELHFDQUFxQywyQkFBMkIsT0FBTyxzUUFBc1EsMkJBQTJCLHVCQUF1QixPQUFPLHVOQUF1Tix1QkFBdUIsbUJBQW1CLGtDQUFrQyxlQUFlLDJjQUEyYyxtS0FBbUssa0NBQWtDLDJDQUEyQyxtQkFBbUIsOERBQThELG1DQUFtQyx1RUFBdUUsbUJBQW1CLG1iQUFtYixnVUFBZ1UsbUJBQW1CLE9BQU8saUhBQWlILHFEQUFxRCwyT0FBMk8sT0FBTyxVQUFVLG9FQUFvRSxxRUFBcUUsMkNBQTJDLG9NQUFvTSw2REFBNkQsK0JBQStCLDREQUE0RCxvQ0FBb0MsMkJBQTJCLHVCQUF1Qix3SUFBd0kseUZBQXlGLGtIQUFrSCxtQkFBbUIsb01BQW9NLGVBQWUsd0tBQXdLLDZDQUE2QyxlQUFlLHNXQUFzVyx1REFBdUQsZUFBZSx5SUFBeUksTUFBTSw0SUFBNEksMldBQTJXLHFLQUFxSyw4SEFBOEgsb0RBQW9ELG1CQUFtQixlQUFlLDhIQUE4SCxnREFBZ0Qsa0RBQWtELCtHQUErRyxtQkFBbUIsZUFBZSxZQUFZLG9EQUFvRCx5QkFBeUIsT0FBTyxpdEJBQWl0QiwwSEFBMEgsc0hBQXNILG9FQUFvRSxzQ0FBc0MsNEZBQTRGLHFDQUFxQyxxQ0FBcUMsZUFBZSxPQUFPLDRCQUE0QixlQUFlLFdBQVcsMkNBQTJDLDJDQUEyQyxXQUFXLG9EQUFvRCx5QkFBeUIsOEVBQThFLFdBQVcseUJBQXlCLHdDQUF3QyxXQUFXLDREQUE0RCxRQUFRLG1MQUFtTCw2QkFBNkIsUUFBUSxzTEFBc0wsU0FBUywrR0FBK0csNEJBQTRCLE9BQU8sa0JBQWtCLE1BQU0sR0FBRyxvSEFBb0gsd0JBQXdCLE9BQU8sOEJBQThCLDZHQUE2RyxnQ0FBZ0MsbUJBQW1CLHFFQUFxRSw2Q0FBNkMsRUFBRSxzTEFBc0wsc09BQXNPLGlEQUFpRCw2REFBNkQsWUFBWSxPQUFPLEVBQUUsd0JBQXdCLG1FQUFtRSw2UUFBNlEsNEJBQTRCLHFEQUFxRCxXQUFXLE9BQU8sbUxBQW1MLE1BQU0sa0VBQWtFLHlKQUF5SixpTEFBaUwsNkRBQTZELGlDQUFpQyw0QkFBNEIsc0JBQXNCLFFBQVEsOExBQThMLE9BQU8sNERBQTRELE9BQU8sb0RBQW9ELE9BQU8sMEZBQTBGLHdEQUF3RCxvQkFBb0IsMEJBQTBCLCtHQUErRyw4RUFBOEUsa0VBQWtFLCswQ0FBKzBDLDRYQUE0WCxpRkFBaUYsdXdCQUF1d0IsZUFBZSxPQUFPLDZFQUE2RSwrRUFBK0UsZUFBZSw2QkFBNkIsdVdBQXVXLGdDQUFnQyx1REFBdUQsZUFBZSxPQUFPLHlDQUF5QyxlQUFlLDJDQUEyQyw0QkFBNEIsV0FBVyx3QkFBd0IsbUJBQW1CLDBmQUEwZixzR0FBc0csZUFBZSxZQUFZLGdSQUFnUixlQUFlLFdBQVcsUUFBUSx5Q0FBeUMsb0ZBQW9GLHVDQUF1QyxXQUFXLHNEQUFzRCx3REFBd0Qsc0RBQXNELGVBQWUsV0FBVyxFQUFFLG1DQUFtQyxPQUFPLGdJQUFnSSxxSUFBcUksa0lBQWtJLDJDQUEyQyxlQUFlLHNRQUFzUSw2QkFBNkIsc0hBQXNILHFIQUFxSCw0SkFBNEosNkNBQTZDLHlFQUF5RSw4Q0FBOEMsbUJBQW1CLHFMQUFxTCxvSUFBb0ksNENBQTRDLG1CQUFtQix1SkFBdUosZ0NBQWdDLGVBQWUsV0FBVyxFQUFFLE9BQU8sb1lBQW9ZLDRCQUE0QixrRkFBa0YsdUVBQXVFLDBCQUEwQiwwQkFBMEIsV0FBVyxrRkFBa0YsOEJBQThCLDBCQUEwQixXQUFXLHdLQUF3Syx3QkFBd0IsNk5BQTZOLG9MQUFvTCx5Q0FBeUMsdUJBQXVCLEVBQUUsb2NBQW9jLGVBQWUsV0FBVyxpSUFBaUkscUVBQXFFLHlCQUF5Qiw4QkFBOEIscUVBQXFFLG1CQUFtQiwrRUFBK0UsZUFBZSxXQUFXLG9nQkFBb2dCLFFBQVEsc0JBQXNCLDhCQUE4QixzT0FBc08sT0FBTyw4RUFBOEUsNERBQTRELFFBQVEsaURBQWlELEdBQUcsUUFBUSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qKiB2aW06IGV0OnRzPTQ6c3c9NDpzdHM9NFxcbiAqIEBsaWNlbnNlIFJlcXVpcmVKUyAyLjEuMTUgQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQsIFRoZSBEb2pvIEZvdW5kYXRpb24gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXG4gKiBBdmFpbGFibGUgdmlhIHRoZSBNSVQgb3IgbmV3IEJTRCBsaWNlbnNlLlxcbiAqIHNlZTogaHR0cDovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMgZm9yIGRldGFpbHNcXG4gKi9cXG4vL05vdCB1c2luZyBzdHJpY3Q6IHVuZXZlbiBzdHJpY3Qgc3VwcG9ydCBpbiBicm93c2VycywgIzM5MiwgYW5kIGNhdXNlc1xcbi8vcHJvYmxlbXMgd2l0aCByZXF1aXJlanMuZXhlYygpL3RyYW5zcGlsZXIgcGx1Z2lucyB0aGF0IG1heSBub3QgYmUgc3RyaWN0Llxcbi8qanNsaW50IHJlZ2V4cDogdHJ1ZSwgbm9tZW46IHRydWUsIHNsb3BweTogdHJ1ZSAqL1xcbi8qZ2xvYmFsIHdpbmRvdywgbmF2aWdhdG9yLCBkb2N1bWVudCwgaW1wb3J0U2NyaXB0cywgc2V0VGltZW91dCwgb3BlcmEgKi9cXG5cXG52YXIgcmVxdWlyZWpzLCByZXF1aXJlLCBkZWZpbmU7XFxuKGZ1bmN0aW9uIChnbG9iYWwpIHtcXG4gICAgdmFyIHJlcSwgcywgaGVhZCwgYmFzZUVsZW1lbnQsIGRhdGFNYWluLCBzcmMsXFxuICAgICAgICBpbnRlcmFjdGl2ZVNjcmlwdCwgY3VycmVudGx5QWRkaW5nU2NyaXB0LCBtYWluU2NyaXB0LCBzdWJQYXRoLFxcbiAgICAgICAgdmVyc2lvbiA9ICcyLjEuMTUnLFxcbiAgICAgICAgY29tbWVudFJlZ0V4cCA9IC8oXFxcXC9cXFxcKihbXFxcXHNcXFxcU10qPylcXFxcKlxcXFwvfChbXjpdfF4pXFxcXC9cXFxcLyguKikkKS9tZyxcXG4gICAgICAgIGNqc1JlcXVpcmVSZWdFeHAgPSAvW14uXVxcXFxzKnJlcXVpcmVcXFxccypcXFxcKFxcXFxzKltcXFwiJ10oW14nXFxcIlxcXFxzXSspW1xcXCInXVxcXFxzKlxcXFwpL2csXFxuICAgICAgICBqc1N1ZmZpeFJlZ0V4cCA9IC9cXFxcLmpzJC8sXFxuICAgICAgICBjdXJyRGlyUmVnRXhwID0gL15cXFxcLlxcXFwvLyxcXG4gICAgICAgIG9wID0gT2JqZWN0LnByb3RvdHlwZSxcXG4gICAgICAgIG9zdHJpbmcgPSBvcC50b1N0cmluZyxcXG4gICAgICAgIGhhc093biA9IG9wLmhhc093blByb3BlcnR5LFxcbiAgICAgICAgYXAgPSBBcnJheS5wcm90b3R5cGUsXFxuICAgICAgICBhcHNwID0gYXAuc3BsaWNlLFxcbiAgICAgICAgaXNCcm93c2VyID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50KSxcXG4gICAgICAgIGlzV2ViV29ya2VyID0gIWlzQnJvd3NlciAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcsXFxuICAgICAgICAvL1BTMyBpbmRpY2F0ZXMgbG9hZGVkIGFuZCBjb21wbGV0ZSwgYnV0IG5lZWQgdG8gd2FpdCBmb3IgY29tcGxldGVcXG4gICAgICAgIC8vc3BlY2lmaWNhbGx5LiBTZXF1ZW5jZSBpcyAnbG9hZGluZycsICdsb2FkZWQnLCBleGVjdXRpb24sXFxuICAgICAgICAvLyB0aGVuICdjb21wbGV0ZScuIFRoZSBVQSBjaGVjayBpcyB1bmZvcnR1bmF0ZSwgYnV0IG5vdCBzdXJlIGhvd1xcbiAgICAgICAgLy90byBmZWF0dXJlIHRlc3Qgdy9vIGNhdXNpbmcgcGVyZiBpc3N1ZXMuXFxuICAgICAgICByZWFkeVJlZ0V4cCA9IGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdQTEFZU1RBVElPTiAzJyA/XFxuICAgICAgICAgICAgICAgICAgICAgIC9eY29tcGxldGUkLyA6IC9eKGNvbXBsZXRlfGxvYWRlZCkkLyxcXG4gICAgICAgIGRlZkNvbnRleHROYW1lID0gJ18nLFxcbiAgICAgICAgLy9PaCB0aGUgdHJhZ2VkeSwgZGV0ZWN0aW5nIG9wZXJhLiBTZWUgdGhlIHVzYWdlIG9mIGlzT3BlcmEgZm9yIHJlYXNvbi5cXG4gICAgICAgIGlzT3BlcmEgPSB0eXBlb2Ygb3BlcmEgIT09ICd1bmRlZmluZWQnICYmIG9wZXJhLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9wZXJhXScsXFxuICAgICAgICBjb250ZXh0cyA9IHt9LFxcbiAgICAgICAgY2ZnID0ge30sXFxuICAgICAgICBnbG9iYWxEZWZRdWV1ZSA9IFtdLFxcbiAgICAgICAgdXNlSW50ZXJhY3RpdmUgPSBmYWxzZTtcXG5cXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpdCkge1xcbiAgICAgICAgcmV0dXJuIG9zdHJpbmcuY2FsbChpdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaXNBcnJheShpdCkge1xcbiAgICAgICAgcmV0dXJuIG9zdHJpbmcuY2FsbChpdCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkuIElmIHRoZSBmdW5jIHJldHVybnNcXG4gICAgICogYSB0cnVlIHZhbHVlLCBpdCB3aWxsIGJyZWFrIG91dCBvZiB0aGUgbG9vcC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGVhY2goYXJ5LCBmdW5jKSB7XFxuICAgICAgICBpZiAoYXJ5KSB7XFxuICAgICAgICAgICAgdmFyIGk7XFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICAgICAgICBpZiAoYXJ5W2ldICYmIGZ1bmMoYXJ5W2ldLCBpLCBhcnkpKSB7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBiYWNrd2FyZHMuIElmIHRoZSBmdW5jXFxuICAgICAqIHJldHVybnMgYSB0cnVlIHZhbHVlLCBpdCB3aWxsIGJyZWFrIG91dCBvZiB0aGUgbG9vcC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGVhY2hSZXZlcnNlKGFyeSwgZnVuYykge1xcbiAgICAgICAgaWYgKGFyeSkge1xcbiAgICAgICAgICAgIHZhciBpO1xcbiAgICAgICAgICAgIGZvciAoaSA9IGFyeS5sZW5ndGggLSAxOyBpID4gLTE7IGkgLT0gMSkge1xcbiAgICAgICAgICAgICAgICBpZiAoYXJ5W2ldICYmIGZ1bmMoYXJ5W2ldLCBpLCBhcnkpKSB7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBoYXNQcm9wKG9iaiwgcHJvcCkge1xcbiAgICAgICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwgcHJvcCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZ2V0T3duKG9iaiwgcHJvcCkge1xcbiAgICAgICAgcmV0dXJuIGhhc1Byb3Aob2JqLCBwcm9wKSAmJiBvYmpbcHJvcF07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEN5Y2xlcyBvdmVyIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0IGFuZCBjYWxscyBhIGZ1bmN0aW9uIGZvciBlYWNoXFxuICAgICAqIHByb3BlcnR5IHZhbHVlLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSwgdGhlbiB0aGVcXG4gICAgICogaXRlcmF0aW9uIGlzIHN0b3BwZWQuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBlYWNoUHJvcChvYmosIGZ1bmMpIHtcXG4gICAgICAgIHZhciBwcm9wO1xcbiAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xcbiAgICAgICAgICAgIGlmIChoYXNQcm9wKG9iaiwgcHJvcCkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMob2JqW3Byb3BdLCBwcm9wKSkge1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNpbXBsZSBmdW5jdGlvbiB0byBtaXggaW4gcHJvcGVydGllcyBmcm9tIHNvdXJjZSBpbnRvIHRhcmdldCxcXG4gICAgICogYnV0IG9ubHkgaWYgdGFyZ2V0IGRvZXMgbm90IGFscmVhZHkgaGF2ZSBhIHByb3BlcnR5IG9mIHRoZSBzYW1lIG5hbWUuXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSwgZm9yY2UsIGRlZXBTdHJpbmdNaXhpbikge1xcbiAgICAgICAgaWYgKHNvdXJjZSkge1xcbiAgICAgICAgICAgIGVhY2hQcm9wKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlLCBwcm9wKSB7XFxuICAgICAgICAgICAgICAgIGlmIChmb3JjZSB8fCAhaGFzUHJvcCh0YXJnZXQsIHByb3ApKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcFN0cmluZ01peGluICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiZcXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNBcnJheSh2YWx1ZSkgJiYgIWlzRnVuY3Rpb24odmFsdWUpICYmXFxuICAgICAgICAgICAgICAgICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFtwcm9wXSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB7fTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4odGFyZ2V0W3Byb3BdLCB2YWx1ZSwgZm9yY2UsIGRlZXBTdHJpbmdNaXhpbik7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xcbiAgICB9XFxuXFxuICAgIC8vU2ltaWxhciB0byBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgYnV0IHRoZSAndGhpcycgb2JqZWN0IGlzIHNwZWNpZmllZFxcbiAgICAvL2ZpcnN0LCBzaW5jZSBpdCBpcyBlYXNpZXIgdG8gcmVhZC9maWd1cmUgb3V0IHdoYXQgJ3RoaXMnIHdpbGwgYmUuXFxuICAgIGZ1bmN0aW9uIGJpbmQob2JqLCBmbikge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmd1bWVudHMpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzY3JpcHRzKCkge1xcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnIpIHtcXG4gICAgICAgIHRocm93IGVycjtcXG4gICAgfVxcblxcbiAgICAvL0FsbG93IGdldHRpbmcgYSBnbG9iYWwgdGhhdCBpcyBleHByZXNzZWQgaW5cXG4gICAgLy9kb3Qgbm90YXRpb24sIGxpa2UgJ2EuYi5jJy5cXG4gICAgZnVuY3Rpb24gZ2V0R2xvYmFsKHZhbHVlKSB7XFxuICAgICAgICBpZiAoIXZhbHVlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGcgPSBnbG9iYWw7XFxuICAgICAgICBlYWNoKHZhbHVlLnNwbGl0KCcuJyksIGZ1bmN0aW9uIChwYXJ0KSB7XFxuICAgICAgICAgICAgZyA9IGdbcGFydF07XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBnO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGVycm9yIHdpdGggYSBwb2ludGVyIHRvIGFuIFVSTCB3aXRoIG1vcmUgaW5mb3JtYXRpb24uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZXJyb3IgSUQgdGhhdCBtYXBzIHRvIGFuIElEIG9uIGEgd2ViIHBhZ2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIGh1bWFuIHJlYWRhYmxlIGVycm9yLlxcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBbZXJyXSB0aGUgb3JpZ2luYWwgZXJyb3IsIGlmIHRoZXJlIGlzIG9uZS5cXG4gICAgICpcXG4gICAgICogQHJldHVybnMge0Vycm9yfVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbWFrZUVycm9yKGlkLCBtc2csIGVyciwgcmVxdWlyZU1vZHVsZXMpIHtcXG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKG1zZyArICdcXFxcbmh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjJyArIGlkKTtcXG4gICAgICAgIGUucmVxdWlyZVR5cGUgPSBpZDtcXG4gICAgICAgIGUucmVxdWlyZU1vZHVsZXMgPSByZXF1aXJlTW9kdWxlcztcXG4gICAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgICAgICBlLm9yaWdpbmFsRXJyb3IgPSBlcnI7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIC8vSWYgYSBkZWZpbmUgaXMgYWxyZWFkeSBpbiBwbGF5IHZpYSBhbm90aGVyIEFNRCBsb2FkZXIsXFxuICAgICAgICAvL2RvIG5vdCBvdmVyd3JpdGUuXFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiByZXF1aXJlanMgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXF1aXJlanMpKSB7XFxuICAgICAgICAgICAgLy9EbyBub3Qgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHJlcXVpcmVqcyBpbnN0YW5jZS5cXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBjZmcgPSByZXF1aXJlanM7XFxuICAgICAgICByZXF1aXJlanMgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgLy9BbGxvdyBmb3IgYSByZXF1aXJlIGNvbmZpZyBvYmplY3RcXG4gICAgaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiAhaXNGdW5jdGlvbihyZXF1aXJlKSkge1xcbiAgICAgICAgLy9hc3N1bWUgaXQgaXMgYSBjb25maWcgb2JqZWN0LlxcbiAgICAgICAgY2ZnID0gcmVxdWlyZTtcXG4gICAgICAgIHJlcXVpcmUgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbmV3Q29udGV4dChjb250ZXh0TmFtZSkge1xcbiAgICAgICAgdmFyIGluQ2hlY2tMb2FkZWQsIE1vZHVsZSwgY29udGV4dCwgaGFuZGxlcnMsXFxuICAgICAgICAgICAgY2hlY2tMb2FkZWRUaW1lb3V0SWQsXFxuICAgICAgICAgICAgY29uZmlnID0ge1xcbiAgICAgICAgICAgICAgICAvL0RlZmF1bHRzLiBEbyBub3Qgc2V0IGEgZGVmYXVsdCBmb3IgbWFwXFxuICAgICAgICAgICAgICAgIC8vY29uZmlnIHRvIHNwZWVkIHVwIG5vcm1hbGl6ZSgpLCB3aGljaFxcbiAgICAgICAgICAgICAgICAvL3dpbGwgcnVuIGZhc3RlciBpZiB0aGVyZSBpcyBubyBkZWZhdWx0LlxcbiAgICAgICAgICAgICAgICB3YWl0U2Vjb25kczogNyxcXG4gICAgICAgICAgICAgICAgYmFzZVVybDogJy4vJyxcXG4gICAgICAgICAgICAgICAgcGF0aHM6IHt9LFxcbiAgICAgICAgICAgICAgICBidW5kbGVzOiB7fSxcXG4gICAgICAgICAgICAgICAgcGtnczoge30sXFxuICAgICAgICAgICAgICAgIHNoaW06IHt9LFxcbiAgICAgICAgICAgICAgICBjb25maWc6IHt9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICByZWdpc3RyeSA9IHt9LFxcbiAgICAgICAgICAgIC8vcmVnaXN0cnkgb2YganVzdCBlbmFibGVkIG1vZHVsZXMsIHRvIHNwZWVkXFxuICAgICAgICAgICAgLy9jeWNsZSBicmVha2luZyBjb2RlIHdoZW4gbG90cyBvZiBtb2R1bGVzXFxuICAgICAgICAgICAgLy9hcmUgcmVnaXN0ZXJlZCwgYnV0IG5vdCBhY3RpdmF0ZWQuXFxuICAgICAgICAgICAgZW5hYmxlZFJlZ2lzdHJ5ID0ge30sXFxuICAgICAgICAgICAgdW5kZWZFdmVudHMgPSB7fSxcXG4gICAgICAgICAgICBkZWZRdWV1ZSA9IFtdLFxcbiAgICAgICAgICAgIGRlZmluZWQgPSB7fSxcXG4gICAgICAgICAgICB1cmxGZXRjaGVkID0ge30sXFxuICAgICAgICAgICAgYnVuZGxlc01hcCA9IHt9LFxcbiAgICAgICAgICAgIHJlcXVpcmVDb3VudGVyID0gMSxcXG4gICAgICAgICAgICB1bm5vcm1hbGl6ZWRDb3VudGVyID0gMTtcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogVHJpbXMgdGhlIC4gYW5kIC4uIGZyb20gYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cXG4gICAgICAgICAqIEl0IHdpbGwga2VlcCBhIGxlYWRpbmcgcGF0aCBzZWdtZW50IGlmIGEgLi4gd2lsbCBiZWNvbWVcXG4gICAgICAgICAqIHRoZSBmaXJzdCBwYXRoIHNlZ21lbnQsIHRvIGhlbHAgd2l0aCBtb2R1bGUgbmFtZSBsb29rdXBzLFxcbiAgICAgICAgICogd2hpY2ggYWN0IGxpa2UgcGF0aHMsIGJ1dCBjYW4gYmUgcmVtYXBwZWQuIEJ1dCB0aGUgZW5kIHJlc3VsdCxcXG4gICAgICAgICAqIGFsbCBwYXRocyB0aGF0IHVzZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsb29rIG5vcm1hbGl6ZWQuXFxuICAgICAgICAgKiBOT1RFOiB0aGlzIG1ldGhvZCBNT0RJRklFUyB0aGUgaW5wdXQgYXJyYXkuXFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnkgdGhlIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXFxuICAgICAgICAgKi9cXG4gICAgICAgIGZ1bmN0aW9uIHRyaW1Eb3RzKGFyeSkge1xcbiAgICAgICAgICAgIHZhciBpLCBwYXJ0O1xcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgcGFydCA9IGFyeVtpXTtcXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xcbiAgICAgICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhdCB0aGUgc3RhcnQsIG9yIHByZXZpb3VzIHZhbHVlIGlzIHN0aWxsIC4uLFxcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCB0aGVtIHNvIHRoYXQgd2hlbiBjb252ZXJ0ZWQgdG8gYSBwYXRoIGl0IG1heVxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgd29yayB3aGVuIGNvbnZlcnRlZCB0byBhIHBhdGgsIGV2ZW4gdGhvdWdoXFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBhbiBJRCBpdCBpcyBsZXNzIHRoYW4gaWRlYWwuIEluIGxhcmdlciBwb2ludFxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsZWFzZXMsIG1heSBiZSBiZXR0ZXIgdG8ganVzdCBraWNrIG91dCBhbiBlcnJvci5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IChpID09IDEgJiYgYXJ5WzJdID09PSAnLi4nKSB8fCBhcnlbaSAtIDFdID09PSAnLi4nKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpIC0gMSwgMik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBHaXZlbiBhIHJlbGF0aXZlIG1vZHVsZSBuYW1lLCBsaWtlIC4vc29tZXRoaW5nLCBub3JtYWxpemUgaXQgdG9cXG4gICAgICAgICAqIGEgcmVhbCBuYW1lIHRoYXQgY2FuIGJlIG1hcHBlZCB0byBhIHBhdGguXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgcmVsYXRpdmUgbmFtZVxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGJhc2VOYW1lIGEgcmVhbCBuYW1lIHRoYXQgdGhlIG5hbWUgYXJnIGlzIHJlbGF0aXZlXFxuICAgICAgICAgKiB0by5cXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXBwbHlNYXAgYXBwbHkgdGhlIG1hcCBjb25maWcgdG8gdGhlIHZhbHVlLiBTaG91bGRcXG4gICAgICAgICAqIG9ubHkgYmUgZG9uZSBpZiB0aGlzIG5vcm1hbGl6YXRpb24gaXMgZm9yIGEgZGVwZW5kZW5jeSBJRC5cXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG5vcm1hbGl6ZWQgbmFtZVxcbiAgICAgICAgICovXFxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUobmFtZSwgYmFzZU5hbWUsIGFwcGx5TWFwKSB7XFxuICAgICAgICAgICAgdmFyIHBrZ01haW4sIG1hcFZhbHVlLCBuYW1lUGFydHMsIGksIGosIG5hbWVTZWdtZW50LCBsYXN0SW5kZXgsXFxuICAgICAgICAgICAgICAgIGZvdW5kTWFwLCBmb3VuZEksIGZvdW5kU3Rhck1hcCwgc3RhckksIG5vcm1hbGl6ZWRCYXNlUGFydHMsXFxuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IChiYXNlTmFtZSAmJiBiYXNlTmFtZS5zcGxpdCgnLycpKSxcXG4gICAgICAgICAgICAgICAgbWFwID0gY29uZmlnLm1hcCxcXG4gICAgICAgICAgICAgICAgc3Rhck1hcCA9IG1hcCAmJiBtYXBbJyonXTtcXG5cXG4gICAgICAgICAgICAvL0FkanVzdCBhbnkgcmVsYXRpdmUgcGF0aHMuXFxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoJy8nKTtcXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbmFtZS5sZW5ndGggLSAxO1xcblxcbiAgICAgICAgICAgICAgICAvLyBJZiB3YW50aW5nIG5vZGUgSUQgY29tcGF0aWJpbGl0eSwgc3RyaXAgLmpzIGZyb20gZW5kXFxuICAgICAgICAgICAgICAgIC8vIG9mIElEcy4gSGF2ZSB0byBkbyB0aGlzIGhlcmUsIGFuZCBub3QgaW4gbmFtZVRvVXJsXFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugbm9kZSBhbGxvd3MgZWl0aGVyIC5qcyBvciBub24gLmpzIHRvIG1hcFxcbiAgICAgICAgICAgICAgICAvLyB0byBzYW1lIGZpbGUuXFxuICAgICAgICAgICAgICAgIGlmIChjb25maWcubm9kZUlkQ29tcGF0ICYmIGpzU3VmZml4UmVnRXhwLnRlc3QobmFtZVtsYXN0SW5kZXhdKSkge1xcbiAgICAgICAgICAgICAgICAgICAgbmFtZVtsYXN0SW5kZXhdID0gbmFtZVtsYXN0SW5kZXhdLnJlcGxhY2UoanNTdWZmaXhSZWdFeHAsICcnKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAvLyBTdGFydHMgd2l0aCBhICcuJyBzbyBuZWVkIHRoZSBiYXNlTmFtZVxcbiAgICAgICAgICAgICAgICBpZiAobmFtZVswXS5jaGFyQXQoMCkgPT09ICcuJyAmJiBiYXNlUGFydHMpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vQ29udmVydCBiYXNlTmFtZSB0byBhcnJheSwgYW5kIGxvcCBvZmYgdGhlIGxhc3QgcGFydCxcXG4gICAgICAgICAgICAgICAgICAgIC8vc28gdGhhdCAuIG1hdGNoZXMgdGhhdCAnZGlyZWN0b3J5JyBhbmQgbm90IG5hbWUgb2YgdGhlIGJhc2VOYW1lJ3NcXG4gICAgICAgICAgICAgICAgICAgIC8vbW9kdWxlLiBGb3IgaW5zdGFuY2UsIGJhc2VOYW1lIG9mICdvbmUvdHdvL3RocmVlJywgbWFwcyB0b1xcbiAgICAgICAgICAgICAgICAgICAgLy8nb25lL3R3by90aHJlZS5qcycsIGJ1dCB3ZSB3YW50IHRoZSBkaXJlY3RvcnksICdvbmUvdHdvJyBmb3JcXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcyBub3JtYWxpemF0aW9uLlxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5zbGljZSgwLCBiYXNlUGFydHMubGVuZ3RoIC0gMSk7XFxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplZEJhc2VQYXJ0cy5jb25jYXQobmFtZSk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdHJpbURvdHMobmFtZSk7XFxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLmpvaW4oJy8nKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9BcHBseSBtYXAgY29uZmlnIGlmIGF2YWlsYWJsZS5cXG4gICAgICAgICAgICBpZiAoYXBwbHlNYXAgJiYgbWFwICYmIChiYXNlUGFydHMgfHwgc3Rhck1hcCkpIHtcXG4gICAgICAgICAgICAgICAgbmFtZVBhcnRzID0gbmFtZS5zcGxpdCgnLycpO1xcblxcbiAgICAgICAgICAgICAgICBvdXRlckxvb3A6IGZvciAoaSA9IG5hbWVQYXJ0cy5sZW5ndGg7IGkgPiAwOyBpIC09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIG5hbWVTZWdtZW50ID0gbmFtZVBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oJy8nKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUGFydHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0ZpbmQgdGhlIGxvbmdlc3QgYmFzZU5hbWUgc2VnbWVudCBtYXRjaCBpbiB0aGUgY29uZmlnLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU28sIGRvIGpvaW5zIG9uIHRoZSBiaWdnZXN0IHRvIHNtYWxsZXN0IGxlbmd0aHMgb2YgYmFzZVBhcnRzLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGJhc2VQYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwVmFsdWUgPSBnZXRPd24obWFwLCBiYXNlUGFydHMuc2xpY2UoMCwgaikuam9pbignLycpKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iYXNlTmFtZSBzZWdtZW50IGhhcyBjb25maWcsIGZpbmQgaWYgaXQgaGFzIG9uZSBmb3JcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIG5hbWUuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwVmFsdWUgPSBnZXRPd24obWFwVmFsdWUsIG5hbWVTZWdtZW50KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTWF0Y2gsIHVwZGF0ZSBuYW1lIHRvIHRoZSBuZXcgdmFsdWUuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNYXAgPSBtYXBWYWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEkgPSBpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyTG9vcDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vQ2hlY2sgZm9yIGEgc3RhciBtYXAgbWF0Y2gsIGJ1dCBqdXN0IGhvbGQgb24gdG8gaXQsXFxuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIGEgc2hvcnRlciBzZWdtZW50IG1hdGNoIGxhdGVyIGluIGEgbWF0Y2hpbmdcXG4gICAgICAgICAgICAgICAgICAgIC8vY29uZmlnLCB0aGVuIGZhdm9yIG92ZXIgdGhpcyBzdGFyIG1hcC5cXG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFyTWFwICYmIHN0YXJNYXAgJiYgZ2V0T3duKHN0YXJNYXAsIG5hbWVTZWdtZW50KSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3Rhck1hcCA9IGdldE93bihzdGFyTWFwLCBuYW1lU2VnbWVudCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhckkgPSBpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICghZm91bmRNYXAgJiYgZm91bmRTdGFyTWFwKSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IGZvdW5kU3Rhck1hcDtcXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kSSA9IHN0YXJJO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmIChmb3VuZE1hcCkge1xcbiAgICAgICAgICAgICAgICAgICAgbmFtZVBhcnRzLnNwbGljZSgwLCBmb3VuZEksIGZvdW5kTWFwKTtcXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lUGFydHMuam9pbignLycpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIElmIHRoZSBuYW1lIHBvaW50cyB0byBhIHBhY2thZ2UncyBuYW1lLCB1c2VcXG4gICAgICAgICAgICAvLyB0aGUgcGFja2FnZSBtYWluIGluc3RlYWQuXFxuICAgICAgICAgICAgcGtnTWFpbiA9IGdldE93bihjb25maWcucGtncywgbmFtZSk7XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHBrZ01haW4gPyBwa2dNYWluIDogbmFtZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVNjcmlwdChuYW1lKSB7XFxuICAgICAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xcbiAgICAgICAgICAgICAgICBlYWNoKHNjcmlwdHMoKSwgZnVuY3Rpb24gKHNjcmlwdE5vZGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JpcHROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1yZXF1aXJlbW9kdWxlJykgPT09IG5hbWUgJiZcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVxdWlyZWNvbnRleHQnKSA9PT0gY29udGV4dC5jb250ZXh0TmFtZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHROb2RlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gaGFzUGF0aEZhbGxiYWNrKGlkKSB7XFxuICAgICAgICAgICAgdmFyIHBhdGhDb25maWcgPSBnZXRPd24oY29uZmlnLnBhdGhzLCBpZCk7XFxuICAgICAgICAgICAgaWYgKHBhdGhDb25maWcgJiYgaXNBcnJheShwYXRoQ29uZmlnKSAmJiBwYXRoQ29uZmlnLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgICAgICAgICAgLy9Qb3Agb2ZmIHRoZSBmaXJzdCBhcnJheSB2YWx1ZSwgc2luY2UgaXQgZmFpbGVkLCBhbmRcXG4gICAgICAgICAgICAgICAgLy9yZXRyeVxcbiAgICAgICAgICAgICAgICBwYXRoQ29uZmlnLnNoaWZ0KCk7XFxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVxdWlyZS51bmRlZihpZCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vQ3VzdG9tIHJlcXVpcmUgdGhhdCBkb2VzIG5vdCBkbyBtYXAgdHJhbnNsYXRpb24sIHNpbmNlXFxuICAgICAgICAgICAgICAgIC8vSUQgaXMgXFxcImFic29sdXRlXFxcIiwgYWxyZWFkeSBtYXBwZWQvcmVzb2x2ZWQuXFxuICAgICAgICAgICAgICAgIGNvbnRleHQubWFrZVJlcXVpcmUobnVsbCwge1xcbiAgICAgICAgICAgICAgICAgICAgc2tpcE1hcDogdHJ1ZVxcbiAgICAgICAgICAgICAgICB9KShbaWRdKTtcXG5cXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9UdXJucyBhIHBsdWdpbiFyZXNvdXJjZSB0byBbcGx1Z2luLCByZXNvdXJjZV1cXG4gICAgICAgIC8vd2l0aCB0aGUgcGx1Z2luIGJlaW5nIHVuZGVmaW5lZCBpZiB0aGUgbmFtZVxcbiAgICAgICAgLy9kaWQgbm90IGhhdmUgYSBwbHVnaW4gcHJlZml4LlxcbiAgICAgICAgZnVuY3Rpb24gc3BsaXRQcmVmaXgobmFtZSkge1xcbiAgICAgICAgICAgIHZhciBwcmVmaXgsXFxuICAgICAgICAgICAgICAgIGluZGV4ID0gbmFtZSA/IG5hbWUuaW5kZXhPZignIScpIDogLTE7XFxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gbmFtZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoaW5kZXggKyAxLCBuYW1lLmxlbmd0aCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBbcHJlZml4LCBuYW1lXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogQ3JlYXRlcyBhIG1vZHVsZSBtYXBwaW5nIHRoYXQgaW5jbHVkZXMgcGx1Z2luIHByZWZpeCwgbW9kdWxlXFxuICAgICAgICAgKiBuYW1lLCBhbmQgcGF0aC4gSWYgcGFyZW50TW9kdWxlTWFwIGlzIHByb3ZpZGVkIGl0IHdpbGxcXG4gICAgICAgICAqIGFsc28gbm9ybWFsaXplIHRoZSBuYW1lIHZpYSByZXF1aXJlLm5vcm1hbGl6ZSgpXFxuICAgICAgICAgKlxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG1vZHVsZSBuYW1lXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmVudE1vZHVsZU1hcF0gcGFyZW50IG1vZHVsZSBtYXBcXG4gICAgICAgICAqIGZvciB0aGUgbW9kdWxlIG5hbWUsIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBuYW1lcy5cXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNOb3JtYWxpemVkOiBpcyB0aGUgSUQgYWxyZWFkeSBub3JtYWxpemVkLlxcbiAgICAgICAgICogVGhpcyBpcyB0cnVlIGlmIHRoaXMgY2FsbCBpcyBkb25lIGZvciBhIGRlZmluZSgpIG1vZHVsZSBJRC5cXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXBwbHlNYXA6IGFwcGx5IHRoZSBtYXAgY29uZmlnIHRvIHRoZSBJRC5cXG4gICAgICAgICAqIFNob3VsZCBvbmx5IGJlIHRydWUgaWYgdGhpcyBtYXAgaXMgZm9yIGEgZGVwZW5kZW5jeS5cXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxcbiAgICAgICAgICovXFxuICAgICAgICBmdW5jdGlvbiBtYWtlTW9kdWxlTWFwKG5hbWUsIHBhcmVudE1vZHVsZU1hcCwgaXNOb3JtYWxpemVkLCBhcHBseU1hcCkge1xcbiAgICAgICAgICAgIHZhciB1cmwsIHBsdWdpbk1vZHVsZSwgc3VmZml4LCBuYW1lUGFydHMsXFxuICAgICAgICAgICAgICAgIHByZWZpeCA9IG51bGwsXFxuICAgICAgICAgICAgICAgIHBhcmVudE5hbWUgPSBwYXJlbnRNb2R1bGVNYXAgPyBwYXJlbnRNb2R1bGVNYXAubmFtZSA6IG51bGwsXFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTmFtZSA9IG5hbWUsXFxuICAgICAgICAgICAgICAgIGlzRGVmaW5lID0gdHJ1ZSxcXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZE5hbWUgPSAnJztcXG5cXG4gICAgICAgICAgICAvL0lmIG5vIG5hbWUsIHRoZW4gaXQgbWVhbnMgaXQgaXMgYSByZXF1aXJlIGNhbGwsIGdlbmVyYXRlIGFuXFxuICAgICAgICAgICAgLy9pbnRlcm5hbCBuYW1lLlxcbiAgICAgICAgICAgIGlmICghbmFtZSkge1xcbiAgICAgICAgICAgICAgICBpc0RlZmluZSA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICBuYW1lID0gJ19AcicgKyAocmVxdWlyZUNvdW50ZXIgKz0gMSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIG5hbWVQYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpO1xcbiAgICAgICAgICAgIHByZWZpeCA9IG5hbWVQYXJ0c1swXTtcXG4gICAgICAgICAgICBuYW1lID0gbmFtZVBhcnRzWzFdO1xcblxcbiAgICAgICAgICAgIGlmIChwcmVmaXgpIHtcXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gbm9ybWFsaXplKHByZWZpeCwgcGFyZW50TmFtZSwgYXBwbHlNYXApO1xcbiAgICAgICAgICAgICAgICBwbHVnaW5Nb2R1bGUgPSBnZXRPd24oZGVmaW5lZCwgcHJlZml4KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9BY2NvdW50IGZvciByZWxhdGl2ZSBwYXRocyBpZiB0aGVyZSBpcyBhIGJhc2UgbmFtZS5cXG4gICAgICAgICAgICBpZiAobmFtZSkge1xcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4KSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luTW9kdWxlICYmIHBsdWdpbk1vZHVsZS5ub3JtYWxpemUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1BsdWdpbiBpcyBsb2FkZWQsIHVzZSBpdHMgbm9ybWFsaXplIG1ldGhvZC5cXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkTmFtZSA9IHBsdWdpbk1vZHVsZS5ub3JtYWxpemUobmFtZSwgZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lLCBwYXJlbnROYW1lLCBhcHBseU1hcCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5lc3RlZCBwbHVnaW4gcmVmZXJlbmNlcywgdGhlbiBkbyBub3QgdHJ5IHRvXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplLCBhcyBpdCB3aWxsIG5vdCBub3JtYWxpemUgY29ycmVjdGx5LiBUaGlzXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2VzIGEgcmVzdHJpY3Rpb24gb24gcmVzb3VyY2VJZHMsIGFuZCB0aGUgbG9uZ2VyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVybSBzb2x1dGlvbiBpcyBub3QgdG8gbm9ybWFsaXplIHVudGlsIHBsdWdpbnMgYXJlXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9hZGVkIGFuZCBhbGwgbm9ybWFsaXphdGlvbnMgdG8gYWxsb3cgZm9yIGFzeW5jXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9hZGluZyBvZiBhIGxvYWRlciBwbHVnaW4uIEJ1dCBmb3Igbm93LCBmaXhlcyB0aGVcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21tb24gdXNlcy4gRGV0YWlscyBpbiAjMTEzMVxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWROYW1lID0gbmFtZS5pbmRleE9mKCchJykgPT09IC0xID9cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShuYW1lLCBwYXJlbnROYW1lLCBhcHBseU1hcCkgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vQSByZWd1bGFyIG1vZHVsZS5cXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUsIHBhcmVudE5hbWUsIGFwcGx5TWFwKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vTm9ybWFsaXplZCBuYW1lIG1heSBiZSBhIHBsdWdpbiBJRCBkdWUgdG8gbWFwIGNvbmZpZ1xcbiAgICAgICAgICAgICAgICAgICAgLy9hcHBsaWNhdGlvbiBpbiBub3JtYWxpemUuIFRoZSBtYXAgY29uZmlnIHZhbHVlcyBtdXN0XFxuICAgICAgICAgICAgICAgICAgICAvL2FscmVhZHkgYmUgbm9ybWFsaXplZCwgc28gZG8gbm90IG5lZWQgdG8gcmVkbyB0aGF0IHBhcnQuXFxuICAgICAgICAgICAgICAgICAgICBuYW1lUGFydHMgPSBzcGxpdFByZWZpeChub3JtYWxpemVkTmFtZSk7XFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBuYW1lUGFydHNbMF07XFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkTmFtZSA9IG5hbWVQYXJ0c1sxXTtcXG4gICAgICAgICAgICAgICAgICAgIGlzTm9ybWFsaXplZCA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBjb250ZXh0Lm5hbWVUb1VybChub3JtYWxpemVkTmFtZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9JZiB0aGUgaWQgaXMgYSBwbHVnaW4gaWQgdGhhdCBjYW5ub3QgYmUgZGV0ZXJtaW5lZCBpZiBpdCBuZWVkc1xcbiAgICAgICAgICAgIC8vbm9ybWFsaXphdGlvbiwgc3RhbXAgaXQgd2l0aCBhIHVuaXF1ZSBJRCBzbyB0d28gbWF0Y2hpbmcgcmVsYXRpdmVcXG4gICAgICAgICAgICAvL2lkcyB0aGF0IG1heSBjb25mbGljdCBjYW4gYmUgc2VwYXJhdGUuXFxuICAgICAgICAgICAgc3VmZml4ID0gcHJlZml4ICYmICFwbHVnaW5Nb2R1bGUgJiYgIWlzTm9ybWFsaXplZCA/XFxuICAgICAgICAgICAgICAgICAgICAgJ191bm5vcm1hbGl6ZWQnICsgKHVubm9ybWFsaXplZENvdW50ZXIgKz0gMSkgOlxcbiAgICAgICAgICAgICAgICAgICAgICcnO1xcblxcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxcbiAgICAgICAgICAgICAgICBuYW1lOiBub3JtYWxpemVkTmFtZSxcXG4gICAgICAgICAgICAgICAgcGFyZW50TWFwOiBwYXJlbnRNb2R1bGVNYXAsXFxuICAgICAgICAgICAgICAgIHVubm9ybWFsaXplZDogISFzdWZmaXgsXFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE5hbWU6IG9yaWdpbmFsTmFtZSxcXG4gICAgICAgICAgICAgICAgaXNEZWZpbmU6IGlzRGVmaW5lLFxcbiAgICAgICAgICAgICAgICBpZDogKHByZWZpeCA/XFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ICsgJyEnICsgbm9ybWFsaXplZE5hbWUgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWROYW1lKSArIHN1ZmZpeFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiBnZXRNb2R1bGUoZGVwTWFwKSB7XFxuICAgICAgICAgICAgdmFyIGlkID0gZGVwTWFwLmlkLFxcbiAgICAgICAgICAgICAgICBtb2QgPSBnZXRPd24ocmVnaXN0cnksIGlkKTtcXG5cXG4gICAgICAgICAgICBpZiAoIW1vZCkge1xcbiAgICAgICAgICAgICAgICBtb2QgPSByZWdpc3RyeVtpZF0gPSBuZXcgY29udGV4dC5Nb2R1bGUoZGVwTWFwKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIG1vZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIG9uKGRlcE1hcCwgbmFtZSwgZm4pIHtcXG4gICAgICAgICAgICB2YXIgaWQgPSBkZXBNYXAuaWQsXFxuICAgICAgICAgICAgICAgIG1vZCA9IGdldE93bihyZWdpc3RyeSwgaWQpO1xcblxcbiAgICAgICAgICAgIGlmIChoYXNQcm9wKGRlZmluZWQsIGlkKSAmJlxcbiAgICAgICAgICAgICAgICAgICAgKCFtb2QgfHwgbW9kLmRlZmluZUVtaXRDb21wbGV0ZSkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdkZWZpbmVkJykge1xcbiAgICAgICAgICAgICAgICAgICAgZm4oZGVmaW5lZFtpZF0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbW9kID0gZ2V0TW9kdWxlKGRlcE1hcCk7XFxuICAgICAgICAgICAgICAgIGlmIChtb2QuZXJyb3IgJiYgbmFtZSA9PT0gJ2Vycm9yJykge1xcbiAgICAgICAgICAgICAgICAgICAgZm4obW9kLmVycm9yKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIG1vZC5vbihuYW1lLCBmbik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiBvbkVycm9yKGVyciwgZXJyYmFjaykge1xcbiAgICAgICAgICAgIHZhciBpZHMgPSBlcnIucmVxdWlyZU1vZHVsZXMsXFxuICAgICAgICAgICAgICAgIG5vdGlmaWVkID0gZmFsc2U7XFxuXFxuICAgICAgICAgICAgaWYgKGVycmJhY2spIHtcXG4gICAgICAgICAgICAgICAgZXJyYmFjayhlcnIpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGVhY2goaWRzLCBmdW5jdGlvbiAoaWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2QgPSBnZXRPd24ocmVnaXN0cnksIGlkKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2QpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1NldCBlcnJvciBvbiBtb2R1bGUsIHNvIGl0IHNraXBzIHRpbWVvdXQgY2hlY2tzLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5lcnJvciA9IGVycjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kLmV2ZW50cy5lcnJvcikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmllZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5lbWl0KCdlcnJvcicsIGVycik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFub3RpZmllZCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIHRyYW5zZmVyIGdsb2JhbFF1ZXVlIGl0ZW1zIHRvIHRoaXMgY29udGV4dCdzXFxuICAgICAgICAgKiBkZWZRdWV1ZS5cXG4gICAgICAgICAqL1xcbiAgICAgICAgZnVuY3Rpb24gdGFrZUdsb2JhbFF1ZXVlKCkge1xcbiAgICAgICAgICAgIC8vUHVzaCBhbGwgdGhlIGdsb2JhbERlZlF1ZXVlIGl0ZW1zIGludG8gdGhlIGNvbnRleHQncyBkZWZRdWV1ZVxcbiAgICAgICAgICAgIGlmIChnbG9iYWxEZWZRdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgLy9BcnJheSBzcGxpY2UgaW4gdGhlIHZhbHVlcyBzaW5jZSB0aGUgY29udGV4dCBjb2RlIGhhcyBhXFxuICAgICAgICAgICAgICAgIC8vbG9jYWwgdmFyIHJlZiB0byBkZWZRdWV1ZSwgc28gY2Fubm90IGp1c3QgcmVhc3NpZ24gdGhlIG9uZVxcbiAgICAgICAgICAgICAgICAvL29uIGNvbnRleHQuXFxuICAgICAgICAgICAgICAgIGFwc3AuYXBwbHkoZGVmUXVldWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RlZlF1ZXVlLmxlbmd0aCwgMF0uY29uY2F0KGdsb2JhbERlZlF1ZXVlKSk7XFxuICAgICAgICAgICAgICAgIGdsb2JhbERlZlF1ZXVlID0gW107XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaGFuZGxlcnMgPSB7XFxuICAgICAgICAgICAgJ3JlcXVpcmUnOiBmdW5jdGlvbiAobW9kKSB7XFxuICAgICAgICAgICAgICAgIGlmIChtb2QucmVxdWlyZSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZC5yZXF1aXJlO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtb2QucmVxdWlyZSA9IGNvbnRleHQubWFrZVJlcXVpcmUobW9kLm1hcCkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAnZXhwb3J0cyc6IGZ1bmN0aW9uIChtb2QpIHtcXG4gICAgICAgICAgICAgICAgbW9kLnVzaW5nRXhwb3J0cyA9IHRydWU7XFxuICAgICAgICAgICAgICAgIGlmIChtb2QubWFwLmlzRGVmaW5lKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kLmV4cG9ydHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRlZmluZWRbbW9kLm1hcC5pZF0gPSBtb2QuZXhwb3J0cyk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kLmV4cG9ydHMgPSBkZWZpbmVkW21vZC5tYXAuaWRdID0ge30pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAnbW9kdWxlJzogZnVuY3Rpb24gKG1vZCkge1xcbiAgICAgICAgICAgICAgICBpZiAobW9kLm1vZHVsZSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZC5tb2R1bGU7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZC5tb2R1bGUgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1vZC5tYXAuaWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiBtb2QubWFwLnVybCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICBnZXRPd24oY29uZmlnLmNvbmZpZywgbW9kLm1hcC5pZCkgfHwge307XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBtb2QuZXhwb3J0cyB8fCAobW9kLmV4cG9ydHMgPSB7fSlcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuUmVnaXN0cnkoaWQpIHtcXG4gICAgICAgICAgICAvL0NsZWFuIHVwIG1hY2hpbmVyeSB1c2VkIGZvciB3YWl0aW5nIG1vZHVsZXMuXFxuICAgICAgICAgICAgZGVsZXRlIHJlZ2lzdHJ5W2lkXTtcXG4gICAgICAgICAgICBkZWxldGUgZW5hYmxlZFJlZ2lzdHJ5W2lkXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIGJyZWFrQ3ljbGUobW9kLCB0cmFjZWQsIHByb2Nlc3NlZCkge1xcbiAgICAgICAgICAgIHZhciBpZCA9IG1vZC5tYXAuaWQ7XFxuXFxuICAgICAgICAgICAgaWYgKG1vZC5lcnJvcikge1xcbiAgICAgICAgICAgICAgICBtb2QuZW1pdCgnZXJyb3InLCBtb2QuZXJyb3IpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRyYWNlZFtpZF0gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICBlYWNoKG1vZC5kZXBNYXBzLCBmdW5jdGlvbiAoZGVwTWFwLCBpKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwSWQgPSBkZXBNYXAuaWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwID0gZ2V0T3duKHJlZ2lzdHJ5LCBkZXBJZCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL09ubHkgZm9yY2UgdGhpbmdzIHRoYXQgaGF2ZSBub3QgY29tcGxldGVkXFxuICAgICAgICAgICAgICAgICAgICAvL2JlaW5nIGRlZmluZWQsIHNvIHN0aWxsIGluIHRoZSByZWdpc3RyeSxcXG4gICAgICAgICAgICAgICAgICAgIC8vYW5kIG9ubHkgaWYgaXQgaGFzIG5vdCBiZWVuIG1hdGNoZWQgdXBcXG4gICAgICAgICAgICAgICAgICAgIC8vaW4gdGhlIG1vZHVsZSBhbHJlYWR5LlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcCAmJiAhbW9kLmRlcE1hdGNoZWRbaV0gJiYgIXByb2Nlc3NlZFtkZXBJZF0pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0T3duKHRyYWNlZCwgZGVwSWQpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5kZWZpbmVEZXAoaSwgZGVmaW5lZFtkZXBJZF0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuY2hlY2soKTsgLy9wYXNzIGZhbHNlP1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrQ3ljbGUoZGVwLCB0cmFjZWQsIHByb2Nlc3NlZCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkW2lkXSA9IHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMb2FkZWQoKSB7XFxuICAgICAgICAgICAgdmFyIGVyciwgdXNpbmdQYXRoRmFsbGJhY2ssXFxuICAgICAgICAgICAgICAgIHdhaXRJbnRlcnZhbCA9IGNvbmZpZy53YWl0U2Vjb25kcyAqIDEwMDAsXFxuICAgICAgICAgICAgICAgIC8vSXQgaXMgcG9zc2libGUgdG8gZGlzYWJsZSB0aGUgd2FpdCBpbnRlcnZhbCBieSB1c2luZyB3YWl0U2Vjb25kcyBvZiAwLlxcbiAgICAgICAgICAgICAgICBleHBpcmVkID0gd2FpdEludGVydmFsICYmIChjb250ZXh0LnN0YXJ0VGltZSArIHdhaXRJbnRlcnZhbCkgPCBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcXG4gICAgICAgICAgICAgICAgbm9Mb2FkcyA9IFtdLFxcbiAgICAgICAgICAgICAgICByZXFDYWxscyA9IFtdLFxcbiAgICAgICAgICAgICAgICBzdGlsbExvYWRpbmcgPSBmYWxzZSxcXG4gICAgICAgICAgICAgICAgbmVlZEN5Y2xlQ2hlY2sgPSB0cnVlO1xcblxcbiAgICAgICAgICAgIC8vRG8gbm90IGJvdGhlciBpZiB0aGlzIGNhbGwgd2FzIGEgcmVzdWx0IG9mIGEgY3ljbGUgYnJlYWsuXFxuICAgICAgICAgICAgaWYgKGluQ2hlY2tMb2FkZWQpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpbkNoZWNrTG9hZGVkID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAvL0ZpZ3VyZSBvdXQgdGhlIHN0YXRlIG9mIGFsbCB0aGUgbW9kdWxlcy5cXG4gICAgICAgICAgICBlYWNoUHJvcChlbmFibGVkUmVnaXN0cnksIGZ1bmN0aW9uIChtb2QpIHtcXG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IG1vZC5tYXAsXFxuICAgICAgICAgICAgICAgICAgICBtb2RJZCA9IG1hcC5pZDtcXG5cXG4gICAgICAgICAgICAgICAgLy9Ta2lwIHRoaW5ncyB0aGF0IGFyZSBub3QgZW5hYmxlZCBvciBpbiBlcnJvciBzdGF0ZS5cXG4gICAgICAgICAgICAgICAgaWYgKCFtb2QuZW5hYmxlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICghbWFwLmlzRGVmaW5lKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXFDYWxscy5wdXNoKG1vZCk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFtb2QuZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIG1vZHVsZSBzaG91bGQgYmUgZXhlY3V0ZWQsIGFuZCBpdCBoYXMgbm90XFxuICAgICAgICAgICAgICAgICAgICAvL2JlZW4gaW5pdGVkIGFuZCB0aW1lIGlzIHVwLCByZW1lbWJlciBpdC5cXG4gICAgICAgICAgICAgICAgICAgIGlmICghbW9kLmluaXRlZCAmJiBleHBpcmVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1BhdGhGYWxsYmFjayhtb2RJZCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmdQYXRoRmFsbGJhY2sgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGlsbExvYWRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vTG9hZHMucHVzaChtb2RJZCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVNjcmlwdChtb2RJZCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghbW9kLmluaXRlZCAmJiBtb2QuZmV0Y2hlZCAmJiBtYXAuaXNEZWZpbmUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGlsbExvYWRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWFwLnByZWZpeCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL05vIHJlYXNvbiB0byBrZWVwIGxvb2tpbmcgZm9yIHVuZmluaXNoZWRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2FkaW5nLiBJZiB0aGUgb25seSBzdGlsbExvYWRpbmcgaXMgYVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BsdWdpbiByZXNvdXJjZSB0aG91Z2gsIGtlZXAgZ29pbmcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmVjYXVzZSBpdCBtYXkgYmUgdGhhdCBhIHBsdWdpbiByZXNvdXJjZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lzIHdhaXRpbmcgb24gYSBub24tcGx1Z2luIGN5Y2xlLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5lZWRDeWNsZUNoZWNrID0gZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGlmIChleHBpcmVkICYmIG5vTG9hZHMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIC8vSWYgd2FpdCB0aW1lIGV4cGlyZWQsIHRocm93IGVycm9yIG9mIHVubG9hZGVkIG1vZHVsZXMuXFxuICAgICAgICAgICAgICAgIGVyciA9IG1ha2VFcnJvcigndGltZW91dCcsICdMb2FkIHRpbWVvdXQgZm9yIG1vZHVsZXM6ICcgKyBub0xvYWRzLCBudWxsLCBub0xvYWRzKTtcXG4gICAgICAgICAgICAgICAgZXJyLmNvbnRleHROYW1lID0gY29udGV4dC5jb250ZXh0TmFtZTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9Ob3QgZXhwaXJlZCwgY2hlY2sgZm9yIGEgY3ljbGUuXFxuICAgICAgICAgICAgaWYgKG5lZWRDeWNsZUNoZWNrKSB7XFxuICAgICAgICAgICAgICAgIGVhY2gocmVxQ2FsbHMsIGZ1bmN0aW9uIChtb2QpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrQ3ljbGUobW9kLCB7fSwge30pO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9JZiBzdGlsbCB3YWl0aW5nIG9uIGxvYWRzLCBhbmQgdGhlIHdhaXRpbmcgbG9hZCBpcyBzb21ldGhpbmdcXG4gICAgICAgICAgICAvL290aGVyIHRoYW4gYSBwbHVnaW4gcmVzb3VyY2UsIG9yIHRoZXJlIGFyZSBzdGlsbCBvdXRzdGFuZGluZ1xcbiAgICAgICAgICAgIC8vc2NyaXB0cywgdGhlbiBqdXN0IHRyeSBiYWNrIGxhdGVyLlxcbiAgICAgICAgICAgIGlmICgoIWV4cGlyZWQgfHwgdXNpbmdQYXRoRmFsbGJhY2spICYmIHN0aWxsTG9hZGluZykge1xcbiAgICAgICAgICAgICAgICAvL1NvbWV0aGluZyBpcyBzdGlsbCB3YWl0aW5nIHRvIGxvYWQuIFdhaXQgZm9yIGl0LCBidXQgb25seVxcbiAgICAgICAgICAgICAgICAvL2lmIGEgdGltZW91dCBpcyBub3QgYWxyZWFkeSBpbiBlZmZlY3QuXFxuICAgICAgICAgICAgICAgIGlmICgoaXNCcm93c2VyIHx8IGlzV2ViV29ya2VyKSAmJiAhY2hlY2tMb2FkZWRUaW1lb3V0SWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTG9hZGVkVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tMb2FkZWRUaW1lb3V0SWQgPSAwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrTG9hZGVkKCk7XFxuICAgICAgICAgICAgICAgICAgICB9LCA1MCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaW5DaGVja0xvYWRlZCA9IGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgTW9kdWxlID0gZnVuY3Rpb24gKG1hcCkge1xcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gZ2V0T3duKHVuZGVmRXZlbnRzLCBtYXAuaWQpIHx8IHt9O1xcbiAgICAgICAgICAgIHRoaXMubWFwID0gbWFwO1xcbiAgICAgICAgICAgIHRoaXMuc2hpbSA9IGdldE93bihjb25maWcuc2hpbSwgbWFwLmlkKTtcXG4gICAgICAgICAgICB0aGlzLmRlcEV4cG9ydHMgPSBbXTtcXG4gICAgICAgICAgICB0aGlzLmRlcE1hcHMgPSBbXTtcXG4gICAgICAgICAgICB0aGlzLmRlcE1hdGNoZWQgPSBbXTtcXG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcHMgPSB7fTtcXG4gICAgICAgICAgICB0aGlzLmRlcENvdW50ID0gMDtcXG5cXG4gICAgICAgICAgICAvKiB0aGlzLmV4cG9ydHMgdGhpcy5mYWN0b3J5XFxuICAgICAgICAgICAgICAgdGhpcy5kZXBNYXBzID0gW10sXFxuICAgICAgICAgICAgICAgdGhpcy5lbmFibGVkLCB0aGlzLmZldGNoZWRcXG4gICAgICAgICAgICAqL1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIE1vZHVsZS5wcm90b3R5cGUgPSB7XFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKGRlcE1hcHMsIGZhY3RvcnksIGVycmJhY2ssIG9wdGlvbnMpIHtcXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAgICAgICAgICAgICAgIC8vRG8gbm90IGRvIG1vcmUgaW5pdHMgaWYgYWxyZWFkeSBkb25lLiBDYW4gaGFwcGVuIGlmIHRoZXJlXFxuICAgICAgICAgICAgICAgIC8vYXJlIG11bHRpcGxlIGRlZmluZSBjYWxscyBmb3IgdGhlIHNhbWUgbW9kdWxlLiBUaGF0IGlzIG5vdFxcbiAgICAgICAgICAgICAgICAvL2Egbm9ybWFsLCBjb21tb24gY2FzZSwgYnV0IGl0IGlzIGFsc28gbm90IHVuZXhwZWN0ZWQuXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluaXRlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChlcnJiYWNrKSB7XFxuICAgICAgICAgICAgICAgICAgICAvL1JlZ2lzdGVyIGZvciBlcnJvcnMgb24gdGhpcyBtb2R1bGUuXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVycmJhY2spO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZXZlbnRzLmVycm9yKSB7XFxuICAgICAgICAgICAgICAgICAgICAvL0lmIG5vIGVycmJhY2sgYWxyZWFkeSwgYnV0IHRoZXJlIGFyZSBlcnJvciBsaXN0ZW5lcnNcXG4gICAgICAgICAgICAgICAgICAgIC8vb24gdGhpcyBtb2R1bGUsIHNldCB1cCBhbiBlcnJiYWNrIHRvIHBhc3MgdG8gdGhlIGRlcHMuXFxuICAgICAgICAgICAgICAgICAgICBlcnJiYWNrID0gYmluZCh0aGlzLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAvL0RvIGEgY29weSBvZiB0aGUgZGVwZW5kZW5jeSBhcnJheSwgc28gdGhhdFxcbiAgICAgICAgICAgICAgICAvL3NvdXJjZSBpbnB1dHMgYXJlIG5vdCBtb2RpZmllZC4gRm9yIGV4YW1wbGVcXG4gICAgICAgICAgICAgICAgLy9cXFwic2hpbVxcXCIgZGVwcyBhcmUgcGFzc2VkIGluIGhlcmUgZGlyZWN0bHksIGFuZFxcbiAgICAgICAgICAgICAgICAvL2RvaW5nIGEgZGlyZWN0IG1vZGlmaWNhdGlvbiBvZiB0aGUgZGVwTWFwcyBhcnJheVxcbiAgICAgICAgICAgICAgICAvL3dvdWxkIGFmZmVjdCB0aGF0IGNvbmZpZy5cXG4gICAgICAgICAgICAgICAgdGhpcy5kZXBNYXBzID0gZGVwTWFwcyAmJiBkZXBNYXBzLnNsaWNlKDApO1xcblxcbiAgICAgICAgICAgICAgICB0aGlzLmVycmJhY2sgPSBlcnJiYWNrO1xcblxcbiAgICAgICAgICAgICAgICAvL0luZGljYXRlIHRoaXMgbW9kdWxlIGhhcyBiZSBpbml0aWFsaXplZFxcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuaWdub3JlID0gb3B0aW9ucy5pZ25vcmU7XFxuXFxuICAgICAgICAgICAgICAgIC8vQ291bGQgaGF2ZSBvcHRpb24gdG8gaW5pdCB0aGlzIG1vZHVsZSBpbiBlbmFibGVkIG1vZGUsXFxuICAgICAgICAgICAgICAgIC8vb3IgY291bGQgaGF2ZSBiZWVuIHByZXZpb3VzbHkgbWFya2VkIGFzIGVuYWJsZWQuIEhvd2V2ZXIsXFxuICAgICAgICAgICAgICAgIC8vdGhlIGRlcGVuZGVuY2llcyBhcmUgbm90IGtub3duIHVudGlsIGluaXQgaXMgY2FsbGVkLiBTb1xcbiAgICAgICAgICAgICAgICAvL2lmIGVuYWJsZWQgcHJldmlvdXNseSwgbm93IHRyaWdnZXIgZGVwZW5kZW5jaWVzIGFzIGVuYWJsZWQuXFxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgdGhpcy5lbmFibGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAvL0VuYWJsZSB0aGlzIG1vZHVsZSBhbmQgZGVwZW5kZW5jaWVzLlxcbiAgICAgICAgICAgICAgICAgICAgLy9XaWxsIGNhbGwgdGhpcy5jaGVjaygpXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVjaygpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICBkZWZpbmVEZXA6IGZ1bmN0aW9uIChpLCBkZXBFeHBvcnRzKSB7XFxuICAgICAgICAgICAgICAgIC8vQmVjYXVzZSBvZiBjeWNsZXMsIGRlZmluZWQgY2FsbGJhY2sgZm9yIGEgZ2l2ZW5cXG4gICAgICAgICAgICAgICAgLy9leHBvcnQgY2FuIGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlcE1hdGNoZWRbaV0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwTWF0Y2hlZFtpXSA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcENvdW50IC09IDE7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcEV4cG9ydHNbaV0gPSBkZXBFeHBvcnRzO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICBmZXRjaDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mZXRjaGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaGVkID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xcblxcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXA7XFxuXFxuICAgICAgICAgICAgICAgIC8vSWYgdGhlIG1hbmFnZXIgaXMgZm9yIGEgcGx1Z2luIG1hbmFnZWQgcmVzb3VyY2UsXFxuICAgICAgICAgICAgICAgIC8vYXNrIHRoZSBwbHVnaW4gdG8gbG9hZCBpdCBub3cuXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoaW0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWFrZVJlcXVpcmUodGhpcy5tYXAsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVCdWlsZENhbGxiYWNrOiB0cnVlXFxuICAgICAgICAgICAgICAgICAgICB9KSh0aGlzLnNoaW0uZGVwcyB8fCBbXSwgYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5wcmVmaXggPyB0aGlzLmNhbGxQbHVnaW4oKSA6IHRoaXMubG9hZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgLy9SZWd1bGFyIGRlcGVuZGVuY3kuXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwLnByZWZpeCA/IHRoaXMuY2FsbFBsdWdpbigpIDogdGhpcy5sb2FkKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcblxcbiAgICAgICAgICAgIGxvYWQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMubWFwLnVybDtcXG5cXG4gICAgICAgICAgICAgICAgLy9SZWd1bGFyIGRlcGVuZGVuY3kuXFxuICAgICAgICAgICAgICAgIGlmICghdXJsRmV0Y2hlZFt1cmxdKSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmxGZXRjaGVkW3VybF0gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sb2FkKHRoaXMubWFwLmlkLCB1cmwpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiBDaGVja3MgaWYgdGhlIG1vZHVsZSBpcyByZWFkeSB0byBkZWZpbmUgaXRzZWxmLCBhbmQgaWYgc28sXFxuICAgICAgICAgICAgICogZGVmaW5lIGl0LlxcbiAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8IHRoaXMuZW5hYmxpbmcpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB2YXIgZXJyLCBjanNNb2R1bGUsXFxuICAgICAgICAgICAgICAgICAgICBpZCA9IHRoaXMubWFwLmlkLFxcbiAgICAgICAgICAgICAgICAgICAgZGVwRXhwb3J0cyA9IHRoaXMuZGVwRXhwb3J0cyxcXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMgPSB0aGlzLmV4cG9ydHMsXFxuICAgICAgICAgICAgICAgICAgICBmYWN0b3J5ID0gdGhpcy5mYWN0b3J5O1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5pdGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZldGNoKCk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5lcnJvcikge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMuZXJyb3IpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmRlZmluaW5nKSB7XFxuICAgICAgICAgICAgICAgICAgICAvL1RoZSBmYWN0b3J5IGNvdWxkIHRyaWdnZXIgYW5vdGhlciByZXF1aXJlIGNhbGxcXG4gICAgICAgICAgICAgICAgICAgIC8vdGhhdCB3b3VsZCByZXN1bHQgaW4gY2hlY2tpbmcgdGhpcyBtb2R1bGUgdG9cXG4gICAgICAgICAgICAgICAgICAgIC8vZGVmaW5lIGl0c2VsZiBhZ2Fpbi4gSWYgYWxyZWFkeSBpbiB0aGUgcHJvY2Vzc1xcbiAgICAgICAgICAgICAgICAgICAgLy9vZiBkb2luZyB0aGF0LCBza2lwIHRoaXMgd29yay5cXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5pbmcgPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwQ291bnQgPCAxICYmICF0aGlzLmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihmYWN0b3J5KSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZXJlIGlzIGFuIGVycm9yIGxpc3RlbmVyLCBmYXZvciBwYXNzaW5nXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdG8gdGhhdCBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yLiBIb3dldmVyLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29ubHkgZG8gaXQgZm9yIGRlZmluZSgpJ2QgIG1vZHVsZXMuIHJlcXVpcmVcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9lcnJiYWNrcyBzaG91bGQgbm90IGJlIGNhbGxlZCBmb3IgZmFpbHVyZXMgaW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGVpciBjYWxsYmFja3MgKCM2OTkpLiBIb3dldmVyIGlmIGEgZ2xvYmFsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25FcnJvciBpcyBzZXQsIHVzZSB0aGF0LlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZXZlbnRzLmVycm9yICYmIHRoaXMubWFwLmlzRGVmaW5lKSB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uRXJyb3IgIT09IGRlZmF1bHRPbkVycm9yKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMgPSBjb250ZXh0LmV4ZWNDYihpZCwgZmFjdG9yeSwgZGVwRXhwb3J0cywgZXhwb3J0cyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMgPSBjb250ZXh0LmV4ZWNDYihpZCwgZmFjdG9yeSwgZGVwRXhwb3J0cywgZXhwb3J0cyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmF2b3IgcmV0dXJuIHZhbHVlIG92ZXIgZXhwb3J0cy4gSWYgbm9kZS9janMgaW4gcGxheSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB3aWxsIG5vdCBoYXZlIGEgcmV0dXJuIHZhbHVlIGFueXdheS4gRmF2b3JcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9kdWxlLmV4cG9ydHMgYXNzaWdubWVudCBvdmVyIGV4cG9ydHMgb2JqZWN0LlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXAuaXNEZWZpbmUgJiYgZXhwb3J0cyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUgPSB0aGlzLm1vZHVsZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjanNNb2R1bGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzID0gY2pzTW9kdWxlLmV4cG9ydHM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudXNpbmdFeHBvcnRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9leHBvcnRzIGFscmVhZHkgc2V0IHRoZSBkZWZpbmVkIHZhbHVlLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMgPSB0aGlzLmV4cG9ydHM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnJlcXVpcmVNYXAgPSB0aGlzLm1hcDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5yZXF1aXJlTW9kdWxlcyA9IHRoaXMubWFwLmlzRGVmaW5lID8gW3RoaXMubWFwLmlkXSA6IG51bGw7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIucmVxdWlyZVR5cGUgPSB0aGlzLm1hcC5pc0RlZmluZSA/ICdkZWZpbmUnIDogJ3JlcXVpcmUnO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IoKHRoaXMuZXJyb3IgPSBlcnIpKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSnVzdCBhIGxpdGVyYWwgdmFsdWVcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cyA9IGZhY3Rvcnk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0cyA9IGV4cG9ydHM7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFwLmlzRGVmaW5lICYmICF0aGlzLmlnbm9yZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVkW2lkXSA9IGV4cG9ydHM7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEub25SZXNvdXJjZUxvYWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vblJlc291cmNlTG9hZChjb250ZXh0LCB0aGlzLm1hcCwgdGhpcy5kZXBNYXBzKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0NsZWFuIHVwXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5SZWdpc3RyeShpZCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmVkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vRmluaXNoZWQgdGhlIGRlZmluZSBzdGFnZS4gQWxsb3cgY2FsbGluZyBjaGVjayBhZ2FpblxcbiAgICAgICAgICAgICAgICAgICAgLy90byBhbGxvdyBkZWZpbmUgbm90aWZpY2F0aW9ucyBiZWxvdyBpbiB0aGUgY2FzZSBvZiBhXFxuICAgICAgICAgICAgICAgICAgICAvL2N5Y2xlLlxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmluZyA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmaW5lZCAmJiAhdGhpcy5kZWZpbmVFbWl0dGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmVFbWl0dGVkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RlZmluZWQnLCB0aGlzLmV4cG9ydHMpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lRW1pdENvbXBsZXRlID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgY2FsbFBsdWdpbjogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXAsXFxuICAgICAgICAgICAgICAgICAgICBpZCA9IG1hcC5pZCxcXG4gICAgICAgICAgICAgICAgICAgIC8vTWFwIGFscmVhZHkgbm9ybWFsaXplZCB0aGUgcHJlZml4LlxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luTWFwID0gbWFrZU1vZHVsZU1hcChtYXAucHJlZml4KTtcXG5cXG4gICAgICAgICAgICAgICAgLy9NYXJrIHRoaXMgYXMgYSBkZXBlbmRlbmN5IGZvciB0aGlzIHBsdWdpbiwgc28gaXRcXG4gICAgICAgICAgICAgICAgLy9jYW4gYmUgdHJhY2VkIGZvciBjeWNsZXMuXFxuICAgICAgICAgICAgICAgIHRoaXMuZGVwTWFwcy5wdXNoKHBsdWdpbk1hcCk7XFxuXFxuICAgICAgICAgICAgICAgIG9uKHBsdWdpbk1hcCwgJ2RlZmluZWQnLCBiaW5kKHRoaXMsIGZ1bmN0aW9uIChwbHVnaW4pIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2FkLCBub3JtYWxpemVkTWFwLCBub3JtYWxpemVkTW9kLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZUlkID0gZ2V0T3duKGJ1bmRsZXNNYXAsIHRoaXMubWFwLmlkKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5tYXAubmFtZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROYW1lID0gdGhpcy5tYXAucGFyZW50TWFwID8gdGhpcy5tYXAucGFyZW50TWFwLm5hbWUgOiBudWxsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUmVxdWlyZSA9IGNvbnRleHQubWFrZVJlcXVpcmUobWFwLnBhcmVudE1hcCwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVCdWlsZENhbGxiYWNrOiB0cnVlXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL0lmIGN1cnJlbnQgbWFwIGlzIG5vdCBub3JtYWxpemVkLCB3YWl0IGZvciB0aGF0XFxuICAgICAgICAgICAgICAgICAgICAvL25vcm1hbGl6ZWQgbmFtZSB0byBsb2FkIGluc3RlYWQgb2YgY29udGludWluZy5cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcC51bm5vcm1hbGl6ZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL05vcm1hbGl6ZSB0aGUgSUQgaWYgdGhlIHBsdWdpbiBhbGxvd3MgaXQuXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5ub3JtYWxpemUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBsdWdpbi5ub3JtYWxpemUobmFtZSwgZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUobmFtZSwgcGFyZW50TmFtZSwgdHJ1ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIHx8ICcnO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ByZWZpeCBhbmQgbmFtZSBzaG91bGQgYWxyZWFkeSBiZSBub3JtYWxpemVkLCBubyBuZWVkXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3IgYXBwbHlpbmcgbWFwIGNvbmZpZyBhZ2FpbiBlaXRoZXIuXFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZE1hcCA9IG1ha2VNb2R1bGVNYXAobWFwLnByZWZpeCArICchJyArIG5hbWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAucGFyZW50TWFwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvbihub3JtYWxpemVkTWFwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVmaW5lZCcsIGJpbmQodGhpcywgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXQoW10sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9LCBudWxsLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmU6IHRydWVcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZE1vZCA9IGdldE93bihyZWdpc3RyeSwgbm9ybWFsaXplZE1hcC5pZCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRNb2QpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9NYXJrIHRoaXMgYXMgYSBkZXBlbmRlbmN5IGZvciB0aGlzIHBsdWdpbiwgc28gaXRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYW4gYmUgdHJhY2VkIGZvciBjeWNsZXMuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwTWFwcy5wdXNoKG5vcm1hbGl6ZWRNYXApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRNb2Qub24oJ2Vycm9yJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZE1vZC5lbmFibGUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgLy9JZiBhIHBhdGhzIGNvbmZpZywgdGhlbiBqdXN0IGxvYWQgdGhhdCBmaWxlIGluc3RlYWQgdG9cXG4gICAgICAgICAgICAgICAgICAgIC8vcmVzb2x2ZSB0aGUgcGx1Z2luLCBhcyBpdCBpcyBidWlsdCBpbnRvIHRoYXQgcGF0aHMgbGF5ZXIuXFxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVuZGxlSWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC51cmwgPSBjb250ZXh0Lm5hbWVUb1VybChidW5kbGVJZCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgbG9hZCA9IGJpbmQodGhpcywgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0KFtdLCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSwgbnVsbCwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGxvYWQuZXJyb3IgPSBiaW5kKHRoaXMsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIucmVxdWlyZU1vZHVsZXMgPSBbaWRdO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vUmVtb3ZlIHRlbXAgdW5ub3JtYWxpemVkIG1vZHVsZXMgZm9yIHRoaXMgbW9kdWxlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2luY2UgdGhleSB3aWxsIG5ldmVyIGJlIHJlc29sdmVkIG90aGVyd2lzZSBub3cuXFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaFByb3AocmVnaXN0cnksIGZ1bmN0aW9uIChtb2QpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZC5tYXAuaWQuaW5kZXhPZihpZCArICdfdW5ub3JtYWxpemVkJykgPT09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuUmVnaXN0cnkobW9kLm1hcC5pZCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vQWxsb3cgcGx1Z2lucyB0byBsb2FkIG90aGVyIGNvZGUgd2l0aG91dCBoYXZpbmcgdG8ga25vdyB0aGVcXG4gICAgICAgICAgICAgICAgICAgIC8vY29udGV4dCBvciBob3cgdG8gJ2NvbXBsZXRlJyB0aGUgbG9hZC5cXG4gICAgICAgICAgICAgICAgICAgIGxvYWQuZnJvbVRleHQgPSBiaW5kKHRoaXMsIGZ1bmN0aW9uICh0ZXh0LCB0ZXh0QWx0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLypqc2xpbnQgZXZpbDogdHJ1ZSAqL1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGVOYW1lID0gbWFwLm5hbWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU1hcCA9IG1ha2VNb2R1bGVNYXAobW9kdWxlTmFtZSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0ludGVyYWN0aXZlID0gdXNlSW50ZXJhY3RpdmU7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9BcyBvZiAyLjEuMCwgc3VwcG9ydCBqdXN0IHBhc3NpbmcgdGhlIHRleHQsIHRvIHJlaW5mb3JjZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZnJvbVRleHQgb25seSBiZWluZyBjYWxsZWQgb25jZSBwZXIgcmVzb3VyY2UuIFN0aWxsXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdXBwb3J0IG9sZCBzdHlsZSBvZiBwYXNzaW5nIG1vZHVsZU5hbWUgYnV0IGRpc2NhcmRcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoYXQgbW9kdWxlTmFtZSBpbiBmYXZvciBvZiB0aGUgaW50ZXJuYWwgcmVmLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0QWx0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0QWx0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1R1cm4gb2ZmIGludGVyYWN0aXZlIHNjcmlwdCBtYXRjaGluZyBmb3IgSUUgZm9yIGFueSBkZWZpbmVcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGxzIGluIHRoZSB0ZXh0LCB0aGVuIHR1cm4gaXQgYmFjayBvbiBhdCB0aGUgZW5kLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNJbnRlcmFjdGl2ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VJbnRlcmFjdGl2ZSA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1ByaW1lIHRoZSBzeXN0ZW0gYnkgY3JlYXRpbmcgYSBtb2R1bGUgaW5zdGFuY2UgZm9yXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pdC5cXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRNb2R1bGUobW9kdWxlTWFwKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RyYW5zZmVyIGFueSBjb25maWcgdG8gdGhpcyBvdGhlciBtb2R1bGUuXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Byb3AoY29uZmlnLmNvbmZpZywgaWQpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5jb25maWdbbW9kdWxlTmFtZV0gPSBjb25maWcuY29uZmlnW2lkXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmV4ZWModGV4dCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25FcnJvcihtYWtlRXJyb3IoJ2Zyb210ZXh0ZXZhbCcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Zyb21UZXh0IGV2YWwgZm9yICcgKyBpZCArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGZhaWxlZDogJyArIGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWRdKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNJbnRlcmFjdGl2ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VJbnRlcmFjdGl2ZSA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vTWFyayB0aGlzIGFzIGEgZGVwZW5kZW5jeSBmb3IgdGhlIHBsdWdpblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzb3VyY2VcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcE1hcHMucHVzaChtb2R1bGVNYXApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU3VwcG9ydCBhbm9ueW1vdXMgbW9kdWxlcy5cXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNvbXBsZXRlTG9hZChtb2R1bGVOYW1lKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0JpbmQgdGhlIHZhbHVlIG9mIHRoYXQgbW9kdWxlIHRvIHRoZSB2YWx1ZSBmb3IgdGhpc1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzb3VyY2UgSUQuXFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxSZXF1aXJlKFttb2R1bGVOYW1lXSwgbG9hZCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vVXNlIHBhcmVudE5hbWUgaGVyZSBzaW5jZSB0aGUgcGx1Z2luJ3MgbmFtZSBpcyBub3QgcmVsaWFibGUsXFxuICAgICAgICAgICAgICAgICAgICAvL2NvdWxkIGJlIHNvbWUgd2VpcmQgc3RyaW5nIHdpdGggbm8gcGF0aCB0aGF0IGFjdHVhbGx5IHdhbnRzIHRvXFxuICAgICAgICAgICAgICAgICAgICAvL3JlZmVyZW5jZSB0aGUgcGFyZW50TmFtZSdzIHBhdGguXFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4ubG9hZChtYXAubmFtZSwgbG9jYWxSZXF1aXJlLCBsb2FkLCBjb25maWcpO1xcbiAgICAgICAgICAgICAgICB9KSk7XFxuXFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZW5hYmxlKHBsdWdpbk1hcCwgdGhpcyk7XFxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwc1twbHVnaW5NYXAuaWRdID0gcGx1Z2luTWFwO1xcbiAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGVuYWJsZWRSZWdpc3RyeVt0aGlzLm1hcC5pZF0gPSB0aGlzO1xcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgICAvL1NldCBmbGFnIG1lbnRpb25pbmcgdGhhdCB0aGUgbW9kdWxlIGlzIGVuYWJsaW5nLFxcbiAgICAgICAgICAgICAgICAvL3NvIHRoYXQgaW1tZWRpYXRlIGNhbGxzIHRvIHRoZSBkZWZpbmVkIGNhbGxiYWNrc1xcbiAgICAgICAgICAgICAgICAvL2ZvciBkZXBlbmRlbmNpZXMgZG8gbm90IHRyaWdnZXIgaW5hZHZlcnRlbnQgbG9hZFxcbiAgICAgICAgICAgICAgICAvL3dpdGggdGhlIGRlcENvdW50IHN0aWxsIGJlaW5nIHplcm8uXFxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxpbmcgPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgICAvL0VuYWJsZSBlYWNoIGRlcGVuZGVuY3lcXG4gICAgICAgICAgICAgICAgZWFjaCh0aGlzLmRlcE1hcHMsIGJpbmQodGhpcywgZnVuY3Rpb24gKGRlcE1hcCwgaSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkLCBtb2QsIGhhbmRsZXI7XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlcE1hcCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0RlcGVuZGVuY3kgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGEgZGVwTWFwXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hbmQgd2lyZWQgdXAgdG8gdGhpcyBtb2R1bGUuXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwTWFwID0gbWFrZU1vZHVsZU1hcChkZXBNYXAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5tYXAuaXNEZWZpbmUgPyB0aGlzLm1hcCA6IHRoaXMubWFwLnBhcmVudE1hcCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLnNraXBNYXApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwTWFwc1tpXSA9IGRlcE1hcDtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyID0gZ2V0T3duKGhhbmRsZXJzLCBkZXBNYXAuaWQpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwRXhwb3J0c1tpXSA9IGhhbmRsZXIodGhpcyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXBDb3VudCArPSAxO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uKGRlcE1hcCwgJ2RlZmluZWQnLCBiaW5kKHRoaXMsIGZ1bmN0aW9uIChkZXBFeHBvcnRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lRGVwKGksIGRlcEV4cG9ydHMpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycmJhY2spIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb24oZGVwTWFwLCAnZXJyb3InLCBiaW5kKHRoaXMsIHRoaXMuZXJyYmFjaykpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZGVwTWFwLmlkO1xcbiAgICAgICAgICAgICAgICAgICAgbW9kID0gcmVnaXN0cnlbaWRdO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9Ta2lwIHNwZWNpYWwgbW9kdWxlcyBsaWtlICdyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJ1xcbiAgICAgICAgICAgICAgICAgICAgLy9BbHNvLCBkb24ndCBjYWxsIGVuYWJsZSBpZiBpdCBpcyBhbHJlYWR5IGVuYWJsZWQsXFxuICAgICAgICAgICAgICAgICAgICAvL2ltcG9ydGFudCBpbiBjaXJjdWxhciBkZXBlbmRlbmN5IGNhc2VzLlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wKGhhbmRsZXJzLCBpZCkgJiYgbW9kICYmICFtb2QuZW5hYmxlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW5hYmxlKGRlcE1hcCwgdGhpcyk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pKTtcXG5cXG4gICAgICAgICAgICAgICAgLy9FbmFibGUgZWFjaCBwbHVnaW4gdGhhdCBpcyB1c2VkIGluXFxuICAgICAgICAgICAgICAgIC8vYSBkZXBlbmRlbmN5XFxuICAgICAgICAgICAgICAgIGVhY2hQcm9wKHRoaXMucGx1Z2luTWFwcywgYmluZCh0aGlzLCBmdW5jdGlvbiAocGx1Z2luTWFwKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kID0gZ2V0T3duKHJlZ2lzdHJ5LCBwbHVnaW5NYXAuaWQpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZCAmJiAhbW9kLmVuYWJsZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVuYWJsZShwbHVnaW5NYXAsIHRoaXMpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KSk7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxpbmcgPSBmYWxzZTtcXG5cXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVjaygpO1xcbiAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgb246IGZ1bmN0aW9uIChuYW1lLCBjYikge1xcbiAgICAgICAgICAgICAgICB2YXIgY2JzID0gdGhpcy5ldmVudHNbbmFtZV07XFxuICAgICAgICAgICAgICAgIGlmICghY2JzKSB7XFxuICAgICAgICAgICAgICAgICAgICBjYnMgPSB0aGlzLmV2ZW50c1tuYW1lXSA9IFtdO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNicy5wdXNoKGNiKTtcXG4gICAgICAgICAgICB9LFxcblxcbiAgICAgICAgICAgIGVtaXQ6IGZ1bmN0aW9uIChuYW1lLCBldnQpIHtcXG4gICAgICAgICAgICAgICAgZWFjaCh0aGlzLmV2ZW50c1tuYW1lXSwgZnVuY3Rpb24gKGNiKSB7XFxuICAgICAgICAgICAgICAgICAgICBjYihldnQpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdlcnJvcicpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vTm93IHRoYXQgdGhlIGVycm9yIGhhbmRsZXIgd2FzIHRyaWdnZXJlZCwgcmVtb3ZlXFxuICAgICAgICAgICAgICAgICAgICAvL3RoZSBsaXN0ZW5lcnMsIHNpbmNlIHRoaXMgYnJva2VuIE1vZHVsZSBpbnN0YW5jZVxcbiAgICAgICAgICAgICAgICAgICAgLy9jYW4gc3RheSBhcm91bmQgZm9yIGEgd2hpbGUgaW4gdGhlIHJlZ2lzdHJ5LlxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzW25hbWVdO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxHZXRNb2R1bGUoYXJncykge1xcbiAgICAgICAgICAgIC8vU2tpcCBtb2R1bGVzIGFscmVhZHkgZGVmaW5lZC5cXG4gICAgICAgICAgICBpZiAoIWhhc1Byb3AoZGVmaW5lZCwgYXJnc1swXSkpIHtcXG4gICAgICAgICAgICAgICAgZ2V0TW9kdWxlKG1ha2VNb2R1bGVNYXAoYXJnc1swXSwgbnVsbCwgdHJ1ZSkpLmluaXQoYXJnc1sxXSwgYXJnc1syXSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIobm9kZSwgZnVuYywgbmFtZSwgaWVOYW1lKSB7XFxuICAgICAgICAgICAgLy9GYXZvciBkZXRhY2hFdmVudCBiZWNhdXNlIG9mIElFOVxcbiAgICAgICAgICAgIC8vaXNzdWUsIHNlZSBhdHRhY2hFdmVudC9hZGRFdmVudExpc3RlbmVyIGNvbW1lbnQgZWxzZXdoZXJlXFxuICAgICAgICAgICAgLy9pbiB0aGlzIGZpbGUuXFxuICAgICAgICAgICAgaWYgKG5vZGUuZGV0YWNoRXZlbnQgJiYgIWlzT3BlcmEpIHtcXG4gICAgICAgICAgICAgICAgLy9Qcm9iYWJseSBJRS4gSWYgbm90IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IsIHdoaWNoIHdpbGwgYmVcXG4gICAgICAgICAgICAgICAgLy91c2VmdWwgdG8ga25vdy5cXG4gICAgICAgICAgICAgICAgaWYgKGllTmFtZSkge1xcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kZXRhY2hFdmVudChpZU5hbWUsIGZ1bmMpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmMsIGZhbHNlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEdpdmVuIGFuIGV2ZW50IGZyb20gYSBzY3JpcHQgbm9kZSwgZ2V0IHRoZSByZXF1aXJlanMgaW5mbyBmcm9tIGl0LFxcbiAgICAgICAgICogYW5kIHRoZW4gcmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBub2RlLlxcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZ0XFxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxcbiAgICAgICAgICovXFxuICAgICAgICBmdW5jdGlvbiBnZXRTY3JpcHREYXRhKGV2dCkge1xcbiAgICAgICAgICAgIC8vVXNpbmcgY3VycmVudFRhcmdldCBpbnN0ZWFkIG9mIHRhcmdldCBmb3IgRmlyZWZveCAyLjAncyBzYWtlLiBOb3RcXG4gICAgICAgICAgICAvL2FsbCBvbGQgYnJvd3NlcnMgd2lsbCBiZSBzdXBwb3J0ZWQsIGJ1dCB0aGlzIG9uZSB3YXMgZWFzeSBlbm91Z2hcXG4gICAgICAgICAgICAvL3RvIHN1cHBvcnQgYW5kIHN0aWxsIG1ha2VzIHNlbnNlLlxcbiAgICAgICAgICAgIHZhciBub2RlID0gZXZ0LmN1cnJlbnRUYXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQ7XFxuXFxuICAgICAgICAgICAgLy9SZW1vdmUgdGhlIGxpc3RlbmVycyBvbmNlIGhlcmUuXFxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobm9kZSwgY29udGV4dC5vblNjcmlwdExvYWQsICdsb2FkJywgJ29ucmVhZHlzdGF0ZWNoYW5nZScpO1xcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKG5vZGUsIGNvbnRleHQub25TY3JpcHRFcnJvciwgJ2Vycm9yJyk7XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcXG4gICAgICAgICAgICAgICAgaWQ6IG5vZGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVxdWlyZW1vZHVsZScpXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIGludGFrZURlZmluZXMoKSB7XFxuICAgICAgICAgICAgdmFyIGFyZ3M7XFxuXFxuICAgICAgICAgICAgLy9BbnkgZGVmaW5lZCBtb2R1bGVzIGluIHRoZSBnbG9iYWwgcXVldWUsIGludGFrZSB0aGVtIG5vdy5cXG4gICAgICAgICAgICB0YWtlR2xvYmFsUXVldWUoKTtcXG5cXG4gICAgICAgICAgICAvL01ha2Ugc3VyZSBhbnkgcmVtYWluaW5nIGRlZlF1ZXVlIGl0ZW1zIGdldCBwcm9wZXJseSBwcm9jZXNzZWQuXFxuICAgICAgICAgICAgd2hpbGUgKGRlZlF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBhcmdzID0gZGVmUXVldWUuc2hpZnQoKTtcXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT09IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbkVycm9yKG1ha2VFcnJvcignbWlzbWF0Y2gnLCAnTWlzbWF0Y2hlZCBhbm9ueW1vdXMgZGVmaW5lKCkgbW9kdWxlOiAnICsgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAvL2FyZ3MgYXJlIGlkLCBkZXBzLCBmYWN0b3J5LiBTaG91bGQgYmUgbm9ybWFsaXplZCBieSB0aGVcXG4gICAgICAgICAgICAgICAgICAgIC8vZGVmaW5lKCkgZnVuY3Rpb24uXFxuICAgICAgICAgICAgICAgICAgICBjYWxsR2V0TW9kdWxlKGFyZ3MpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgY29udGV4dCA9IHtcXG4gICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcXG4gICAgICAgICAgICBjb250ZXh0TmFtZTogY29udGV4dE5hbWUsXFxuICAgICAgICAgICAgcmVnaXN0cnk6IHJlZ2lzdHJ5LFxcbiAgICAgICAgICAgIGRlZmluZWQ6IGRlZmluZWQsXFxuICAgICAgICAgICAgdXJsRmV0Y2hlZDogdXJsRmV0Y2hlZCxcXG4gICAgICAgICAgICBkZWZRdWV1ZTogZGVmUXVldWUsXFxuICAgICAgICAgICAgTW9kdWxlOiBNb2R1bGUsXFxuICAgICAgICAgICAgbWFrZU1vZHVsZU1hcDogbWFrZU1vZHVsZU1hcCxcXG4gICAgICAgICAgICBuZXh0VGljazogcmVxLm5leHRUaWNrLFxcbiAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3IsXFxuXFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICogU2V0IGEgY29uZmlndXJhdGlvbiBmb3IgdGhlIGNvbnRleHQuXFxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyBjb25maWcgb2JqZWN0IHRvIGludGVncmF0ZS5cXG4gICAgICAgICAgICAgKi9cXG4gICAgICAgICAgICBjb25maWd1cmU6IGZ1bmN0aW9uIChjZmcpIHtcXG4gICAgICAgICAgICAgICAgLy9NYWtlIHN1cmUgdGhlIGJhc2VVcmwgZW5kcyBpbiBhIHNsYXNoLlxcbiAgICAgICAgICAgICAgICBpZiAoY2ZnLmJhc2VVcmwpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZmcuYmFzZVVybC5jaGFyQXQoY2ZnLmJhc2VVcmwubGVuZ3RoIC0gMSkgIT09ICcvJykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNmZy5iYXNlVXJsICs9ICcvJztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAvL1NhdmUgb2ZmIHRoZSBwYXRocyBzaW5jZSB0aGV5IHJlcXVpcmUgc3BlY2lhbCBwcm9jZXNzaW5nLFxcbiAgICAgICAgICAgICAgICAvL3RoZXkgYXJlIGFkZGl0aXZlLlxcbiAgICAgICAgICAgICAgICB2YXIgc2hpbSA9IGNvbmZpZy5zaGltLFxcbiAgICAgICAgICAgICAgICAgICAgb2JqcyA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoczogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBidW5kbGVzOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXA6IHRydWVcXG4gICAgICAgICAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgICAgIGVhY2hQcm9wKGNmZywgZnVuY3Rpb24gKHZhbHVlLCBwcm9wKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAob2Jqc1twcm9wXSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnW3Byb3BdKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1twcm9wXSA9IHt9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXhpbihjb25maWdbcHJvcF0sIHZhbHVlLCB0cnVlLCB0cnVlKTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnW3Byb3BdID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAvL1JldmVyc2UgbWFwIHRoZSBidW5kbGVzXFxuICAgICAgICAgICAgICAgIGlmIChjZmcuYnVuZGxlcykge1xcbiAgICAgICAgICAgICAgICAgICAgZWFjaFByb3AoY2ZnLmJ1bmRsZXMsIGZ1bmN0aW9uICh2YWx1ZSwgcHJvcCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2godmFsdWUsIGZ1bmN0aW9uICh2KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSBwcm9wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGVzTWFwW3ZdID0gcHJvcDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgLy9NZXJnZSBzaGltXFxuICAgICAgICAgICAgICAgIGlmIChjZmcuc2hpbSkge1xcbiAgICAgICAgICAgICAgICAgICAgZWFjaFByb3AoY2ZnLnNoaW0sIGZ1bmN0aW9uICh2YWx1ZSwgaWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL05vcm1hbGl6ZSB0aGUgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogdmFsdWVcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZS5leHBvcnRzIHx8IHZhbHVlLmluaXQpICYmICF2YWx1ZS5leHBvcnRzRm4pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZXhwb3J0c0ZuID0gY29udGV4dC5tYWtlU2hpbUV4cG9ydHModmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGltW2lkXSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICBjb25maWcuc2hpbSA9IHNoaW07XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgLy9BZGp1c3QgcGFja2FnZXMgaWYgbmVjZXNzYXJ5LlxcbiAgICAgICAgICAgICAgICBpZiAoY2ZnLnBhY2thZ2VzKSB7XFxuICAgICAgICAgICAgICAgICAgICBlYWNoKGNmZy5wYWNrYWdlcywgZnVuY3Rpb24gKHBrZ09iaikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiwgbmFtZTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBwa2dPYmogPSB0eXBlb2YgcGtnT2JqID09PSAnc3RyaW5nJyA/IHsgbmFtZTogcGtnT2JqIH0gOiBwa2dPYmo7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBrZ09iai5uYW1lO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gcGtnT2JqLmxvY2F0aW9uO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcucGF0aHNbbmFtZV0gPSBwa2dPYmoubG9jYXRpb247XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU2F2ZSBwb2ludGVyIHRvIG1haW4gbW9kdWxlIElEIGZvciBwa2cgbmFtZS5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1JlbW92ZSBsZWFkaW5nIGRvdCBpbiBtYWluLCBzbyBtYWluIHBhdGhzIGFyZSBub3JtYWxpemVkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYW5kIHJlbW92ZSBhbnkgdHJhaWxpbmcgLmpzLCBzaW5jZSBkaWZmZXJlbnQgcGFja2FnZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZW52cyBoYXZlIGRpZmZlcmVudCBjb252ZW50aW9uczogc29tZSB1c2UgYSBtb2R1bGUgbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NvbWUgdXNlIGEgZmlsZSBuYW1lLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5wa2dzW25hbWVdID0gcGtnT2JqLm5hbWUgKyAnLycgKyAocGtnT2JqLm1haW4gfHwgJ21haW4nKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShjdXJyRGlyUmVnRXhwLCAnJylcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoanNTdWZmaXhSZWdFeHAsICcnKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vSWYgdGhlcmUgYXJlIGFueSBcXFwid2FpdGluZyB0byBleGVjdXRlXFxcIiBtb2R1bGVzIGluIHRoZSByZWdpc3RyeSxcXG4gICAgICAgICAgICAgICAgLy91cGRhdGUgdGhlIG1hcHMgZm9yIHRoZW0sIHNpbmNlIHRoZWlyIGluZm8sIGxpa2UgVVJMcyB0byBsb2FkLFxcbiAgICAgICAgICAgICAgICAvL21heSBoYXZlIGNoYW5nZWQuXFxuICAgICAgICAgICAgICAgIGVhY2hQcm9wKHJlZ2lzdHJ5LCBmdW5jdGlvbiAobW9kLCBpZCkge1xcbiAgICAgICAgICAgICAgICAgICAgLy9JZiBtb2R1bGUgYWxyZWFkeSBoYXMgaW5pdCBjYWxsZWQsIHNpbmNlIGl0IGlzIHRvb1xcbiAgICAgICAgICAgICAgICAgICAgLy9sYXRlIHRvIG1vZGlmeSB0aGVtLCBhbmQgaWdub3JlIHVubm9ybWFsaXplZCBvbmVzXFxuICAgICAgICAgICAgICAgICAgICAvL3NpbmNlIHRoZXkgYXJlIHRyYW5zaWVudC5cXG4gICAgICAgICAgICAgICAgICAgIGlmICghbW9kLmluaXRlZCAmJiAhbW9kLm1hcC51bm5vcm1hbGl6ZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2QubWFwID0gbWFrZU1vZHVsZU1hcChpZCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAvL0lmIGEgZGVwcyBhcnJheSBvciBhIGNvbmZpZyBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHRoZW4gY2FsbFxcbiAgICAgICAgICAgICAgICAvL3JlcXVpcmUgd2l0aCB0aG9zZSBhcmdzLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHJlcXVpcmUgaXMgZGVmaW5lZCBhcyBhXFxuICAgICAgICAgICAgICAgIC8vY29uZmlnIG9iamVjdCBiZWZvcmUgcmVxdWlyZS5qcyBpcyBsb2FkZWQuXFxuICAgICAgICAgICAgICAgIGlmIChjZmcuZGVwcyB8fCBjZmcuY2FsbGJhY2spIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVxdWlyZShjZmcuZGVwcyB8fCBbXSwgY2ZnLmNhbGxiYWNrKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgbWFrZVNoaW1FeHBvcnRzOiBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZm4oKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0O1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluaXQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSB2YWx1ZS5pbml0LmFwcGx5KGdsb2JhbCwgYXJndW1lbnRzKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgfHwgKHZhbHVlLmV4cG9ydHMgJiYgZ2V0R2xvYmFsKHZhbHVlLmV4cG9ydHMpKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICBtYWtlUmVxdWlyZTogZnVuY3Rpb24gKHJlbE1hcCwgb3B0aW9ucykge1xcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbG9jYWxSZXF1aXJlKGRlcHMsIGNhbGxiYWNrLCBlcnJiYWNrKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgaWQsIG1hcCwgcmVxdWlyZU1vZDtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZUJ1aWxkQ2FsbGJhY2sgJiYgY2FsbGJhY2sgJiYgaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5fX3JlcXVpcmVKc0J1aWxkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JbnZhbGlkIGNhbGxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IobWFrZUVycm9yKCdyZXF1aXJlYXJncycsICdJbnZhbGlkIHJlcXVpcmUgY2FsbCcpLCBlcnJiYWNrKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiByZXF1aXJlfGV4cG9ydHN8bW9kdWxlIGFyZSByZXF1ZXN0ZWQsIGdldCB0aGVcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhbHVlIGZvciB0aGVtIGZyb20gdGhlIHNwZWNpYWwgaGFuZGxlcnMuIENhdmVhdDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgb25seSB3b3JrcyB3aGlsZSBtb2R1bGUgaXMgYmVpbmcgZGVmaW5lZC5cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsTWFwICYmIGhhc1Byb3AoaGFuZGxlcnMsIGRlcHMpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyc1tkZXBzXShyZWdpc3RyeVtyZWxNYXAuaWRdKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9TeW5jaHJvbm91cyBhY2Nlc3MgdG8gb25lIG1vZHVsZS4gSWYgcmVxdWlyZS5nZXQgaXNcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2F2YWlsYWJsZSAoYXMgaW4gdGhlIE5vZGUgYWRhcHRlciksIHByZWZlciB0aGF0LlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEuZ2V0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXEuZ2V0KGNvbnRleHQsIGRlcHMsIHJlbE1hcCwgbG9jYWxSZXF1aXJlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9Ob3JtYWxpemUgbW9kdWxlIG5hbWUsIGlmIGl0IGNvbnRhaW5zIC4gb3IgLi5cXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAgPSBtYWtlTW9kdWxlTWFwKGRlcHMsIHJlbE1hcCwgZmFsc2UsIHRydWUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gbWFwLmlkO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBpZCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IobWFrZUVycm9yKCdub3Rsb2FkZWQnLCAnTW9kdWxlIG5hbWUgXFxcIicgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXFwiIGhhcyBub3QgYmVlbiBsb2FkZWQgeWV0IGZvciBjb250ZXh0OiAnICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dE5hbWUgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVsTWFwID8gJycgOiAnLiBVc2UgcmVxdWlyZShbXSknKSkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5lZFtpZF07XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL0dyYWIgZGVmaW5lcyB3YWl0aW5nIGluIHRoZSBnbG9iYWwgcXVldWUuXFxuICAgICAgICAgICAgICAgICAgICBpbnRha2VEZWZpbmVzKCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL01hcmsgYWxsIHRoZSBkZXBlbmRlbmNpZXMgYXMgbmVlZGluZyB0byBiZSBsb2FkZWQuXFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1NvbWUgZGVmaW5lcyBjb3VsZCBoYXZlIGJlZW4gYWRkZWQgc2luY2UgdGhlXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXF1aXJlIGNhbGwsIGNvbGxlY3QgdGhlbS5cXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRha2VEZWZpbmVzKCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZU1vZCA9IGdldE1vZHVsZShtYWtlTW9kdWxlTWFwKG51bGwsIHJlbE1hcCkpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU3RvcmUgaWYgbWFwIGNvbmZpZyBzaG91bGQgYmUgYXBwbGllZCB0byB0aGlzIHJlcXVpcmVcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGwgZm9yIGRlcGVuZGVuY2llcy5cXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlTW9kLnNraXBNYXAgPSBvcHRpb25zLnNraXBNYXA7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZU1vZC5pbml0KGRlcHMsIGNhbGxiYWNrLCBlcnJiYWNrLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0xvYWRlZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxSZXF1aXJlO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIG1peGluKGxvY2FsUmVxdWlyZSwge1xcbiAgICAgICAgICAgICAgICAgICAgaXNCcm93c2VyOiBpc0Jyb3dzZXIsXFxuXFxuICAgICAgICAgICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgICAgICAgICAqIENvbnZlcnRzIGEgbW9kdWxlIG5hbWUgKyAuZXh0ZW5zaW9uIGludG8gYW4gVVJMIHBhdGguXFxuICAgICAgICAgICAgICAgICAgICAgKiAqUmVxdWlyZXMqIHRoZSB1c2Ugb2YgYSBtb2R1bGUgbmFtZS4gSXQgZG9lcyBub3Qgc3VwcG9ydCB1c2luZ1xcbiAgICAgICAgICAgICAgICAgICAgICogcGxhaW4gVVJMcyBsaWtlIG5hbWVUb1VybC5cXG4gICAgICAgICAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgICAgICAgICAgdG9Vcmw6IGZ1bmN0aW9uIChtb2R1bGVOYW1lUGx1c0V4dCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbW9kdWxlTmFtZVBsdXNFeHQubGFzdEluZGV4T2YoJy4nKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IG1vZHVsZU5hbWVQbHVzRXh0LnNwbGl0KCcvJylbMF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVsYXRpdmUgPSBzZWdtZW50ID09PSAnLicgfHwgc2VnbWVudCA9PT0gJy4uJztcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0hhdmUgYSBmaWxlIGV4dGVuc2lvbiBhbGlhcywgYW5kIGl0IGlzIG5vdCB0aGVcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RvdHMgZnJvbSBhIHJlbGF0aXZlIHBhdGguXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiAoIWlzUmVsYXRpdmUgfHwgaW5kZXggPiAxKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHQgPSBtb2R1bGVOYW1lUGx1c0V4dC5zdWJzdHJpbmcoaW5kZXgsIG1vZHVsZU5hbWVQbHVzRXh0Lmxlbmd0aCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWVQbHVzRXh0ID0gbW9kdWxlTmFtZVBsdXNFeHQuc3Vic3RyaW5nKDAsIGluZGV4KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQubmFtZVRvVXJsKG5vcm1hbGl6ZShtb2R1bGVOYW1lUGx1c0V4dCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxNYXAgJiYgcmVsTWFwLmlkLCB0cnVlKSwgZXh0LCAgdHJ1ZSk7XFxuICAgICAgICAgICAgICAgICAgICB9LFxcblxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZDogZnVuY3Rpb24gKGlkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3AoZGVmaW5lZCwgbWFrZU1vZHVsZU1hcChpZCwgcmVsTWFwLCBmYWxzZSwgdHJ1ZSkuaWQpO1xcbiAgICAgICAgICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZDogZnVuY3Rpb24gKGlkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBtYWtlTW9kdWxlTWFwKGlkLCByZWxNYXAsIGZhbHNlLCB0cnVlKS5pZDtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzUHJvcChkZWZpbmVkLCBpZCkgfHwgaGFzUHJvcChyZWdpc3RyeSwgaWQpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgLy9Pbmx5IGFsbG93IHVuZGVmIG9uIHRvcCBsZXZlbCByZXF1aXJlIGNhbGxzXFxuICAgICAgICAgICAgICAgIGlmICghcmVsTWFwKSB7XFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFJlcXVpcmUudW5kZWYgPSBmdW5jdGlvbiAoaWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0JpbmQgYW55IHdhaXRpbmcgZGVmaW5lKCkgY2FsbHMgdG8gdGhpcyBjb250ZXh0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZml4IGZvciAjNDA4XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFrZUdsb2JhbFF1ZXVlKCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IG1ha2VNb2R1bGVNYXAoaWQsIHJlbE1hcCwgdHJ1ZSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZCA9IGdldE93bihyZWdpc3RyeSwgaWQpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVNjcmlwdChpZCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlZmluZWRbaWRdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB1cmxGZXRjaGVkW21hcC51cmxdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB1bmRlZkV2ZW50c1tpZF07XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9DbGVhbiBxdWV1ZWQgZGVmaW5lcyB0b28uIEdvIGJhY2t3YXJkc1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaW4gYXJyYXkgc28gdGhhdCB0aGUgc3BsaWNlcyBkbyBub3RcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21lc3MgdXAgdGhlIGl0ZXJhdGlvbi5cXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoUmV2ZXJzZShkZWZRdWV1ZSwgZnVuY3Rpb24oYXJncywgaSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhcmdzWzBdID09PSBpZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmUXVldWUuc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0hvbGQgb24gdG8gbGlzdGVuZXJzIGluIGNhc2UgdGhlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbW9kdWxlIHdpbGwgYmUgYXR0ZW1wdGVkIHRvIGJlIHJlbG9hZGVkXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXNpbmcgYSBkaWZmZXJlbnQgY29uZmlnLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kLmV2ZW50cy5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZkV2ZW50c1tpZF0gPSBtb2QuZXZlbnRzO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuUmVnaXN0cnkoaWQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsUmVxdWlyZTtcXG4gICAgICAgICAgICB9LFxcblxcbiAgICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgICAqIENhbGxlZCB0byBlbmFibGUgYSBtb2R1bGUgaWYgaXQgaXMgc3RpbGwgaW4gdGhlIHJlZ2lzdHJ5XFxuICAgICAgICAgICAgICogYXdhaXRpbmcgZW5hYmxlbWVudC4gQSBzZWNvbmQgYXJnLCBwYXJlbnQsIHRoZSBwYXJlbnQgbW9kdWxlLFxcbiAgICAgICAgICAgICAqIGlzIHBhc3NlZCBpbiBmb3IgY29udGV4dCwgd2hlbiB0aGlzIG1ldGhvZCBpcyBvdmVycmlkZGVuIGJ5XFxuICAgICAgICAgICAgICogdGhlIG9wdGltaXplci4gTm90IHNob3duIGhlcmUgdG8ga2VlcCBjb2RlIGNvbXBhY3QuXFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgZW5hYmxlOiBmdW5jdGlvbiAoZGVwTWFwKSB7XFxuICAgICAgICAgICAgICAgIHZhciBtb2QgPSBnZXRPd24ocmVnaXN0cnksIGRlcE1hcC5pZCk7XFxuICAgICAgICAgICAgICAgIGlmIChtb2QpIHtcXG4gICAgICAgICAgICAgICAgICAgIGdldE1vZHVsZShkZXBNYXApLmVuYWJsZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiBJbnRlcm5hbCBtZXRob2QgdXNlZCBieSBlbnZpcm9ubWVudCBhZGFwdGVycyB0byBjb21wbGV0ZSBhIGxvYWQgZXZlbnQuXFxuICAgICAgICAgICAgICogQSBsb2FkIGV2ZW50IGNvdWxkIGJlIGEgc2NyaXB0IGxvYWQgb3IganVzdCBhIGxvYWQgcGFzcyBmcm9tIGEgc3luY2hyb25vdXNcXG4gICAgICAgICAgICAgKiBsb2FkIGNhbGwuXFxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZU5hbWUgdGhlIG5hbWUgb2YgdGhlIG1vZHVsZSB0byBwb3RlbnRpYWxseSBjb21wbGV0ZS5cXG4gICAgICAgICAgICAgKi9cXG4gICAgICAgICAgICBjb21wbGV0ZUxvYWQ6IGZ1bmN0aW9uIChtb2R1bGVOYW1lKSB7XFxuICAgICAgICAgICAgICAgIHZhciBmb3VuZCwgYXJncywgbW9kLFxcbiAgICAgICAgICAgICAgICAgICAgc2hpbSA9IGdldE93bihjb25maWcuc2hpbSwgbW9kdWxlTmFtZSkgfHwge30sXFxuICAgICAgICAgICAgICAgICAgICBzaEV4cG9ydHMgPSBzaGltLmV4cG9ydHM7XFxuXFxuICAgICAgICAgICAgICAgIHRha2VHbG9iYWxRdWV1ZSgpO1xcblxcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGVmUXVldWUubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gZGVmUXVldWUuc2hpZnQoKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSBudWxsKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IG1vZHVsZU5hbWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBhbHJlYWR5IGZvdW5kIGFuIGFub255bW91cyBtb2R1bGUgYW5kIGJvdW5kIGl0XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy90byB0aGlzIG5hbWUsIHRoZW4gdGhpcyBpcyBzb21lIG90aGVyIGFub24gbW9kdWxlXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy93YWl0aW5nIGZvciBpdHMgY29tcGxldGVMb2FkIHRvIGZpcmUuXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3NbMF0gPT09IG1vZHVsZU5hbWUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0ZvdW5kIG1hdGNoaW5nIGRlZmluZSBjYWxsIGZvciB0aGlzIHNjcmlwdCFcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICBjYWxsR2V0TW9kdWxlKGFyZ3MpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vRG8gdGhpcyBhZnRlciB0aGUgY3ljbGUgb2YgY2FsbEdldE1vZHVsZSBpbiBjYXNlIHRoZSByZXN1bHRcXG4gICAgICAgICAgICAgICAgLy9vZiB0aG9zZSBjYWxscy9pbml0IGNhbGxzIGNoYW5nZXMgdGhlIHJlZ2lzdHJ5LlxcbiAgICAgICAgICAgICAgICBtb2QgPSBnZXRPd24ocmVnaXN0cnksIG1vZHVsZU5hbWUpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kICYmICFoYXNQcm9wKGRlZmluZWQsIG1vZHVsZU5hbWUpICYmIG1vZCAmJiAhbW9kLmluaXRlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5lbmZvcmNlRGVmaW5lICYmICghc2hFeHBvcnRzIHx8ICFnZXRHbG9iYWwoc2hFeHBvcnRzKSkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUGF0aEZhbGxiYWNrKG1vZHVsZU5hbWUpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25FcnJvcihtYWtlRXJyb3IoJ25vZGVmaW5lJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTm8gZGVmaW5lIGNhbGwgZm9yICcgKyBtb2R1bGVOYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW21vZHVsZU5hbWVdKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0Egc2NyaXB0IHRoYXQgZG9lcyBub3QgY2FsbCBkZWZpbmUoKSwgc28ganVzdCBzaW11bGF0ZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGNhbGwgZm9yIGl0LlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxHZXRNb2R1bGUoW21vZHVsZU5hbWUsIChzaGltLmRlcHMgfHwgW10pLCBzaGltLmV4cG9ydHNGbl0pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGNoZWNrTG9hZGVkKCk7XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBhIG1vZHVsZSBuYW1lIHRvIGEgZmlsZSBwYXRoLiBTdXBwb3J0cyBjYXNlcyB3aGVyZVxcbiAgICAgICAgICAgICAqIG1vZHVsZU5hbWUgbWF5IGFjdHVhbGx5IGJlIGp1c3QgYW4gVVJMLlxcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCBpdCAqKmRvZXMgbm90KiogY2FsbCBub3JtYWxpemUgb24gdGhlIG1vZHVsZU5hbWUsXFxuICAgICAgICAgICAgICogaXQgaXMgYXNzdW1lZCB0byBoYXZlIGFscmVhZHkgYmVlbiBub3JtYWxpemVkLiBUaGlzIGlzIGFuXFxuICAgICAgICAgICAgICogaW50ZXJuYWwgQVBJLCBub3QgYSBwdWJsaWMgb25lLiBVc2UgdG9VcmwgZm9yIHRoZSBwdWJsaWMgQVBJLlxcbiAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIG5hbWVUb1VybDogZnVuY3Rpb24gKG1vZHVsZU5hbWUsIGV4dCwgc2tpcEV4dCkge1xcbiAgICAgICAgICAgICAgICB2YXIgcGF0aHMsIHN5bXMsIGksIHBhcmVudE1vZHVsZSwgdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UGF0aCwgYnVuZGxlSWQsXFxuICAgICAgICAgICAgICAgICAgICBwa2dNYWluID0gZ2V0T3duKGNvbmZpZy5wa2dzLCBtb2R1bGVOYW1lKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHBrZ01haW4pIHtcXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWUgPSBwa2dNYWluO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGJ1bmRsZUlkID0gZ2V0T3duKGJ1bmRsZXNNYXAsIG1vZHVsZU5hbWUpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoYnVuZGxlSWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0Lm5hbWVUb1VybChidW5kbGVJZCwgZXh0LCBza2lwRXh0KTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAvL0lmIGEgY29sb24gaXMgaW4gdGhlIFVSTCwgaXQgaW5kaWNhdGVzIGEgcHJvdG9jb2wgaXMgdXNlZCBhbmQgaXQgaXMganVzdFxcbiAgICAgICAgICAgICAgICAvL2FuIFVSTCB0byBhIGZpbGUsIG9yIGlmIGl0IHN0YXJ0cyB3aXRoIGEgc2xhc2gsIGNvbnRhaW5zIGEgcXVlcnkgYXJnIChpLmUuID8pXFxuICAgICAgICAgICAgICAgIC8vb3IgZW5kcyB3aXRoIC5qcywgdGhlbiBhc3N1bWUgdGhlIHVzZXIgbWVhbnQgdG8gdXNlIGFuIHVybCBhbmQgbm90IGEgbW9kdWxlIGlkLlxcbiAgICAgICAgICAgICAgICAvL1RoZSBzbGFzaCBpcyBpbXBvcnRhbnQgZm9yIHByb3RvY29sLWxlc3MgVVJMcyBhcyB3ZWxsIGFzIGZ1bGwgcGF0aHMuXFxuICAgICAgICAgICAgICAgIGlmIChyZXEuanNFeHRSZWdFeHAudGVzdChtb2R1bGVOYW1lKSkge1xcbiAgICAgICAgICAgICAgICAgICAgLy9KdXN0IGEgcGxhaW4gcGF0aCwgbm90IG1vZHVsZSBuYW1lIGxvb2t1cCwgc28ganVzdCByZXR1cm4gaXQuXFxuICAgICAgICAgICAgICAgICAgICAvL0FkZCBleHRlbnNpb24gaWYgaXQgaXMgaW5jbHVkZWQuIFRoaXMgaXMgYSBiaXQgd29ua3ksIG9ubHkgbm9uLS5qcyB0aGluZ3MgcGFzc1xcbiAgICAgICAgICAgICAgICAgICAgLy9hbiBleHRlbnNpb24sIHRoaXMgbWV0aG9kIHByb2JhYmx5IG5lZWRzIHRvIGJlIHJld29ya2VkLlxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gbW9kdWxlTmFtZSArIChleHQgfHwgJycpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgLy9BIG1vZHVsZSB0aGF0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHBhdGguXFxuICAgICAgICAgICAgICAgICAgICBwYXRocyA9IGNvbmZpZy5wYXRocztcXG5cXG4gICAgICAgICAgICAgICAgICAgIHN5bXMgPSBtb2R1bGVOYW1lLnNwbGl0KCcvJyk7XFxuICAgICAgICAgICAgICAgICAgICAvL0ZvciBlYWNoIG1vZHVsZSBuYW1lIHNlZ21lbnQsIHNlZSBpZiB0aGVyZSBpcyBhIHBhdGhcXG4gICAgICAgICAgICAgICAgICAgIC8vcmVnaXN0ZXJlZCBmb3IgaXQuIFN0YXJ0IHdpdGggbW9zdCBzcGVjaWZpYyBuYW1lXFxuICAgICAgICAgICAgICAgICAgICAvL2FuZCB3b3JrIHVwIGZyb20gaXQuXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBzeW1zLmxlbmd0aDsgaSA+IDA7IGkgLT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE1vZHVsZSA9IHN5bXMuc2xpY2UoMCwgaSkuam9pbignLycpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFBhdGggPSBnZXRPd24ocGF0aHMsIHBhcmVudE1vZHVsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFBhdGgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBhbiBhcnJheSwgaXQgbWVhbnMgdGhlcmUgYXJlIGEgZmV3IGNob2ljZXMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQ2hvb3NlIHRoZSBvbmUgdGhhdCBpcyBkZXNpcmVkXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHBhcmVudFBhdGgpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRQYXRoID0gcGFyZW50UGF0aFswXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1zLnNwbGljZSgwLCBpLCBwYXJlbnRQYXRoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgLy9Kb2luIHRoZSBwYXRoIHBhcnRzIHRvZ2V0aGVyLCB0aGVuIGZpZ3VyZSBvdXQgaWYgYmFzZVVybCBpcyBuZWVkZWQuXFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBzeW1zLmpvaW4oJy8nKTtcXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAoZXh0IHx8ICgvXmRhdGFcXFxcOnxcXFxcPy8udGVzdCh1cmwpIHx8IHNraXBFeHQgPyAnJyA6ICcuanMnKSk7XFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSAodXJsLmNoYXJBdCgwKSA9PT0gJy8nIHx8IHVybC5tYXRjaCgvXltcXFxcd1xcXFwrXFxcXC5cXFxcLV0rOi8pID8gJycgOiBjb25maWcuYmFzZVVybCkgKyB1cmw7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy51cmxBcmdzID8gdXJsICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVybEFyZ3MpIDogdXJsO1xcbiAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgLy9EZWxlZ2F0ZXMgdG8gcmVxLmxvYWQuIEJyb2tlbiBvdXQgYXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiB0b1xcbiAgICAgICAgICAgIC8vYWxsb3cgb3ZlcnJpZGluZyBpbiB0aGUgb3B0aW1pemVyLlxcbiAgICAgICAgICAgIGxvYWQ6IGZ1bmN0aW9uIChpZCwgdXJsKSB7XFxuICAgICAgICAgICAgICAgIHJlcS5sb2FkKGNvbnRleHQsIGlkLCB1cmwpO1xcbiAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICogRXhlY3V0ZXMgYSBtb2R1bGUgY2FsbGJhY2sgZnVuY3Rpb24uIEJyb2tlbiBvdXQgYXMgYSBzZXBhcmF0ZSBmdW5jdGlvblxcbiAgICAgICAgICAgICAqIHNvbGVseSB0byBhbGxvdyB0aGUgYnVpbGQgc3lzdGVtIHRvIHNlcXVlbmNlIHRoZSBmaWxlcyBpbiB0aGUgYnVpbHRcXG4gICAgICAgICAgICAgKiBsYXllciBpbiB0aGUgcmlnaHQgc2VxdWVuY2UuXFxuICAgICAgICAgICAgICpcXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIGV4ZWNDYjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBhcmdzLCBleHBvcnRzKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShleHBvcnRzLCBhcmdzKTtcXG4gICAgICAgICAgICB9LFxcblxcbiAgICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgICAqIGNhbGxiYWNrIGZvciBzY3JpcHQgbG9hZHMsIHVzZWQgdG8gY2hlY2sgc3RhdHVzIG9mIGxvYWRpbmcuXFxuICAgICAgICAgICAgICpcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldnQgdGhlIGV2ZW50IGZyb20gdGhlIGJyb3dzZXIgZm9yIHRoZSBzY3JpcHRcXG4gICAgICAgICAgICAgKiB0aGF0IHdhcyBsb2FkZWQuXFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgb25TY3JpcHRMb2FkOiBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICAgICAgICAgIC8vVXNpbmcgY3VycmVudFRhcmdldCBpbnN0ZWFkIG9mIHRhcmdldCBmb3IgRmlyZWZveCAyLjAncyBzYWtlLiBOb3RcXG4gICAgICAgICAgICAgICAgLy9hbGwgb2xkIGJyb3dzZXJzIHdpbGwgYmUgc3VwcG9ydGVkLCBidXQgdGhpcyBvbmUgd2FzIGVhc3kgZW5vdWdoXFxuICAgICAgICAgICAgICAgIC8vdG8gc3VwcG9ydCBhbmQgc3RpbGwgbWFrZXMgc2Vuc2UuXFxuICAgICAgICAgICAgICAgIGlmIChldnQudHlwZSA9PT0gJ2xvYWQnIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlYWR5UmVnRXhwLnRlc3QoKGV2dC5jdXJyZW50VGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50KS5yZWFkeVN0YXRlKSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vUmVzZXQgaW50ZXJhY3RpdmUgc2NyaXB0IHNvIGEgc2NyaXB0IG5vZGUgaXMgbm90IGhlbGQgb250byBmb3JcXG4gICAgICAgICAgICAgICAgICAgIC8vdG8gbG9uZy5cXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlU2NyaXB0ID0gbnVsbDtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vUHVsbCBvdXQgdGhlIG5hbWUgb2YgdGhlIG1vZHVsZSBhbmQgdGhlIGNvbnRleHQuXFxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGdldFNjcmlwdERhdGEoZXZ0KTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcGxldGVMb2FkKGRhdGEuaWQpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiBDYWxsYmFjayBmb3Igc2NyaXB0IGVycm9ycy5cXG4gICAgICAgICAgICAgKi9cXG4gICAgICAgICAgICBvblNjcmlwdEVycm9yOiBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZ2V0U2NyaXB0RGF0YShldnQpO1xcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1BhdGhGYWxsYmFjayhkYXRhLmlkKSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IobWFrZUVycm9yKCdzY3JpcHRlcnJvcicsICdTY3JpcHQgZXJyb3IgZm9yOiAnICsgZGF0YS5pZCwgZXZ0LCBbZGF0YS5pZF0pKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBjb250ZXh0LnJlcXVpcmUgPSBjb250ZXh0Lm1ha2VSZXF1aXJlKCk7XFxuICAgICAgICByZXR1cm4gY29udGV4dDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogTWFpbiBlbnRyeSBwb2ludC5cXG4gICAgICpcXG4gICAgICogSWYgdGhlIG9ubHkgYXJndW1lbnQgdG8gcmVxdWlyZSBpcyBhIHN0cmluZywgdGhlbiB0aGUgbW9kdWxlIHRoYXRcXG4gICAgICogaXMgcmVwcmVzZW50ZWQgYnkgdGhhdCBzdHJpbmcgaXMgZmV0Y2hlZCBmb3IgdGhlIGFwcHJvcHJpYXRlIGNvbnRleHQuXFxuICAgICAqXFxuICAgICAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSwgdGhlbiBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYW4gYXJyYXlcXG4gICAgICogb2YgZGVwZW5kZW5jeSBzdHJpbmcgbmFtZXMgdG8gZmV0Y2guIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIGNhbGxiYWNrIGNhblxcbiAgICAgKiBiZSBzcGVjaWZpZWQgdG8gZXhlY3V0ZSB3aGVuIGFsbCBvZiB0aG9zZSBkZXBlbmRlbmNpZXMgYXJlIGF2YWlsYWJsZS5cXG4gICAgICpcXG4gICAgICogTWFrZSBhIGxvY2FsIHJlcSB2YXJpYWJsZSB0byBoZWxwIENhamEgY29tcGxpYW5jZSAoaXQgYXNzdW1lcyB0aGluZ3NcXG4gICAgICogb24gYSByZXF1aXJlIHRoYXQgYXJlIG5vdCBzdGFuZGFyZGl6ZWQpLCBhbmQgdG8gZ2l2ZSBhIHNob3J0XFxuICAgICAqIG5hbWUgZm9yIG1pbmlmaWNhdGlvbi9sb2NhbCBzY29wZSB1c2UuXFxuICAgICAqL1xcbiAgICByZXEgPSByZXF1aXJlanMgPSBmdW5jdGlvbiAoZGVwcywgY2FsbGJhY2ssIGVycmJhY2ssIG9wdGlvbmFsKSB7XFxuXFxuICAgICAgICAvL0ZpbmQgdGhlIHJpZ2h0IGNvbnRleHQsIHVzZSBkZWZhdWx0XFxuICAgICAgICB2YXIgY29udGV4dCwgY29uZmlnLFxcbiAgICAgICAgICAgIGNvbnRleHROYW1lID0gZGVmQ29udGV4dE5hbWU7XFxuXFxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgaGF2ZSBjb25maWcgb2JqZWN0IGluIHRoZSBjYWxsLlxcbiAgICAgICAgaWYgKCFpc0FycmF5KGRlcHMpICYmIHR5cGVvZiBkZXBzICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICAgIC8vIGRlcHMgaXMgYSBjb25maWcgb2JqZWN0XFxuICAgICAgICAgICAgY29uZmlnID0gZGVwcztcXG4gICAgICAgICAgICBpZiAoaXNBcnJheShjYWxsYmFjaykpIHtcXG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IGFyZ3MgaWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llc1xcbiAgICAgICAgICAgICAgICBkZXBzID0gY2FsbGJhY2s7XFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyYmFjaztcXG4gICAgICAgICAgICAgICAgZXJyYmFjayA9IG9wdGlvbmFsO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGRlcHMgPSBbXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5jb250ZXh0KSB7XFxuICAgICAgICAgICAgY29udGV4dE5hbWUgPSBjb25maWcuY29udGV4dDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnRleHQgPSBnZXRPd24oY29udGV4dHMsIGNvbnRleHROYW1lKTtcXG4gICAgICAgIGlmICghY29udGV4dCkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0c1tjb250ZXh0TmFtZV0gPSByZXEucy5uZXdDb250ZXh0KGNvbnRleHROYW1lKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjb25maWcpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmNvbmZpZ3VyZShjb25maWcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmVxdWlyZShkZXBzLCBjYWxsYmFjaywgZXJyYmFjayk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBTdXBwb3J0IHJlcXVpcmUuY29uZmlnKCkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gY29vcGVyYXRlIHdpdGggb3RoZXJcXG4gICAgICogQU1EIGxvYWRlcnMgb24gZ2xvYmFsbHkgYWdyZWVkIG5hbWVzLlxcbiAgICAgKi9cXG4gICAgcmVxLmNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcXG4gICAgICAgIHJldHVybiByZXEoY29uZmlnKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgc29tZXRoaW5nIGFmdGVyIHRoZSBjdXJyZW50IHRpY2tcXG4gICAgICogb2YgdGhlIGV2ZW50IGxvb3AuIE92ZXJyaWRlIGZvciBvdGhlciBlbnZzXFxuICAgICAqIHRoYXQgaGF2ZSBhIGJldHRlciBzb2x1dGlvbiB0aGFuIHNldFRpbWVvdXQuXFxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiBmdW5jdGlvbiB0byBleGVjdXRlIGxhdGVyLlxcbiAgICAgKi9cXG4gICAgcmVxLm5leHRUaWNrID0gdHlwZW9mIHNldFRpbWVvdXQgIT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24gKGZuKSB7XFxuICAgICAgICBzZXRUaW1lb3V0KGZuLCA0KTtcXG4gICAgfSA6IGZ1bmN0aW9uIChmbikgeyBmbigpOyB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhwb3J0IHJlcXVpcmUgYXMgYSBnbG9iYWwsIGJ1dCBvbmx5IGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXFxuICAgICAqL1xcbiAgICBpZiAoIXJlcXVpcmUpIHtcXG4gICAgICAgIHJlcXVpcmUgPSByZXE7XFxuICAgIH1cXG5cXG4gICAgcmVxLnZlcnNpb24gPSB2ZXJzaW9uO1xcblxcbiAgICAvL1VzZWQgdG8gZmlsdGVyIG91dCBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgYWxyZWFkeSBwYXRocy5cXG4gICAgcmVxLmpzRXh0UmVnRXhwID0gL15cXFxcL3w6fFxcXFw/fFxcXFwuanMkLztcXG4gICAgcmVxLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcXG4gICAgcyA9IHJlcS5zID0ge1xcbiAgICAgICAgY29udGV4dHM6IGNvbnRleHRzLFxcbiAgICAgICAgbmV3Q29udGV4dDogbmV3Q29udGV4dFxcbiAgICB9O1xcblxcbiAgICAvL0NyZWF0ZSBkZWZhdWx0IGNvbnRleHQuXFxuICAgIHJlcSh7fSk7XFxuXFxuICAgIC8vRXhwb3J0cyBzb21lIGNvbnRleHQtc2Vuc2l0aXZlIG1ldGhvZHMgb24gZ2xvYmFsIHJlcXVpcmUuXFxuICAgIGVhY2goW1xcbiAgICAgICAgJ3RvVXJsJyxcXG4gICAgICAgICd1bmRlZicsXFxuICAgICAgICAnZGVmaW5lZCcsXFxuICAgICAgICAnc3BlY2lmaWVkJ1xcbiAgICBdLCBmdW5jdGlvbiAocHJvcCkge1xcbiAgICAgICAgLy9SZWZlcmVuY2UgZnJvbSBjb250ZXh0cyBpbnN0ZWFkIG9mIGVhcmx5IGJpbmRpbmcgdG8gZGVmYXVsdCBjb250ZXh0LFxcbiAgICAgICAgLy9zbyB0aGF0IGR1cmluZyBidWlsZHMsIHRoZSBsYXRlc3QgaW5zdGFuY2Ugb2YgdGhlIGRlZmF1bHQgY29udGV4dFxcbiAgICAgICAgLy93aXRoIGl0cyBjb25maWcgZ2V0cyB1c2VkLlxcbiAgICAgICAgcmVxW3Byb3BdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0c1tkZWZDb250ZXh0TmFtZV07XFxuICAgICAgICAgICAgcmV0dXJuIGN0eC5yZXF1aXJlW3Byb3BdLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcXG4gICAgICAgIH07XFxuICAgIH0pO1xcblxcbiAgICBpZiAoaXNCcm93c2VyKSB7XFxuICAgICAgICBoZWFkID0gcy5oZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcXG4gICAgICAgIC8vSWYgQkFTRSB0YWcgaXMgaW4gcGxheSwgdXNpbmcgYXBwZW5kQ2hpbGQgaXMgYSBwcm9ibGVtIGZvciBJRTYuXFxuICAgICAgICAvL1doZW4gdGhhdCBicm93c2VyIGRpZXMsIHRoaXMgY2FuIGJlIHJlbW92ZWQuIERldGFpbHMgaW4gdGhpcyBqUXVlcnkgYnVnOlxcbiAgICAgICAgLy9odHRwOi8vZGV2LmpxdWVyeS5jb20vdGlja2V0LzI3MDlcXG4gICAgICAgIGJhc2VFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKVswXTtcXG4gICAgICAgIGlmIChiYXNlRWxlbWVudCkge1xcbiAgICAgICAgICAgIGhlYWQgPSBzLmhlYWQgPSBiYXNlRWxlbWVudC5wYXJlbnROb2RlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBbnkgZXJyb3JzIHRoYXQgcmVxdWlyZSBleHBsaWNpdGx5IGdlbmVyYXRlcyB3aWxsIGJlIHBhc3NlZCB0byB0aGlzXFxuICAgICAqIGZ1bmN0aW9uLiBJbnRlcmNlcHQvb3ZlcnJpZGUgaXQgaWYgeW91IHdhbnQgY3VzdG9tIGVycm9yIGhhbmRsaW5nLlxcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdC5cXG4gICAgICovXFxuICAgIHJlcS5vbkVycm9yID0gZGVmYXVsdE9uRXJyb3I7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIHRoZSBub2RlIGZvciB0aGUgbG9hZCBjb21tYW5kLiBPbmx5IHVzZWQgaW4gYnJvd3NlciBlbnZzLlxcbiAgICAgKi9cXG4gICAgcmVxLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoY29uZmlnLCBtb2R1bGVOYW1lLCB1cmwpIHtcXG4gICAgICAgIHZhciBub2RlID0gY29uZmlnLnhodG1sID9cXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2h0bWw6c2NyaXB0JykgOlxcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcXG4gICAgICAgIG5vZGUudHlwZSA9IGNvbmZpZy5zY3JpcHRUeXBlIHx8ICd0ZXh0L2phdmFzY3JpcHQnO1xcbiAgICAgICAgbm9kZS5jaGFyc2V0ID0gJ3V0Zi04JztcXG4gICAgICAgIG5vZGUuYXN5bmMgPSB0cnVlO1xcbiAgICAgICAgcmV0dXJuIG5vZGU7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEb2VzIHRoZSByZXF1ZXN0IHRvIGxvYWQgYSBtb2R1bGUgZm9yIHRoZSBicm93c2VyIGNhc2UuXFxuICAgICAqIE1ha2UgdGhpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGFsbG93IG90aGVyIGVudmlyb25tZW50c1xcbiAgICAgKiB0byBvdmVycmlkZSBpdC5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgdGhlIHJlcXVpcmUgY29udGV4dCB0byBmaW5kIHN0YXRlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kdWxlTmFtZSB0aGUgbmFtZSBvZiB0aGUgbW9kdWxlLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXJsIHRoZSBVUkwgdG8gdGhlIG1vZHVsZS5cXG4gICAgICovXFxuICAgIHJlcS5sb2FkID0gZnVuY3Rpb24gKGNvbnRleHQsIG1vZHVsZU5hbWUsIHVybCkge1xcbiAgICAgICAgdmFyIGNvbmZpZyA9IChjb250ZXh0ICYmIGNvbnRleHQuY29uZmlnKSB8fCB7fSxcXG4gICAgICAgICAgICBub2RlO1xcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xcbiAgICAgICAgICAgIC8vSW4gdGhlIGJyb3dzZXIgc28gdXNlIGEgc2NyaXB0IHRhZ1xcbiAgICAgICAgICAgIG5vZGUgPSByZXEuY3JlYXRlTm9kZShjb25maWcsIG1vZHVsZU5hbWUsIHVybCk7XFxuXFxuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmVxdWlyZWNvbnRleHQnLCBjb250ZXh0LmNvbnRleHROYW1lKTtcXG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1yZXF1aXJlbW9kdWxlJywgbW9kdWxlTmFtZSk7XFxuXFxuICAgICAgICAgICAgLy9TZXQgdXAgbG9hZCBsaXN0ZW5lci4gVGVzdCBhdHRhY2hFdmVudCBmaXJzdCBiZWNhdXNlIElFOSBoYXNcXG4gICAgICAgICAgICAvL2Egc3VidGxlIGlzc3VlIGluIGl0cyBhZGRFdmVudExpc3RlbmVyIGFuZCBzY3JpcHQgb25sb2FkIGZpcmluZ3NcXG4gICAgICAgICAgICAvL3RoYXQgZG8gbm90IG1hdGNoIHRoZSBiZWhhdmlvciBvZiBhbGwgb3RoZXIgYnJvd3NlcnMgd2l0aFxcbiAgICAgICAgICAgIC8vYWRkRXZlbnRMaXN0ZW5lciBzdXBwb3J0LCB3aGljaCBmaXJlIHRoZSBvbmxvYWQgZXZlbnQgZm9yIGFcXG4gICAgICAgICAgICAvL3NjcmlwdCByaWdodCBhZnRlciB0aGUgc2NyaXB0IGV4ZWN1dGlvbi4gU2VlOlxcbiAgICAgICAgICAgIC8vaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy82NDgwNTcvc2NyaXB0LW9ubG9hZC1ldmVudC1pcy1ub3QtZmlyZWQtaW1tZWRpYXRlbHktYWZ0ZXItc2NyaXB0LWV4ZWN1dGlvblxcbiAgICAgICAgICAgIC8vVU5GT1JUVU5BVEVMWSBPcGVyYSBpbXBsZW1lbnRzIGF0dGFjaEV2ZW50IGJ1dCBkb2VzIG5vdCBmb2xsb3cgdGhlIHNjcmlwdFxcbiAgICAgICAgICAgIC8vc2NyaXB0IGV4ZWN1dGlvbiBtb2RlLlxcbiAgICAgICAgICAgIGlmIChub2RlLmF0dGFjaEV2ZW50ICYmXFxuICAgICAgICAgICAgICAgICAgICAvL0NoZWNrIGlmIG5vZGUuYXR0YWNoRXZlbnQgaXMgYXJ0aWZpY2lhbGx5IGFkZGVkIGJ5IGN1c3RvbSBzY3JpcHQgb3JcXG4gICAgICAgICAgICAgICAgICAgIC8vbmF0aXZlbHkgc3VwcG9ydGVkIGJ5IGJyb3dzZXJcXG4gICAgICAgICAgICAgICAgICAgIC8vcmVhZCBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvaXNzdWVzLzE4N1xcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBjYW4gTk9UIGZpbmQgW25hdGl2ZSBjb2RlXSB0aGVuIGl0IG11c3QgTk9UIG5hdGl2ZWx5IHN1cHBvcnRlZC5cXG4gICAgICAgICAgICAgICAgICAgIC8vaW4gSUU4LCBub2RlLmF0dGFjaEV2ZW50IGRvZXMgbm90IGhhdmUgdG9TdHJpbmcoKVxcbiAgICAgICAgICAgICAgICAgICAgLy9Ob3RlIHRoZSB0ZXN0IGZvciBcXFwiW25hdGl2ZSBjb2RlXFxcIiB3aXRoIG5vIGNsb3NpbmcgYnJhY2UsIHNlZTpcXG4gICAgICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL2lzc3Vlcy8yNzNcXG4gICAgICAgICAgICAgICAgICAgICEobm9kZS5hdHRhY2hFdmVudC50b1N0cmluZyAmJiBub2RlLmF0dGFjaEV2ZW50LnRvU3RyaW5nKCkuaW5kZXhPZignW25hdGl2ZSBjb2RlJykgPCAwKSAmJlxcbiAgICAgICAgICAgICAgICAgICAgIWlzT3BlcmEpIHtcXG4gICAgICAgICAgICAgICAgLy9Qcm9iYWJseSBJRS4gSUUgKGF0IGxlYXN0IDYtOCkgZG8gbm90IGZpcmVcXG4gICAgICAgICAgICAgICAgLy9zY3JpcHQgb25sb2FkIHJpZ2h0IGFmdGVyIGV4ZWN1dGluZyB0aGUgc2NyaXB0LCBzb1xcbiAgICAgICAgICAgICAgICAvL3dlIGNhbm5vdCB0aWUgdGhlIGFub255bW91cyBkZWZpbmUgY2FsbCB0byBhIG5hbWUuXFxuICAgICAgICAgICAgICAgIC8vSG93ZXZlciwgSUUgcmVwb3J0cyB0aGUgc2NyaXB0IGFzIGJlaW5nIGluICdpbnRlcmFjdGl2ZSdcXG4gICAgICAgICAgICAgICAgLy9yZWFkeVN0YXRlIGF0IHRoZSB0aW1lIG9mIHRoZSBkZWZpbmUgY2FsbC5cXG4gICAgICAgICAgICAgICAgdXNlSW50ZXJhY3RpdmUgPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgICBub2RlLmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBjb250ZXh0Lm9uU2NyaXB0TG9hZCk7XFxuICAgICAgICAgICAgICAgIC8vSXQgd291bGQgYmUgZ3JlYXQgdG8gYWRkIGFuIGVycm9yIGhhbmRsZXIgaGVyZSB0byBjYXRjaFxcbiAgICAgICAgICAgICAgICAvLzQwNHMgaW4gSUU5Ky4gSG93ZXZlciwgb25yZWFkeXN0YXRlY2hhbmdlIHdpbGwgZmlyZSBiZWZvcmVcXG4gICAgICAgICAgICAgICAgLy90aGUgZXJyb3IgaGFuZGxlciwgc28gdGhhdCBkb2VzIG5vdCBoZWxwLiBJZiBhZGRFdmVudExpc3RlbmVyXFxuICAgICAgICAgICAgICAgIC8vaXMgdXNlZCwgdGhlbiBJRSB3aWxsIGZpcmUgZXJyb3IgYmVmb3JlIGxvYWQsIGJ1dCB3ZSBjYW5ub3RcXG4gICAgICAgICAgICAgICAgLy91c2UgdGhhdCBwYXRod2F5IGdpdmVuIHRoZSBjb25uZWN0Lm1pY3Jvc29mdC5jb20gaXNzdWVcXG4gICAgICAgICAgICAgICAgLy9tZW50aW9uZWQgYWJvdmUgYWJvdXQgbm90IGRvaW5nIHRoZSAnc2NyaXB0IGV4ZWN1dGUsXFxuICAgICAgICAgICAgICAgIC8vdGhlbiBmaXJlIHRoZSBzY3JpcHQgbG9hZCBldmVudCBsaXN0ZW5lciBiZWZvcmUgZXhlY3V0ZVxcbiAgICAgICAgICAgICAgICAvL25leHQgc2NyaXB0JyB0aGF0IG90aGVyIGJyb3dzZXJzIGRvLlxcbiAgICAgICAgICAgICAgICAvL0Jlc3QgaG9wZTogSUUxMCBmaXhlcyB0aGUgaXNzdWVzLFxcbiAgICAgICAgICAgICAgICAvL2FuZCB0aGVuIGRlc3Ryb3lzIGFsbCBpbnN0YWxscyBvZiBJRSA2LTkuXFxuICAgICAgICAgICAgICAgIC8vbm9kZS5hdHRhY2hFdmVudCgnb25lcnJvcicsIGNvbnRleHQub25TY3JpcHRFcnJvcik7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY29udGV4dC5vblNjcmlwdExvYWQsIGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGNvbnRleHQub25TY3JpcHRFcnJvciwgZmFsc2UpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBub2RlLnNyYyA9IHVybDtcXG5cXG4gICAgICAgICAgICAvL0ZvciBzb21lIGNhY2hlIGNhc2VzIGluIElFIDYtOCwgdGhlIHNjcmlwdCBleGVjdXRlcyBiZWZvcmUgdGhlIGVuZFxcbiAgICAgICAgICAgIC8vb2YgdGhlIGFwcGVuZENoaWxkIGV4ZWN1dGlvbiwgc28gdG8gdGllIGFuIGFub255bW91cyBkZWZpbmVcXG4gICAgICAgICAgICAvL2NhbGwgdG8gdGhlIG1vZHVsZSBuYW1lICh3aGljaCBpcyBzdG9yZWQgb24gdGhlIG5vZGUpLCBob2xkIG9uXFxuICAgICAgICAgICAgLy90byBhIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUsIGJ1dCBjbGVhciBhZnRlciB0aGUgRE9NIGluc2VydGlvbi5cXG4gICAgICAgICAgICBjdXJyZW50bHlBZGRpbmdTY3JpcHQgPSBub2RlO1xcbiAgICAgICAgICAgIGlmIChiYXNlRWxlbWVudCkge1xcbiAgICAgICAgICAgICAgICBoZWFkLmluc2VydEJlZm9yZShub2RlLCBiYXNlRWxlbWVudCk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChub2RlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY3VycmVudGx5QWRkaW5nU2NyaXB0ID0gbnVsbDtcXG5cXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcXG4gICAgICAgIH0gZWxzZSBpZiAoaXNXZWJXb3JrZXIpIHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAvL0luIGEgd2ViIHdvcmtlciwgdXNlIGltcG9ydFNjcmlwdHMuIFRoaXMgaXMgbm90IGEgdmVyeVxcbiAgICAgICAgICAgICAgICAvL2VmZmljaWVudCB1c2Ugb2YgaW1wb3J0U2NyaXB0cywgaW1wb3J0U2NyaXB0cyB3aWxsIGJsb2NrIHVudGlsXFxuICAgICAgICAgICAgICAgIC8vaXRzIHNjcmlwdCBpcyBkb3dubG9hZGVkIGFuZCBldmFsdWF0ZWQuIEhvd2V2ZXIsIGlmIHdlYiB3b3JrZXJzXFxuICAgICAgICAgICAgICAgIC8vYXJlIGluIHBsYXksIHRoZSBleHBlY3RhdGlvbiB0aGF0IGEgYnVpbGQgaGFzIGJlZW4gZG9uZSBzbyB0aGF0XFxuICAgICAgICAgICAgICAgIC8vb25seSBvbmUgc2NyaXB0IG5lZWRzIHRvIGJlIGxvYWRlZCBhbnl3YXkuIFRoaXMgbWF5IG5lZWQgdG8gYmVcXG4gICAgICAgICAgICAgICAgLy9yZWV2YWx1YXRlZCBpZiBvdGhlciB1c2UgY2FzZXMgYmVjb21lIGNvbW1vbi5cXG4gICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyh1cmwpO1xcblxcbiAgICAgICAgICAgICAgICAvL0FjY291bnQgZm9yIGFub255bW91cyBtb2R1bGVzXFxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcGxldGVMb2FkKG1vZHVsZU5hbWUpO1xcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKG1ha2VFcnJvcignaW1wb3J0c2NyaXB0cycsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW1wb3J0U2NyaXB0cyBmYWlsZWQgZm9yICcgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWUgKyAnIGF0ICcgKyB1cmwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW21vZHVsZU5hbWVdKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBnZXRJbnRlcmFjdGl2ZVNjcmlwdCgpIHtcXG4gICAgICAgIGlmIChpbnRlcmFjdGl2ZVNjcmlwdCAmJiBpbnRlcmFjdGl2ZVNjcmlwdC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGludGVyYWN0aXZlU2NyaXB0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZWFjaFJldmVyc2Uoc2NyaXB0cygpLCBmdW5jdGlvbiAoc2NyaXB0KSB7XFxuICAgICAgICAgICAgaWYgKHNjcmlwdC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAoaW50ZXJhY3RpdmVTY3JpcHQgPSBzY3JpcHQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIGludGVyYWN0aXZlU2NyaXB0O1xcbiAgICB9XFxuXFxuICAgIC8vTG9vayBmb3IgYSBkYXRhLW1haW4gc2NyaXB0IGF0dHJpYnV0ZSwgd2hpY2ggY291bGQgYWxzbyBhZGp1c3QgdGhlIGJhc2VVcmwuXFxuICAgIGlmIChpc0Jyb3dzZXIgJiYgIWNmZy5za2lwRGF0YU1haW4pIHtcXG4gICAgICAgIC8vRmlndXJlIG91dCBiYXNlVXJsLiBHZXQgaXQgZnJvbSB0aGUgc2NyaXB0IHRhZyB3aXRoIHJlcXVpcmUuanMgaW4gaXQuXFxuICAgICAgICBlYWNoUmV2ZXJzZShzY3JpcHRzKCksIGZ1bmN0aW9uIChzY3JpcHQpIHtcXG4gICAgICAgICAgICAvL1NldCB0aGUgJ2hlYWQnIHdoZXJlIHdlIGNhbiBhcHBlbmQgY2hpbGRyZW4gYnlcXG4gICAgICAgICAgICAvL3VzaW5nIHRoZSBzY3JpcHQncyBwYXJlbnQuXFxuICAgICAgICAgICAgaWYgKCFoZWFkKSB7XFxuICAgICAgICAgICAgICAgIGhlYWQgPSBzY3JpcHQucGFyZW50Tm9kZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9Mb29rIGZvciBhIGRhdGEtbWFpbiBhdHRyaWJ1dGUgdG8gc2V0IG1haW4gc2NyaXB0IGZvciB0aGUgcGFnZVxcbiAgICAgICAgICAgIC8vdG8gbG9hZC4gSWYgaXQgaXMgdGhlcmUsIHRoZSBwYXRoIHRvIGRhdGEgbWFpbiBiZWNvbWVzIHRoZVxcbiAgICAgICAgICAgIC8vYmFzZVVybCwgaWYgaXQgaXMgbm90IGFscmVhZHkgc2V0LlxcbiAgICAgICAgICAgIGRhdGFNYWluID0gc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1tYWluJyk7XFxuICAgICAgICAgICAgaWYgKGRhdGFNYWluKSB7XFxuICAgICAgICAgICAgICAgIC8vUHJlc2VydmUgZGF0YU1haW4gaW4gY2FzZSBpdCBpcyBhIHBhdGggKGkuZS4gY29udGFpbnMgJz8nKVxcbiAgICAgICAgICAgICAgICBtYWluU2NyaXB0ID0gZGF0YU1haW47XFxuXFxuICAgICAgICAgICAgICAgIC8vU2V0IGZpbmFsIGJhc2VVcmwgaWYgdGhlcmUgaXMgbm90IGFscmVhZHkgYW4gZXhwbGljaXQgb25lLlxcbiAgICAgICAgICAgICAgICBpZiAoIWNmZy5iYXNlVXJsKSB7XFxuICAgICAgICAgICAgICAgICAgICAvL1B1bGwgb2ZmIHRoZSBkaXJlY3Rvcnkgb2YgZGF0YS1tYWluIGZvciB1c2UgYXMgdGhlXFxuICAgICAgICAgICAgICAgICAgICAvL2Jhc2VVcmwuXFxuICAgICAgICAgICAgICAgICAgICBzcmMgPSBtYWluU2NyaXB0LnNwbGl0KCcvJyk7XFxuICAgICAgICAgICAgICAgICAgICBtYWluU2NyaXB0ID0gc3JjLnBvcCgpO1xcbiAgICAgICAgICAgICAgICAgICAgc3ViUGF0aCA9IHNyYy5sZW5ndGggPyBzcmMuam9pbignLycpICArICcvJyA6ICcuLyc7XFxuXFxuICAgICAgICAgICAgICAgICAgICBjZmcuYmFzZVVybCA9IHN1YlBhdGg7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgLy9TdHJpcCBvZmYgYW55IHRyYWlsaW5nIC5qcyBzaW5jZSBtYWluU2NyaXB0IGlzIG5vd1xcbiAgICAgICAgICAgICAgICAvL2xpa2UgYSBtb2R1bGUgbmFtZS5cXG4gICAgICAgICAgICAgICAgbWFpblNjcmlwdCA9IG1haW5TY3JpcHQucmVwbGFjZShqc1N1ZmZpeFJlZ0V4cCwgJycpO1xcblxcbiAgICAgICAgICAgICAgICAgLy9JZiBtYWluU2NyaXB0IGlzIHN0aWxsIGEgcGF0aCwgZmFsbCBiYWNrIHRvIGRhdGFNYWluXFxuICAgICAgICAgICAgICAgIGlmIChyZXEuanNFeHRSZWdFeHAudGVzdChtYWluU2NyaXB0KSkge1xcbiAgICAgICAgICAgICAgICAgICAgbWFpblNjcmlwdCA9IGRhdGFNYWluO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vUHV0IHRoZSBkYXRhLW1haW4gc2NyaXB0IGluIHRoZSBmaWxlcyB0byBsb2FkLlxcbiAgICAgICAgICAgICAgICBjZmcuZGVwcyA9IGNmZy5kZXBzID8gY2ZnLmRlcHMuY29uY2F0KG1haW5TY3JpcHQpIDogW21haW5TY3JpcHRdO1xcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVGhlIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyBkZWZpbml0aW9ucyBvZiBtb2R1bGVzLiBEaWZmZXJzIGZyb21cXG4gICAgICogcmVxdWlyZSgpIGluIHRoYXQgYSBzdHJpbmcgZm9yIHRoZSBtb2R1bGUgc2hvdWxkIGJlIHRoZSBmaXJzdCBhcmd1bWVudCxcXG4gICAgICogYW5kIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIGRlcGVuZGVuY2llcyBhcmUgbG9hZGVkIHNob3VsZFxcbiAgICAgKiByZXR1cm4gYSB2YWx1ZSB0byBkZWZpbmUgdGhlIG1vZHVsZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmaXJzdCBhcmd1bWVudCdzXFxuICAgICAqIG5hbWUuXFxuICAgICAqL1xcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgY2FsbGJhY2spIHtcXG4gICAgICAgIHZhciBub2RlLCBjb250ZXh0O1xcblxcbiAgICAgICAgLy9BbGxvdyBmb3IgYW5vbnltb3VzIG1vZHVsZXNcXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgICAvL0FkanVzdCBhcmdzIGFwcHJvcHJpYXRlbHlcXG4gICAgICAgICAgICBjYWxsYmFjayA9IGRlcHM7XFxuICAgICAgICAgICAgZGVwcyA9IG5hbWU7XFxuICAgICAgICAgICAgbmFtZSA9IG51bGw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL1RoaXMgbW9kdWxlIG1heSBub3QgaGF2ZSBkZXBlbmRlbmNpZXNcXG4gICAgICAgIGlmICghaXNBcnJheShkZXBzKSkge1xcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZGVwcztcXG4gICAgICAgICAgICBkZXBzID0gbnVsbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vSWYgbm8gbmFtZSwgYW5kIGNhbGxiYWNrIGlzIGEgZnVuY3Rpb24sIHRoZW4gZmlndXJlIG91dCBpZiBpdCBhXFxuICAgICAgICAvL0NvbW1vbkpTIHRoaW5nIHdpdGggZGVwZW5kZW5jaWVzLlxcbiAgICAgICAgaWYgKCFkZXBzICYmIGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XFxuICAgICAgICAgICAgZGVwcyA9IFtdO1xcbiAgICAgICAgICAgIC8vUmVtb3ZlIGNvbW1lbnRzIGZyb20gdGhlIGNhbGxiYWNrIHN0cmluZyxcXG4gICAgICAgICAgICAvL2xvb2sgZm9yIHJlcXVpcmUgY2FsbHMsIGFuZCBwdWxsIHRoZW0gaW50byB0aGUgZGVwZW5kZW5jaWVzLFxcbiAgICAgICAgICAgIC8vYnV0IG9ubHkgaWYgdGhlcmUgYXJlIGZ1bmN0aW9uIGFyZ3MuXFxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBjYWxsYmFja1xcbiAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKClcXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKGNvbW1lbnRSZWdFeHAsICcnKVxcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoY2pzUmVxdWlyZVJlZ0V4cCwgZnVuY3Rpb24gKG1hdGNoLCBkZXApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAvL01heSBiZSBhIENvbW1vbkpTIHRoaW5nIGV2ZW4gd2l0aG91dCByZXF1aXJlIGNhbGxzLCBidXQgc3RpbGxcXG4gICAgICAgICAgICAgICAgLy9jb3VsZCB1c2UgZXhwb3J0cywgYW5kIG1vZHVsZS4gQXZvaWQgZG9pbmcgZXhwb3J0cyBhbmQgbW9kdWxlXFxuICAgICAgICAgICAgICAgIC8vd29yayB0aG91Z2ggaWYgaXQganVzdCBuZWVkcyByZXF1aXJlLlxcbiAgICAgICAgICAgICAgICAvL1JFUVVJUkVTIHRoZSBmdW5jdGlvbiB0byBleHBlY3QgdGhlIENvbW1vbkpTIHZhcmlhYmxlcyBpbiB0aGVcXG4gICAgICAgICAgICAgICAgLy9vcmRlciBsaXN0ZWQgYmVsb3cuXFxuICAgICAgICAgICAgICAgIGRlcHMgPSAoY2FsbGJhY2subGVuZ3RoID09PSAxID8gWydyZXF1aXJlJ10gOiBbJ3JlcXVpcmUnLCAnZXhwb3J0cycsICdtb2R1bGUnXSkuY29uY2F0KGRlcHMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vSWYgaW4gSUUgNi04IGFuZCBoaXQgYW4gYW5vbnltb3VzIGRlZmluZSgpIGNhbGwsIGRvIHRoZSBpbnRlcmFjdGl2ZVxcbiAgICAgICAgLy93b3JrLlxcbiAgICAgICAgaWYgKHVzZUludGVyYWN0aXZlKSB7XFxuICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRseUFkZGluZ1NjcmlwdCB8fCBnZXRJbnRlcmFjdGl2ZVNjcmlwdCgpO1xcbiAgICAgICAgICAgIGlmIChub2RlKSB7XFxuICAgICAgICAgICAgICAgIGlmICghbmFtZSkge1xcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXJlcXVpcmVtb2R1bGUnKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dHNbbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVxdWlyZWNvbnRleHQnKV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9BbHdheXMgc2F2ZSBvZmYgZXZhbHVhdGluZyB0aGUgZGVmIGNhbGwgdW50aWwgdGhlIHNjcmlwdCBvbmxvYWQgaGFuZGxlci5cXG4gICAgICAgIC8vVGhpcyBhbGxvd3MgbXVsdGlwbGUgbW9kdWxlcyB0byBiZSBpbiBhIGZpbGUgd2l0aG91dCBwcmVtYXR1cmVseVxcbiAgICAgICAgLy90cmFjaW5nIGRlcGVuZGVuY2llcywgYW5kIGFsbG93cyBmb3IgYW5vbnltb3VzIG1vZHVsZSBzdXBwb3J0LFxcbiAgICAgICAgLy93aGVyZSB0aGUgbW9kdWxlIG5hbWUgaXMgbm90IGtub3duIHVudGlsIHRoZSBzY3JpcHQgb25sb2FkIGV2ZW50XFxuICAgICAgICAvL29jY3Vycy4gSWYgbm8gY29udGV4dCwgdXNlIHRoZSBnbG9iYWwgcXVldWUsIGFuZCBnZXQgaXQgcHJvY2Vzc2VkXFxuICAgICAgICAvL2luIHRoZSBvbnNjcmlwdCBsb2FkIGNhbGxiYWNrLlxcbiAgICAgICAgKGNvbnRleHQgPyBjb250ZXh0LmRlZlF1ZXVlIDogZ2xvYmFsRGVmUXVldWUpLnB1c2goW25hbWUsIGRlcHMsIGNhbGxiYWNrXSk7XFxuICAgIH07XFxuXFxuICAgIGRlZmluZS5hbWQgPSB7XFxuICAgICAgICBqUXVlcnk6IHRydWVcXG4gICAgfTtcXG5cXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGVzIHRoZSB0ZXh0LiBOb3JtYWxseSBqdXN0IHVzZXMgZXZhbCwgYnV0IGNhbiBiZSBtb2RpZmllZFxcbiAgICAgKiB0byB1c2UgYSBiZXR0ZXIsIGVudmlyb25tZW50LXNwZWNpZmljIGNhbGwuIE9ubHkgdXNlZCBmb3IgdHJhbnNwaWxpbmdcXG4gICAgICogbG9hZGVyIHBsdWdpbnMsIG5vdCBmb3IgcGxhaW4gSlMgbW9kdWxlcy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIHRleHQgdG8gZXhlY3V0ZS9ldmFsdWF0ZS5cXG4gICAgICovXFxuICAgIHJlcS5leGVjID0gZnVuY3Rpb24gKHRleHQpIHtcXG4gICAgICAgIC8qanNsaW50IGV2aWw6IHRydWUgKi9cXG4gICAgICAgIHJldHVybiBldmFsKHRleHQpO1xcbiAgICB9O1xcblxcbiAgICAvL1NldCB1cCB3aXRoIGNvbmZpZyBpbmZvLlxcbiAgICByZXEoY2ZnKTtcXG59KHRoaXMpKTtcXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL3JlcXVpcmUuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 4:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(5))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3Byb2ZpbGVzL3NoYXJlZC5qcz83ODMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvVXNlcnMvdml2aWFuL2Rhb2Nsb3VkL0RDRS9zcGx1bmsvb2VtLXN0YXJ0ZXIta2l0LW5ldy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL3Zpdmlhbi9kYW9jbG91ZC9EQ0Uvc3BsdW5rL29lbS1zdGFydGVyLWtpdC1uZXcvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL3Zpdmlhbi9kYW9jbG91ZC9EQ0Uvc3BsdW5rL29lbS1zdGFydGVyLWtpdC1uZXcvcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9wcm9maWxlcy9zaGFyZWQuanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3Byb2ZpbGVzL3NoYXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 5:
/***/ (function(module, exports) {

	eval("module.exports = \"// reference this from another build profile with mainConfigFile: './shared.build.profile.js'\\nrequirejs.config({\\n    baseUrl: '../',\\n    preserveLicenseComments: false,\\n    map: {\\n        \\\"*\\\": {\\n            css: \\\"splunkjs/contrib/require-css/css\\\",\\n            'requirejs': 'require/requirejs',\\n            // Aliases for files that have been moved, but need to be acessible to apps\\n            // SPL-120323\\n            'views/shared/WaitSpinner': 'views/shared/waitspinner/Master'\\n        }\\n    },\\n    paths: {\\n        // paths outside of baseUrl\\n        'templates': '../../templates',\\n        'api': '../build/api',\\n\\n        // Makes requring an app's static assets cleaner\\n        'app': '../app',\\n\\n        // jQuery and contrib plugins\\n        'jquery': 'contrib/jquery-2.1.0',\\n        'jquery.history': 'contrib/jquery.history',\\n        'jquery.bgiframe': 'contrib/jquery.bgiframe-3.0.0',\\n        'jquery.cookie': 'contrib/jquery.cookie',\\n        'jquery.deparam': 'contrib/jquery.deparam',\\n        'jquery.fileupload': 'contrib/jquery.fileupload',\\n        'jquery.iframe-transport': 'contrib/jquery.iframe-transport',\\n\\n        // internal jQuery plugins\\n        'splunk.jquery.csrf': 'splunk.jquery.csrf_protection',\\n\\n        // jQuery UI plugins\\n        'jquery.ui.core': 'contrib/jquery-ui-1.10.4/jquery.ui.core',\\n        'jquery.ui.widget': 'contrib/jquery-ui-1.10.4/jquery.ui.widget',\\n        'jquery.ui.datepicker': 'contrib/jquery-ui-1.10.4/jquery.ui.datepicker',\\n        'jquery.ui.position': 'contrib/jquery-ui-1.10.4/jquery.ui.position',\\n        'jquery.ui.mouse': 'contrib/jquery-ui-1.10.4/jquery.ui.mouse',\\n        'jquery.ui.draggable': 'contrib/jquery-ui-1.10.4/jquery.ui.draggable',\\n        'jquery.ui.droppable': 'contrib/jquery-ui-1.10.4/jquery.ui.droppable',\\n        'jquery.ui.sortable': 'contrib/jquery-ui-1.10.4/jquery.ui.sortable',\\n        'jquery.ui.resizable': 'contrib/jquery-ui-1.10.4/jquery.ui.resizable',\\n        'jquery.ui.button': 'contrib/jquery-ui-1.10.4/jquery.ui.button',\\n        'jquery.ui.spinner': 'contrib/jquery-ui-1.10.4/jquery.ui.spinner',\\n        'jquery.ui.effect': 'contrib/jquery-ui-1.10.4/jquery.ui.effect',\\n        'jquery.ui.effect-slide': 'contrib/jquery-ui-1.10.4/jquery.ui.effect-slide',\\n        'tree.jquery': 'contrib/jqTree/tree.jquery',\\n        'jquery.resize': 'contrib/jquery-resize',\\n\\n        // bootstrap components\\n        // FIXME: bootstrap.button collides with jquery.ui.button on the jQuery prototype !!\\n        'bootstrap.affix': 'contrib/bootstrap-2.3.1/bootstrap-affix',\\n        'bootstrap.alert': 'contrib/bootstrap-2.3.1/bootstrap-alert',\\n        'bootstrap.button': 'contrib/bootstrap-2.3.1/bootstrap-button',\\n        'bootstrap.carousel': 'contrib/bootstrap-2.3.1/bootstrap-carousel',\\n        'bootstrap.collapse': 'contrib/bootstrap-2.3.1/bootstrap-collapse',\\n        'bootstrap.dropdown': 'contrib/bootstrap-2.3.1/bootstrap-dropdown',\\n        'bootstrap.modal': 'contrib/bootstrap-2.3.1/bootstrap-modal',\\n        'bootstrap.popover': 'contrib/bootstrap-2.3.1/bootstrap-popover',\\n        'bootstrap.scrollspy': 'contrib/bootstrap-2.3.1/bootstrap-scrollspy',\\n        'bootstrap.tab': 'contrib/bootstrap-2.3.1/bootstrap-tab',\\n        'bootstrap.tooltip': 'contrib/bootstrap-2.3.1/bootstrap-tooltip',\\n        'bootstrap.transition': 'contrib/bootstrap-2.3.1/bootstrap-transition',\\n        'bootstrap.typeahead': 'contrib/bootstrap-2.3.1/bootstrap-typeahead',\\n\\n        // other contrib libraries\\n        'moment': 'contrib/moment',\\n        'numeral': 'contrib/numeral',\\n        'underscore': 'require/underscore',\\n        'backbone': 'require/backbone',\\n        'highcharts': 'contrib/highcharts-4.0.4/highcharts',\\n        'backbone_validation': 'contrib/backbone-validation-amd',\\n        'prettify': 'contrib/google-code-prettify/prettify',\\n        'intro': 'contrib/intro',\\n        'document-register-element': 'contrib/polyfills/document-register-element.max.amd',\\n\\n        /* augments builtin prototype */\\n        'strftime': 'contrib/strftime',\\n        'leaflet': 'contrib/leaflet/leaflet',\\n        'jg_global': 'contrib/jg_global',\\n        'jgatt': 'contrib/jg_library',\\n        'jg': 'contrib/jg_lib',\\n        'lowpro': 'contrib/lowpro_for_jquery',\\n        'spin': 'contrib/spin',\\n        'sax': 'contrib/sax',\\n        \\\"ace\\\":\\\"contrib/ace-editor\\\",\\n\\n        // Splunk legacy\\n        'splunk': 'splunk',\\n        'splunk.legend': 'legend',\\n        'splunk.logger': 'logger',\\n        'splunk.error': 'error',\\n        'splunk.util': 'util',\\n        'util/sprintf': 'contrib/sprintf',\\n        'splunk.pdf': 'pdf',\\n        'splunk.i18n': 'stubs/i18n',\\n        'splunk.config': 'stubs/splunk.config',\\n        'splunk.paginator': 'paginator',\\n        'splunk.messenger': 'messenger',\\n        'splunk.time': 'splunk_time',\\n        'splunk.timerange': 'time_range',\\n        'splunk.window': 'window',\\n        'splunk.jabridge': 'ja_bridge',\\n        'splunk.print': 'print',\\n        'splunk.session': 'session',\\n\\n        // splunkjs\\n        \\\"async\\\": \\\"splunkjs/contrib/requirejs-plugins/async\\\",\\n        \\\"select2\\\": \\\"contrib/select2-3.4.6\\\",\\n    },\\n    shim: {\\n\\n        /* START splunkjs */\\n        'splunkjs/splunk': {\\n            deps: ['jquery'],\\n            exports: 'splunkjs'\\n        },\\n\\n        /* Select2*/\\n        \\\"select2/select2\\\": {\\n            deps: [\\\"jquery\\\", \\\"helpers/user_agent\\\", \\\"css!contrib/select2-3.4.6/select2.css\\\", \\\"views/shared/pcss/select2.pcss\\\"],\\n            exports: \\\"Select2\\\",\\n            init: function($, UserAgent) {\\n                var Select2 = this.Select2;\\n                Select2.class.single.prototype.getPlaceholder = function() {\\n                    // if a placeholder is specified on a single select without a valid placeholder option ignore it\\n                    if (this.select) {\\n                        if (this.getPlaceholderOption() === undefined) {\\n                            return undefined;\\n                        }\\n                    }\\n                    // https://github.com/select2/select2/issues/3300\\n                    // SPL-111895, SPL-112886, disable placeholder for IE <= 11\\n                    if (UserAgent.isIELessThan(12)) {\\n                        return undefined;\\n                    }\\n                    return Select2.class.abstract.prototype.getPlaceholder.apply(this, arguments);\\n                };\\n                return Select2;\\n            }\\n        },\\n\\n        /* START contrib jQuery plugins */\\n        'jquery.cookie': {\\n            deps: ['jquery']\\n        },\\n         'jquery.fileupload': {\\n            deps: ['jquery']\\n        },\\n        'jquery.iframe-transport': {\\n        \\tdeps: ['jquery']\\n        },\\n        'jquery.history': {\\n            deps: ['jquery'],\\n                exports: 'History'\\n        },\\n        'jquery.bgiframe': {\\n            deps: ['jquery']\\n        },\\n\\n        \\\"jquery.attributes\\\": {\\n            deps: ['jquery']\\n        },\\n\\n        \\\"jquery.spin\\\": {\\n            deps: ['jquery']\\n        },\\n\\n        \\\"jquery.sparkline\\\": {\\n            deps: ['jquery']\\n        },\\n\\n        \\\"jquery.deparam\\\": {\\n            deps: ['jquery'],\\n            exports: \\\"jQuery.fn.deparam\\\"\\n        },\\n\\n        /* START internal jQuery plugins */\\n        'splunk.jquery.csrf_protection': {\\n            deps: ['jquery.cookie', 'splunk.util']\\n        },\\n\\n        /* START jQuery UI plugins */\\n        'jquery.ui.core': {\\n            deps: ['jquery']\\n        },\\n        'jquery.ui.widget': {\\n            deps: ['jquery.ui.core']\\n        },\\n        'jquery.ui.position': {\\n            deps: ['jquery.ui.widget']\\n        },\\n        'jquery.ui.mouse': {\\n            deps: ['jquery.ui.widget']\\n        },\\n        'jquery.ui.sortable': {\\n            deps: ['jquery.ui.widget', 'jquery.ui.mouse', 'jquery.ui.draggable', 'jquery.ui.droppable']\\n        },\\n        'jquery.ui.draggable': {\\n            deps: ['jquery.ui.widget', 'jquery.ui.mouse']\\n        },\\n        'jquery.ui.droppable': {\\n            deps: ['jquery.ui.widget', 'jquery.ui.mouse']\\n        },\\n        'jquery.ui.resizable': {\\n            deps: ['jquery.ui.widget', 'jquery.ui.mouse']\\n        },\\n        'jquery.ui.datepicker': {\\n            deps: ['jquery', 'jquery.ui.widget', 'splunk.i18n'],\\n            exports: 'jquery.ui.datepicker',\\n            init: function(jQuery, widget, i18n) {\\n                var initFn = i18n.jQuery_ui_datepicker_install;\\n                if (typeof initFn === 'function') {\\n                    initFn(jQuery);\\n                }\\n                return jQuery.ui.datepicker;\\n            }\\n        },\\n        'jquery.ui.button': {\\n            deps: ['jquery.ui.widget', 'jquery.ui.core']\\n        },\\n        'jquery.ui.spinner': {\\n            deps: ['jquery.ui.widget', 'jquery.ui.core', 'jquery.ui.button']\\n        },\\n        'jquery.ui.effect': {\\n            deps: ['jquery.ui.core']\\n        },\\n        'jquery.ui.effect-slide': {\\n            deps: ['jquery.ui.core', 'jquery.ui.effect']\\n        },\\n        'tree.jquery': {\\n            deps: ['jquery']\\n        },\\n        'jquery.resize': {\\n            deps: ['jquery'],\\n            init: function($) {\\n                // The plugin itself does not prevent bubbling of the resize events, add that here.\\n                $.event.special.elementResize.noBubble = true;\\n            }\\n        },\\n\\n        // bootstrap components\\n        'bootstrap.affix': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.alert': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.button': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.carousel': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.collapse': {\\n            deps: ['jquery', 'bootstrap.transition']\\n        },\\n        'bootstrap.dropdown': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.modal': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.popover': {\\n            deps: ['jquery', 'bootstrap.tooltip']\\n        },\\n        'bootstrap.scrollspy': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.tab': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.tooltip': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.transition': {\\n            deps: ['jquery']\\n        },\\n        'bootstrap.typeahead': {\\n            deps: ['jquery']\\n        },\\n\\n        /* START other contrib libraries */\\n        \\\"backbone.nested\\\": {\\n            // Not sure if needed\\n            deps: ['backbone'],\\n            exports: 'Backbone.NestedModel'\\n        },\\n        highcharts: {\\n            deps: ['jquery', 'splunk'],\\n            init: function($, Splunk) {\\n                var Highcharts = Splunk.Highcharts = this.Highcharts;\\n                // Remove Highcharts from the global namespace so multiple versions can\\n                // co-exist on the same page.  As a safety measure in case existing external\\n                // code relies on this global, it is still available as `Splunk.Highcharts`.\\n                delete this.Highcharts;\\n                return Highcharts;\\n            }\\n        },\\n        prettify: {\\n            exports: 'prettyPrint'\\n        },\\n        leaflet: {\\n            deps: ['jquery', 'splunk.util', 'splunk.config', 'helpers/user_agent', 'contrib/text!contrib/leaflet/leaflet.css'],\\n            exports: 'L',\\n            init: function($, SplunkUtil, splunkConfig, userAgent, css) {\\n                if (splunkConfig.INDEPENDENT_MODE) {\\n                    var imageUrl = require.toUrl('') + 'splunkjs/contrib/leaflet/images';\\n                    css = css.replace(/url\\\\(images/g, 'url(' + imageUrl);\\n                }\\n                else {\\n                    // resolve image urls\\n                    css = css.replace(/url\\\\(images/g, \\\"url(\\\" + SplunkUtil.make_url(\\\"/static/js/contrib/leaflet/images\\\"));\\n                }\\n                // inject css into head\\n                $(\\\"head\\\").append(\\\"<style type=\\\\\\\"text/css\\\\\\\">\\\" + css + \\\"</style>\\\");\\n\\n                // SPL-98647: monkey patch the getParamString method to avoid an XSS vulnerability in our\\n                // version of Leaflet.\\n                // See https://github.com/Leaflet/Leaflet/pull/1317/files\\n                if (this.L && this.L.Util) {\\n                    this.L.Util.getParamString = function(obj, existingUrl) {\\n                        var params = [];\\n                        for(var i in obj) {\\n                            if (obj.hasOwnProperty(i)) {\\n                                params.push(encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]));\\n                            }\\n                        }\\n                        return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\\n                    };\\n                }\\n            }\\n        },\\n        jg_global: {\\n            // export the dictionary of functions to a different variable, since in \\\"wrapShim\\\" mode require will\\n            // assign the return value from init to that global.\\n            exports: 'jg_globals',\\n            init: function() {\\n                this.jg_globals = {\\n                    jg_namespace: this.jg_namespace,\\n                    jg_extend: this.jg_extend,\\n                    jg_static: this.jg_static,\\n                    jg_mixin: this.jg_mixin,\\n                    jg_has_mixin: this.jg_has_mixin\\n                };\\n                return this.jg_globals;\\n            }\\n        },\\n        jgatt: {\\n            deps: ['jg_global'],\\n            exports: 'jgatt'\\n        },\\n        lowpro: {\\n            deps: ['jquery']\\n        },\\n        'sax': {\\n            exports: 'sax'\\n        },\\n        'ace/ace': {\\n            exports: 'ace'\\n        },\\n\\n        /* Start Splunk legacy */\\n        splunk: {\\n            exports: 'Splunk'\\n        },\\n        'splunk.util': {\\n            deps: ['jquery', 'splunk', 'splunk.config', 'util/sprintf'],\\n            exports: 'Splunk.util',\\n            init: function($, Splunk, config, sprintf) {\\n                return $.extend({ sprintf: sprintf }, Splunk.util);\\n            }\\n        },\\n        'util/sprintf': {\\n            exports: 'sprintf'\\n        },\\n        'splunk.legend': {\\n            deps: ['splunk'],\\n                exports: 'Splunk.Legend'\\n        },\\n        'splunk.logger': {\\n            deps: ['splunk', 'splunk.util'],\\n                exports: 'Splunk.Logger'\\n        },\\n        'splunk.error': {\\n            deps: ['jquery', 'splunk', 'splunk.logger'],\\n            exports: 'Splunk.Error'\\n        },\\n        'splunk.pdf': {\\n            deps: ['splunk', 'splunk.util', 'jquery'],\\n            exports: 'Splunk.pdf'\\n        },\\n        strftime: {\\n            deps: []\\n        },\\n        'splunk.paginator': {\\n            deps: ['splunk'],\\n                exports: 'Splunk.paginator'\\n        },\\n        'splunk.jquery.csrf': {\\n            deps: ['jquery', 'jquery.cookie', 'splunk.util']\\n        },\\n        'splunk.messenger': {\\n            deps: ['splunk', 'splunk.util', 'splunk.logger', 'splunk.i18n', 'lowpro'],\\n            exports: 'Splunk.Messenger'\\n        },\\n        'splunk.time': {\\n            deps: ['jg_global', 'jgatt'],\\n            exports: 'splunk.time'\\n        },\\n        'splunk.timerange': {\\n            deps: ['splunk', 'splunk.util', 'splunk.logger', 'splunk.i18n', 'splunk.time', 'lowpro'],\\n            exports: 'Splunk.Timerange',\\n            init: function(Splunk) {\\n                Splunk.namespace(\\\"Globals\\\");\\n                if (!Splunk.Globals.timeZone) {\\n                    Splunk.Globals.timeZone = new Splunk.TimeZone(Splunk.util.getConfigValue('SERVER_ZONEINFO'));\\n                }\\n                return Splunk.TimeRange;\\n            }\\n        },\\n        'splunk.window': {\\n            deps: ['splunk', 'splunk.util', 'splunk.i18n'],\\n            exports: 'Splunk.window'\\n        },\\n        'splunk.jabridge': {\\n            deps: ['splunk'],\\n            exports: 'Splunk.JABridge'\\n        },\\n        'splunk.print': {\\n            deps: ['jquery', 'lowpro', 'splunk', 'splunk.logger'],\\n            exports: 'Splunk.Print'\\n        },\\n        'splunk.session': {\\n            deps: ['lowpro', 'splunk', 'jquery', 'splunk.logger', 'splunk.util'],\\n            exports: 'Splunk.Session'\\n        },\\n\\n        // shim handlers for the various versions of jquery\\n\\n        'contrib/jquery-2.1.0': {\\n            exports: 'jQuery'\\n        },\\n        'contrib/jquery-1.10.2': {\\n            exports: 'jQuery',\\n            init: function() {\\n                if(this.console && typeof this.console.warn === 'function') {\\n                    this.console.warn('You are using a deprecated version of jQuery, please upgrade to the latest version');\\n                }\\n                return this.jQuery;\\n            }\\n        },\\n        'contrib/jquery-1.8.2': {\\n            exports: 'jQuery',\\n            init: function() {\\n                if(this.console && typeof this.console.warn === 'function') {\\n                    this.console.warn('You are using a deprecated version of jQuery, please upgrade to the latest version');\\n                }\\n                return this.jQuery;\\n            }\\n        },\\n        'contrib/jquery-1.8.3': {\\n            exports: 'jQuery',\\n            init: function() {\\n                if(this.console && typeof this.console.warn === 'function') {\\n                    this.console.warn('You are using a deprecated version of jQuery, please upgrade to the latest version');\\n                }\\n                return this.jQuery;\\n            }\\n        }\\n    }\\n})\\n\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3Byb2ZpbGVzL3NoYXJlZC5qcz9jZGFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG1JQUFtSSxzRUFBc0Usa0JBQWtCLGlUQUFpVCxPQUFPLGVBQWUscW1KQUFxbUosY0FBYyw4REFBOEQsMkVBQTJFLHlEQUF5RCx1TkFBdU4sNkNBQTZDLDhFQUE4RSw4SkFBOEosMEVBQTBFLCtDQUErQywyQkFBMkIsdUJBQXVCLCtNQUErTSwyQ0FBMkMsdUJBQXVCLG9HQUFvRyxvQkFBb0IsaUNBQWlDLGVBQWUsV0FBVywyRUFBMkUseUNBQXlDLGtDQUFrQyx5Q0FBeUMsdUNBQXVDLHVDQUF1Qyw4QkFBOEIsOEVBQThFLCtCQUErQix5Q0FBeUMscUNBQXFDLHlDQUF5QywrQkFBK0IseUNBQXlDLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLHNGQUFzRiw0RkFBNEYsK0RBQStELHVFQUF1RSx5Q0FBeUMsZ0NBQWdDLGlEQUFpRCxrQ0FBa0MsbURBQW1ELCtCQUErQixtREFBbUQsa0NBQWtDLG9IQUFvSCxtQ0FBbUMsc0VBQXNFLG1DQUFtQyxzRUFBc0UsbUNBQW1DLHNFQUFzRSxvQ0FBb0Msb0tBQW9LLGlFQUFpRSxxREFBcUQscUNBQXFDLG1CQUFtQiw4Q0FBOEMsZUFBZSxXQUFXLGdDQUFnQyxxRUFBcUUsaUNBQWlDLHlGQUF5RixnQ0FBZ0MsaURBQWlELHNDQUFzQyxxRUFBcUUsMkJBQTJCLHlDQUF5Qyw2QkFBNkIsZ0VBQWdFLHFLQUFxSyxlQUFlLFdBQVcsa0VBQWtFLHlDQUF5QywrQkFBK0IseUNBQXlDLGdDQUFnQyx5Q0FBeUMsa0NBQWtDLHlDQUF5QyxrQ0FBa0MsaUVBQWlFLGtDQUFrQyx5Q0FBeUMsK0JBQStCLHlDQUF5QyxpQ0FBaUMsOERBQThELG1DQUFtQyx5Q0FBeUMsNkJBQTZCLHlDQUF5QyxpQ0FBaUMseUNBQXlDLG9DQUFvQyx5Q0FBeUMsbUNBQW1DLHlDQUF5QyxnRkFBZ0YsNEhBQTRILHdCQUF3QixrRkFBa0YsdUVBQXVFLDhUQUE4VCxvQ0FBb0MsZUFBZSxXQUFXLHNCQUFzQiwrQ0FBK0MscUJBQXFCLHVPQUF1TyxzREFBc0QsMkZBQTJGLDRFQUE0RSxtQkFBbUIsd0JBQXdCLDJLQUEySyxtQkFBbUIsc0lBQXNJLDhRQUE4USwrRUFBK0UsMENBQTBDLDZDQUE2QywwREFBMEQsd0dBQXdHLCtCQUErQiwyQkFBMkIsb0hBQW9ILHdCQUF3QixtQkFBbUIsZUFBZSxXQUFXLHVCQUF1QiwwUEFBMFAscUNBQXFDLDZRQUE2USx5Q0FBeUMsZUFBZSxXQUFXLG1CQUFtQiwyRUFBMkUsb0JBQW9CLHlDQUF5QyxtQkFBbUIsdUNBQXVDLHVCQUF1Qix1Q0FBdUMseURBQXlELDBDQUEwQywyQkFBMkIseUtBQXlLLG1DQUFtQyxtQkFBbUIsZUFBZSxlQUFlLFdBQVcsNEJBQTRCLDJDQUEyQyw2QkFBNkIsb0ZBQW9GLDZCQUE2QixtR0FBbUcsNEJBQTRCLDBHQUEwRywwQkFBMEIsc0dBQXNHLHNCQUFzQixpQ0FBaUMsZ0NBQWdDLHVGQUF1RixrQ0FBa0MseUVBQXlFLGdDQUFnQyw0SUFBNEksMkJBQTJCLDBGQUEwRixnQ0FBZ0MsdUxBQXVMLGdEQUFnRCxpREFBaUQsbUhBQW1ILG1CQUFtQiwwQ0FBMEMsZUFBZSxXQUFXLDZCQUE2Qiw4R0FBOEcsK0JBQStCLGtGQUFrRiw0QkFBNEIsb0hBQW9ILDhCQUE4QixxSUFBcUkscUdBQXFHLDBDQUEwQyxxQ0FBcUMsZ0VBQWdFLCtFQUErRSw4SEFBOEgsbUJBQW1CLHFDQUFxQyxlQUFlLFdBQVcsb0NBQW9DLGdFQUFnRSwrRUFBK0UsOEhBQThILG1CQUFtQixxQ0FBcUMsZUFBZSxXQUFXLG9DQUFvQyxnRUFBZ0UsK0VBQStFLDhIQUE4SCxtQkFBbUIscUNBQXFDLGVBQWUsV0FBVyxPQUFPLEdBQUciLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvLyByZWZlcmVuY2UgdGhpcyBmcm9tIGFub3RoZXIgYnVpbGQgcHJvZmlsZSB3aXRoIG1haW5Db25maWdGaWxlOiAnLi9zaGFyZWQuYnVpbGQucHJvZmlsZS5qcydcXG5yZXF1aXJlanMuY29uZmlnKHtcXG4gICAgYmFzZVVybDogJy4uLycsXFxuICAgIHByZXNlcnZlTGljZW5zZUNvbW1lbnRzOiBmYWxzZSxcXG4gICAgbWFwOiB7XFxuICAgICAgICBcXFwiKlxcXCI6IHtcXG4gICAgICAgICAgICBjc3M6IFxcXCJzcGx1bmtqcy9jb250cmliL3JlcXVpcmUtY3NzL2Nzc1xcXCIsXFxuICAgICAgICAgICAgJ3JlcXVpcmVqcyc6ICdyZXF1aXJlL3JlcXVpcmVqcycsXFxuICAgICAgICAgICAgLy8gQWxpYXNlcyBmb3IgZmlsZXMgdGhhdCBoYXZlIGJlZW4gbW92ZWQsIGJ1dCBuZWVkIHRvIGJlIGFjZXNzaWJsZSB0byBhcHBzXFxuICAgICAgICAgICAgLy8gU1BMLTEyMDMyM1xcbiAgICAgICAgICAgICd2aWV3cy9zaGFyZWQvV2FpdFNwaW5uZXInOiAndmlld3Mvc2hhcmVkL3dhaXRzcGlubmVyL01hc3RlcidcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgcGF0aHM6IHtcXG4gICAgICAgIC8vIHBhdGhzIG91dHNpZGUgb2YgYmFzZVVybFxcbiAgICAgICAgJ3RlbXBsYXRlcyc6ICcuLi8uLi90ZW1wbGF0ZXMnLFxcbiAgICAgICAgJ2FwaSc6ICcuLi9idWlsZC9hcGknLFxcblxcbiAgICAgICAgLy8gTWFrZXMgcmVxdXJpbmcgYW4gYXBwJ3Mgc3RhdGljIGFzc2V0cyBjbGVhbmVyXFxuICAgICAgICAnYXBwJzogJy4uL2FwcCcsXFxuXFxuICAgICAgICAvLyBqUXVlcnkgYW5kIGNvbnRyaWIgcGx1Z2luc1xcbiAgICAgICAgJ2pxdWVyeSc6ICdjb250cmliL2pxdWVyeS0yLjEuMCcsXFxuICAgICAgICAnanF1ZXJ5Lmhpc3RvcnknOiAnY29udHJpYi9qcXVlcnkuaGlzdG9yeScsXFxuICAgICAgICAnanF1ZXJ5LmJnaWZyYW1lJzogJ2NvbnRyaWIvanF1ZXJ5LmJnaWZyYW1lLTMuMC4wJyxcXG4gICAgICAgICdqcXVlcnkuY29va2llJzogJ2NvbnRyaWIvanF1ZXJ5LmNvb2tpZScsXFxuICAgICAgICAnanF1ZXJ5LmRlcGFyYW0nOiAnY29udHJpYi9qcXVlcnkuZGVwYXJhbScsXFxuICAgICAgICAnanF1ZXJ5LmZpbGV1cGxvYWQnOiAnY29udHJpYi9qcXVlcnkuZmlsZXVwbG9hZCcsXFxuICAgICAgICAnanF1ZXJ5LmlmcmFtZS10cmFuc3BvcnQnOiAnY29udHJpYi9qcXVlcnkuaWZyYW1lLXRyYW5zcG9ydCcsXFxuXFxuICAgICAgICAvLyBpbnRlcm5hbCBqUXVlcnkgcGx1Z2luc1xcbiAgICAgICAgJ3NwbHVuay5qcXVlcnkuY3NyZic6ICdzcGx1bmsuanF1ZXJ5LmNzcmZfcHJvdGVjdGlvbicsXFxuXFxuICAgICAgICAvLyBqUXVlcnkgVUkgcGx1Z2luc1xcbiAgICAgICAgJ2pxdWVyeS51aS5jb3JlJzogJ2NvbnRyaWIvanF1ZXJ5LXVpLTEuMTAuNC9qcXVlcnkudWkuY29yZScsXFxuICAgICAgICAnanF1ZXJ5LnVpLndpZGdldCc6ICdjb250cmliL2pxdWVyeS11aS0xLjEwLjQvanF1ZXJ5LnVpLndpZGdldCcsXFxuICAgICAgICAnanF1ZXJ5LnVpLmRhdGVwaWNrZXInOiAnY29udHJpYi9qcXVlcnktdWktMS4xMC40L2pxdWVyeS51aS5kYXRlcGlja2VyJyxcXG4gICAgICAgICdqcXVlcnkudWkucG9zaXRpb24nOiAnY29udHJpYi9qcXVlcnktdWktMS4xMC40L2pxdWVyeS51aS5wb3NpdGlvbicsXFxuICAgICAgICAnanF1ZXJ5LnVpLm1vdXNlJzogJ2NvbnRyaWIvanF1ZXJ5LXVpLTEuMTAuNC9qcXVlcnkudWkubW91c2UnLFxcbiAgICAgICAgJ2pxdWVyeS51aS5kcmFnZ2FibGUnOiAnY29udHJpYi9qcXVlcnktdWktMS4xMC40L2pxdWVyeS51aS5kcmFnZ2FibGUnLFxcbiAgICAgICAgJ2pxdWVyeS51aS5kcm9wcGFibGUnOiAnY29udHJpYi9qcXVlcnktdWktMS4xMC40L2pxdWVyeS51aS5kcm9wcGFibGUnLFxcbiAgICAgICAgJ2pxdWVyeS51aS5zb3J0YWJsZSc6ICdjb250cmliL2pxdWVyeS11aS0xLjEwLjQvanF1ZXJ5LnVpLnNvcnRhYmxlJyxcXG4gICAgICAgICdqcXVlcnkudWkucmVzaXphYmxlJzogJ2NvbnRyaWIvanF1ZXJ5LXVpLTEuMTAuNC9qcXVlcnkudWkucmVzaXphYmxlJyxcXG4gICAgICAgICdqcXVlcnkudWkuYnV0dG9uJzogJ2NvbnRyaWIvanF1ZXJ5LXVpLTEuMTAuNC9qcXVlcnkudWkuYnV0dG9uJyxcXG4gICAgICAgICdqcXVlcnkudWkuc3Bpbm5lcic6ICdjb250cmliL2pxdWVyeS11aS0xLjEwLjQvanF1ZXJ5LnVpLnNwaW5uZXInLFxcbiAgICAgICAgJ2pxdWVyeS51aS5lZmZlY3QnOiAnY29udHJpYi9qcXVlcnktdWktMS4xMC40L2pxdWVyeS51aS5lZmZlY3QnLFxcbiAgICAgICAgJ2pxdWVyeS51aS5lZmZlY3Qtc2xpZGUnOiAnY29udHJpYi9qcXVlcnktdWktMS4xMC40L2pxdWVyeS51aS5lZmZlY3Qtc2xpZGUnLFxcbiAgICAgICAgJ3RyZWUuanF1ZXJ5JzogJ2NvbnRyaWIvanFUcmVlL3RyZWUuanF1ZXJ5JyxcXG4gICAgICAgICdqcXVlcnkucmVzaXplJzogJ2NvbnRyaWIvanF1ZXJ5LXJlc2l6ZScsXFxuXFxuICAgICAgICAvLyBib290c3RyYXAgY29tcG9uZW50c1xcbiAgICAgICAgLy8gRklYTUU6IGJvb3RzdHJhcC5idXR0b24gY29sbGlkZXMgd2l0aCBqcXVlcnkudWkuYnV0dG9uIG9uIHRoZSBqUXVlcnkgcHJvdG90eXBlICEhXFxuICAgICAgICAnYm9vdHN0cmFwLmFmZml4JzogJ2NvbnRyaWIvYm9vdHN0cmFwLTIuMy4xL2Jvb3RzdHJhcC1hZmZpeCcsXFxuICAgICAgICAnYm9vdHN0cmFwLmFsZXJ0JzogJ2NvbnRyaWIvYm9vdHN0cmFwLTIuMy4xL2Jvb3RzdHJhcC1hbGVydCcsXFxuICAgICAgICAnYm9vdHN0cmFwLmJ1dHRvbic6ICdjb250cmliL2Jvb3RzdHJhcC0yLjMuMS9ib290c3RyYXAtYnV0dG9uJyxcXG4gICAgICAgICdib290c3RyYXAuY2Fyb3VzZWwnOiAnY29udHJpYi9ib290c3RyYXAtMi4zLjEvYm9vdHN0cmFwLWNhcm91c2VsJyxcXG4gICAgICAgICdib290c3RyYXAuY29sbGFwc2UnOiAnY29udHJpYi9ib290c3RyYXAtMi4zLjEvYm9vdHN0cmFwLWNvbGxhcHNlJyxcXG4gICAgICAgICdib290c3RyYXAuZHJvcGRvd24nOiAnY29udHJpYi9ib290c3RyYXAtMi4zLjEvYm9vdHN0cmFwLWRyb3Bkb3duJyxcXG4gICAgICAgICdib290c3RyYXAubW9kYWwnOiAnY29udHJpYi9ib290c3RyYXAtMi4zLjEvYm9vdHN0cmFwLW1vZGFsJyxcXG4gICAgICAgICdib290c3RyYXAucG9wb3Zlcic6ICdjb250cmliL2Jvb3RzdHJhcC0yLjMuMS9ib290c3RyYXAtcG9wb3ZlcicsXFxuICAgICAgICAnYm9vdHN0cmFwLnNjcm9sbHNweSc6ICdjb250cmliL2Jvb3RzdHJhcC0yLjMuMS9ib290c3RyYXAtc2Nyb2xsc3B5JyxcXG4gICAgICAgICdib290c3RyYXAudGFiJzogJ2NvbnRyaWIvYm9vdHN0cmFwLTIuMy4xL2Jvb3RzdHJhcC10YWInLFxcbiAgICAgICAgJ2Jvb3RzdHJhcC50b29sdGlwJzogJ2NvbnRyaWIvYm9vdHN0cmFwLTIuMy4xL2Jvb3RzdHJhcC10b29sdGlwJyxcXG4gICAgICAgICdib290c3RyYXAudHJhbnNpdGlvbic6ICdjb250cmliL2Jvb3RzdHJhcC0yLjMuMS9ib290c3RyYXAtdHJhbnNpdGlvbicsXFxuICAgICAgICAnYm9vdHN0cmFwLnR5cGVhaGVhZCc6ICdjb250cmliL2Jvb3RzdHJhcC0yLjMuMS9ib290c3RyYXAtdHlwZWFoZWFkJyxcXG5cXG4gICAgICAgIC8vIG90aGVyIGNvbnRyaWIgbGlicmFyaWVzXFxuICAgICAgICAnbW9tZW50JzogJ2NvbnRyaWIvbW9tZW50JyxcXG4gICAgICAgICdudW1lcmFsJzogJ2NvbnRyaWIvbnVtZXJhbCcsXFxuICAgICAgICAndW5kZXJzY29yZSc6ICdyZXF1aXJlL3VuZGVyc2NvcmUnLFxcbiAgICAgICAgJ2JhY2tib25lJzogJ3JlcXVpcmUvYmFja2JvbmUnLFxcbiAgICAgICAgJ2hpZ2hjaGFydHMnOiAnY29udHJpYi9oaWdoY2hhcnRzLTQuMC40L2hpZ2hjaGFydHMnLFxcbiAgICAgICAgJ2JhY2tib25lX3ZhbGlkYXRpb24nOiAnY29udHJpYi9iYWNrYm9uZS12YWxpZGF0aW9uLWFtZCcsXFxuICAgICAgICAncHJldHRpZnknOiAnY29udHJpYi9nb29nbGUtY29kZS1wcmV0dGlmeS9wcmV0dGlmeScsXFxuICAgICAgICAnaW50cm8nOiAnY29udHJpYi9pbnRybycsXFxuICAgICAgICAnZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudCc6ICdjb250cmliL3BvbHlmaWxscy9kb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50Lm1heC5hbWQnLFxcblxcbiAgICAgICAgLyogYXVnbWVudHMgYnVpbHRpbiBwcm90b3R5cGUgKi9cXG4gICAgICAgICdzdHJmdGltZSc6ICdjb250cmliL3N0cmZ0aW1lJyxcXG4gICAgICAgICdsZWFmbGV0JzogJ2NvbnRyaWIvbGVhZmxldC9sZWFmbGV0JyxcXG4gICAgICAgICdqZ19nbG9iYWwnOiAnY29udHJpYi9qZ19nbG9iYWwnLFxcbiAgICAgICAgJ2pnYXR0JzogJ2NvbnRyaWIvamdfbGlicmFyeScsXFxuICAgICAgICAnamcnOiAnY29udHJpYi9qZ19saWInLFxcbiAgICAgICAgJ2xvd3Bybyc6ICdjb250cmliL2xvd3Byb19mb3JfanF1ZXJ5JyxcXG4gICAgICAgICdzcGluJzogJ2NvbnRyaWIvc3BpbicsXFxuICAgICAgICAnc2F4JzogJ2NvbnRyaWIvc2F4JyxcXG4gICAgICAgIFxcXCJhY2VcXFwiOlxcXCJjb250cmliL2FjZS1lZGl0b3JcXFwiLFxcblxcbiAgICAgICAgLy8gU3BsdW5rIGxlZ2FjeVxcbiAgICAgICAgJ3NwbHVuayc6ICdzcGx1bmsnLFxcbiAgICAgICAgJ3NwbHVuay5sZWdlbmQnOiAnbGVnZW5kJyxcXG4gICAgICAgICdzcGx1bmsubG9nZ2VyJzogJ2xvZ2dlcicsXFxuICAgICAgICAnc3BsdW5rLmVycm9yJzogJ2Vycm9yJyxcXG4gICAgICAgICdzcGx1bmsudXRpbCc6ICd1dGlsJyxcXG4gICAgICAgICd1dGlsL3NwcmludGYnOiAnY29udHJpYi9zcHJpbnRmJyxcXG4gICAgICAgICdzcGx1bmsucGRmJzogJ3BkZicsXFxuICAgICAgICAnc3BsdW5rLmkxOG4nOiAnc3R1YnMvaTE4bicsXFxuICAgICAgICAnc3BsdW5rLmNvbmZpZyc6ICdzdHVicy9zcGx1bmsuY29uZmlnJyxcXG4gICAgICAgICdzcGx1bmsucGFnaW5hdG9yJzogJ3BhZ2luYXRvcicsXFxuICAgICAgICAnc3BsdW5rLm1lc3Nlbmdlcic6ICdtZXNzZW5nZXInLFxcbiAgICAgICAgJ3NwbHVuay50aW1lJzogJ3NwbHVua190aW1lJyxcXG4gICAgICAgICdzcGx1bmsudGltZXJhbmdlJzogJ3RpbWVfcmFuZ2UnLFxcbiAgICAgICAgJ3NwbHVuay53aW5kb3cnOiAnd2luZG93JyxcXG4gICAgICAgICdzcGx1bmsuamFicmlkZ2UnOiAnamFfYnJpZGdlJyxcXG4gICAgICAgICdzcGx1bmsucHJpbnQnOiAncHJpbnQnLFxcbiAgICAgICAgJ3NwbHVuay5zZXNzaW9uJzogJ3Nlc3Npb24nLFxcblxcbiAgICAgICAgLy8gc3BsdW5ranNcXG4gICAgICAgIFxcXCJhc3luY1xcXCI6IFxcXCJzcGx1bmtqcy9jb250cmliL3JlcXVpcmVqcy1wbHVnaW5zL2FzeW5jXFxcIixcXG4gICAgICAgIFxcXCJzZWxlY3QyXFxcIjogXFxcImNvbnRyaWIvc2VsZWN0Mi0zLjQuNlxcXCIsXFxuICAgIH0sXFxuICAgIHNoaW06IHtcXG5cXG4gICAgICAgIC8qIFNUQVJUIHNwbHVua2pzICovXFxuICAgICAgICAnc3BsdW5ranMvc3BsdW5rJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J10sXFxuICAgICAgICAgICAgZXhwb3J0czogJ3NwbHVua2pzJ1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qIFNlbGVjdDIqL1xcbiAgICAgICAgXFxcInNlbGVjdDIvc2VsZWN0MlxcXCI6IHtcXG4gICAgICAgICAgICBkZXBzOiBbXFxcImpxdWVyeVxcXCIsIFxcXCJoZWxwZXJzL3VzZXJfYWdlbnRcXFwiLCBcXFwiY3NzIWNvbnRyaWIvc2VsZWN0Mi0zLjQuNi9zZWxlY3QyLmNzc1xcXCIsIFxcXCJ2aWV3cy9zaGFyZWQvcGNzcy9zZWxlY3QyLnBjc3NcXFwiXSxcXG4gICAgICAgICAgICBleHBvcnRzOiBcXFwiU2VsZWN0MlxcXCIsXFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oJCwgVXNlckFnZW50KSB7XFxuICAgICAgICAgICAgICAgIHZhciBTZWxlY3QyID0gdGhpcy5TZWxlY3QyO1xcbiAgICAgICAgICAgICAgICBTZWxlY3QyLmNsYXNzLnNpbmdsZS5wcm90b3R5cGUuZ2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgcGxhY2Vob2xkZXIgaXMgc3BlY2lmaWVkIG9uIGEgc2luZ2xlIHNlbGVjdCB3aXRob3V0IGEgdmFsaWQgcGxhY2Vob2xkZXIgb3B0aW9uIGlnbm9yZSBpdFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UGxhY2Vob2xkZXJPcHRpb24oKSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlbGVjdDIvc2VsZWN0Mi9pc3N1ZXMvMzMwMFxcbiAgICAgICAgICAgICAgICAgICAgLy8gU1BMLTExMTg5NSwgU1BMLTExMjg4NiwgZGlzYWJsZSBwbGFjZWhvbGRlciBmb3IgSUUgPD0gMTFcXG4gICAgICAgICAgICAgICAgICAgIGlmIChVc2VyQWdlbnQuaXNJRUxlc3NUaGFuKDEyKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VsZWN0Mi5jbGFzcy5hYnN0cmFjdC5wcm90b3R5cGUuZ2V0UGxhY2Vob2xkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlbGVjdDI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qIFNUQVJUIGNvbnRyaWIgalF1ZXJ5IHBsdWdpbnMgKi9cXG4gICAgICAgICdqcXVlcnkuY29va2llJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J11cXG4gICAgICAgIH0sXFxuICAgICAgICAgJ2pxdWVyeS5maWxldXBsb2FkJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J11cXG4gICAgICAgIH0sXFxuICAgICAgICAnanF1ZXJ5LmlmcmFtZS10cmFuc3BvcnQnOiB7XFxuICAgICAgICBcXHRkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2pxdWVyeS5oaXN0b3J5Jzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J10sXFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6ICdIaXN0b3J5J1xcbiAgICAgICAgfSxcXG4gICAgICAgICdqcXVlcnkuYmdpZnJhbWUnOiB7XFxuICAgICAgICAgICAgZGVwczogWydqcXVlcnknXVxcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIFxcXCJqcXVlcnkuYXR0cmlidXRlc1xcXCI6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcblxcbiAgICAgICAgXFxcImpxdWVyeS5zcGluXFxcIjoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J11cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICBcXFwianF1ZXJ5LnNwYXJrbGluZVxcXCI6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcblxcbiAgICAgICAgXFxcImpxdWVyeS5kZXBhcmFtXFxcIjoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J10sXFxuICAgICAgICAgICAgZXhwb3J0czogXFxcImpRdWVyeS5mbi5kZXBhcmFtXFxcIlxcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qIFNUQVJUIGludGVybmFsIGpRdWVyeSBwbHVnaW5zICovXFxuICAgICAgICAnc3BsdW5rLmpxdWVyeS5jc3JmX3Byb3RlY3Rpb24nOiB7XFxuICAgICAgICAgICAgZGVwczogWydqcXVlcnkuY29va2llJywgJ3NwbHVuay51dGlsJ11cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKiBTVEFSVCBqUXVlcnkgVUkgcGx1Z2lucyAqL1xcbiAgICAgICAgJ2pxdWVyeS51aS5jb3JlJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J11cXG4gICAgICAgIH0sXFxuICAgICAgICAnanF1ZXJ5LnVpLndpZGdldCc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeS51aS5jb3JlJ11cXG4gICAgICAgIH0sXFxuICAgICAgICAnanF1ZXJ5LnVpLnBvc2l0aW9uJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5LnVpLndpZGdldCddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2pxdWVyeS51aS5tb3VzZSc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeS51aS53aWRnZXQnXVxcbiAgICAgICAgfSxcXG4gICAgICAgICdqcXVlcnkudWkuc29ydGFibGUnOiB7XFxuICAgICAgICAgICAgZGVwczogWydqcXVlcnkudWkud2lkZ2V0JywgJ2pxdWVyeS51aS5tb3VzZScsICdqcXVlcnkudWkuZHJhZ2dhYmxlJywgJ2pxdWVyeS51aS5kcm9wcGFibGUnXVxcbiAgICAgICAgfSxcXG4gICAgICAgICdqcXVlcnkudWkuZHJhZ2dhYmxlJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5LnVpLndpZGdldCcsICdqcXVlcnkudWkubW91c2UnXVxcbiAgICAgICAgfSxcXG4gICAgICAgICdqcXVlcnkudWkuZHJvcHBhYmxlJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5LnVpLndpZGdldCcsICdqcXVlcnkudWkubW91c2UnXVxcbiAgICAgICAgfSxcXG4gICAgICAgICdqcXVlcnkudWkucmVzaXphYmxlJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5LnVpLndpZGdldCcsICdqcXVlcnkudWkubW91c2UnXVxcbiAgICAgICAgfSxcXG4gICAgICAgICdqcXVlcnkudWkuZGF0ZXBpY2tlcic6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeScsICdqcXVlcnkudWkud2lkZ2V0JywgJ3NwbHVuay5pMThuJ10sXFxuICAgICAgICAgICAgZXhwb3J0czogJ2pxdWVyeS51aS5kYXRlcGlja2VyJyxcXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihqUXVlcnksIHdpZGdldCwgaTE4bikge1xcbiAgICAgICAgICAgICAgICB2YXIgaW5pdEZuID0gaTE4bi5qUXVlcnlfdWlfZGF0ZXBpY2tlcl9pbnN0YWxsO1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluaXRGbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgICAgICAgICAgaW5pdEZuKGpRdWVyeSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS51aS5kYXRlcGlja2VyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICAnanF1ZXJ5LnVpLmJ1dHRvbic6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeS51aS53aWRnZXQnLCAnanF1ZXJ5LnVpLmNvcmUnXVxcbiAgICAgICAgfSxcXG4gICAgICAgICdqcXVlcnkudWkuc3Bpbm5lcic6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeS51aS53aWRnZXQnLCAnanF1ZXJ5LnVpLmNvcmUnLCAnanF1ZXJ5LnVpLmJ1dHRvbiddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2pxdWVyeS51aS5lZmZlY3QnOiB7XFxuICAgICAgICAgICAgZGVwczogWydqcXVlcnkudWkuY29yZSddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2pxdWVyeS51aS5lZmZlY3Qtc2xpZGUnOiB7XFxuICAgICAgICAgICAgZGVwczogWydqcXVlcnkudWkuY29yZScsICdqcXVlcnkudWkuZWZmZWN0J11cXG4gICAgICAgIH0sXFxuICAgICAgICAndHJlZS5qcXVlcnknOiB7XFxuICAgICAgICAgICAgZGVwczogWydqcXVlcnknXVxcbiAgICAgICAgfSxcXG4gICAgICAgICdqcXVlcnkucmVzaXplJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J10sXFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oJCkge1xcbiAgICAgICAgICAgICAgICAvLyBUaGUgcGx1Z2luIGl0c2VsZiBkb2VzIG5vdCBwcmV2ZW50IGJ1YmJsaW5nIG9mIHRoZSByZXNpemUgZXZlbnRzLCBhZGQgdGhhdCBoZXJlLlxcbiAgICAgICAgICAgICAgICAkLmV2ZW50LnNwZWNpYWwuZWxlbWVudFJlc2l6ZS5ub0J1YmJsZSA9IHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8vIGJvb3RzdHJhcCBjb21wb25lbnRzXFxuICAgICAgICAnYm9vdHN0cmFwLmFmZml4Jzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J11cXG4gICAgICAgIH0sXFxuICAgICAgICAnYm9vdHN0cmFwLmFsZXJ0Jzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J11cXG4gICAgICAgIH0sXFxuICAgICAgICAnYm9vdHN0cmFwLmJ1dHRvbic6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2Jvb3RzdHJhcC5jYXJvdXNlbCc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2Jvb3RzdHJhcC5jb2xsYXBzZSc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeScsICdib290c3RyYXAudHJhbnNpdGlvbiddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2Jvb3RzdHJhcC5kcm9wZG93bic6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2Jvb3RzdHJhcC5tb2RhbCc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2Jvb3RzdHJhcC5wb3BvdmVyJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5JywgJ2Jvb3RzdHJhcC50b29sdGlwJ11cXG4gICAgICAgIH0sXFxuICAgICAgICAnYm9vdHN0cmFwLnNjcm9sbHNweSc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2Jvb3RzdHJhcC50YWInOiB7XFxuICAgICAgICAgICAgZGVwczogWydqcXVlcnknXVxcbiAgICAgICAgfSxcXG4gICAgICAgICdib290c3RyYXAudG9vbHRpcCc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ2Jvb3RzdHJhcC50cmFuc2l0aW9uJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5J11cXG4gICAgICAgIH0sXFxuICAgICAgICAnYm9vdHN0cmFwLnR5cGVhaGVhZCc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyogU1RBUlQgb3RoZXIgY29udHJpYiBsaWJyYXJpZXMgKi9cXG4gICAgICAgIFxcXCJiYWNrYm9uZS5uZXN0ZWRcXFwiOiB7XFxuICAgICAgICAgICAgLy8gTm90IHN1cmUgaWYgbmVlZGVkXFxuICAgICAgICAgICAgZGVwczogWydiYWNrYm9uZSddLFxcbiAgICAgICAgICAgIGV4cG9ydHM6ICdCYWNrYm9uZS5OZXN0ZWRNb2RlbCdcXG4gICAgICAgIH0sXFxuICAgICAgICBoaWdoY2hhcnRzOiB7XFxuICAgICAgICAgICAgZGVwczogWydqcXVlcnknLCAnc3BsdW5rJ10sXFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oJCwgU3BsdW5rKSB7XFxuICAgICAgICAgICAgICAgIHZhciBIaWdoY2hhcnRzID0gU3BsdW5rLkhpZ2hjaGFydHMgPSB0aGlzLkhpZ2hjaGFydHM7XFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBIaWdoY2hhcnRzIGZyb20gdGhlIGdsb2JhbCBuYW1lc3BhY2Ugc28gbXVsdGlwbGUgdmVyc2lvbnMgY2FuXFxuICAgICAgICAgICAgICAgIC8vIGNvLWV4aXN0IG9uIHRoZSBzYW1lIHBhZ2UuICBBcyBhIHNhZmV0eSBtZWFzdXJlIGluIGNhc2UgZXhpc3RpbmcgZXh0ZXJuYWxcXG4gICAgICAgICAgICAgICAgLy8gY29kZSByZWxpZXMgb24gdGhpcyBnbG9iYWwsIGl0IGlzIHN0aWxsIGF2YWlsYWJsZSBhcyBgU3BsdW5rLkhpZ2hjaGFydHNgLlxcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5IaWdoY2hhcnRzO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gSGlnaGNoYXJ0cztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgcHJldHRpZnk6IHtcXG4gICAgICAgICAgICBleHBvcnRzOiAncHJldHR5UHJpbnQnXFxuICAgICAgICB9LFxcbiAgICAgICAgbGVhZmxldDoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5JywgJ3NwbHVuay51dGlsJywgJ3NwbHVuay5jb25maWcnLCAnaGVscGVycy91c2VyX2FnZW50JywgJ2NvbnRyaWIvdGV4dCFjb250cmliL2xlYWZsZXQvbGVhZmxldC5jc3MnXSxcXG4gICAgICAgICAgICBleHBvcnRzOiAnTCcsXFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oJCwgU3BsdW5rVXRpbCwgc3BsdW5rQ29uZmlnLCB1c2VyQWdlbnQsIGNzcykge1xcbiAgICAgICAgICAgICAgICBpZiAoc3BsdW5rQ29uZmlnLklOREVQRU5ERU5UX01PREUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVVybCA9IHJlcXVpcmUudG9VcmwoJycpICsgJ3NwbHVua2pzL2NvbnRyaWIvbGVhZmxldC9pbWFnZXMnO1xcbiAgICAgICAgICAgICAgICAgICAgY3NzID0gY3NzLnJlcGxhY2UoL3VybFxcXFwoaW1hZ2VzL2csICd1cmwoJyArIGltYWdlVXJsKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgaW1hZ2UgdXJsc1xcbiAgICAgICAgICAgICAgICAgICAgY3NzID0gY3NzLnJlcGxhY2UoL3VybFxcXFwoaW1hZ2VzL2csIFxcXCJ1cmwoXFxcIiArIFNwbHVua1V0aWwubWFrZV91cmwoXFxcIi9zdGF0aWMvanMvY29udHJpYi9sZWFmbGV0L2ltYWdlc1xcXCIpKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBpbmplY3QgY3NzIGludG8gaGVhZFxcbiAgICAgICAgICAgICAgICAkKFxcXCJoZWFkXFxcIikuYXBwZW5kKFxcXCI8c3R5bGUgdHlwZT1cXFxcXFxcInRleHQvY3NzXFxcXFxcXCI+XFxcIiArIGNzcyArIFxcXCI8L3N0eWxlPlxcXCIpO1xcblxcbiAgICAgICAgICAgICAgICAvLyBTUEwtOTg2NDc6IG1vbmtleSBwYXRjaCB0aGUgZ2V0UGFyYW1TdHJpbmcgbWV0aG9kIHRvIGF2b2lkIGFuIFhTUyB2dWxuZXJhYmlsaXR5IGluIG91clxcbiAgICAgICAgICAgICAgICAvLyB2ZXJzaW9uIG9mIExlYWZsZXQuXFxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L3B1bGwvMTMxNy9maWxlc1xcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5MICYmIHRoaXMuTC5VdGlsKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkwuVXRpbC5nZXRQYXJhbVN0cmluZyA9IGZ1bmN0aW9uKG9iaiwgZXhpc3RpbmdVcmwpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpIGluIG9iaikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XFxuICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGpnX2dsb2JhbDoge1xcbiAgICAgICAgICAgIC8vIGV4cG9ydCB0aGUgZGljdGlvbmFyeSBvZiBmdW5jdGlvbnMgdG8gYSBkaWZmZXJlbnQgdmFyaWFibGUsIHNpbmNlIGluIFxcXCJ3cmFwU2hpbVxcXCIgbW9kZSByZXF1aXJlIHdpbGxcXG4gICAgICAgICAgICAvLyBhc3NpZ24gdGhlIHJldHVybiB2YWx1ZSBmcm9tIGluaXQgdG8gdGhhdCBnbG9iYWwuXFxuICAgICAgICAgICAgZXhwb3J0czogJ2pnX2dsb2JhbHMnLFxcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLmpnX2dsb2JhbHMgPSB7XFxuICAgICAgICAgICAgICAgICAgICBqZ19uYW1lc3BhY2U6IHRoaXMuamdfbmFtZXNwYWNlLFxcbiAgICAgICAgICAgICAgICAgICAgamdfZXh0ZW5kOiB0aGlzLmpnX2V4dGVuZCxcXG4gICAgICAgICAgICAgICAgICAgIGpnX3N0YXRpYzogdGhpcy5qZ19zdGF0aWMsXFxuICAgICAgICAgICAgICAgICAgICBqZ19taXhpbjogdGhpcy5qZ19taXhpbixcXG4gICAgICAgICAgICAgICAgICAgIGpnX2hhc19taXhpbjogdGhpcy5qZ19oYXNfbWl4aW5cXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuamdfZ2xvYmFscztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgamdhdHQ6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pnX2dsb2JhbCddLFxcbiAgICAgICAgICAgIGV4cG9ydHM6ICdqZ2F0dCdcXG4gICAgICAgIH0sXFxuICAgICAgICBsb3dwcm86IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeSddXFxuICAgICAgICB9LFxcbiAgICAgICAgJ3NheCc6IHtcXG4gICAgICAgICAgICBleHBvcnRzOiAnc2F4J1xcbiAgICAgICAgfSxcXG4gICAgICAgICdhY2UvYWNlJzoge1xcbiAgICAgICAgICAgIGV4cG9ydHM6ICdhY2UnXFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyogU3RhcnQgU3BsdW5rIGxlZ2FjeSAqL1xcbiAgICAgICAgc3BsdW5rOiB7XFxuICAgICAgICAgICAgZXhwb3J0czogJ1NwbHVuaydcXG4gICAgICAgIH0sXFxuICAgICAgICAnc3BsdW5rLnV0aWwnOiB7XFxuICAgICAgICAgICAgZGVwczogWydqcXVlcnknLCAnc3BsdW5rJywgJ3NwbHVuay5jb25maWcnLCAndXRpbC9zcHJpbnRmJ10sXFxuICAgICAgICAgICAgZXhwb3J0czogJ1NwbHVuay51dGlsJyxcXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbigkLCBTcGx1bmssIGNvbmZpZywgc3ByaW50Zikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5leHRlbmQoeyBzcHJpbnRmOiBzcHJpbnRmIH0sIFNwbHVuay51dGlsKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgJ3V0aWwvc3ByaW50Zic6IHtcXG4gICAgICAgICAgICBleHBvcnRzOiAnc3ByaW50ZidcXG4gICAgICAgIH0sXFxuICAgICAgICAnc3BsdW5rLmxlZ2VuZCc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ3NwbHVuayddLFxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiAnU3BsdW5rLkxlZ2VuZCdcXG4gICAgICAgIH0sXFxuICAgICAgICAnc3BsdW5rLmxvZ2dlcic6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ3NwbHVuaycsICdzcGx1bmsudXRpbCddLFxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiAnU3BsdW5rLkxvZ2dlcidcXG4gICAgICAgIH0sXFxuICAgICAgICAnc3BsdW5rLmVycm9yJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5JywgJ3NwbHVuaycsICdzcGx1bmsubG9nZ2VyJ10sXFxuICAgICAgICAgICAgZXhwb3J0czogJ1NwbHVuay5FcnJvcidcXG4gICAgICAgIH0sXFxuICAgICAgICAnc3BsdW5rLnBkZic6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ3NwbHVuaycsICdzcGx1bmsudXRpbCcsICdqcXVlcnknXSxcXG4gICAgICAgICAgICBleHBvcnRzOiAnU3BsdW5rLnBkZidcXG4gICAgICAgIH0sXFxuICAgICAgICBzdHJmdGltZToge1xcbiAgICAgICAgICAgIGRlcHM6IFtdXFxuICAgICAgICB9LFxcbiAgICAgICAgJ3NwbHVuay5wYWdpbmF0b3InOiB7XFxuICAgICAgICAgICAgZGVwczogWydzcGx1bmsnXSxcXG4gICAgICAgICAgICAgICAgZXhwb3J0czogJ1NwbHVuay5wYWdpbmF0b3InXFxuICAgICAgICB9LFxcbiAgICAgICAgJ3NwbHVuay5qcXVlcnkuY3NyZic6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pxdWVyeScsICdqcXVlcnkuY29va2llJywgJ3NwbHVuay51dGlsJ11cXG4gICAgICAgIH0sXFxuICAgICAgICAnc3BsdW5rLm1lc3Nlbmdlcic6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ3NwbHVuaycsICdzcGx1bmsudXRpbCcsICdzcGx1bmsubG9nZ2VyJywgJ3NwbHVuay5pMThuJywgJ2xvd3BybyddLFxcbiAgICAgICAgICAgIGV4cG9ydHM6ICdTcGx1bmsuTWVzc2VuZ2VyJ1xcbiAgICAgICAgfSxcXG4gICAgICAgICdzcGx1bmsudGltZSc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ2pnX2dsb2JhbCcsICdqZ2F0dCddLFxcbiAgICAgICAgICAgIGV4cG9ydHM6ICdzcGx1bmsudGltZSdcXG4gICAgICAgIH0sXFxuICAgICAgICAnc3BsdW5rLnRpbWVyYW5nZSc6IHtcXG4gICAgICAgICAgICBkZXBzOiBbJ3NwbHVuaycsICdzcGx1bmsudXRpbCcsICdzcGx1bmsubG9nZ2VyJywgJ3NwbHVuay5pMThuJywgJ3NwbHVuay50aW1lJywgJ2xvd3BybyddLFxcbiAgICAgICAgICAgIGV4cG9ydHM6ICdTcGx1bmsuVGltZXJhbmdlJyxcXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihTcGx1bmspIHtcXG4gICAgICAgICAgICAgICAgU3BsdW5rLm5hbWVzcGFjZShcXFwiR2xvYmFsc1xcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoIVNwbHVuay5HbG9iYWxzLnRpbWVab25lKSB7XFxuICAgICAgICAgICAgICAgICAgICBTcGx1bmsuR2xvYmFscy50aW1lWm9uZSA9IG5ldyBTcGx1bmsuVGltZVpvbmUoU3BsdW5rLnV0aWwuZ2V0Q29uZmlnVmFsdWUoJ1NFUlZFUl9aT05FSU5GTycpKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gU3BsdW5rLlRpbWVSYW5nZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgJ3NwbHVuay53aW5kb3cnOiB7XFxuICAgICAgICAgICAgZGVwczogWydzcGx1bmsnLCAnc3BsdW5rLnV0aWwnLCAnc3BsdW5rLmkxOG4nXSxcXG4gICAgICAgICAgICBleHBvcnRzOiAnU3BsdW5rLndpbmRvdydcXG4gICAgICAgIH0sXFxuICAgICAgICAnc3BsdW5rLmphYnJpZGdlJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnc3BsdW5rJ10sXFxuICAgICAgICAgICAgZXhwb3J0czogJ1NwbHVuay5KQUJyaWRnZSdcXG4gICAgICAgIH0sXFxuICAgICAgICAnc3BsdW5rLnByaW50Jzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnanF1ZXJ5JywgJ2xvd3BybycsICdzcGx1bmsnLCAnc3BsdW5rLmxvZ2dlciddLFxcbiAgICAgICAgICAgIGV4cG9ydHM6ICdTcGx1bmsuUHJpbnQnXFxuICAgICAgICB9LFxcbiAgICAgICAgJ3NwbHVuay5zZXNzaW9uJzoge1xcbiAgICAgICAgICAgIGRlcHM6IFsnbG93cHJvJywgJ3NwbHVuaycsICdqcXVlcnknLCAnc3BsdW5rLmxvZ2dlcicsICdzcGx1bmsudXRpbCddLFxcbiAgICAgICAgICAgIGV4cG9ydHM6ICdTcGx1bmsuU2Vzc2lvbidcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvLyBzaGltIGhhbmRsZXJzIGZvciB0aGUgdmFyaW91cyB2ZXJzaW9ucyBvZiBqcXVlcnlcXG5cXG4gICAgICAgICdjb250cmliL2pxdWVyeS0yLjEuMCc6IHtcXG4gICAgICAgICAgICBleHBvcnRzOiAnalF1ZXJ5J1xcbiAgICAgICAgfSxcXG4gICAgICAgICdjb250cmliL2pxdWVyeS0xLjEwLjInOiB7XFxuICAgICAgICAgICAgZXhwb3J0czogJ2pRdWVyeScsXFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uc29sZSAmJiB0eXBlb2YgdGhpcy5jb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc29sZS53YXJuKCdZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCB2ZXJzaW9uIG9mIGpRdWVyeSwgcGxlYXNlIHVwZ3JhZGUgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMualF1ZXJ5O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICAnY29udHJpYi9qcXVlcnktMS44LjInOiB7XFxuICAgICAgICAgICAgZXhwb3J0czogJ2pRdWVyeScsXFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uc29sZSAmJiB0eXBlb2YgdGhpcy5jb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc29sZS53YXJuKCdZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCB2ZXJzaW9uIG9mIGpRdWVyeSwgcGxlYXNlIHVwZ3JhZGUgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMualF1ZXJ5O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICAnY29udHJpYi9qcXVlcnktMS44LjMnOiB7XFxuICAgICAgICAgICAgZXhwb3J0czogJ2pRdWVyeScsXFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uc29sZSAmJiB0eXBlb2YgdGhpcy5jb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc29sZS53YXJuKCdZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCB2ZXJzaW9uIG9mIGpRdWVyeSwgcGxlYXNlIHVwZ3JhZGUgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMualF1ZXJ5O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbn0pXFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvcHJvZmlsZXMvc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "util/console":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(\"shim/jquery\"),\n            __webpack_require__(\"require/underscore\"),\n            __webpack_require__(\"util/console_dev\"),\n            __webpack_require__(\"shim/splunk.logger\"),\n            __webpack_require__(\"shim/splunk.util\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n            $,\n            _,\n            devConsole,\n            SplunkLogger,\n            splunkUtils\n        ) {\n\n    var LOG_MODE = splunkUtils.getConfigValue(\"JS_LOGGER_MODE\", \"None\"),\n        LOG_LEVEL = splunkUtils.getConfigValue(\"JS_LOGGER_LEVEL\", \"INFO\"),\n        EMPTY = function() { };\n\n    if(LOG_MODE === 'Firebug') {\n        // if Function.prototype.bind is supported natively, we can use it to properly respect log levels\n        // if not, it would result in log statements having incorrect source file names, so don't do it\n        if(typeof devConsole.log.bind === 'function' && devConsole.log.bind.toString().indexOf('native code') > -1) {\n            return ({\n                trace: LOG_LEVEL === 'DEBUG' ? devConsole.trace.bind(devConsole) : EMPTY,\n                debug: LOG_LEVEL === 'DEBUG' ? devConsole.debug.bind(devConsole) : EMPTY,\n                log: LOG_LEVEL in { INFO: true, DEBUG: true } ? devConsole.log.bind(devConsole) : EMPTY,\n                info: LOG_LEVEL in { INFO: true, DEBUG: true } ? devConsole.info.bind(devConsole) : EMPTY,\n                warn: LOG_LEVEL !== 'ERROR' ? devConsole.warn.bind(devConsole) : EMPTY,\n                error: devConsole.error.bind(devConsole)\n            });\n        }\n        return devConsole;\n    }\n    return SplunkLogger.getLogger(splunkUtils.getConfigValue('USERNAME', '') + ':::' + window.location.href);\n\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvY29uc29sZS5qcz8zMDYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEI7QUFDN0Qsb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJmaWxlIjoidXRpbC9jb25zb2xlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcbiAgICAgICAgICAgICdqcXVlcnknLFxuICAgICAgICAgICAgJ3VuZGVyc2NvcmUnLFxuICAgICAgICAgICAgJ3V0aWwvY29uc29sZV9kZXYnLFxuICAgICAgICAgICAgJ3NwbHVuay5sb2dnZXInLFxuICAgICAgICAgICAgJ3NwbHVuay51dGlsJ1xuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbihcbiAgICAgICAgICAgICQsXG4gICAgICAgICAgICBfLFxuICAgICAgICAgICAgZGV2Q29uc29sZSxcbiAgICAgICAgICAgIFNwbHVua0xvZ2dlcixcbiAgICAgICAgICAgIHNwbHVua1V0aWxzXG4gICAgICAgICkge1xuXG4gICAgdmFyIExPR19NT0RFID0gc3BsdW5rVXRpbHMuZ2V0Q29uZmlnVmFsdWUoXCJKU19MT0dHRVJfTU9ERVwiLCBcIk5vbmVcIiksXG4gICAgICAgIExPR19MRVZFTCA9IHNwbHVua1V0aWxzLmdldENvbmZpZ1ZhbHVlKFwiSlNfTE9HR0VSX0xFVkVMXCIsIFwiSU5GT1wiKSxcbiAgICAgICAgRU1QVFkgPSBmdW5jdGlvbigpIHsgfTtcblxuICAgIGlmKExPR19NT0RFID09PSAnRmlyZWJ1ZycpIHtcbiAgICAgICAgLy8gaWYgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgaXMgc3VwcG9ydGVkIG5hdGl2ZWx5LCB3ZSBjYW4gdXNlIGl0IHRvIHByb3Blcmx5IHJlc3BlY3QgbG9nIGxldmVsc1xuICAgICAgICAvLyBpZiBub3QsIGl0IHdvdWxkIHJlc3VsdCBpbiBsb2cgc3RhdGVtZW50cyBoYXZpbmcgaW5jb3JyZWN0IHNvdXJjZSBmaWxlIG5hbWVzLCBzbyBkb24ndCBkbyBpdFxuICAgICAgICBpZih0eXBlb2YgZGV2Q29uc29sZS5sb2cuYmluZCA9PT0gJ2Z1bmN0aW9uJyAmJiBkZXZDb25zb2xlLmxvZy5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZignbmF0aXZlIGNvZGUnKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICB0cmFjZTogTE9HX0xFVkVMID09PSAnREVCVUcnID8gZGV2Q29uc29sZS50cmFjZS5iaW5kKGRldkNvbnNvbGUpIDogRU1QVFksXG4gICAgICAgICAgICAgICAgZGVidWc6IExPR19MRVZFTCA9PT0gJ0RFQlVHJyA/IGRldkNvbnNvbGUuZGVidWcuYmluZChkZXZDb25zb2xlKSA6IEVNUFRZLFxuICAgICAgICAgICAgICAgIGxvZzogTE9HX0xFVkVMIGluIHsgSU5GTzogdHJ1ZSwgREVCVUc6IHRydWUgfSA/IGRldkNvbnNvbGUubG9nLmJpbmQoZGV2Q29uc29sZSkgOiBFTVBUWSxcbiAgICAgICAgICAgICAgICBpbmZvOiBMT0dfTEVWRUwgaW4geyBJTkZPOiB0cnVlLCBERUJVRzogdHJ1ZSB9ID8gZGV2Q29uc29sZS5pbmZvLmJpbmQoZGV2Q29uc29sZSkgOiBFTVBUWSxcbiAgICAgICAgICAgICAgICB3YXJuOiBMT0dfTEVWRUwgIT09ICdFUlJPUicgPyBkZXZDb25zb2xlLndhcm4uYmluZChkZXZDb25zb2xlKSA6IEVNUFRZLFxuICAgICAgICAgICAgICAgIGVycm9yOiBkZXZDb25zb2xlLmVycm9yLmJpbmQoZGV2Q29uc29sZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXZDb25zb2xlO1xuICAgIH1cbiAgICByZXR1cm4gU3BsdW5rTG9nZ2VyLmdldExvZ2dlcihzcGx1bmtVdGlscy5nZXRDb25maWdWYWx1ZSgnVVNFUk5BTUUnLCAnJykgKyAnOjo6JyArIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvY29uc29sZS5qc1xuLy8gbW9kdWxlIGlkID0gdXRpbC9jb25zb2xlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "require/underscore":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"contrib/underscore\"), __webpack_require__(\"stubs/i18n\")], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, i18n) {\n    // use underscore's mixin functionality to add the ability to localize a string\n    _.mixin({\n        t: function(string) {\n            return i18n._(string);\n        }\n    });\n\n    return _.noConflict();\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3JlcXVpcmUvdW5kZXJzY29yZS5qcz80OGQ2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQyIsImZpbGUiOiJyZXF1aXJlL3VuZGVyc2NvcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydjb250cmliL3VuZGVyc2NvcmUnLCAnc3BsdW5rLmkxOG4nXSwgZnVuY3Rpb24oXywgaTE4bikge1xuICAgIC8vIHVzZSB1bmRlcnNjb3JlJ3MgbWl4aW4gZnVuY3Rpb25hbGl0eSB0byBhZGQgdGhlIGFiaWxpdHkgdG8gbG9jYWxpemUgYSBzdHJpbmdcbiAgICBfLm1peGluKHtcbiAgICAgICAgdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gaTE4bi5fKHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBfLm5vQ29uZmxpY3QoKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9yZXF1aXJlL3VuZGVyc2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IHJlcXVpcmUvdW5kZXJzY29yZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/underscore":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.6.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.6.0';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return obj;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, length = obj.length; i < length; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results.push(iterator.call(context, value, index, list));\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !predicate.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    var result = -Infinity, lastComputed = -Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed > lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    var result = Infinity, lastComputed = Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed < lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Shuffle an array, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return value;\n    return _.property(value);\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iterator, context) {\n      var result = {};\n      iterator = lookupIterator(iterator);\n      each(obj, function(value, index) {\n        var key = iterator.call(context, value, index, obj);\n        behavior(result, key, value);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, key, value) {\n    _.has(result, key) ? result[key].push(value) : result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, key, value) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, key) {\n    _.has(result, key) ? result[key]++ : result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    each(input, function(value) {\n      if (_.isArray(value) || _.isArguments(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Split an array into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(array, predicate, context) {\n    predicate = lookupIterator(predicate);\n    var pass = [], fail = [];\n    each(array, function(elem) {\n      (predicate.call(context, elem) ? pass : fail).push(elem);\n    });\n    return [pass, fail];\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.contains(other, item);\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var length = _.max(_.pluck(arguments, 'length').concat(0));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, '' + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(length);\n\n    while(idx < length) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) throw new Error('bindAll must be passed function names');\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n      if (last < wait) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] === void 0) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))\n                        && ('constructor' in a && 'constructor' in b)) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (true) {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function () {\n      return value;\n    };\n  };\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    return function(obj) {\n      if (obj === attrs) return true; //avoid comparing an object to itself.\n      for (var key in attrs) {\n        if (attrs[key] !== obj[key])\n          return false;\n      }\n      return true;\n    }\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(Math.max(0, n));\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() { return new Date().getTime(); };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n  // NOTE: this file has been patched so that Underscore defines itself as an\n  // anonymous AMD module.  This allows us to create a wrapper module called \"underscore\"\n  // that adds mixin functionality and enforces no-conflict mode.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n      return _;\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}).call(this);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvdW5kZXJzY29yZS5qcz9lM2NhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQ0FBaUMsRUFBRTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEIsRUFBRTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0IsRUFBRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsNkJBQTZCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4QkFBOEIsRUFBRTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQjs7QUFFakI7QUFDQSxrREFBa0QsRUFBRSxpQkFBaUI7O0FBRXJFO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RCwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFLGlCQUFpQjs7QUFFdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMiLCJmaWxlIjoiY29udHJpYi91bmRlcnNjb3JlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgIFVuZGVyc2NvcmUuanMgMS42LjBcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgb2JqZWN0IHRoYXQgZ2V0cyByZXR1cm5lZCB0byBicmVhayBvdXQgb2YgYSBsb29wIGl0ZXJhdGlvbi5cbiAgdmFyIGJyZWFrZXIgPSB7fTtcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgY29uY2F0ICAgICAgICAgICA9IEFycmF5UHJvdG8uY29uY2F0LFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVGb3JFYWNoICAgICAgPSBBcnJheVByb3RvLmZvckVhY2gsXG4gICAgbmF0aXZlTWFwICAgICAgICAgID0gQXJyYXlQcm90by5tYXAsXG4gICAgbmF0aXZlUmVkdWNlICAgICAgID0gQXJyYXlQcm90by5yZWR1Y2UsXG4gICAgbmF0aXZlUmVkdWNlUmlnaHQgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodCxcbiAgICBuYXRpdmVGaWx0ZXIgICAgICAgPSBBcnJheVByb3RvLmZpbHRlcixcbiAgICBuYXRpdmVFdmVyeSAgICAgICAgPSBBcnJheVByb3RvLmV2ZXJ5LFxuICAgIG5hdGl2ZVNvbWUgICAgICAgICA9IEFycmF5UHJvdG8uc29tZSxcbiAgICBuYXRpdmVJbmRleE9mICAgICAgPSBBcnJheVByb3RvLmluZGV4T2YsXG4gICAgbmF0aXZlTGFzdEluZGV4T2YgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZixcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kO1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcbiAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgXCJhZHZhbmNlZFwiIG1vZGUuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuNi4wJztcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIG9iamVjdHMgd2l0aCB0aGUgYnVpbHQtaW4gYGZvckVhY2hgLCBhcnJheXMsIGFuZCByYXcgb2JqZWN0cy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZvckVhY2hgIGlmIGF2YWlsYWJsZS5cbiAgdmFyIGVhY2ggPSBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0b3IgdG8gZWFjaCBlbGVtZW50LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBpZiAobmF0aXZlTWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkgcmV0dXJuIG9iai5tYXAoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJlc3VsdHMucHVzaChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIHZhciByZWR1Y2VFcnJvciA9ICdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJztcblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VgIGlmIGF2YWlsYWJsZS5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICBpZiAoY29udGV4dCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGluaXRpYWwgPyBvYmoucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2UoaXRlcmF0b3IpO1xuICAgIH1cbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IHZhbHVlO1xuICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZVJpZ2h0YCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlUmlnaHQgJiYgb2JqLnJlZHVjZVJpZ2h0ID09PSBuYXRpdmVSZWR1Y2VSaWdodCkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvcik7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09ICtsZW5ndGgpIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaW5kZXggPSBrZXlzID8ga2V5c1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gb2JqW2luZGV4XTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaW5kZXhdLCBpbmRleCwgbGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGFueShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZpbHRlcmAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZUZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHJldHVybiBvYmouZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgIH0sIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZXZlcnlgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlRXZlcnkgJiYgb2JqLmV2ZXJ5ID09PSBuYXRpdmVFdmVyeSkgcmV0dXJuIG9iai5ldmVyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmICghKHJlc3VsdCA9IHJlc3VsdCAmJiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgc29tZWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICB2YXIgYW55ID0gXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlU29tZSAmJiBvYmouc29tZSA9PT0gbmF0aXZlU29tZSkgcmV0dXJuIG9iai5zb21lKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHJlc3VsdCB8fCAocmVzdWx0ID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBvYmouaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgcmV0dXJuIGFueShvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRhcmdldDtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgb3IgKGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICAvLyBDYW4ndCBvcHRpbWl6ZSBhcnJheXMgb2YgaW50ZWdlcnMgbG9uZ2VyIHRoYW4gNjUsNTM1IGVsZW1lbnRzLlxuICAvLyBTZWUgW1dlYktpdCBCdWcgODA3OTddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD04MDc5NylcbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2JqKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5O1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XG4gICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSAmJiBvYmoubGVuZ3RoIDwgNjU1MzUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBvYmopO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5O1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XG4gICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhbiBhcnJheSwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByYW5kO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNodWZmbGVkID0gW107XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oaW5kZXgrKyk7XG4gICAgICBzaHVmZmxlZFtpbmRleCAtIDFdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gXy5zaHVmZmxlKG9iaikuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbikpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGxvb2t1cCBpdGVyYXRvcnMuXG4gIHZhciBsb29rdXBJdGVyYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRvci5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRvciA9IGxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgXy5oYXMocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSkgOiByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIGtleSwgdmFsdWUpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCBrZXkpIHtcbiAgICBfLmhhcyhyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSsrIDogcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVttaWRdKSA8IHZhbHVlID8gbG93ID0gbWlkICsgMSA6IGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICBpZiAobiA8IDApIHJldHVybiBbXTtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aFxuICAvLyBgXy5tYXBgLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gKChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgTWF0aC5tYXgoYXJyYXkubGVuZ3RoIC0gbiwgMCkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqXG4gIC8vIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgb3V0cHV0KSB7XG4gICAgaWYgKHNoYWxsb3cgJiYgXy5ldmVyeShpbnB1dCwgXy5pc0FycmF5KSkge1xuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShvdXRwdXQsIGlucHV0KTtcbiAgICB9XG4gICAgZWFjaChpbnB1dCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgIHNoYWxsb3cgPyBwdXNoLmFwcGx5KG91dHB1dCwgdmFsdWUpIDogZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgb3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgW10pO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gU3BsaXQgYW4gYXJyYXkgaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gbG9va3VwSXRlcmF0b3IocHJlZGljYXRlKTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgZWFjaChhcnJheSwgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIGVsZW0pID8gcGFzcyA6IGZhaWwpLnB1c2goZWxlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0b3I7XG4gICAgICBpdGVyYXRvciA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGluaXRpYWwgPSBpdGVyYXRvciA/IF8ubWFwKGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkgOiBhcnJheTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZWFjaChpbml0aWFsLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGlmIChpc1NvcnRlZCA/ICghaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSB2YWx1ZSkgOiAhXy5jb250YWlucyhzZWVuLCB2YWx1ZSkpIHtcbiAgICAgICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShfLmZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmV2ZXJ5KHJlc3QsIGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBfLmNvbnRhaW5zKG90aGVyLCBpdGVtKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpOyB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBfLm1heChfLnBsdWNrKGFyZ3VtZW50cywgJ2xlbmd0aCcpLmNvbmNhdCgwKSk7XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRzW2ldID0gXy5wbHVjayhhcmd1bWVudHMsICcnICsgaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwbHkgdXMgd2l0aCBpbmRleE9mIChJJ20gbG9va2luZyBhdCB5b3UsICoqTVNJRSoqKSxcbiAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuXG4gIC8vIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBpbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpID0gKGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGlzU29ydGVkKSA6IGlzU29ydGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBhcnJheS5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtLCBpc1NvcnRlZCk7XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGxhc3RJbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGhhc0luZGV4ID0gZnJvbSAhPSBudWxsO1xuICAgIGlmIChuYXRpdmVMYXN0SW5kZXhPZiAmJiBhcnJheS5sYXN0SW5kZXhPZiA9PT0gbmF0aXZlTGFzdEluZGV4T2YpIHtcbiAgICAgIHJldHVybiBoYXNJbmRleCA/IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0sIGZyb20pIDogYXJyYXkubGFzdEluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIHZhciBpID0gKGhhc0luZGV4ID8gZnJvbSA6IGFycmF5Lmxlbmd0aCk7XG4gICAgd2hpbGUgKGktLSkgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlKGlkeCA8IGxlbmd0aCkge1xuICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldXNhYmxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBwcm90b3R5cGUgc2V0dGluZy5cbiAgdmFyIGN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcjtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICB2YXIgYXJncyA9IGJvdW5kQXJncy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0gPT09IF8pIGFyZ3NbaV0gPSBhcmd1bWVudHNbcG9zaXRpb24rK107XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbihmKSB7IG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7IH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW8gPSB7fTtcbiAgICBoYXNoZXIgfHwgKGhhc2hlciA9IF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpeyByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTsgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG4gICAgICBpZiAobGFzdCA8IHdhaXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGZvciAodmFyIGkgPSBmdW5jcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGFmdGVyIGJlaW5nIGNhbGxlZCBOIHRpbWVzLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgZWFjaChrZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIV8uY29udGFpbnMoa2V5cywga2V5KSkgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKG9ialtwcm9wXSA9PT0gdm9pZCAwKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09ICtiO1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT0gYjtcbiAgICB9XG4gICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgKGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcbiAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gYi5sZW5ndGg7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBlcShhW3NpemVdLCBiW3NpemVdLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChfLmhhcyhhLCBrZXkpKSB7XG4gICAgICAgICAgLy8gQ291bnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAgICAgaWYgKF8uaGFzKGIsIGtleSkgJiYgIShzaXplLS0pKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSAhc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cC5cbiAgZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLlxuICBpZiAodHlwZW9mICgvLi8pICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRvcnMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqID09PSBhdHRycykgcmV0dXJuIHRydWU7IC8vYXZvaWQgY29tcGFyaW5nIGFuIG9iamVjdCB0byBpdHNlbGYuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgZXNjYXBlOiB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjeDI3OydcbiAgICB9XG4gIH07XG4gIGVudGl0eU1hcC51bmVzY2FwZSA9IF8uaW52ZXJ0KGVudGl0eU1hcC5lc2NhcGUpO1xuXG4gIC8vIFJlZ2V4ZXMgY29udGFpbmluZyB0aGUga2V5cyBhbmQgdmFsdWVzIGxpc3RlZCBpbW1lZGlhdGVseSBhYm92ZS5cbiAgdmFyIGVudGl0eVJlZ2V4ZXMgPSB7XG4gICAgZXNjYXBlOiAgIG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxuICAgIHVuZXNjYXBlOiBuZXcgUmVnRXhwKCcoJyArIF8ua2V5cyhlbnRpdHlNYXAudW5lc2NhcGUpLmpvaW4oJ3wnKSArICcpJywgJ2cnKVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgXy5lYWNoKFsnZXNjYXBlJywgJ3VuZXNjYXBlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdCc6ICAgICAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdHxcXHUyMDI4fFxcdTIwMjkvZztcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcmVuZGVyO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAgIC5yZXBsYWNlKGVzY2FwZXIsIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTsgfSk7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyBcInJldHVybiBfX3A7XFxuXCI7XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChkYXRhKSByZXR1cm4gcmVuZGVyKGRhdGEsIF8pO1xuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24gc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVyLlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PSAnc2hpZnQnIHx8IG5hbWUgPT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICBfLmV4dGVuZChfLnByb3RvdHlwZSwge1xuXG4gICAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICAgIGNoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gTk9URTogdGhpcyBmaWxlIGhhcyBiZWVuIHBhdGNoZWQgc28gdGhhdCBVbmRlcnNjb3JlIGRlZmluZXMgaXRzZWxmIGFzIGFuXG4gIC8vIGFub255bW91cyBBTUQgbW9kdWxlLiAgVGhpcyBhbGxvd3MgdXMgdG8gY3JlYXRlIGEgd3JhcHBlciBtb2R1bGUgY2FsbGVkIFwidW5kZXJzY29yZVwiXG4gIC8vIHRoYXQgYWRkcyBtaXhpbiBmdW5jdGlvbmFsaXR5IGFuZCBlbmZvcmNlcyBuby1jb25mbGljdCBtb2RlLlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvdW5kZXJzY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi91bmRlcnNjb3JlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "stubs/i18n":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"contrib/strftime\"), __webpack_require__(\"shim/splunk.util\")], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\n    /*\n     * monkey patches to the i18n library\n     * see SPL-75565\n     */\n\n    // NOTE: this code block is duplicated in the util/test_i18n_patches.html unit test.\n    //       any changes made here must also be reflected there.\n    if(window.locale_name() in { ko_KR: true, zh_CN: true, zh_TW: true }) {\n        window._i18n_locale.date_formats['short'] = { \"pattern\": \"yy/MM/dd\", \"format\": \"%(yy)s/%(MM)s/%(dd)s\" };\n        window._i18n_locale.date_formats['medium'] = {\"pattern\": \"yyyy/MM/dd\", \"format\": \"%(yyyy)s/%(MM)s/%(dd)s\"};\n        window._i18n_locale.time_formats['short'] = { \"pattern\": \"H:mm\", \"format\": \"%(H)s:%(mm)s\" };\n        window._i18n_locale.time_formats['medium'] = { \"pattern\": \"H:mm:ss\", \"format\": \"%(H)s:%(mm)s:%(ss)s\" };\n    }\n\n    var asianLanguageDateReplacements = [\n        [/^ccc MMM d$/, 'M/d (ccc)'],\n        [/^YYYY-MM/, 'YYYY/MM'],\n        [/MM-dd/, 'MM/dd']\n    ];\n\n    // maintain a hash of locales where custom string replacements are needed to get correct translation\n    var FORMAT_DATE_REPLACEMENTS = {\n        'ja_JP': asianLanguageDateReplacements,\n        'ko_KR': asianLanguageDateReplacements,\n        'zh_CN': asianLanguageDateReplacements,\n        'zh_TW': asianLanguageDateReplacements\n    };\n\n    // maintain a list of replacements needed when a locale specifies that day comes before month\n    var DAY_FIRST_FORMATS = [\n        ['MMM d', 'd MMM']\n    ];\n\n    var oldFormatDate = window.format_date;\n    window.format_date = function(date, format) {\n        format = format || 'medium';\n        var i, replacements,\n            locale = window.locale_name();\n\n        if(format && (typeof format === 'string') && window.locale_uses_day_before_month()) {\n            replacements = DAY_FIRST_FORMATS;\n            for(i = 0; i < replacements.length; i++) {\n                format = format.replace(replacements[i][0], replacements[i][1]);\n            }\n        }\n        if(format && (typeof format === 'string') && locale in FORMAT_DATE_REPLACEMENTS) {\n            replacements = FORMAT_DATE_REPLACEMENTS[locale];\n\n            for(i = 0; i < replacements.length; i++) {\n                var replacement = replacements[i];\n                format = format.replace(replacement[0], replacement[1]);\n            }\n        }\n        return oldFormatDate(date, format);\n    };\n    \n    return ({\n        _: window.gettext,\n        ungettext: window.ungettext,\n        format_decimal: window.format_decimal,\n        format_number: window.format_number,\n        format_percent: window.format_percent,\n        format_scientific: window.format_scientific,\n        format_date: window.format_date,\n        format_datetime: window.format_datetime,\n        format_time: window.format_time,\n        format_datetime_microseconds: window.format_datetime_microseconds,\n        format_time_microseconds: window.format_time_microseconds,\n        locale_uses_day_before_month: window.locale_uses_day_before_month,\n        format_datetime_range: window.format_datetime_range,\n        locale_name: window.locale_name,\n        DateTime: window.DateTime,\n        moment_install: window.moment_install,\n        numeral_install: window.numeral_install,\n        jQuery_ui_datepicker_install: window.jQuery_ui_datepicker_install\n    });\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3N0dWJzL2kxOG4uanM/YzExMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyx3Q0FBd0M7QUFDeEUscURBQXFEO0FBQ3JELHNEQUFzRDtBQUN0RCxxREFBcUQ7QUFDckQsc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMiLCJmaWxlIjoic3R1YnMvaTE4bi5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbJ3N0cmZ0aW1lJywgJ3NwbHVuay51dGlsJ10sIGZ1bmN0aW9uKCkge1xuXG4gICAgLypcbiAgICAgKiBtb25rZXkgcGF0Y2hlcyB0byB0aGUgaTE4biBsaWJyYXJ5XG4gICAgICogc2VlIFNQTC03NTU2NVxuICAgICAqL1xuXG4gICAgLy8gTk9URTogdGhpcyBjb2RlIGJsb2NrIGlzIGR1cGxpY2F0ZWQgaW4gdGhlIHV0aWwvdGVzdF9pMThuX3BhdGNoZXMuaHRtbCB1bml0IHRlc3QuXG4gICAgLy8gICAgICAgYW55IGNoYW5nZXMgbWFkZSBoZXJlIG11c3QgYWxzbyBiZSByZWZsZWN0ZWQgdGhlcmUuXG4gICAgaWYod2luZG93LmxvY2FsZV9uYW1lKCkgaW4geyBrb19LUjogdHJ1ZSwgemhfQ046IHRydWUsIHpoX1RXOiB0cnVlIH0pIHtcbiAgICAgICAgd2luZG93Ll9pMThuX2xvY2FsZS5kYXRlX2Zvcm1hdHNbJ3Nob3J0J10gPSB7IFwicGF0dGVyblwiOiBcInl5L01NL2RkXCIsIFwiZm9ybWF0XCI6IFwiJSh5eSlzLyUoTU0pcy8lKGRkKXNcIiB9O1xuICAgICAgICB3aW5kb3cuX2kxOG5fbG9jYWxlLmRhdGVfZm9ybWF0c1snbWVkaXVtJ10gPSB7XCJwYXR0ZXJuXCI6IFwieXl5eS9NTS9kZFwiLCBcImZvcm1hdFwiOiBcIiUoeXl5eSlzLyUoTU0pcy8lKGRkKXNcIn07XG4gICAgICAgIHdpbmRvdy5faTE4bl9sb2NhbGUudGltZV9mb3JtYXRzWydzaG9ydCddID0geyBcInBhdHRlcm5cIjogXCJIOm1tXCIsIFwiZm9ybWF0XCI6IFwiJShIKXM6JShtbSlzXCIgfTtcbiAgICAgICAgd2luZG93Ll9pMThuX2xvY2FsZS50aW1lX2Zvcm1hdHNbJ21lZGl1bSddID0geyBcInBhdHRlcm5cIjogXCJIOm1tOnNzXCIsIFwiZm9ybWF0XCI6IFwiJShIKXM6JShtbSlzOiUoc3Mpc1wiIH07XG4gICAgfVxuXG4gICAgdmFyIGFzaWFuTGFuZ3VhZ2VEYXRlUmVwbGFjZW1lbnRzID0gW1xuICAgICAgICBbL15jY2MgTU1NIGQkLywgJ00vZCAoY2NjKSddLFxuICAgICAgICBbL15ZWVlZLU1NLywgJ1lZWVkvTU0nXSxcbiAgICAgICAgWy9NTS1kZC8sICdNTS9kZCddXG4gICAgXTtcblxuICAgIC8vIG1haW50YWluIGEgaGFzaCBvZiBsb2NhbGVzIHdoZXJlIGN1c3RvbSBzdHJpbmcgcmVwbGFjZW1lbnRzIGFyZSBuZWVkZWQgdG8gZ2V0IGNvcnJlY3QgdHJhbnNsYXRpb25cbiAgICB2YXIgRk9STUFUX0RBVEVfUkVQTEFDRU1FTlRTID0ge1xuICAgICAgICAnamFfSlAnOiBhc2lhbkxhbmd1YWdlRGF0ZVJlcGxhY2VtZW50cyxcbiAgICAgICAgJ2tvX0tSJzogYXNpYW5MYW5ndWFnZURhdGVSZXBsYWNlbWVudHMsXG4gICAgICAgICd6aF9DTic6IGFzaWFuTGFuZ3VhZ2VEYXRlUmVwbGFjZW1lbnRzLFxuICAgICAgICAnemhfVFcnOiBhc2lhbkxhbmd1YWdlRGF0ZVJlcGxhY2VtZW50c1xuICAgIH07XG5cbiAgICAvLyBtYWludGFpbiBhIGxpc3Qgb2YgcmVwbGFjZW1lbnRzIG5lZWRlZCB3aGVuIGEgbG9jYWxlIHNwZWNpZmllcyB0aGF0IGRheSBjb21lcyBiZWZvcmUgbW9udGhcbiAgICB2YXIgREFZX0ZJUlNUX0ZPUk1BVFMgPSBbXG4gICAgICAgIFsnTU1NIGQnLCAnZCBNTU0nXVxuICAgIF07XG5cbiAgICB2YXIgb2xkRm9ybWF0RGF0ZSA9IHdpbmRvdy5mb3JtYXRfZGF0ZTtcbiAgICB3aW5kb3cuZm9ybWF0X2RhdGUgPSBmdW5jdGlvbihkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICdtZWRpdW0nO1xuICAgICAgICB2YXIgaSwgcmVwbGFjZW1lbnRzLFxuICAgICAgICAgICAgbG9jYWxlID0gd2luZG93LmxvY2FsZV9uYW1lKCk7XG5cbiAgICAgICAgaWYoZm9ybWF0ICYmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykgJiYgd2luZG93LmxvY2FsZV91c2VzX2RheV9iZWZvcmVfbW9udGgoKSkge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnRzID0gREFZX0ZJUlNUX0ZPUk1BVFM7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCByZXBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShyZXBsYWNlbWVudHNbaV1bMF0sIHJlcGxhY2VtZW50c1tpXVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoZm9ybWF0ICYmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykgJiYgbG9jYWxlIGluIEZPUk1BVF9EQVRFX1JFUExBQ0VNRU5UUykge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnRzID0gRk9STUFUX0RBVEVfUkVQTEFDRU1FTlRTW2xvY2FsZV07XG5cbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IHJlcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShyZXBsYWNlbWVudFswXSwgcmVwbGFjZW1lbnRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbGRGb3JtYXREYXRlKGRhdGUsIGZvcm1hdCk7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gKHtcbiAgICAgICAgXzogd2luZG93LmdldHRleHQsXG4gICAgICAgIHVuZ2V0dGV4dDogd2luZG93LnVuZ2V0dGV4dCxcbiAgICAgICAgZm9ybWF0X2RlY2ltYWw6IHdpbmRvdy5mb3JtYXRfZGVjaW1hbCxcbiAgICAgICAgZm9ybWF0X251bWJlcjogd2luZG93LmZvcm1hdF9udW1iZXIsXG4gICAgICAgIGZvcm1hdF9wZXJjZW50OiB3aW5kb3cuZm9ybWF0X3BlcmNlbnQsXG4gICAgICAgIGZvcm1hdF9zY2llbnRpZmljOiB3aW5kb3cuZm9ybWF0X3NjaWVudGlmaWMsXG4gICAgICAgIGZvcm1hdF9kYXRlOiB3aW5kb3cuZm9ybWF0X2RhdGUsXG4gICAgICAgIGZvcm1hdF9kYXRldGltZTogd2luZG93LmZvcm1hdF9kYXRldGltZSxcbiAgICAgICAgZm9ybWF0X3RpbWU6IHdpbmRvdy5mb3JtYXRfdGltZSxcbiAgICAgICAgZm9ybWF0X2RhdGV0aW1lX21pY3Jvc2Vjb25kczogd2luZG93LmZvcm1hdF9kYXRldGltZV9taWNyb3NlY29uZHMsXG4gICAgICAgIGZvcm1hdF90aW1lX21pY3Jvc2Vjb25kczogd2luZG93LmZvcm1hdF90aW1lX21pY3Jvc2Vjb25kcyxcbiAgICAgICAgbG9jYWxlX3VzZXNfZGF5X2JlZm9yZV9tb250aDogd2luZG93LmxvY2FsZV91c2VzX2RheV9iZWZvcmVfbW9udGgsXG4gICAgICAgIGZvcm1hdF9kYXRldGltZV9yYW5nZTogd2luZG93LmZvcm1hdF9kYXRldGltZV9yYW5nZSxcbiAgICAgICAgbG9jYWxlX25hbWU6IHdpbmRvdy5sb2NhbGVfbmFtZSxcbiAgICAgICAgRGF0ZVRpbWU6IHdpbmRvdy5EYXRlVGltZSxcbiAgICAgICAgbW9tZW50X2luc3RhbGw6IHdpbmRvdy5tb21lbnRfaW5zdGFsbCxcbiAgICAgICAgbnVtZXJhbF9pbnN0YWxsOiB3aW5kb3cubnVtZXJhbF9pbnN0YWxsLFxuICAgICAgICBqUXVlcnlfdWlfZGF0ZXBpY2tlcl9pbnN0YWxsOiB3aW5kb3cualF1ZXJ5X3VpX2RhdGVwaWNrZXJfaW5zdGFsbFxuICAgIH0pO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvc3R1YnMvaTE4bi5qc1xuLy8gbW9kdWxlIGlkID0gc3R1YnMvaTE4blxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/strftime":
/***/ (function(module, exports) {

	eval("/* version 0.1: http://dren.ch/ */\n\nNumber.prototype.pad =\n\tfunction (n,p) {\n\t\tvar s = '' + this;\n\t\tp = p || '0';\n\t\twhile (s.length < n) s = p + s;\n\t\treturn s;\n\t};\n\nDate.prototype.months = [\n\t\t'January', 'February', 'March', 'April', 'May', 'June', 'July',\n\t\t'August', 'September', 'October', 'November', 'December'\n\t];\nDate.prototype.weekdays = [\n\t\t'Sunday', 'Monday', 'Tuesday', 'Wednesday',\n\t\t'Thursday', 'Friday', 'Saturday'\n\t];\nDate.prototype.dpm = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n\nDate.prototype.strftime_f = {\n\t\tA: function (d) { return d.weekdays[d.getDay()] },\n\t\ta: function (d) { return d.weekdays[d.getDay()].substring(0,3) },\n\t\tB: function (d) { return d.months[d.getMonth()] },\n\t\tb: function (d) { return d.months[d.getMonth()].substring(0,3) },\n\t\tC: function (d) { return Math.floor(d.getFullYear()/100); },\n\t\tc: function (d) { return d.toString() },\n\t\tD: function (d) {\n\t\t\t\treturn d.strftime_f.m(d) + '/' +\n\t\t\t\t\td.strftime_f.d(d) + '/' + d.strftime_f.y(d);\n\t\t\t},\n\t\td: function (d) { return d.getDate().pad(2,'0') },\n\t\te: function (d) { return d.getDate()},\n\t\tF: function (d) {\n\t\t\t\treturn d.strftime_f.Y(d) + '-' + d.strftime_f.m(d) + '-' +\n\t\t\t\t\td.strftime_f.d(d);\n\t\t\t},\n\t\tH: function (d) { return d.getHours().pad(2,'0') },\n\t\tI: function (d) { return ((d.getHours() % 12 || 12).pad(2)) },\n\t\tj: function (d) {\n\t\t\t\tvar t = d.getDate();\n\t\t\t\tvar m = d.getMonth() - 1;\n\t\t\t\tif (m > 1) {\n\t\t\t\t\tvar y = d.getYear();\n\t\t\t\t\tif (((y % 100) == 0) && ((y % 400) == 0)) ++t;\n\t\t\t\t\telse if ((y % 4) == 0) ++t;\n\t\t\t\t}\n\t\t\t\twhile (m > -1) t += d.dpm[m--];\n\t\t\t\treturn t.pad(3,'0');\n\t\t\t},\n\t\tk: function (d) { return d.getHours().pad(2,' ') },\n\t\tl: function (d) { return ((d.getHours() % 12 || 12)) },\n\t\tM: function (d) { return d.getMinutes().pad(2,'0') },\n\t\tm: function (d) { return (d.getMonth()+1).pad(2,'0') },\n\t\tn: function (d) { return \"\\n\" },\n\t\tp: function (d) { return (d.getHours() > 11) ? 'PM' : 'AM' },\n\t\t\n\t\tQ: function (d) { return (d.getMilliseconds()==0) ? \"000\" : d.getMilliseconds().pad(3,'0')},\n\t\t\n\t\tR: function (d) { return d.strftime_f.H(d) + ':' + d.strftime_f.M(d) },\n\t\tr: function (d) {\n\t\t\t\treturn d.strftime_f.I(d) + ':' + d.strftime_f.M(d) + ':' +\n\t\t\t\t\td.strftime_f.S(d) + ' ' + d.strftime_f.p(d);\n\t\t\t},\n\t\tS: function (d) { return d.getSeconds().pad(2,'0') },\n\t\ts: function (d) { return Math.floor(d.getTime()/1000) },\n\t\tT: function (d) {\n\t\t\t\treturn d.strftime_f.H(d) + ':' + d.strftime_f.M(d) + ':' +\n\t\t\t\t\td.strftime_f.S(d);\n\t\t\t},\n\t\tt: function (d) { return \"\\t\" },\n/*\t\tU: function (d) { return false }, */\n\t\tu: function (d) { return(d.getDay() || 7) },\n/*\t\tV: function (d) { return false }, */\n\t\tv: function (d) {\n\t\t\t\treturn d.strftime_f.e(d) + '-' + d.strftime_f.b(d) + '-' +\n\t\t\t\t\td.strftime_f.Y(d);\n\t\t\t},\n/*\t\tW: function (d) { return false }, */\n\t\tw: function (d) { return d.getDay() },\n\t\tX: function (d) { return d.toTimeString() }, // wrong?\n\t\tx: function (d) { return d.toDateString() }, // wrong?\n\t\tY: function (d) { return d.getFullYear() },\n\t\ty: function (d) { return (d.getYear() % 100).pad(2) },\n\t\tz: function (d) { return '' }, // don't support time offset rendering\n\t\tZ: function (d) { return '' }, // don't support time offset rendering\n\t\t'%': function (d) { return '%' }\n\t};\n\nDate.prototype.strftime_f['+'] = Date.prototype.strftime_f.c;\nDate.prototype.strftime_f.h = Date.prototype.strftime_f.b;\n\n\nDate.prototype.strftime = // revised 1/23/08 jthane for performance\n\tfunction (fmt) {\n    var rv;\n    if (rv = this[fmt]) return rv;  // caching reduces avg. time from .32ms to .06ms for typical actions\n    \n\t\tvar r = []; // '';\n\t\tvar n = 0;\n\t\twhile(n < fmt.length) {\n\t\t\tvar c = fmt.charAt(n);\n\t\t\tif (c == '%') {\n\t\t\t\tc = fmt.charAt(++n);\n\t\t\t\tr.push((this.strftime_f[c]) ? this.strftime_f[c](this) : c);\n\t\t\t} else r.push(c);\n\t\t\t++n;\n\t\t}\n    return this[fmt] = r.join('');\n\t};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvc3RyZnRpbWUuanM/MzgxMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25ELG1CQUFtQiwrQ0FBK0M7QUFDbEUsbUJBQW1CLGdDQUFnQztBQUNuRCxtQkFBbUIsK0NBQStDO0FBQ2xFLG1CQUFtQix3Q0FBd0MsRUFBRTtBQUM3RCxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUIsZ0NBQWdDO0FBQ25ELG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG1CQUFtQixpQ0FBaUM7QUFDcEQsbUJBQW1CLDRDQUE0QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUIsaUNBQWlDO0FBQ3BELG1CQUFtQixxQ0FBcUM7QUFDeEQsbUJBQW1CLG1DQUFtQztBQUN0RCxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQiwyQ0FBMkM7O0FBRTlELG1CQUFtQiwwRUFBMEU7O0FBRTdGLG1CQUFtQixxREFBcUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG1CQUFtQixtQ0FBbUM7QUFDdEQsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osbUJBQW1CLGNBQWM7QUFDakMscUJBQXFCLGVBQWU7QUFDcEMsbUJBQW1CLDBCQUEwQjtBQUM3QyxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUJBQXFCLGVBQWU7QUFDcEMsbUJBQW1CLG9CQUFvQjtBQUN2QyxtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQiwwQkFBMEI7QUFDN0MsbUJBQW1CLHlCQUF5QjtBQUM1QyxtQkFBbUIsb0NBQW9DO0FBQ3ZELG1CQUFtQixZQUFZO0FBQy9CLG1CQUFtQixZQUFZO0FBQy9CLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiY29udHJpYi9zdHJmdGltZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIHZlcnNpb24gMC4xOiBodHRwOi8vZHJlbi5jaC8gKi9cblxuTnVtYmVyLnByb3RvdHlwZS5wYWQgPVxuXHRmdW5jdGlvbiAobixwKSB7XG5cdFx0dmFyIHMgPSAnJyArIHRoaXM7XG5cdFx0cCA9IHAgfHwgJzAnO1xuXHRcdHdoaWxlIChzLmxlbmd0aCA8IG4pIHMgPSBwICsgcztcblx0XHRyZXR1cm4gcztcblx0fTtcblxuRGF0ZS5wcm90b3R5cGUubW9udGhzID0gW1xuXHRcdCdKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLFxuXHRcdCdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXG5cdF07XG5EYXRlLnByb3RvdHlwZS53ZWVrZGF5cyA9IFtcblx0XHQnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsXG5cdFx0J1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSdcblx0XTtcbkRhdGUucHJvdG90eXBlLmRwbSA9IFsgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMSBdO1xuXG5EYXRlLnByb3RvdHlwZS5zdHJmdGltZV9mID0ge1xuXHRcdEE6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLndlZWtkYXlzW2QuZ2V0RGF5KCldIH0sXG5cdFx0YTogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQud2Vla2RheXNbZC5nZXREYXkoKV0uc3Vic3RyaW5nKDAsMykgfSxcblx0XHRCOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5tb250aHNbZC5nZXRNb250aCgpXSB9LFxuXHRcdGI6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm1vbnRoc1tkLmdldE1vbnRoKCldLnN1YnN0cmluZygwLDMpIH0sXG5cdFx0QzogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIE1hdGguZmxvb3IoZC5nZXRGdWxsWWVhcigpLzEwMCk7IH0sXG5cdFx0YzogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudG9TdHJpbmcoKSB9LFxuXHRcdEQ6IGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdHJldHVybiBkLnN0cmZ0aW1lX2YubShkKSArICcvJyArXG5cdFx0XHRcdFx0ZC5zdHJmdGltZV9mLmQoZCkgKyAnLycgKyBkLnN0cmZ0aW1lX2YueShkKTtcblx0XHRcdH0sXG5cdFx0ZDogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZ2V0RGF0ZSgpLnBhZCgyLCcwJykgfSxcblx0XHRlOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5nZXREYXRlKCl9LFxuXHRcdEY6IGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdHJldHVybiBkLnN0cmZ0aW1lX2YuWShkKSArICctJyArIGQuc3RyZnRpbWVfZi5tKGQpICsgJy0nICtcblx0XHRcdFx0XHRkLnN0cmZ0aW1lX2YuZChkKTtcblx0XHRcdH0sXG5cdFx0SDogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZ2V0SG91cnMoKS5wYWQoMiwnMCcpIH0sXG5cdFx0STogZnVuY3Rpb24gKGQpIHsgcmV0dXJuICgoZC5nZXRIb3VycygpICUgMTIgfHwgMTIpLnBhZCgyKSkgfSxcblx0XHRqOiBmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHR2YXIgdCA9IGQuZ2V0RGF0ZSgpO1xuXHRcdFx0XHR2YXIgbSA9IGQuZ2V0TW9udGgoKSAtIDE7XG5cdFx0XHRcdGlmIChtID4gMSkge1xuXHRcdFx0XHRcdHZhciB5ID0gZC5nZXRZZWFyKCk7XG5cdFx0XHRcdFx0aWYgKCgoeSAlIDEwMCkgPT0gMCkgJiYgKCh5ICUgNDAwKSA9PSAwKSkgKyt0O1xuXHRcdFx0XHRcdGVsc2UgaWYgKCh5ICUgNCkgPT0gMCkgKyt0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChtID4gLTEpIHQgKz0gZC5kcG1bbS0tXTtcblx0XHRcdFx0cmV0dXJuIHQucGFkKDMsJzAnKTtcblx0XHRcdH0sXG5cdFx0azogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZ2V0SG91cnMoKS5wYWQoMiwnICcpIH0sXG5cdFx0bDogZnVuY3Rpb24gKGQpIHsgcmV0dXJuICgoZC5nZXRIb3VycygpICUgMTIgfHwgMTIpKSB9LFxuXHRcdE06IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmdldE1pbnV0ZXMoKS5wYWQoMiwnMCcpIH0sXG5cdFx0bTogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIChkLmdldE1vbnRoKCkrMSkucGFkKDIsJzAnKSB9LFxuXHRcdG46IGZ1bmN0aW9uIChkKSB7IHJldHVybiBcIlxcblwiIH0sXG5cdFx0cDogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIChkLmdldEhvdXJzKCkgPiAxMSkgPyAnUE0nIDogJ0FNJyB9LFxuXHRcdFxuXHRcdFE6IGZ1bmN0aW9uIChkKSB7IHJldHVybiAoZC5nZXRNaWxsaXNlY29uZHMoKT09MCkgPyBcIjAwMFwiIDogZC5nZXRNaWxsaXNlY29uZHMoKS5wYWQoMywnMCcpfSxcblx0XHRcblx0XHRSOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5zdHJmdGltZV9mLkgoZCkgKyAnOicgKyBkLnN0cmZ0aW1lX2YuTShkKSB9LFxuXHRcdHI6IGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdHJldHVybiBkLnN0cmZ0aW1lX2YuSShkKSArICc6JyArIGQuc3RyZnRpbWVfZi5NKGQpICsgJzonICtcblx0XHRcdFx0XHRkLnN0cmZ0aW1lX2YuUyhkKSArICcgJyArIGQuc3RyZnRpbWVfZi5wKGQpO1xuXHRcdFx0fSxcblx0XHRTOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5nZXRTZWNvbmRzKCkucGFkKDIsJzAnKSB9LFxuXHRcdHM6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBNYXRoLmZsb29yKGQuZ2V0VGltZSgpLzEwMDApIH0sXG5cdFx0VDogZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0cmV0dXJuIGQuc3RyZnRpbWVfZi5IKGQpICsgJzonICsgZC5zdHJmdGltZV9mLk0oZCkgKyAnOicgK1xuXHRcdFx0XHRcdGQuc3RyZnRpbWVfZi5TKGQpO1xuXHRcdFx0fSxcblx0XHR0OiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gXCJcXHRcIiB9LFxuLypcdFx0VTogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGZhbHNlIH0sICovXG5cdFx0dTogZnVuY3Rpb24gKGQpIHsgcmV0dXJuKGQuZ2V0RGF5KCkgfHwgNykgfSxcbi8qXHRcdFY6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBmYWxzZSB9LCAqL1xuXHRcdHY6IGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdHJldHVybiBkLnN0cmZ0aW1lX2YuZShkKSArICctJyArIGQuc3RyZnRpbWVfZi5iKGQpICsgJy0nICtcblx0XHRcdFx0XHRkLnN0cmZ0aW1lX2YuWShkKTtcblx0XHRcdH0sXG4vKlx0XHRXOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZmFsc2UgfSwgKi9cblx0XHR3OiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5nZXREYXkoKSB9LFxuXHRcdFg6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnRvVGltZVN0cmluZygpIH0sIC8vIHdyb25nP1xuXHRcdHg6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnRvRGF0ZVN0cmluZygpIH0sIC8vIHdyb25nP1xuXHRcdFk6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmdldEZ1bGxZZWFyKCkgfSxcblx0XHR5OiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gKGQuZ2V0WWVhcigpICUgMTAwKS5wYWQoMikgfSxcblx0XHR6OiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gJycgfSwgLy8gZG9uJ3Qgc3VwcG9ydCB0aW1lIG9mZnNldCByZW5kZXJpbmdcblx0XHRaOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gJycgfSwgLy8gZG9uJ3Qgc3VwcG9ydCB0aW1lIG9mZnNldCByZW5kZXJpbmdcblx0XHQnJSc6IGZ1bmN0aW9uIChkKSB7IHJldHVybiAnJScgfVxuXHR9O1xuXG5EYXRlLnByb3RvdHlwZS5zdHJmdGltZV9mWycrJ10gPSBEYXRlLnByb3RvdHlwZS5zdHJmdGltZV9mLmM7XG5EYXRlLnByb3RvdHlwZS5zdHJmdGltZV9mLmggPSBEYXRlLnByb3RvdHlwZS5zdHJmdGltZV9mLmI7XG5cblxuRGF0ZS5wcm90b3R5cGUuc3RyZnRpbWUgPSAvLyByZXZpc2VkIDEvMjMvMDgganRoYW5lIGZvciBwZXJmb3JtYW5jZVxuXHRmdW5jdGlvbiAoZm10KSB7XG4gICAgdmFyIHJ2O1xuICAgIGlmIChydiA9IHRoaXNbZm10XSkgcmV0dXJuIHJ2OyAgLy8gY2FjaGluZyByZWR1Y2VzIGF2Zy4gdGltZSBmcm9tIC4zMm1zIHRvIC4wNm1zIGZvciB0eXBpY2FsIGFjdGlvbnNcbiAgICBcblx0XHR2YXIgciA9IFtdOyAvLyAnJztcblx0XHR2YXIgbiA9IDA7XG5cdFx0d2hpbGUobiA8IGZtdC5sZW5ndGgpIHtcblx0XHRcdHZhciBjID0gZm10LmNoYXJBdChuKTtcblx0XHRcdGlmIChjID09ICclJykge1xuXHRcdFx0XHRjID0gZm10LmNoYXJBdCgrK24pO1xuXHRcdFx0XHRyLnB1c2goKHRoaXMuc3RyZnRpbWVfZltjXSkgPyB0aGlzLnN0cmZ0aW1lX2ZbY10odGhpcykgOiBjKTtcblx0XHRcdH0gZWxzZSByLnB1c2goYyk7XG5cdFx0XHQrK247XG5cdFx0fVxuICAgIHJldHVybiB0aGlzW2ZtdF0gPSByLmpvaW4oJycpO1xuXHR9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL3N0cmZ0aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL3N0cmZ0aW1lXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "shim/splunk.util":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/jquery\"), __webpack_require__(\"shim/splunk\"), __webpack_require__(\"util/sprintf\"), __webpack_require__(\"stubs/splunk.config\"), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Splunk, sprintf) {\n    Splunk.util.sprintf = sprintf;\n    return Splunk.util;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vc3BsdW5rLnV0aWwuanM/NjQ1OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJzaGltL3NwbHVuay51dGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFsnanF1ZXJ5JywgJ3NwbHVuaycsICd1dGlsL3NwcmludGYnLCAnc3BsdW5rLmNvbmZpZycsICdpbXBvcnRzPyQ9anF1ZXJ5LHRoaXM9PndpbmRvdyF1dGlsJ10sIGZ1bmN0aW9uKCQsIFNwbHVuaywgc3ByaW50Zikge1xuICAgIFNwbHVuay51dGlsLnNwcmludGYgPSBzcHJpbnRmO1xuICAgIHJldHVybiBTcGx1bmsudXRpbDtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vc3BsdW5rLnV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IHNoaW0vc3BsdW5rLnV0aWxcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "shim/splunk":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n    return window.Splunk;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vc3BsdW5rLmpzPzgzZjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InNoaW0vc3BsdW5rLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFsnaW1wb3J0cz90aGlzPT53aW5kb3chLi4vc3BsdW5rLmpzJ10sIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB3aW5kb3cuU3BsdW5rO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vc3BsdW5rLmpzXG4vLyBtb2R1bGUgaWQgPSBzaGltL3NwbHVua1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 6:
/***/ (function(module, exports) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n(function(global) {\n\nif (typeof global.Splunk==\"undefined\" || !global.Splunk) {\n    /**\n     * The Splunk global namespace object.  If Splunk is defined, the\n     * existing Splunk object will not be overwritten so that existing\n     * namespaces are preserved.\n     */\n    global.Splunk = {};\n}\n/**\n * Returns the namespace specified and creates it if it doesn't exist\n * <pre>\n * Splunk.namespace(\"property.package\");\n * Splunk.namespace(\"Splunk.property.package\");\n * </pre>\n * Either of the above would create Splunk.property, then\n * Splunk.property.package\n *\n * @method namespace\n * @static\n * @param  {String} name A \".\" delimited namespace to create\n * @return {Object} A reference to the last namespace object created\n */\nglobal.Splunk.namespace = function(name) {\n    var parts = name.split(\".\");\n    var obj = Splunk;\n    for (var i=(parts[0]==\"Splunk\")?1:0; i<parts.length; i=i+1) {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n    }\n    return obj;\n};\n\n})(this);\n\n}.call(window));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NwbHVuay5qcz8xZWJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsQ0FBQyIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xuKGZ1bmN0aW9uKCkge1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbmlmICh0eXBlb2YgZ2xvYmFsLlNwbHVuaz09XCJ1bmRlZmluZWRcIiB8fCAhZ2xvYmFsLlNwbHVuaykge1xuICAgIC8qKlxuICAgICAqIFRoZSBTcGx1bmsgZ2xvYmFsIG5hbWVzcGFjZSBvYmplY3QuICBJZiBTcGx1bmsgaXMgZGVmaW5lZCwgdGhlXG4gICAgICogZXhpc3RpbmcgU3BsdW5rIG9iamVjdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBzbyB0aGF0IGV4aXN0aW5nXG4gICAgICogbmFtZXNwYWNlcyBhcmUgcHJlc2VydmVkLlxuICAgICAqL1xuICAgIGdsb2JhbC5TcGx1bmsgPSB7fTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZXNwYWNlIHNwZWNpZmllZCBhbmQgY3JlYXRlcyBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gKiA8cHJlPlxuICogU3BsdW5rLm5hbWVzcGFjZShcInByb3BlcnR5LnBhY2thZ2VcIik7XG4gKiBTcGx1bmsubmFtZXNwYWNlKFwiU3BsdW5rLnByb3BlcnR5LnBhY2thZ2VcIik7XG4gKiA8L3ByZT5cbiAqIEVpdGhlciBvZiB0aGUgYWJvdmUgd291bGQgY3JlYXRlIFNwbHVuay5wcm9wZXJ0eSwgdGhlblxuICogU3BsdW5rLnByb3BlcnR5LnBhY2thZ2VcbiAqXG4gKiBAbWV0aG9kIG5hbWVzcGFjZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIEEgXCIuXCIgZGVsaW1pdGVkIG5hbWVzcGFjZSB0byBjcmVhdGVcbiAqIEByZXR1cm4ge09iamVjdH0gQSByZWZlcmVuY2UgdG8gdGhlIGxhc3QgbmFtZXNwYWNlIG9iamVjdCBjcmVhdGVkXG4gKi9cbmdsb2JhbC5TcGx1bmsubmFtZXNwYWNlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIHZhciBvYmogPSBTcGx1bms7XG4gICAgZm9yICh2YXIgaT0ocGFydHNbMF09PVwiU3BsdW5rXCIpPzE6MDsgaTxwYXJ0cy5sZW5ndGg7IGk9aSsxKSB7XG4gICAgICAgIG9ialtwYXJ0c1tpXV0gPSBvYmpbcGFydHNbaV1dIHx8IHt9O1xuICAgICAgICBvYmogPSBvYmpbcGFydHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxufSkodGhpcyk7XG5cbn0uY2FsbCh3aW5kb3cpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaW1wb3J0cy1sb2FkZXI/dGhpcz0+d2luZG93IS4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmsuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "util/sprintf":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function(sprintf) {\n    return sprintf;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvc3ByaW50Zi5qcz83MzA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJ1dGlsL3NwcmludGYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydleHBvcnRzP3NwcmludGYhY29udHJpYi9zcHJpbnRmJ10sIGZ1bmN0aW9uKHNwcmludGYpIHtcbiAgICByZXR1cm4gc3ByaW50Zjtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy91dGlsL3NwcmludGYuanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvc3ByaW50ZlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 7:
/***/ (function(module, exports) {

	eval("/**\n* sprintf routine borrowed from http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_sprintf/\n* Licensed under GPL and MIT licenses\n*\n* Modified by Gareth to add support for Python style argument specifiers:\n* sprintf(\"Hi %(name)s, welcome to %(application)s\", { name: 'Gareth', app: 'Splunk })\n*/\nfunction sprintf( ) {\n    // Return a formatted string\n    // \n    // +    discuss at: http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_sprintf/\n    // +       version: 810.1015\n    // +   original by: Ash Searle (http://hexmen.com/blog/)\n    // + namespaced by: Michael White (http://getsprink.com)\n    // +    tweaked by: Jack\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // *     example 1: sprintf(\"%01.2f\", 123.1);\n    // *     returns 1: 123.10\n\n    var regex = /%%|%(\\d+\\$)?(\\([^)]+\\))?([-+#0 ]*)(\\*\\d+\\$|\\*|\\d+)?(\\.(\\*\\d+\\$|\\*|\\d+))?([scboxXuidfegEG])/g;\n    var a = arguments, i = 0, format = a[i++];\n\n    // pad()\n    var pad = function(str, len, chr, leftJustify) {\n        var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);\n        return leftJustify ? str + padding : padding + str;\n    };\n\n    // justify()\n    var justify = function(value, prefix, leftJustify, minWidth, zeroPad) {\n        var diff = minWidth - value.length;\n        if (diff > 0) {\n            if (leftJustify || !zeroPad) {\n                value = pad(value, minWidth, ' ', leftJustify);\n            } else {\n                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);\n            }\n        }\n        return value;\n    };\n\n    // formatBaseX()\n    var formatBaseX = function(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {\n        // Note: casts negative numbers to positive ones\n        var number = value >>> 0;\n        prefix = prefix && number && {'2': '0b', '8': '0', '16': '0x'}[base] || '';\n        value = prefix + pad(number.toString(base), precision || 0, '0', false);\n        return justify(value, prefix, leftJustify, minWidth, zeroPad);\n    };\n\n    // formatString()\n    var formatString = function(value, leftJustify, minWidth, precision, zeroPad) {\n        if (precision != null) {\n            value = value.slice(0, precision);\n        }\n        return justify(value, '', leftJustify, minWidth, zeroPad);\n    };\n\n    // finalFormat()\n    var doFormat = function(substring, valueIndex, valueName, flags, minWidth, _, precision, type) {\n        if (substring == '%%') return '%';\n\n        // parse flags\n        var leftJustify = false, positivePrefix = '', zeroPad = false, prefixBaseX = false;\n        var flagsl = flags.length;\n        for (var j = 0; flags && j < flagsl; j++) switch (flags.charAt(j)) {\n            case ' ': positivePrefix = ' '; break;\n            case '+': positivePrefix = '+'; break;\n            case '-': leftJustify = true; break;\n            case '0': zeroPad = true; break;\n            case '#': prefixBaseX = true; break;\n        }\n\n        // parameters may be null, undefined, empty-string or real valued\n        // we want to ignore null, undefined and empty-string values\n        if (!minWidth) {\n            minWidth = 0;\n        } else if (minWidth == '*') {\n            minWidth = +a[i++];\n        } else if (minWidth.charAt(0) == '*') {\n            minWidth = +a[minWidth.slice(1, -1)];\n        } else {\n            minWidth = +minWidth;\n        }\n\n        // Note: undocumented perl feature:\n        if (minWidth < 0) {\n            minWidth = -minWidth;\n            leftJustify = true;\n        }\n\n        if (!isFinite(minWidth)) {\n            throw new Error('sprintf: (minimum-)width must be finite');\n        }\n\n        if (!precision) {\n            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : void(0);\n        } else if (precision == '*') {\n            precision = +a[i++];\n        } else if (precision.charAt(0) == '*') {\n            precision = +a[precision.slice(1, -1)];\n        } else {\n            precision = +precision;\n        }\n\n        // grab value using valueIndex if required?\n        if (valueName) {\n            valueName = valueName.substr(1, valueName.length-2);\n            var value = a[1][valueName];\n        } else {\n            var value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];\n        }\n\n        switch (type) {\n            case 's': return formatString(String(value), leftJustify, minWidth, precision, zeroPad);\n            case 'c': return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);\n            case 'b': return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n            case 'o': return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n            case 'x': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n            case 'X': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();\n            case 'u': return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n            case 'i':\n            case 'd': {\n                        var number = parseInt(+value);\n                        var prefix = number < 0 ? '-' : positivePrefix;\n                        value = prefix + pad(String(Math.abs(number)), precision, '0', false);\n                        return justify(value, prefix, leftJustify, minWidth, zeroPad);\n                    }\n            case 'e':\n            case 'E':\n            case 'f':\n            case 'F':\n            case 'g':\n            case 'G':\n                        {\n                        var number = +value;\n                        var prefix = number < 0 ? '-' : positivePrefix;\n                        var method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];\n                        var textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];\n                        value = prefix + Math.abs(number)[method](precision);\n                        return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();\n                    }\n            default: return substring;\n        }\n    };\n\n    return format.replace(regex, doFormat);\n}// }}}\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = sprintf;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvc3ByaW50Zi5qcz80MThhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0JBQStCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0NBQWdDO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFDckMseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBzcHJpbnRmIHJvdXRpbmUgYm9ycm93ZWQgZnJvbSBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldC90ZWNoYmxvZy9hcnRpY2xlL2phdmFzY3JpcHRfZXF1aXZhbGVudF9mb3JfcGhwc19zcHJpbnRmL1xuKiBMaWNlbnNlZCB1bmRlciBHUEwgYW5kIE1JVCBsaWNlbnNlc1xuKlxuKiBNb2RpZmllZCBieSBHYXJldGggdG8gYWRkIHN1cHBvcnQgZm9yIFB5dGhvbiBzdHlsZSBhcmd1bWVudCBzcGVjaWZpZXJzOlxuKiBzcHJpbnRmKFwiSGkgJShuYW1lKXMsIHdlbGNvbWUgdG8gJShhcHBsaWNhdGlvbilzXCIsIHsgbmFtZTogJ0dhcmV0aCcsIGFwcDogJ1NwbHVuayB9KVxuKi9cbmZ1bmN0aW9uIHNwcmludGYoICkge1xuICAgIC8vIFJldHVybiBhIGZvcm1hdHRlZCBzdHJpbmdcbiAgICAvLyBcbiAgICAvLyArICAgIGRpc2N1c3MgYXQ6IGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0L3RlY2hibG9nL2FydGljbGUvamF2YXNjcmlwdF9lcXVpdmFsZW50X2Zvcl9waHBzX3NwcmludGYvXG4gICAgLy8gKyAgICAgICB2ZXJzaW9uOiA4MTAuMTAxNVxuICAgIC8vICsgICBvcmlnaW5hbCBieTogQXNoIFNlYXJsZSAoaHR0cDovL2hleG1lbi5jb20vYmxvZy8pXG4gICAgLy8gKyBuYW1lc3BhY2VkIGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vZ2V0c3ByaW5rLmNvbSlcbiAgICAvLyArICAgIHR3ZWFrZWQgYnk6IEphY2tcbiAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgIC8vICogICAgIGV4YW1wbGUgMTogc3ByaW50ZihcIiUwMS4yZlwiLCAxMjMuMSk7XG4gICAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjMuMTBcblxuICAgIHZhciByZWdleCA9IC8lJXwlKFxcZCtcXCQpPyhcXChbXildK1xcKSk/KFstKyMwIF0qKShcXCpcXGQrXFwkfFxcKnxcXGQrKT8oXFwuKFxcKlxcZCtcXCR8XFwqfFxcZCspKT8oW3NjYm94WHVpZGZlZ0VHXSkvZztcbiAgICB2YXIgYSA9IGFyZ3VtZW50cywgaSA9IDAsIGZvcm1hdCA9IGFbaSsrXTtcblxuICAgIC8vIHBhZCgpXG4gICAgdmFyIHBhZCA9IGZ1bmN0aW9uKHN0ciwgbGVuLCBjaHIsIGxlZnRKdXN0aWZ5KSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gKHN0ci5sZW5ndGggPj0gbGVuKSA/ICcnIDogQXJyYXkoMSArIGxlbiAtIHN0ci5sZW5ndGggPj4+IDApLmpvaW4oY2hyKTtcbiAgICAgICAgcmV0dXJuIGxlZnRKdXN0aWZ5ID8gc3RyICsgcGFkZGluZyA6IHBhZGRpbmcgKyBzdHI7XG4gICAgfTtcblxuICAgIC8vIGp1c3RpZnkoKVxuICAgIHZhciBqdXN0aWZ5ID0gZnVuY3Rpb24odmFsdWUsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCB6ZXJvUGFkKSB7XG4gICAgICAgIHZhciBkaWZmID0gbWluV2lkdGggLSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgaWYgKGxlZnRKdXN0aWZ5IHx8ICF6ZXJvUGFkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYWQodmFsdWUsIG1pbldpZHRoLCAnICcsIGxlZnRKdXN0aWZ5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBwcmVmaXgubGVuZ3RoKSArIHBhZCgnJywgZGlmZiwgJzAnLCB0cnVlKSArIHZhbHVlLnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gZm9ybWF0QmFzZVgoKVxuICAgIHZhciBmb3JtYXRCYXNlWCA9IGZ1bmN0aW9uKHZhbHVlLCBiYXNlLCBwcmVmaXgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCB6ZXJvUGFkKSB7XG4gICAgICAgIC8vIE5vdGU6IGNhc3RzIG5lZ2F0aXZlIG51bWJlcnMgdG8gcG9zaXRpdmUgb25lc1xuICAgICAgICB2YXIgbnVtYmVyID0gdmFsdWUgPj4+IDA7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeCAmJiBudW1iZXIgJiYgeycyJzogJzBiJywgJzgnOiAnMCcsICcxNic6ICcweCd9W2Jhc2VdIHx8ICcnO1xuICAgICAgICB2YWx1ZSA9IHByZWZpeCArIHBhZChudW1iZXIudG9TdHJpbmcoYmFzZSksIHByZWNpc2lvbiB8fCAwLCAnMCcsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGp1c3RpZnkodmFsdWUsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCB6ZXJvUGFkKTtcbiAgICB9O1xuXG4gICAgLy8gZm9ybWF0U3RyaW5nKClcbiAgICB2YXIgZm9ybWF0U3RyaW5nID0gZnVuY3Rpb24odmFsdWUsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChwcmVjaXNpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBwcmVjaXNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqdXN0aWZ5KHZhbHVlLCAnJywgbGVmdEp1c3RpZnksIG1pbldpZHRoLCB6ZXJvUGFkKTtcbiAgICB9O1xuXG4gICAgLy8gZmluYWxGb3JtYXQoKVxuICAgIHZhciBkb0Zvcm1hdCA9IGZ1bmN0aW9uKHN1YnN0cmluZywgdmFsdWVJbmRleCwgdmFsdWVOYW1lLCBmbGFncywgbWluV2lkdGgsIF8sIHByZWNpc2lvbiwgdHlwZSkge1xuICAgICAgICBpZiAoc3Vic3RyaW5nID09ICclJScpIHJldHVybiAnJSc7XG5cbiAgICAgICAgLy8gcGFyc2UgZmxhZ3NcbiAgICAgICAgdmFyIGxlZnRKdXN0aWZ5ID0gZmFsc2UsIHBvc2l0aXZlUHJlZml4ID0gJycsIHplcm9QYWQgPSBmYWxzZSwgcHJlZml4QmFzZVggPSBmYWxzZTtcbiAgICAgICAgdmFyIGZsYWdzbCA9IGZsYWdzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGZsYWdzICYmIGogPCBmbGFnc2w7IGorKykgc3dpdGNoIChmbGFncy5jaGFyQXQoaikpIHtcbiAgICAgICAgICAgIGNhc2UgJyAnOiBwb3NpdGl2ZVByZWZpeCA9ICcgJzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcrJzogcG9zaXRpdmVQcmVmaXggPSAnKyc7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLSc6IGxlZnRKdXN0aWZ5ID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcwJzogemVyb1BhZCA9IHRydWU7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIyc6IHByZWZpeEJhc2VYID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXJhbWV0ZXJzIG1heSBiZSBudWxsLCB1bmRlZmluZWQsIGVtcHR5LXN0cmluZyBvciByZWFsIHZhbHVlZFxuICAgICAgICAvLyB3ZSB3YW50IHRvIGlnbm9yZSBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5LXN0cmluZyB2YWx1ZXNcbiAgICAgICAgaWYgKCFtaW5XaWR0aCkge1xuICAgICAgICAgICAgbWluV2lkdGggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbldpZHRoID09ICcqJykge1xuICAgICAgICAgICAgbWluV2lkdGggPSArYVtpKytdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbldpZHRoLmNoYXJBdCgwKSA9PSAnKicpIHtcbiAgICAgICAgICAgIG1pbldpZHRoID0gK2FbbWluV2lkdGguc2xpY2UoMSwgLTEpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbldpZHRoID0gK21pbldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90ZTogdW5kb2N1bWVudGVkIHBlcmwgZmVhdHVyZTpcbiAgICAgICAgaWYgKG1pbldpZHRoIDwgMCkge1xuICAgICAgICAgICAgbWluV2lkdGggPSAtbWluV2lkdGg7XG4gICAgICAgICAgICBsZWZ0SnVzdGlmeSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRmluaXRlKG1pbldpZHRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcHJpbnRmOiAobWluaW11bS0pd2lkdGggbXVzdCBiZSBmaW5pdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJlY2lzaW9uKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSAnZkZlRScuaW5kZXhPZih0eXBlKSA+IC0xID8gNiA6ICh0eXBlID09ICdkJykgPyAwIDogdm9pZCgwKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVjaXNpb24gPT0gJyonKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSArYVtpKytdO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWNpc2lvbi5jaGFyQXQoMCkgPT0gJyonKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSArYVtwcmVjaXNpb24uc2xpY2UoMSwgLTEpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9ICtwcmVjaXNpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBncmFiIHZhbHVlIHVzaW5nIHZhbHVlSW5kZXggaWYgcmVxdWlyZWQ/XG4gICAgICAgIGlmICh2YWx1ZU5hbWUpIHtcbiAgICAgICAgICAgIHZhbHVlTmFtZSA9IHZhbHVlTmFtZS5zdWJzdHIoMSwgdmFsdWVOYW1lLmxlbmd0aC0yKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFbMV1bdmFsdWVOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW5kZXggPyBhW3ZhbHVlSW5kZXguc2xpY2UoMCwgLTEpXSA6IGFbaSsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncyc6IHJldHVybiBmb3JtYXRTdHJpbmcoU3RyaW5nKHZhbHVlKSwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuICAgICAgICAgICAgY2FzZSAnYyc6IHJldHVybiBmb3JtYXRTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgrdmFsdWUpLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCk7XG4gICAgICAgICAgICBjYXNlICdiJzogcmV0dXJuIGZvcm1hdEJhc2VYKHZhbHVlLCAyLCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuICAgICAgICAgICAgY2FzZSAnbyc6IHJldHVybiBmb3JtYXRCYXNlWCh2YWx1ZSwgOCwgcHJlZml4QmFzZVgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCB6ZXJvUGFkKTtcbiAgICAgICAgICAgIGNhc2UgJ3gnOiByZXR1cm4gZm9ybWF0QmFzZVgodmFsdWUsIDE2LCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuICAgICAgICAgICAgY2FzZSAnWCc6IHJldHVybiBmb3JtYXRCYXNlWCh2YWx1ZSwgMTYsIHByZWZpeEJhc2VYLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ3UnOiByZXR1cm4gZm9ybWF0QmFzZVgodmFsdWUsIDEwLCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBjYXNlICdkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bWJlciA9IHBhcnNlSW50KCt2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbnVtYmVyIDwgMCA/ICctJyA6IHBvc2l0aXZlUHJlZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVmaXggKyBwYWQoU3RyaW5nKE1hdGguYWJzKG51bWJlcikpLCBwcmVjaXNpb24sICcwJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGp1c3RpZnkodmFsdWUsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCB6ZXJvUGFkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgY2FzZSAnRic6XG4gICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bWJlciA9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBudW1iZXIgPCAwID8gJy0nIDogcG9zaXRpdmVQcmVmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gWyd0b0V4cG9uZW50aWFsJywgJ3RvRml4ZWQnLCAndG9QcmVjaXNpb24nXVsnZWZnJy5pbmRleE9mKHR5cGUudG9Mb3dlckNhc2UoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRUcmFuc2Zvcm0gPSBbJ3RvU3RyaW5nJywgJ3RvVXBwZXJDYXNlJ11bJ2VFZkZnRycuaW5kZXhPZih0eXBlKSAlIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVmaXggKyBNYXRoLmFicyhudW1iZXIpW21ldGhvZF0ocHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqdXN0aWZ5KHZhbHVlLCBwcmVmaXgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgemVyb1BhZClbdGV4dFRyYW5zZm9ybV0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHN1YnN0cmluZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UocmVnZXgsIGRvRm9ybWF0KTtcbn0vLyB9fX1cblxuXG4vKioqIEVYUE9SVFMgRlJPTSBleHBvcnRzLWxvYWRlciAqKiovXG5tb2R1bGUuZXhwb3J0cyA9IHNwcmludGY7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V4cG9ydHMtbG9hZGVyP3NwcmludGYhLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvc3ByaW50Zi5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "stubs/splunk.config":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n    return window.$C;\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3N0dWJzL3NwbHVuay5jb25maWcuanM/MGRhYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoia0NBQUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoic3R1YnMvc3BsdW5rLmNvbmZpZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gd2luZG93LiRDO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3N0dWJzL3NwbHVuay5jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IHN0dWJzL3NwbHVuay5jb25maWdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 8:
/***/ (function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar $ = __webpack_require__(\"shim/jquery\");\n(function() {\n\n(function(global) {\n\nSplunk.namespace(\"util\");\n\nSplunk.util = {\n\n\n    /**\n     * Assign empty handlers for logger calls. Overriden by Splunk.Logger if it is imported.\n     */\n    logger : {\n        \"info\":function(){},\n        \"log\":function(){},\n        \"debug\":function(){},\n        \"warn\":function(){},\n        \"error\":function(){}\n    },\n\n    /**\n     * Converts an object literal to an encoded querystring key/value string.\n     *\n     */\n    propToQueryString: function(dictionary) {\n        var o = [];\n        var val;\n        for (var prop in dictionary) {\n            val = dictionary[prop];\n            o.push(encodeURIComponent(prop) + '=' + encodeURIComponent(val));\n        }\n        return o.join('&');\n    },\n\n    /**\n     * Converts a flat querystring into an object literal\n     *\n     */\n    queryStringToProp: function(args) {\n        args = this.trim(args, '&\\?#');\n        if (!args || args.length == 0) {\n            return {};\n        }\n\n        var parts = args.split('&');\n        var output = {};\n\n        var key;\n        var value;\n        var equalsSegments;\n        for (var i = 0; i < parts.length; i++) {\n            equalsSegments = parts[i].split('=');\n            try {\n                key = decodeURIComponent(equalsSegments.shift());\n            } catch(e) {\n                continue;\n            }\n            try {\n                value = decodeURIComponent(equalsSegments.join('=').replace(/\\+/g, ' '));\n            } catch(e) {\n                continue;\n            }\n            output[key] = value;\n        }\n        return output;\n    },\n\n    /**\n     * Extracts the fragment identifier value.\n     */\n    getHash: function(){\n    var hashPos = window.location.href.indexOf('#');\n\n    if (hashPos == -1) {\n        return \"\";\n    }\n\n    var qPos = window.location.href.indexOf('?', hashPos);\n\n    if (qPos != -1)\n        return window.location.href.substr(qPos);\n\n    return window.location.href.substr(hashPos);\n    },\n\n    /**\n     * This was ported, rewritten a bit and greatly simplified from the\n     * same method in the old Calendar object we used to use.\n     * TODO - it is only here temporarily, and we should continue trying to\n     * kill it.\n     */\n    parseDate : function(str, fmt) {\n\n        if ((!str) || (!str.indexOf) || (str.indexOf(\"mm\")==0)) return null;\n\n        var y = 0;\n        var m = -1;\n        var d = 0;\n        var a = str.split(/\\W+/);\n        var b = fmt.match(/%./g);\n        var i = 0, j = 0;\n        var hr = 0;\n        var min = 0;\n        var sec = 0;\n\n        for (i = 0; i < a.length; ++i) {\n            if (!a[i])\n                continue;\n            switch (b[i]) {\n                case \"%d\":\n                    d = parseInt(a[i], 10);\n                    break;\n\n                case \"%m\":\n                    m = parseInt(a[i], 10) - 1;\n                    break;\n\n                case \"%Y\":\n                case \"%y\":\n                    y = parseInt(a[i], 10);\n                    (y < 100) && (y += (y > 29) ? 1900 : 2000);\n                    break;\n\n                case \"%H\":\n                    hr = parseInt(a[i], 10);\n                    break;\n\n                case \"%M\":\n                    min = parseInt(a[i], 10);\n                    break;\n\n                case \"%S\":\n                    sec = parseInt(a[i], 10);\n                    break;\n\n                default:\n                    break;\n            }\n        }\n        if (y != 0 && m != -1 && d != 0) {\n            var ourDate = new Date(y, m, d, hr, min, sec);\n            return ourDate;\n        } else {\n            //this.logger.warn('unable to parse date \"' + str + '\" into \"' + fmt + '\"');\n            return false;\n        }\n    },\n    /**\n     * Given a timezone offset in minutes, and  a JS Date object,\n     * returns the delta in milliseconds, of the two timezones.\n     * Note that this will include the offset contributions from DST for both.\n     */\n    getTimezoneOffsetDelta: function(serverOffsetThen, d) {\n        if (!Splunk.util.isInt(serverOffsetThen)) {\n            return 0;\n        }\n        // what JS thinks the timezone offset is at the time given by d. This WILL INCLUDE DST\n        var clientOffsetThen = d.getTimezoneOffset() * 60;\n        // what splunkd told is the actual timezone offset.\n        serverOffsetThen     = serverOffsetThen * -60;\n\n        return 1000 * (serverOffsetThen - clientOffsetThen);\n    },\n\n    getEpochTimeFromISO: function(isoStr) {\n        // lazily init the regex so we only do it only if necessary and only once.\n        if (!this._isoTimeRegex) {\n            // Nobody doesnt like ISO.\n            this._isoTimeRegex = /([\\+\\-])?(\\d{4,})(?:(?:\\-(\\d{2}))(?:(?:\\-(\\d{2}))(?:(?:[T ](\\d{2}))(?:(?:\\:(\\d{2}))(?:(?:\\:(\\d{2}(?:\\.\\d+)?)))?)?(?:(Z)|([\\+\\-])(\\d{2})[:]*(\\d{2})?)?)?)?)?/;\n        }\n        var m = this._isoTimeRegex.exec(isoStr);\n        // put it into a string form that JS Date constructors can actually deal with.\n\n        // Being Super Careful: calling substring on undefined variable\n        // here throws an exception that kills the stack but doesnt\n        // appear in firebug nor even in the Error Console.\n        var seconds, millisecondsStr;\n        if (m[7]) {\n            seconds = m[7].substring(0,2);\n            // Note this includes the period.  ie \".003\"\n            millisecondsStr = m[7].substring(2);\n        } else {\n            millisecondsStr = \"\";\n        }\n        /*jshint -W061:false */\n        // If m[11] is undefined, use 0 instead.\n        var offset = eval(m[9] + (60*m[10] + parseInt(m[11] || 0, 10)));\n        /*jshint -W061:true */\n\n        var str = sprintf(\"%s/%s/%s %s:%s:%s\", m[3], m[4], m[2], m[5], m[6], seconds);\n        // its still wrong, because JS will interpret this time in localtime,\n        // AND if you give IE the timezone part of the string, it passes out in its own vomit.\n        var t = new Date(str);\n\n        // so we patch it.\n        t.setTime(t.getTime() + this.getTimezoneOffsetDelta(offset, t));\n        var startTime = t.getTime() / 1000;\n\n        return startTime + millisecondsStr;\n    },\n\n    getConfigValue: function(configKey, optionalDefault) {\n        if (window.$C && window.$C.hasOwnProperty(configKey)) return window.$C[configKey];\n        else if (configKey === 'FORM_KEY') {\n            // maintain backwards compatibility now that we've moved the form_key from config endpoint to cookie\n            return this.getFormKey();\n        } else {\n            if (typeof optionalDefault != 'undefined') { // ensure optionalDefault can be set to 'false'\n                // util.logger will have been swapped out by the Logger when Logger\n                // has already been setup, but still works when its not.\n\n                //this.logger.debug('getConfigValue - ' + configKey + ' not set, defaulting to ' + optionalDefault);\n                return optionalDefault;\n            }\n\n            throw new Error('getConfigValue - ' + configKey + ' not set, no default provided');\n        }\n    },\n\n    getCookie: function(name) {\n        var cookieValue = null;\n        if (document.cookie && document.cookie != '') {\n            var cookies = document.cookie.split(';');\n            for (var i = 0; i < cookies.length; i++) {\n                var cookie = $.trim(cookies[i]);\n                // Does this cookie string begin with the name we want?\n                if (cookie.substring(0, name.length + 1) == (name + '=')) {\n                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                    break;\n                }\n            }\n        }\n        return cookieValue;\n    },\n\n    deleteCookie: function(name) {\n        var expdate = new Date();\n        expdate.setTime(expdate.getTime() + (-1 * 24 * 60 * 60 * 1000));\n        expdate.toUTCString();\n        document.cookie = sprintf('%s=;expires=%s;path=/',name, expdate);\n    },\n\n    getFormKey: function() {\n        var cookieName = \"splunkweb_csrf_token_\" + Splunk.util.getConfigValue('MRSPARKLE_PORT_NUMBER', '');\n        var cookieValue = Splunk.util.getCookie(cookieName);\n        if (cookieValue) {\n            return cookieValue;\n        }\n        return \"\";\n    },\n\n    loginCheck: function() {\n        return Splunk.util.getCookie('login');\n    },\n\n    /**\n     * Returns a proper path that is relative to the current appserver location.\n     * This is critical to ensure that we are proxy compatible. This method\n     * takes 1 or more arguments, which will all be stiched together in sequence.\n     *\n     * Ex: make_url('search/job'); // \"/splunk/search/job\"\n     * Ex: make_url('/search/job'); // \"/splunk/search/job\"\n     * Ex: make_url('/search', '/job'); // \"/splunk/search/job\"\n     * Ex: make_url('/search', '/job', 1234); // \"/splunk/search/job/1234\"\n     *\n     * Static paths are augmented with a cache defeater\n     *\n     * Ex: make_url('/static/js/foo.js'); // \"/splunk/static/@12345/js/foo.js\"\n     * Ex: make_url('/static/js/foo.js'); // \"/splunk/static/@12345.1/js/foo.js\"\n     *\n     * @param path {String} The relative path to extend\n     */\n    make_url: function() {\n        var output = '', seg, len;\n        for (var i=0,l=arguments.length; i<l; i++) {\n            seg = arguments[i].toString();\n            len = seg.length;\n            if (len > 1 && seg.charAt(len-1) == '/') {\n                seg = seg.substring(0, len-1);\n            }\n            if (seg.charAt(0) != '/') {\n                output += '/' + seg;\n            } else {\n                output += seg;\n            }\n        }\n\n        // augment static dirs with build number\n        if (output!='/') {\n            var segments = output.split('/');\n            var firstseg = segments[1];\n            if (firstseg=='static' || firstseg=='modules') {\n                var postfix = output.substring(firstseg.length+2, output.length);\n                output = '/'+firstseg+'/@' + window.$C['BUILD_NUMBER'];\n                if (window.$C['BUILD_PUSH_NUMBER']) output += '.' + window.$C['BUILD_PUSH_NUMBER'];\n                if (segments[2] == 'app')\n                    output += ':'+this.getConfigValue('APP_BUILD', 0);\n                output += '/' + postfix;\n            }\n        }\n\n        var root = Splunk.util.getConfigValue('MRSPARKLE_ROOT_PATH', '/');\n        var djangoRoot = Splunk.util.getConfigValue('DJANGO_ROOT_PATH', '');\n        var locale = Splunk.util.getConfigValue('LOCALE', 'en-US');\n\n        var combinedPath = \"\";\n        if (djangoRoot && output.substring(0, djangoRoot.length) === djangoRoot) {\n            combinedPath = output.replace(djangoRoot, djangoRoot + \"/\" + locale.toLowerCase());\n        } else {\n            combinedPath = \"/\" + locale + output;\n        }\n\n        if (root == '' || root == '/') {\n            return combinedPath;\n        } else {\n            return root + combinedPath;\n        }\n    },\n\n    /**\n     * Given a path and a dictionary of options, builds a qualified query string.\n     *\n     * @param uri {String} required; path to endpoint. eg. \"search/jobs\"\n     * @param options {Object} key / value par of query params eg. {'foo': 'bar'}\n     */\n    make_full_url: function(url, options) {\n        url = this.make_url(url);\n        if (options) url = url + '?' + this.propToQueryString(options);\n        return url;\n    },\n\n    /**\n     * Redirects user to a new page.\n     *\n     * @param uri {String} required\n     * @param options {Object} containing parameters like:\n     *         sid => attaches optional sid in valid format\n     *         s => attaches optional saved search name\n     *         q => attaches optional search string in valid format\n     *\n     *         Example:\n     *             util.redirect_to('app/core/search', {\n     *                 'sid' : 1234,\n     *                 'foo' : 'bar'\n     *             });\n     *\n     *             redirects to 'splunk/app/core/search?sid=1234&foo=bar'\n     * @param windowObj {Window Object} an optional window object to target the location change\n     * @param focus {Boolean} if true, focus is called on windowObj\n     */\n    redirect_to: function(uri, options, windowObj, focus) {\n        uri = this.make_full_url(uri, options);\n        if (!windowObj) windowObj = window;\n        windowObj.document.location = uri;\n        if (focus && windowObj.focus) windowObj.focus();\n        return;\n    },\n\n    /**\n     * Returns the current app name (not label).\n     */\n    getCurrentApp: function() {\n        return $(document.body).attr(\"s:app\") || 'UNKNOWN_APP';\n    },\n\n    /**\n     * Returns the current view name (not label).\n     */\n    getCurrentView: function() {\n        return $(document.body).attr(\"s:view\") || 'UNKNOWN_VIEW';\n    },\n    /**\n     * Returns the current 'displayView' name if it differs from the view name, else returns the current view name.\n     */\n    getCurrentDisplayView: function() {\n        return $(document.body).attr(\"s:displayview\") || this.getCurrentView();\n    },\n    getAutoCancelInterval: function() {\n        var interval = $(document.body).attr(\"s:autoCancelInterval\");\n        if (!interval) {\n            this.logger.error(\"no autoCancelInterval found. Returning 0\");\n            interval = 0;\n        }\n        return interval;\n    },\n    /**\n     * Returns the current viewstate ID as requested via the URI parameter\n     * 'vs'.  This is embedded in the <body> tag.\n     *\n     * If no viewstate has been requested, then all parameter writes will\n     * go to the default sticky state, keyed by the reserved token '_current'.\n     *\n     * NOTE: viewstate is also provided to the modules through context resurrection,\n     * And that being the case, the value of this is marginal.\n     */\n    //getCurrentViewState: function() {\n    //    return $(document.body).attr(\"s:viewstateid\") || null;\n    //},\n\n    /**\n     * Returns a dictionary of all the app, view, and saved search config\n     * data that is specified in the current view.  Ex:\n     * {\n     *    'view': {\"template\": \"builder.html\", \"displayView\": \"report_builder_display\", \"refresh\": null, \"label\": \"Display Report\", \"viewstateId\": \"*:ft10i02z\", \"onunloadCancelJobs\": false, \"id\": \"report_builder_display\"},\n     *    'app': {\"id\": \"search\", \"label\": \"Search\"},\n     *    'savedSearch': {\"search\": \"johnvey | timechart count\", \"name\": \"jvreport3\", \"vsid\": \"*:ft10i02z\", \"qualifiedSearch\": \"search  johnvey | timechart count\"}\n     * }\n     */\n    getCurrentViewConfig: function() {\n        return $.extend({}, Splunk.ViewConfig);\n    },\n\n    /**\n     * Return the path without the localization segment.\n     */\n    getPath: function(path) {\n        if (path === undefined) {\n            path = document.location.pathname;\n        }\n        var locale = this.getConfigValue('LOCALE').toString();\n\n        // if there is no way to figure out the locale, just return pathname\n        if (!this.getConfigValue('LOCALE') || path.indexOf(locale) == -1) {\n            return path;\n        }\n        var start = locale.length + path.indexOf(locale);\n        return path.slice(start);\n    },\n\n    /**\n     * Get the cumulative offsetTop for an element.\n     *\n     * @param {Object} element A DOM element.\n     */\n    getCumlativeOffsetTop: function(element){\n        if(!element) return 0;\n        return element.offsetTop + this.getCumlativeOffsetTop(element.offsetParent);\n    },\n\n    /**\n     * Get the cumulative offsetLeft for an element.\n     *\n     * @param {Object} element A DOM element.\n     */\n    getCumlativeOffsetLeft: function(element){\n        if(!element) return 0;\n        return element.offsetLeft + this.getCumlativeOffsetLeft(element.offsetParent);\n    },\n\n    /**\n     * Retrieve the amount of content that has been hidden by scrolling down.\n     *\n     * @type Number\n     * @return 0-n value.\n     */\n    getPageYOffset: function(){\n        var pageYOffset = 0;\n        if(window.pageYOffset){\n            pageYOffset = window.pageYOffset;\n        }else if(document.documentElement && document.documentElement.scrollTop){\n            pageYOffset = document.documentElement.scrollTop;\n        }\n        return pageYOffset;\n    },\n\n    /**\n     * Retrieve the inner dimensions of the window. This does not work in jQuery.\n     *\n     * @type Object\n     * @return An object literal having width and height attributes.\n     */\n    getWindowDimensions: function(){\n        return {\n            width:(!isNaN(window.innerWidth))?window.innerWidth:document.documentElement.clientWidth||0,\n            height:(!isNaN(window.innerHeight))?window.innerHeight:document.documentElement.clientHeight||0\n        };\n    },\n\n    /**\n     * Retrieve the computed style from a specified element.\n     *\n     * @param el\n     * @param styleProperty\n     * @return The computed style value.\n     * @type String\n     */\n    getComputedStyleHelper: function(el, styleProperty){\n        if(el.currentStyle){\n            return el.currentStyle[styleProperty];\n        }else if(window.getComputedStyle){\n            var cssProperty = styleProperty.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n            var computedStyle = window.getComputedStyle(el, \"\");\n            return computedStyle.getPropertyValue(cssProperty);\n        }else{\n            return \"\";\n        }\n    },\n\n    /**\n     * Retrieve a GET parameter from the window.location. Type casting is not performed.\n     * @param {String} p The param value to retrieve.\n     * @param {String} s Optional string to search through instead of window.location.search\n     * @return {String || null} The string value or null if it does not exist.\n     */\n    getParameter: function(p, s){\n        s = s || window.location.search;\n        if(!s){\n            return null;\n        }\n        if(!(s.indexOf(p+'=')+1)){\n            return null;\n        }\n        return s.split(p+'=')[1].split('&')[0];\n    },\n\n    /**\n     * Take an RGB value and convert to HEX equivalent.\n     *\n     * @param {String} rgb A RGB value following rgb(XXX, XXX, XXX) convention.\n     * @type String\n     * @return A HEX equivalent for a given RGB value with a leading '#' character.\n     */\n    getHEX: function(rgb){\n        var parts = rgb.match(/^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/);\n        var hex = (parts[1]<<16|parts[2]<<8|parts[3]).toString(16);\n        return \"#\"+Array(6-hex.length).concat([hex]).toString().replace(/,/g, 0);\n    },\n\n    /**\n     * Take an arbitrary RGB or HEX in long or shorthand notation and normalize to standard long HEX form with leading '#' character.\n     *\n     * @param {String} color A RGB or HEX color value in long or short notation.\n     * @type String or null\n     * @return A fully qualified 6 character hexadecimal value or with leading '#' character or null if it can't be processed.\n     */\n    normalizeColor: function(color){\n        normalizedColor = null;\n        if(color.charAt(0)===\"#\"){\n            if(color.length===4){\n                normalizedColor = color + color.charAt(1) + color.charAt(2) + color.charAt(3);\n            }else{\n                normalizedColor = color;\n            }\n        }else{\n            try{\n                normalizedColor = this.getHEX(color);\n            }catch(e){}\n        }\n        return normalizedColor;\n    },\n\n    // **\n    // * validate a cron string\n    // * returns true if the cron string has five elements and each element contains one or more values (comma separated) from the following list\n    // * [X, *, */X, X/Y, X-Y, X-Y/Z and X,Y]\n    // * the allowed range of values for every field is as follows:\n    // * [MINUTES HOURS DAY_OF_MONTH MONTH DAY_OF_WEEK] = [0-59 0-23 1-31 1-12 0-7]\n    // */\n    // p.s. need to comment the header different to not exit the comment block for the */X case\n    validateCronString: function(cronString) {\n        var cronRegEx = /^((0*([0-9]|[1-5][0-9])|\\*)(-0*([0-9]|[1-5][0-9]))?(\\/\\d+)?,)*(0*([0-9]|[1-5][0-9])|\\*)(-0*([0-9]|[1-5][0-9]))?(\\/\\d+)?\\s((0*([0-9]|1[0-9]|2[0-3])|\\*)(-0*([0-9]|1[0-9]|2[0-3]))?(\\/\\d+)?,)*(0*([0-9]|1[0-9]|2[0-3])|\\*)(-0*([0-9]|1[0-9]|2[0-3]))?(\\/\\d+)?\\s((0*([1-9]|[1-2][0-9]|3[0-1])|\\*)(-0*([1-9]|[1-2][0-9]|3[0-1]))?(\\/\\d+)?,)*(0*([1-9]|[1-2][0-9]|3[0-1])|\\*)(-0*([1-9]|[1-2][0-9]|3[0-1]))?(\\/\\d+)?\\s((0*([1-9]|1[0-2])|\\*)(-0*([1-9]|1[0-2]))?(\\/\\d+)?,)*(0*([1-9]|1[0-2])|\\*)(-0*([1-9]|1[0-2]))?(\\/\\d+)?\\s((0*[0-7]|\\*)(-0*[0-7])?(\\/\\d+)?,)*(0*[0-7]|\\*)(-0*[0-7])?(\\/\\d+)?$/;\n        if (!cronRegEx.test(cronString)) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * innerHTML substitute when it is not fast enough.\n     * @param {HTMLObject} target The target DOM element to replace innerHTML content with.\n     * @param {String} innerHTML The innerHTML string to add.\n     * @return {HTMLObject} The reference to the target DOM element as it may have been cloned and removed.\n     */\n    turboInnerHTML: function(target, innerHTML) {\n        /*@cc_on //innerHTML is faster for IE\n            target.innerHTML = innerHTML;\n            return target;\n        @*/\n        var targetClone = target.cloneNode(false);\n        targetClone.innerHTML = innerHTML;\n        target.parentNode.replaceChild(targetClone, target);\n        return targetClone;\n    },\n    normalizeBoolean: function(test, strictMode) {\n\n        if (typeof(test) == 'string') {\n            test = test.toLowerCase();\n        }\n\n        switch (test) {\n            case true:\n            case 1:\n            case '1':\n            case 'yes':\n            case 'on':\n            case 'true':\n                return true;\n\n            case false:\n            case 0:\n            case '0':\n            case 'no':\n            case 'off':\n            case 'false':\n                return false;\n\n            default:\n                if (strictMode) throw TypeError(\"Unable to cast value into boolean: \" + test);\n                return test;\n        }\n    },\n    getCommaFormattedNumber: function(nStr) {\n        nStr += '';\n        var x = nStr.split('.');\n        var x1 = x[0];\n        var x2 = x.length > 1 ? '.' + x[1] : '';\n        var rgx = /(\\d+)(\\d{3})/;\n        while (rgx.test(x1)) {\n            x1 = x1.replace(rgx, '$1' + ',' + '$2');\n        }\n        return x1 + x2;\n    },\n\n\n    reLTrim: /^[\\s\\t\\r\\n]+/,\n    reLTrimCommand: /^[\\s\\t\\r\\n\\|]+/,\n    reRNormalize: /[\\s\\t\\r\\n]+$/,\n\n    /**\n     * Returns a fully qualified search string by prepending the 'search'\n     * command of unqualified searches.  This method deems strings as unqualified\n     * if it does not start with a | or 'search '\n     *\n     * @param {boolean} isUserEntered Indicates if 'q' is expected to be unqualified\n     */\n    addLeadingSearchCommand: function(q, isUserEntered) {\n        var workingQ = '' + q;\n        workingQ = workingQ.replace(this.reLTrim, '').replace(this.reRNormalize, ' ');\n        if (workingQ.substring(0, 1) == '|') {\n            return q;\n        }\n\n        // this is specific to the case where searchstring = 'search ',\n        // which we conservatively assume does not constitute a search command\n        if (!isUserEntered\n            && (workingQ.substring(0, 7) == 'search ' && workingQ.length > 7))\n        {\n            return q;\n        }\n        return 'search ' + workingQ;\n    },\n\n    /**\n     * Returns an unqualified search string by removing any leading 'search '\n     * command.  This method does a simple search at the beginning of the\n     * search.\n     */\n    stripLeadingSearchCommand: function(q) {\n        var workingQ = '' + q;\n        workingQ = workingQ.replace(this.reLTrimCommand, '');\n        if (workingQ.substring(0, 7) == 'search ') {\n            return workingQ.substring(7).replace(this.reLTrimCommand, '');\n        }\n        return q;\n    },\n\n    /**\n     * Deserializes a string into a field list.\n     */\n    stringToFieldList: function(strList) {\n        if (typeof(strList) != 'string' || !strList) return [];\n        var items = [];\n        var field_name_buffer = [];\n        var inquote = false;\n        var str = $.trim(strList);\n        for (var i=0,j=str.length; i<j; i++) {\n            if (str.charAt(i) == '\\\\') {\n                var nextidx = i+1;\n                if (j > nextidx && (str.charAt(nextidx) == '\\\\' || str.charAt(nextidx) == '\"')) {\n                    field_name_buffer.push(str.charAt(nextidx));\n                    i++;\n                    continue;\n                } else {\n                    field_name_buffer.push(str.charAt(i));\n                    continue;\n                }\n            }\n\n            if (str.charAt(i) == '\"') {\n                if (!inquote) {\n                    inquote = true;\n                    continue;\n                } else {\n                    inquote = false;\n                    items.push(field_name_buffer.join(''));\n                    field_name_buffer = [];\n                    continue;\n                }\n            }\n\n            if ((str.charAt(i) == ' ' || str.charAt(i) == ',') && !inquote) {\n                if (field_name_buffer.length > 0) {\n                    items.push(field_name_buffer.join(''));\n                }\n                field_name_buffer = [];\n                continue;\n            }\n            field_name_buffer.push(str.charAt(i));\n        }\n        if (field_name_buffer.length > 0) items.push(field_name_buffer.join(''));\n        return items;\n    },\n\n\n    /**\n     * Serializes a field list array into a string.\n     */\n    _sflQuotable: /([\\\\\",\\s])/,\n    _sflEscapable: /([\\\\\"])/g,\n    fieldListToString: function(fieldArray) {\n        if (!fieldArray) return '';\n        var output = [];\n        for (var i=0,L=fieldArray.length; i<L; i++) {\n            var v = $.trim(fieldArray[i]);\n            if (v != '') {\n                // Escape any char with the backslash.\n                if (v.search(this._sflEscapable) > -1) {\n                    v = v.replace(this._sflEscapable, \"\\\\$1\");\n                }\n\n                // Quote the entire string if a backslash, comma, space\n                // or double quote is present.\n                if (v.search(this._sflQuotable) > -1) {\n                    v = ['\"', v, '\"'].join('');\n                }\n\n                output.push(v);\n            }\n        }\n        return output.join(',');\n    },\n    /**\n     * Escapes a string for use in the search language.\n     *\n     * @param str {String} string to escape\n     * @param options {Object} {\n     *     forceQuotes {Boolean, default false} adds quotes around the string even if it doesn't contain special characters,\n     *                 useful if the result is being used as a string literal in the search language.\n     * }\n     * @returns {string}\n     */\n    searchEscape: function(str, options) {\n        if (!str.match(/[\\s\\,=|\\[\\]\\\"]/))\n            return options && options.forceQuotes ? '\"' + str + '\"' : str;\n\n        return '\"' + str.replace(/(\\\"|\\\\)/g, \"\\\\$1\") + '\"';\n    },\n\n    /**\n     * Un-escapes a string that was previously escaped using `searchEscape`.\n     *\n     * @param str {String}\n     * @returns {String}\n     */\n    searchUnescape: function(str) {\n        if (str[0] !== '\"' || str[str.length -1] !== '\"') {\n            return str;\n        }\n        return str.slice(1, -1).replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\');\n    },\n\n    /**\n     * Compare the likeness of two objects. Please use with discretion.\n     */\n    objectSimilarity: function(obj1, obj2){\n            if(obj1 instanceof Array && obj2 instanceof Array){\n                    if(obj1.length!==obj2.length){\n                       return false;\n                    }else{\n                        for(var i=0; i<obj1.length; i++){\n                            if(!this.objectSimilarity(obj1[i], obj2[i])){\n                                return false;\n                            }\n                        }\n                    }\n            }else if(obj1 instanceof Object && obj2 instanceof Object){\n                if(obj1!=obj2){\n                    for(var j in obj2){\n                        if(!obj1.hasOwnProperty(j)){\n                            return false;\n                        }\n                    }\n                    for(var k in obj1){\n                        if(obj1.hasOwnProperty(k)){\n                            if(obj2.hasOwnProperty(k)){\n                                if(!this.objectSimilarity(obj1[k], obj2[k])){\n                                    return false;\n                                }\n                            }else{\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }else if(typeof(obj1)===\"function\" && typeof(obj2)===\"function\"){\n                if(obj1.toString()!==obj2.toString()){\n                    return false;\n                }\n            }else if(obj1!==obj2){\n                return false;\n            }\n            return true;\n    },\n    /**\n     * Stop watch class.\n     */\n    StopWatch: function(){\n        var self = this,\n            startTime = null,\n            stopTime = null,\n            times = [];\n        var isSet = function(prop){\n            return (prop==null)?false:true;\n        };\n        var isStarted = function(){\n            return isSet(startTime);\n        };\n        var isStopped = function(){\n            return isSet(stopTime);\n        };\n        var softReset = function(){\n            startTime = null;\n            stopTime = null;\n        };\n        self.start = function(){\n            if(isStarted()){\n               throw new Error(\"cannot call start, start already invoked.\");\n            }\n            startTime = new Date();\n        };\n        self.stop = function(){\n           if(!isStarted()){\n               throw new Error(\"cannot call stop, start not invoked.\");\n           }\n           if(isStopped()){\n               throw new Error(\"cannot call stop, stop already invoked.\");\n           }\n           stopTime = new Date();\n           time = stopTime - startTime;\n           times.push(time);\n        };\n        self.pause = function(){\n            if(!isStarted()){\n               throw new Error(\"cannot call pause, start not invoked.\");\n            }\n            if(isStopped()){\n               throw new Error(\"cannot call pause, stop already invoked.\");\n            }\n            self.stop();\n            softReset();\n        };\n        self.reset = function(){\n            softReset();\n            times = [];\n        };\n        self.time = function(){\n            var total = 0;\n            for(i=0; i<times.length; i++){\n                total += times[i];\n            }\n            if(isStarted() && !isStopped()){\n                total += (new Date() - startTime);\n            }\n            return total/1000;\n        };\n    },\n\n    isInt: function(num) {\n        return num!=='' && !isNaN(parseInt(num, 10)) && parseInt(num, 10)==(num/1);\n    },\n\n    /**\n     * Returns a string trimmed to maxLength by removing characters from the\n     * middle of the string and replacing with ellipses.\n     *\n     * Ex: Splunk.util.smartTrim('1234567890', 5) ==> '12...890'\n     *\n     */\n    smartTrim: function(string, maxLength) {\n        if (!string) return string;\n        if (maxLength < 1) return string;\n        if (string.length <= maxLength) return string;\n        if (maxLength == 1) return string.substring(0,1) + '...';\n\n        var midpoint = Math.ceil(string.length / 2);\n        var toremove = string.length - maxLength;\n        var lstrip = Math.ceil(toremove/2);\n        var rstrip = toremove - lstrip;\n        return string.substring(0, midpoint-lstrip) + '...' + string.substring(midpoint+rstrip);\n    },\n    _tokenDiscoverer : /\\$([^$]+)\\$/g,\n\n    /**\n     * Finds all instances of any string looking like \"$foo$\" anywhere in the given object literal.\n     * returns an array of all the distinct values it found, eg 'foo'.\n     * if a single string value in the struct has two, like \"$foo$ $bar$\", duplicates are removed.\n     * This will also discover any number of \"$foo$\" substrings that are found within the\n     * keys of object literals, not just the values.\n     */\n    discoverReplacementTokens: function(fragment) {\n        var keys = [];\n        var tokenDiscoverer = Splunk.util._tokenDiscoverer;\n        var keysToAdd;\n\n        if (typeof fragment == 'string') {\n            if (fragment.match(tokenDiscoverer)) {\n                keysToAdd = fragment.match(tokenDiscoverer);\n                // TODO - im sure there's a way to write the re so that it doesnt include the '$' chars but im moving on.\n                for (var i=0; i<keysToAdd.length; i++ ) {\n                    keysToAdd[i] = keysToAdd[i].substring(1, keysToAdd[i].length-1);\n                }\n                return keysToAdd;\n            }\n            return [];\n        }\n        else if (typeof fragment == \"function\") {\n            return [];\n        }\n\n        // then fragment is not a string.\n        for (var key in fragment) {\n            keysToAdd = [];\n            keysToAdd = Splunk.util.discoverReplacementTokens(fragment[key]);\n\n            // up until now we've only looked at values. We have to also discover keys in the key itself..\n            var matchesInTheKeyItself = key.match(tokenDiscoverer) || [];\n            for (var j=0; j<matchesInTheKeyItself.length; j++) {\n                // TODO - im sure there's a way to write the re so that it doesnt include the '$' chars but im moving on.\n                keysToAdd.push(matchesInTheKeyItself[j].substring(1, matchesInTheKeyItself[j].length-1));\n            }\n            // check against duplicates.\n            for (var k=0; k<keysToAdd.length; k++) {\n                if (keys.indexOf(keysToAdd[k]) ==-1) {\n                    keys.push(keysToAdd[k]);\n                }\n            }\n        }\n        return keys;\n    },\n\n    /**\n     * walked through the entirety of fragment to all levels of nesting\n     *  and will replace all matches of the given single regex with the given\n     *  single value.\n     *  replacement will occur in both keys and values.\n     */\n    replaceTokens: function(fragment, reg, value) {\n        if (typeof fragment == 'string') {\n            if (fragment.match(reg)) {\n                fragment = fragment.replace(reg, value);\n            }\n            return fragment;\n        }\n        else if (typeof fragment == \"function\") {\n            return fragment;\n        }\n        // watch out for infinite loops.  We make all changes to the array after iteration.\n\n        var keysToRename = {};\n        for (var key in fragment) {\n            // recurse\n            if (typeof fragment[key] == 'object') {\n                Splunk.util.replaceTokens(fragment[key], reg, value);\n            }\n            // we have hit a string value.\n            else if (typeof fragment[key] == 'string' && fragment[key].match(reg)) {\n                fragment[key] = fragment[key].replace(reg, value);\n            }\n            // now that the value is changed we check the key itself\n            if (key.match(reg)) {\n                // mark this to be changed after we're out of the iterator\n                keysToRename[key] = key.replace(reg, value);\n            }\n        }\n        for (var oldKey in keysToRename) {\n            var newKey = keysToRename[oldKey];\n            fragment[newKey] = fragment[oldKey];\n            delete(fragment[oldKey]);\n        }\n        return fragment;\n    },\n\n\n    getServerTimezoneOffset: function() {\n        return Splunk.util.getConfigValue('SERVER_TIMEZONE_OFFSET');\n    },\n\n    // constants used by Modules as well as ModuleLoader, to denote runtime states\n    // WAITING_FOR_INITIALIZATION and WAITING_FOR_HIERARCHY mean that the Modules\n    // are still being loaded by ModuleLoader.\n    // the remaining two states are relevant BOTH during page load, and in general\n    // at runtime thereafter.\n    // whether or not the page is still loading is an orthogonal piece of information,\n    // and modules can check it on demand by calling Module.isPageLoadComplete().\n    moduleLoadStates: {\n        WAITING_FOR_INITIALIZATION   : 1,  // waiting for INITIALIZATION\n        WAITING_FOR_HIERARCHY   : 2,  // waiting for HIERARCHY\n        WAITING_FOR_CONTEXT: 6,\n        HAS_CONTEXT         : 7\n    },\n\n    /**\n     * Returns a wait time (sec) based on the current time elapsed, as mapped\n     * onto a cubic easing function.\n     *\n     * elapsed_time: number of seconds that have elapsed since the first\n     *     call to getRetryInterval()\n     *\n     * min_interval: minimum return value of this method; also the interval\n     *     returned when elapsed_time = 0\n     *\n     * max_interval: maximum return value of this method; also the interval\n     *     returned when elapsed_time >= clamp_time\n     *\n     * clamp_time: total duration over which to calculate a wait time; while\n     *     elapsed_time < clamp_time, the return value will be less than\n     *     max_interval; when elapsed_time >= clamp_time, the return value will\n     *     always be max_interval\n     *\n     */\n    getRetryInterval: function(elapsed_time, min_interval, max_interval, clamp_time) {\n        if (elapsed_time >= clamp_time) return parseFloat(max_interval);\n        return Math.min(max_interval * Math.pow(elapsed_time/parseFloat(clamp_time), 3) + min_interval, max_interval);\n    },\n\n\n    /**\n     * Returns a string with HTML entities escaped.\n     * NOTE: IE will not interpret \"\"&apos;\", opting to just render it encoded\n     *      we use the alternate decimal version instead\n     *\n     */\n    escapeHtml: function(input) {\n        return (\"\"+input).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n    },\n\n    /**\n     * Returns a string with backslashes escaped\n     */\n    escapeBackslash: function(input) {\n        return (\"\"+input).replace(/\\\\/g, '\\\\\\\\');\n    },\n\n    /**\n     * Returns a string with double quotes escaped\n     */\n    escapeQuotes: function(input) {\n        return (\"\"+input).replace(\"\\\"\",\"\\\\\\\"\");\n    },\n\n    /**\n     * Returns a string with regex characters escaped\n     * http://stackoverflow.com/questions/2593637\n     */\n    escapeRegex: function(input) {\n        return (input+'').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n    },\n\n    /**\n     * Escapes any special characters for use in a jQuery selector\n     */\n    escapeSelector: function(input) {\n        return (\"\"+input).replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\n    },\n\n    /**\n     * Trim out any special characters, leaving alphanumeric and -_{}?\n     *\n     * @param input\n     * @return {*}\n     */\n    trimToAlphaNumeric: function(input) {\n        return (\"\"+input).replace(/([\\s;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=<>`\\/\\|\\\\])/g, '');\n    },\n\n    /**\n     * From http://blog.stevenlevithan.com/archives/faster-trim-javascript\n     * profiler shows this is much faster than the previous implementation in both IE and Firefox.\n     *\n     * @param {String} str The string to trim.\n     * @param {String} (Optional) delim The characters to remove from the start/end of the string.\n     *\n     * @type String\n     * @return A trimmed string.\n     */\n    trim: function(str, delim) {\n        if (delim) return str.replace(new RegExp(\"^[\\\\s\" + delim + \"]+\"),'').replace(new RegExp(\"[\\\\s\" + delim + \"]+$\"), '');\n        else return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    },\n\n    /**\n     * Simple normalization for user input: trims whitespaces and lowercases string\n     *\n     * @param str {String} input string\n     * @param defValue {String} (optional) default value if str is null\n     * @return {String} cleansed string\n     */\n    lowerTrimStr: function(str, defValue) {\n        if (!str) {\n            return defValue ? defValue : str;\n        }\n        return this.trim(str).toLowerCase();\n    },\n\n    focusFirstField: function(popup){ //this puts the focus on the first form element whether an input or select dropdown\n        var firstInput = $(\":input:visible:enabled:first\",popup),\n        firstSelect = $(\"select:visible:enabled:first\",popup);\n\n        if(firstInput.is(\":button\") && firstInput.hasClass('splButton-secondary')) {\n            if($(\":input:button.splButton-primary:first\", popup).length) {\n                firstInput = $(\":input:button.splButton-primary:first\", popup);\n            }\n        }\n\n        var firstInputOffset = (firstInput.length) ? firstInput.offset().top : false,\n        firstSelectOffset = (firstSelect.length) ? firstSelect.offset().top : false,\n        firstElem = firstInput;\n\n        if(firstInputOffset && firstSelectOffset && (firstSelectOffset < firstInputOffset)){\n            firstElem = firstSelect;\n        }\n        firstElem.focus();\n        var isFirstElemFocused = firstElem.is(\":focus\");\n\n        //Fix for IE8\n        if(!isFirstElemFocused) {\n            setTimeout(function() {\n                firstElem.focus();\n            }, 10);\n        }\n    },\n\n    /**\n     * Transform a string against wiki formatting rules.\n     *\n     * @param {String} str The string to format.\n     *\n     * @type String\n     * @return A HTML formatted string.\n     */\n    getWikiTransform: function(str) {\n        var text = Splunk.util.escapeHtml(str);\n        // we tokenize the conditional '!' prefix and replace it after\n        text = text.replace(/\\[(\\!?)(\\w+\\:\\/\\/[^\\s]+)\\s+([^\\]]+)\\]/g, '<a href=\"$2\" #~#$1#~#>$3</a>');\n        text = text.replace(/\\[\\[(\\!?)([^\\|]+)\\|([^\\]]+)\\]\\]/g, Splunk.util._generateInternalLink);\n        text = text.replace(/#~#!#~#/g, 'target=\"_blank\"');\n        text = text.replace(/\\s*#~##~#/g, '');\n        return text;\n    },\n\n    _generateInternalLink: function(str, blank_token, url, text) {\n        url = Splunk.util.make_url(url);\n        return '<a href=\"'+url+'\"#~#'+blank_token+'#~#>'+text+'</a>';\n    },\n\n    /**\n     * Utility to get the indices of all regular expression matches\n     *\n     * @param rex {RegExp} regular expression to match on\n     * @param source {string} the text on which to find matches\n     * @return {Array} all of the matches\n     *             {Object}\n     *                 match {string} the substring match found in the source\n     *                 start {number} the index in the source for the start of the match\n     *                 end {number} the index in the source for the end of the match\n     */\n    findMatchIndices: function(rex, source) {\n        var matches = source.match(rex);\n        var index = 0;\n        var results = [];\n        var length = matches.length;\n\n        for (var i = 0; i < length; i++) {\n            var match = matches[i];\n            index = source.indexOf(match, index);\n            if (index != -1) {\n                results.push({match: match, start: index, end: index + match.length - 1});\n            }\n            index++;\n        }\n\n        return results;\n    },\n\n    isRainmakr: function(isDmcEnabled, isCloud) {\n        return (!isDmcEnabled && isCloud);\n    },\n\n    isStackmakr: function(isDmcEnabled, isCloud) {\n        return (isDmcEnabled && isCloud);\n    },\n\n    /**\n     * Returns IE version or -1 if it's not IE\n     *\n     */\n     getIEVersion: function() {\n        var myNav = navigator.userAgent.toLowerCase();\n        if (myNav.indexOf('msie') != -1) {\n            return parseInt(myNav.split('msie')[1], 10);\n        }\n        // Check IE > 10\n        if (myNav.indexOf('trident') != -1) {\n            return parseInt(myNav.split(' rv:')[1], 10);\n        }\n        return -1;\n    },\n\n    /**\n    * Restart splunkd/splunkweb and udpate the UI with progress\n    */\n    restart_server: function(return_to) {\n        var start_time;\n        var restart_timeout = false;\n        var restart_tries = 0;\n        var restart_url_base;\n        var restart_url_proto;\n        var restart_done = false;\n        var restart_notified = false;\n        var img_list = [];\n        var RESTART_MAX_TRIES = 180; // Wait max of 3 minutes for restart\n        var PING_INTERVAL = 2000;\n\n        var restart_fail = function(msg) {\n            Splunk.Messenger.System.getInstance().send('error', 'restart_server', msg);\n            $(document).trigger('restart_failed');\n        };\n\n        var restart_succeeded = function() {\n            if (!restart_notified) {\n                restart_notified = true;\n                alert(_('Restart successful - click OK to log back into Splunk'));\n                var bounce_url;\n                if (return_to) {\n                    bounce_url = restart_url_base + this.make_full_url('/account/login', { return_to: return_to });\n                } else {\n                    bounce_url = restart_url_base + this.make_url('/');\n                }\n                window.location.href = bounce_url;\n            }\n        }.bind(this);\n\n        /**\n        * Track when the current instance of the appserver was started; if it changes then\n        * the restart has finished.\n        */\n        var restart_check_status = function () {\n            if (restart_done)\n                return;\n\n            if(restart_tries++ >= RESTART_MAX_TRIES) {\n                restart_fail(_('Timed out waiting for restart'));\n                return;\n            }\n\n            $.ajax({\n                type: 'GET',\n                dataType: 'json',\n                cache: false,\n                url: restart_url_base + this.make_url('/api/config/UI_UNIX_START_TIME'),\n                success: function(data) {\n                    if (data.start_time > start_time) {\n                        restart_done = true;\n                        clearTimeout(restart_timeout);\n                        restart_succeeded();\n                    }\n                }\n            });\n            // if the script fails to load (ie. because splunkweb is still down)\n            // jquery won't give us an error; instead nothing will happen hence we\n            // need to refire the poll\n            restart_timeout = setTimeout(restart_check_status, PING_INTERVAL);\n        }.bind(this);\n\n        var restart_img_loaded = function() {\n            restart_done = true;\n            clearTimeout(restart_timeout);\n            restart_succeeded();\n        };\n\n        /**\n        * Img checking works better than timestamp checking if the protocol has been changed\n        */\n        var restart_check_status_img = function() {\n            if (restart_done) {\n                return;\n            }\n            var im = new Image();\n            im.onload = restart_img_loaded;\n            im.src = restart_url_base + this.make_url('/config/img?proto='+restart_url_proto+'&_='+ Math.random());\n            img_list.push(im);\n            restart_timeout = setTimeout(restart_check_status_img, PING_INTERVAL);\n        }.bind(this);\n\n        $.post(this.make_url('/api/manager/control'), {operation: 'restart_server'}, function(data) {\n            if (data.status=='OK') {\n                start_time = data.start_time;\n\n                if (data.ssl == 'window') data.ssl = window.location.protocol == 'https:';\n\n                restart_url_proto = data.ssl ? 'https' : 'http';\n                restart_url_base = (data.ssl ? 'https://' : 'http://') + window.location.hostname + (data.port==80 || (data.ssl && data.port==443) ? '' : ':'+data.port);\n\n                // Turn off stuff that continues to try to communicate with the appserver\n                Splunk.Logger.mode.Default = Splunk.Logger.mode.None;\n                if (Splunk.Messenger) {\n                    Splunk.Messenger.System.getInstance().abortRequests = true;\n                }\n                // Send a signal to stop all the pollers\n                Splunk.Session.getInstance().signalRestart();\n\n                restart_tries = 0;\n                var current_port = window.location.port || (window.location.protocol=='http:' ? 80 : 443);\n                var current_ssl = window.location.protocol == 'https:';\n                if ((!current_ssl && data.ssl) || (data.ssl && current_port!=data.port)) {\n                    // Switching into SSL or changing ports with SSL enabled can cause problems if the browser doesn't accept the new cert\n                    // (ie. a self signed, or untrusted cert is in use which is a common case)\n                    $(document).trigger({ type: 'restart_ssl', sslBase: restart_url_base });\n                    return;\n                }\n                if (data.ssl!=current_ssl || current_port!=data.port) {\n                    restart_check_status_img();\n                } else {\n                    restart_check_status();\n                }\n            } else if (data.status == 'PERMS') {\n                restart_fail(_('Permission Denied - You are not authorized to restart the server'));\n            } else if (data.status == 'AUTH') {\n                restart_fail(_('Restart failed'));\n            } else if (data.status == 'FAIL') {\n                restart_fail(_('Restart failed: '+data.reason));\n            } else {\n                restart_fail(_('Restart failed'));\n            }\n        }.bind(this), 'json');\n    },\n\n    /**\n     * Push data to Splunk Web Analytics (SWA)\n     */\n    trackEvent: function (data) {\n        if (window._splunk_metrics_events && typeof data === 'object') {\n            window._splunk_metrics_events.push(data);\n        }\n    }\n};\n\n/**\n * ----------------------\n * Black magic for Prototype's bind() method which we're still using.\n *\n */\n\nif(!Function.prototype.bind) {\n  var $A = function(iterable) {\n    if (!iterable) return [];\n    if (iterable.toArray) {\n      return iterable.toArray();\n    } else {\n      var results = [];\n      for (var i = 0, length = iterable.length; i < length; i++)\n        results.push(iterable[i]);\n      return results;\n    }\n  };\n  Function.prototype.bind = function() {\n    var __method = this, args = $A(arguments), object = args.shift();\n    return function() {\n      return __method.apply(object, args.concat($A(arguments)));\n    };\n  };\n}\n/**\n * ----------------------\n * Prototype augmentation.\n * TODO - find another way.\n *\n */\n\nif (!String.prototype.repeat) {\n    String.prototype.repeat = function(count) {\n        return new Array(count+1).join(this);\n    };\n}\n\nif (!String.prototype.reverse) {\n    String.prototype.reverse = function() {\n        return this.split('').reverse().join('');\n    };\n}\n\nif (!String.prototype.rsplit) {\n    String.prototype.rsplit = function(sep, limit) {\n        var sp = this.split(sep);\n        if (limit && sp.length > limit) {\n            var r = [];\n            for(var i=0; i<limit; i++)\n                r[i] = sp[sp.length-limit+i];\n            return r;\n        }\n        return sp;\n    };\n}\n\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(search, fromIndex) {\n        if (!fromIndex) fromIndex = 0;\n        for(var i=0; i<this.length; i++) {\n            if (this[i] === search)\n                return i;\n        }\n        return -1;\n    };\n}\n\nif (!Array.prototype.extend) {\n    Array.prototype.extend = function(arr) {\n        for(var i=0; i<arr.length; i++)\n            this.push(arr[i]);\n    };\n}\n\n/**\n* sprintf routine borrowed from http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_sprintf/\n* Licensed under GPL and MIT licenses\n*\n* Modified by Gareth to add support for Python style argument specifiers:\n* sprintf(\"Hi %(name)s, welcome to %(application)s\", { name: 'Gareth', app: 'Splunk })\n* Objects holding named arguments can also implement a python style __getitem__ method to return dynamic values\n*/\nvar sprintf = global.sprintf = function( ) {\n    // Return a formatted string\n    //\n    // +    discuss at: http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_sprintf/\n    // +       version: 810.1015\n    // +   original by: Ash Searle (http://hexmen.com/blog/)\n    // + namespaced by: Michael White (http://getsprink.com)\n    // +    tweaked by: Jack\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // *     example 1: sprintf(\"%01.2f\", 123.1);\n    // *     returns 1: 123.10\n\n    var regex = /%%|%(\\d+\\$)?(\\([^)]+\\))?([-+#0 ]*)(\\*\\d+\\$|\\*|\\d+)?(\\.(\\*\\d+\\$|\\*|\\d+))?([scboxXuidfegEG])/g;\n    var a = arguments;\n    var i = 0;\n    var format = a[i];\n    i++;\n\n    // pad()\n    var pad = function(str, len, chr, leftJustify) {\n        var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);\n        return leftJustify ? str + padding : padding + str;\n    };\n\n    // justify()\n    var justify = function(value, prefix, leftJustify, minWidth, zeroPad) {\n        var diff = minWidth - value.length;\n        if (diff > 0) {\n            if (leftJustify || !zeroPad) {\n                value = pad(value, minWidth, ' ', leftJustify);\n            } else {\n                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);\n            }\n        }\n        return value;\n    };\n\n    // formatBaseX()\n    var formatBaseX = function(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {\n        // Note: casts negative numbers to positive ones\n        var number = value >>> 0;\n        prefix = prefix && number && {'2': '0b', '8': '0', '16': '0x'}[base] || '';\n        value = prefix + pad(number.toString(base), precision || 0, '0', false);\n        return justify(value, prefix, leftJustify, minWidth, zeroPad);\n    };\n\n    // formatString()\n    var formatString = function(value, leftJustify, minWidth, precision, zeroPad) {\n        if (precision != null) {\n            value = value.slice(0, precision);\n        }\n        return justify(value, '', leftJustify, minWidth, zeroPad);\n    };\n\n    // finalFormat()\n    var doFormat = function(substring, valueIndex, valueName, flags, minWidth, _, precision, type) {\n        if (substring == '%%') return '%';\n\n        // parse flags\n        var leftJustify = false, positivePrefix = '', zeroPad = false, prefixBaseX = false;\n        var flagsl = flags.length;\n        for (var j = 0; flags && j < flagsl; j++) switch (flags.charAt(j)) {\n            case ' ': positivePrefix = ' '; break;\n            case '+': positivePrefix = '+'; break;\n            case '-': leftJustify = true; break;\n            case '0': zeroPad = true; break;\n            case '#': prefixBaseX = true; break;\n            default: break;\n        }\n\n        // parameters may be null, undefined, empty-string or real valued\n        // we want to ignore null, undefined and empty-string values\n        if (!minWidth) {\n            minWidth = 0;\n        } else if (minWidth == '*') {\n            minWidth = +a[i];\n            i++;\n        } else if (minWidth.charAt(0) == '*') {\n            minWidth = +a[minWidth.slice(1, -1)];\n        } else {\n            minWidth = +minWidth;\n        }\n\n        // Note: undocumented perl feature:\n        if (minWidth < 0) {\n            minWidth = -minWidth;\n            leftJustify = true;\n        }\n\n        if (!isFinite(minWidth)) {\n            throw new Error('sprintf: (minimum-)width must be finite');\n        }\n\n        if (!precision) {\n            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : void(0);\n        } else if (precision == '*') {\n            precision = +a[i];\n            i++;\n        } else if (precision.charAt(0) == '*') {\n            precision = +a[precision.slice(1, -1)];\n        } else {\n            precision = +precision;\n        }\n\n        // grab value using valueIndex if required?\n        var value;\n        if (valueName) {\n            valueName = valueName.substr(1, valueName.length-2);\n            value = a[1].__getitem__ ? a[1].__getitem__(valueName) : a[1][valueName];\n        } else {\n            if (valueIndex){\n                value = a[valueIndex.slice(0, -1)];\n            }\n            else\n            {\n                value = a[i];\n                i++;\n            }\n        }\n\n        var number;\n        var prefix;\n        switch (type) {\n            case 's': return formatString(String(value), leftJustify, minWidth, precision, zeroPad);\n            case 'c': return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);\n            case 'b': return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n            case 'o': return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n            case 'x': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n            case 'X': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();\n            case 'u': return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n            case 'i':\n            case 'd': {\n                        number = parseInt(+value, 10);\n                        prefix = number < 0 ? '-' : positivePrefix;\n                        value = prefix + pad(String(Math.abs(number)), precision, '0', false);\n                        return justify(value, prefix, leftJustify, minWidth, zeroPad);\n                    }\n            case 'e':\n            case 'E':\n            case 'f':\n            case 'F':\n            case 'g':\n            case 'G':\n                        {\n                        number = +value;\n                        prefix = number < 0 ? '-' : positivePrefix;\n                        var method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];\n                        var textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];\n                        value = prefix + Math.abs(number)[method](precision);\n                        return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();\n                    }\n            default: return substring;\n        }\n    };\n\n    return format.replace(regex, doFormat);\n};// }}}\n\n})(this);\n\n}.call(window));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwuanM/MWQzNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHLGFBQWEsRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxtQ0FBbUMsRUFBRSxTQUFTLEVBQUU7QUFDbkw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DLHVDQUF1QztBQUN2Qyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QztBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTyxVQUFVO0FBQ3BDLHVCQUF1QixPQUFPLHNDQUFzQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQix1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QyxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsME1BQTBNO0FBQzdOLGtCQUFrQixrQ0FBa0M7QUFDcEQsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsdUJBQXVCLE9BQU87QUFDOUIsd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzQkFBc0Isc0JBQXNCLHdCQUF3Qix1QkFBdUI7QUFDekksS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsS0FBSzs7QUFFTDtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHdCQUF3QixPQUFPO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixzQkFBc0IsT0FBTztBQUM3QixnQkFBZ0IsTUFBTTtBQUN0QixvQkFBb0I7QUFDcEIsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87QUFDckMsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwREFBMEQ7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLHVCQUF1QjtBQUNqSCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCx1REFBdUQsNEJBQTRCO0FBQ25GO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaURBQWlEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0JBQStCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQ0FBZ0M7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MseUNBQXlDO0FBQ3pDLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGLENBQUM7O0FBRUQsQ0FBQyIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xuKGZ1bmN0aW9uKCkge1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cblNwbHVuay5uYW1lc3BhY2UoXCJ1dGlsXCIpO1xuXG5TcGx1bmsudXRpbCA9IHtcblxuXG4gICAgLyoqXG4gICAgICogQXNzaWduIGVtcHR5IGhhbmRsZXJzIGZvciBsb2dnZXIgY2FsbHMuIE92ZXJyaWRlbiBieSBTcGx1bmsuTG9nZ2VyIGlmIGl0IGlzIGltcG9ydGVkLlxuICAgICAqL1xuICAgIGxvZ2dlciA6IHtcbiAgICAgICAgXCJpbmZvXCI6ZnVuY3Rpb24oKXt9LFxuICAgICAgICBcImxvZ1wiOmZ1bmN0aW9uKCl7fSxcbiAgICAgICAgXCJkZWJ1Z1wiOmZ1bmN0aW9uKCl7fSxcbiAgICAgICAgXCJ3YXJuXCI6ZnVuY3Rpb24oKXt9LFxuICAgICAgICBcImVycm9yXCI6ZnVuY3Rpb24oKXt9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBsaXRlcmFsIHRvIGFuIGVuY29kZWQgcXVlcnlzdHJpbmcga2V5L3ZhbHVlIHN0cmluZy5cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3BUb1F1ZXJ5U3RyaW5nOiBmdW5jdGlvbihkaWN0aW9uYXJ5KSB7XG4gICAgICAgIHZhciBvID0gW107XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZGljdGlvbmFyeSkge1xuICAgICAgICAgICAgdmFsID0gZGljdGlvbmFyeVtwcm9wXTtcbiAgICAgICAgICAgIG8ucHVzaChlbmNvZGVVUklDb21wb25lbnQocHJvcCkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG8uam9pbignJicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGZsYXQgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3QgbGl0ZXJhbFxuICAgICAqXG4gICAgICovXG4gICAgcXVlcnlTdHJpbmdUb1Byb3A6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgYXJncyA9IHRoaXMudHJpbShhcmdzLCAnJlxcPyMnKTtcbiAgICAgICAgaWYgKCFhcmdzIHx8IGFyZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0cyA9IGFyZ3Muc3BsaXQoJyYnKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuXG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIGVxdWFsc1NlZ21lbnRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlcXVhbHNTZWdtZW50cyA9IHBhcnRzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChlcXVhbHNTZWdtZW50cy5zaGlmdCgpKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChlcXVhbHNTZWdtZW50cy5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIHZhbHVlLlxuICAgICAqL1xuICAgIGdldEhhc2g6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhc2hQb3MgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgICBpZiAoaGFzaFBvcyA9PSAtMSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgcVBvcyA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJz8nLCBoYXNoUG9zKTtcblxuICAgIGlmIChxUG9zICE9IC0xKVxuICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhyZWYuc3Vic3RyKHFQb3MpO1xuXG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnN1YnN0cihoYXNoUG9zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyB3YXMgcG9ydGVkLCByZXdyaXR0ZW4gYSBiaXQgYW5kIGdyZWF0bHkgc2ltcGxpZmllZCBmcm9tIHRoZVxuICAgICAqIHNhbWUgbWV0aG9kIGluIHRoZSBvbGQgQ2FsZW5kYXIgb2JqZWN0IHdlIHVzZWQgdG8gdXNlLlxuICAgICAqIFRPRE8gLSBpdCBpcyBvbmx5IGhlcmUgdGVtcG9yYXJpbHksIGFuZCB3ZSBzaG91bGQgY29udGludWUgdHJ5aW5nIHRvXG4gICAgICoga2lsbCBpdC5cbiAgICAgKi9cbiAgICBwYXJzZURhdGUgOiBmdW5jdGlvbihzdHIsIGZtdCkge1xuXG4gICAgICAgIGlmICgoIXN0cikgfHwgKCFzdHIuaW5kZXhPZikgfHwgKHN0ci5pbmRleE9mKFwibW1cIik9PTApKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgIHZhciBtID0gLTE7XG4gICAgICAgIHZhciBkID0gMDtcbiAgICAgICAgdmFyIGEgPSBzdHIuc3BsaXQoL1xcVysvKTtcbiAgICAgICAgdmFyIGIgPSBmbXQubWF0Y2goLyUuL2cpO1xuICAgICAgICB2YXIgaSA9IDAsIGogPSAwO1xuICAgICAgICB2YXIgaHIgPSAwO1xuICAgICAgICB2YXIgbWluID0gMDtcbiAgICAgICAgdmFyIHNlYyA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghYVtpXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoYltpXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIlZFwiOlxuICAgICAgICAgICAgICAgICAgICBkID0gcGFyc2VJbnQoYVtpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCIlbVwiOlxuICAgICAgICAgICAgICAgICAgICBtID0gcGFyc2VJbnQoYVtpXSwgMTApIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiJVlcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiJXlcIjpcbiAgICAgICAgICAgICAgICAgICAgeSA9IHBhcnNlSW50KGFbaV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgKHkgPCAxMDApICYmICh5ICs9ICh5ID4gMjkpID8gMTkwMCA6IDIwMDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCIlSFwiOlxuICAgICAgICAgICAgICAgICAgICBociA9IHBhcnNlSW50KGFbaV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiJU1cIjpcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcGFyc2VJbnQoYVtpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCIlU1wiOlxuICAgICAgICAgICAgICAgICAgICBzZWMgPSBwYXJzZUludChhW2ldLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgIT0gMCAmJiBtICE9IC0xICYmIGQgIT0gMCkge1xuICAgICAgICAgICAgdmFyIG91ckRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBociwgbWluLCBzZWMpO1xuICAgICAgICAgICAgcmV0dXJuIG91ckRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3RoaXMubG9nZ2VyLndhcm4oJ3VuYWJsZSB0byBwYXJzZSBkYXRlIFwiJyArIHN0ciArICdcIiBpbnRvIFwiJyArIGZtdCArICdcIicpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHRpbWV6b25lIG9mZnNldCBpbiBtaW51dGVzLCBhbmQgIGEgSlMgRGF0ZSBvYmplY3QsXG4gICAgICogcmV0dXJucyB0aGUgZGVsdGEgaW4gbWlsbGlzZWNvbmRzLCBvZiB0aGUgdHdvIHRpbWV6b25lcy5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIGluY2x1ZGUgdGhlIG9mZnNldCBjb250cmlidXRpb25zIGZyb20gRFNUIGZvciBib3RoLlxuICAgICAqL1xuICAgIGdldFRpbWV6b25lT2Zmc2V0RGVsdGE6IGZ1bmN0aW9uKHNlcnZlck9mZnNldFRoZW4sIGQpIHtcbiAgICAgICAgaWYgKCFTcGx1bmsudXRpbC5pc0ludChzZXJ2ZXJPZmZzZXRUaGVuKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hhdCBKUyB0aGlua3MgdGhlIHRpbWV6b25lIG9mZnNldCBpcyBhdCB0aGUgdGltZSBnaXZlbiBieSBkLiBUaGlzIFdJTEwgSU5DTFVERSBEU1RcbiAgICAgICAgdmFyIGNsaWVudE9mZnNldFRoZW4gPSBkLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDtcbiAgICAgICAgLy8gd2hhdCBzcGx1bmtkIHRvbGQgaXMgdGhlIGFjdHVhbCB0aW1lem9uZSBvZmZzZXQuXG4gICAgICAgIHNlcnZlck9mZnNldFRoZW4gICAgID0gc2VydmVyT2Zmc2V0VGhlbiAqIC02MDtcblxuICAgICAgICByZXR1cm4gMTAwMCAqIChzZXJ2ZXJPZmZzZXRUaGVuIC0gY2xpZW50T2Zmc2V0VGhlbik7XG4gICAgfSxcblxuICAgIGdldEVwb2NoVGltZUZyb21JU086IGZ1bmN0aW9uKGlzb1N0cikge1xuICAgICAgICAvLyBsYXppbHkgaW5pdCB0aGUgcmVnZXggc28gd2Ugb25seSBkbyBpdCBvbmx5IGlmIG5lY2Vzc2FyeSBhbmQgb25seSBvbmNlLlxuICAgICAgICBpZiAoIXRoaXMuX2lzb1RpbWVSZWdleCkge1xuICAgICAgICAgICAgLy8gTm9ib2R5IGRvZXNudCBsaWtlIElTTy5cbiAgICAgICAgICAgIHRoaXMuX2lzb1RpbWVSZWdleCA9IC8oW1xcK1xcLV0pPyhcXGR7NCx9KSg/Oig/OlxcLShcXGR7Mn0pKSg/Oig/OlxcLShcXGR7Mn0pKSg/Oig/OltUIF0oXFxkezJ9KSkoPzooPzpcXDooXFxkezJ9KSkoPzooPzpcXDooXFxkezJ9KD86XFwuXFxkKyk/KSkpPyk/KD86KFopfChbXFwrXFwtXSkoXFxkezJ9KVs6XSooXFxkezJ9KT8pPyk/KT8pPy87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG0gPSB0aGlzLl9pc29UaW1lUmVnZXguZXhlYyhpc29TdHIpO1xuICAgICAgICAvLyBwdXQgaXQgaW50byBhIHN0cmluZyBmb3JtIHRoYXQgSlMgRGF0ZSBjb25zdHJ1Y3RvcnMgY2FuIGFjdHVhbGx5IGRlYWwgd2l0aC5cblxuICAgICAgICAvLyBCZWluZyBTdXBlciBDYXJlZnVsOiBjYWxsaW5nIHN1YnN0cmluZyBvbiB1bmRlZmluZWQgdmFyaWFibGVcbiAgICAgICAgLy8gaGVyZSB0aHJvd3MgYW4gZXhjZXB0aW9uIHRoYXQga2lsbHMgdGhlIHN0YWNrIGJ1dCBkb2VzbnRcbiAgICAgICAgLy8gYXBwZWFyIGluIGZpcmVidWcgbm9yIGV2ZW4gaW4gdGhlIEVycm9yIENvbnNvbGUuXG4gICAgICAgIHZhciBzZWNvbmRzLCBtaWxsaXNlY29uZHNTdHI7XG4gICAgICAgIGlmIChtWzddKSB7XG4gICAgICAgICAgICBzZWNvbmRzID0gbVs3XS5zdWJzdHJpbmcoMCwyKTtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhpcyBpbmNsdWRlcyB0aGUgcGVyaW9kLiAgaWUgXCIuMDAzXCJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kc1N0ciA9IG1bN10uc3Vic3RyaW5nKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzU3RyID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICAvKmpzaGludCAtVzA2MTpmYWxzZSAqL1xuICAgICAgICAvLyBJZiBtWzExXSBpcyB1bmRlZmluZWQsIHVzZSAwIGluc3RlYWQuXG4gICAgICAgIHZhciBvZmZzZXQgPSBldmFsKG1bOV0gKyAoNjAqbVsxMF0gKyBwYXJzZUludChtWzExXSB8fCAwLCAxMCkpKTtcbiAgICAgICAgLypqc2hpbnQgLVcwNjE6dHJ1ZSAqL1xuXG4gICAgICAgIHZhciBzdHIgPSBzcHJpbnRmKFwiJXMvJXMvJXMgJXM6JXM6JXNcIiwgbVszXSwgbVs0XSwgbVsyXSwgbVs1XSwgbVs2XSwgc2Vjb25kcyk7XG4gICAgICAgIC8vIGl0cyBzdGlsbCB3cm9uZywgYmVjYXVzZSBKUyB3aWxsIGludGVycHJldCB0aGlzIHRpbWUgaW4gbG9jYWx0aW1lLFxuICAgICAgICAvLyBBTkQgaWYgeW91IGdpdmUgSUUgdGhlIHRpbWV6b25lIHBhcnQgb2YgdGhlIHN0cmluZywgaXQgcGFzc2VzIG91dCBpbiBpdHMgb3duIHZvbWl0LlxuICAgICAgICB2YXIgdCA9IG5ldyBEYXRlKHN0cik7XG5cbiAgICAgICAgLy8gc28gd2UgcGF0Y2ggaXQuXG4gICAgICAgIHQuc2V0VGltZSh0LmdldFRpbWUoKSArIHRoaXMuZ2V0VGltZXpvbmVPZmZzZXREZWx0YShvZmZzZXQsIHQpKTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHQuZ2V0VGltZSgpIC8gMTAwMDtcblxuICAgICAgICByZXR1cm4gc3RhcnRUaW1lICsgbWlsbGlzZWNvbmRzU3RyO1xuICAgIH0sXG5cbiAgICBnZXRDb25maWdWYWx1ZTogZnVuY3Rpb24oY29uZmlnS2V5LCBvcHRpb25hbERlZmF1bHQpIHtcbiAgICAgICAgaWYgKHdpbmRvdy4kQyAmJiB3aW5kb3cuJEMuaGFzT3duUHJvcGVydHkoY29uZmlnS2V5KSkgcmV0dXJuIHdpbmRvdy4kQ1tjb25maWdLZXldO1xuICAgICAgICBlbHNlIGlmIChjb25maWdLZXkgPT09ICdGT1JNX0tFWScpIHtcbiAgICAgICAgICAgIC8vIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IG5vdyB0aGF0IHdlJ3ZlIG1vdmVkIHRoZSBmb3JtX2tleSBmcm9tIGNvbmZpZyBlbmRwb2ludCB0byBjb29raWVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZvcm1LZXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uYWxEZWZhdWx0ICE9ICd1bmRlZmluZWQnKSB7IC8vIGVuc3VyZSBvcHRpb25hbERlZmF1bHQgY2FuIGJlIHNldCB0byAnZmFsc2UnXG4gICAgICAgICAgICAgICAgLy8gdXRpbC5sb2dnZXIgd2lsbCBoYXZlIGJlZW4gc3dhcHBlZCBvdXQgYnkgdGhlIExvZ2dlciB3aGVuIExvZ2dlclxuICAgICAgICAgICAgICAgIC8vIGhhcyBhbHJlYWR5IGJlZW4gc2V0dXAsIGJ1dCBzdGlsbCB3b3JrcyB3aGVuIGl0cyBub3QuXG5cbiAgICAgICAgICAgICAgICAvL3RoaXMubG9nZ2VyLmRlYnVnKCdnZXRDb25maWdWYWx1ZSAtICcgKyBjb25maWdLZXkgKyAnIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gJyArIG9wdGlvbmFsRGVmYXVsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbmFsRGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRDb25maWdWYWx1ZSAtICcgKyBjb25maWdLZXkgKyAnIG5vdCBzZXQsIG5vIGRlZmF1bHQgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDb29raWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGNvb2tpZVZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGRvY3VtZW50LmNvb2tpZSAmJiBkb2N1bWVudC5jb29raWUgIT0gJycpIHtcbiAgICAgICAgICAgIHZhciBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb2tpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29va2llID0gJC50cmltKGNvb2tpZXNbaV0pO1xuICAgICAgICAgICAgICAgIC8vIERvZXMgdGhpcyBjb29raWUgc3RyaW5nIGJlZ2luIHdpdGggdGhlIG5hbWUgd2Ugd2FudD9cbiAgICAgICAgICAgICAgICBpZiAoY29va2llLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCArIDEpID09IChuYW1lICsgJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb29raWVWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChjb29raWUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb2tpZVZhbHVlO1xuICAgIH0sXG5cbiAgICBkZWxldGVDb29raWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGV4cGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBleHBkYXRlLnNldFRpbWUoZXhwZGF0ZS5nZXRUaW1lKCkgKyAoLTEgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgIGV4cGRhdGUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gc3ByaW50ZignJXM9O2V4cGlyZXM9JXM7cGF0aD0vJyxuYW1lLCBleHBkYXRlKTtcbiAgICB9LFxuXG4gICAgZ2V0Rm9ybUtleTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb29raWVOYW1lID0gXCJzcGx1bmt3ZWJfY3NyZl90b2tlbl9cIiArIFNwbHVuay51dGlsLmdldENvbmZpZ1ZhbHVlKCdNUlNQQVJLTEVfUE9SVF9OVU1CRVInLCAnJyk7XG4gICAgICAgIHZhciBjb29raWVWYWx1ZSA9IFNwbHVuay51dGlsLmdldENvb2tpZShjb29raWVOYW1lKTtcbiAgICAgICAgaWYgKGNvb2tpZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29va2llVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSxcblxuICAgIGxvZ2luQ2hlY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU3BsdW5rLnV0aWwuZ2V0Q29va2llKCdsb2dpbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvcGVyIHBhdGggdGhhdCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBhcHBzZXJ2ZXIgbG9jYXRpb24uXG4gICAgICogVGhpcyBpcyBjcml0aWNhbCB0byBlbnN1cmUgdGhhdCB3ZSBhcmUgcHJveHkgY29tcGF0aWJsZS4gVGhpcyBtZXRob2RcbiAgICAgKiB0YWtlcyAxIG9yIG1vcmUgYXJndW1lbnRzLCB3aGljaCB3aWxsIGFsbCBiZSBzdGljaGVkIHRvZ2V0aGVyIGluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogRXg6IG1ha2VfdXJsKCdzZWFyY2gvam9iJyk7IC8vIFwiL3NwbHVuay9zZWFyY2gvam9iXCJcbiAgICAgKiBFeDogbWFrZV91cmwoJy9zZWFyY2gvam9iJyk7IC8vIFwiL3NwbHVuay9zZWFyY2gvam9iXCJcbiAgICAgKiBFeDogbWFrZV91cmwoJy9zZWFyY2gnLCAnL2pvYicpOyAvLyBcIi9zcGx1bmsvc2VhcmNoL2pvYlwiXG4gICAgICogRXg6IG1ha2VfdXJsKCcvc2VhcmNoJywgJy9qb2InLCAxMjM0KTsgLy8gXCIvc3BsdW5rL3NlYXJjaC9qb2IvMTIzNFwiXG4gICAgICpcbiAgICAgKiBTdGF0aWMgcGF0aHMgYXJlIGF1Z21lbnRlZCB3aXRoIGEgY2FjaGUgZGVmZWF0ZXJcbiAgICAgKlxuICAgICAqIEV4OiBtYWtlX3VybCgnL3N0YXRpYy9qcy9mb28uanMnKTsgLy8gXCIvc3BsdW5rL3N0YXRpYy9AMTIzNDUvanMvZm9vLmpzXCJcbiAgICAgKiBFeDogbWFrZV91cmwoJy9zdGF0aWMvanMvZm9vLmpzJyk7IC8vIFwiL3NwbHVuay9zdGF0aWMvQDEyMzQ1LjEvanMvZm9vLmpzXCJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIHtTdHJpbmd9IFRoZSByZWxhdGl2ZSBwYXRoIHRvIGV4dGVuZFxuICAgICAqL1xuICAgIG1ha2VfdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBzZWcsIGxlbjtcbiAgICAgICAgZm9yICh2YXIgaT0wLGw9YXJndW1lbnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgIHNlZyA9IGFyZ3VtZW50c1tpXS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGVuID0gc2VnLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPiAxICYmIHNlZy5jaGFyQXQobGVuLTEpID09ICcvJykge1xuICAgICAgICAgICAgICAgIHNlZyA9IHNlZy5zdWJzdHJpbmcoMCwgbGVuLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZy5jaGFyQXQoMCkgIT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICcvJyArIHNlZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHNlZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF1Z21lbnQgc3RhdGljIGRpcnMgd2l0aCBidWlsZCBudW1iZXJcbiAgICAgICAgaWYgKG91dHB1dCE9Jy8nKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBvdXRwdXQuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgIHZhciBmaXJzdHNlZyA9IHNlZ21lbnRzWzFdO1xuICAgICAgICAgICAgaWYgKGZpcnN0c2VnPT0nc3RhdGljJyB8fCBmaXJzdHNlZz09J21vZHVsZXMnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc3RmaXggPSBvdXRwdXQuc3Vic3RyaW5nKGZpcnN0c2VnLmxlbmd0aCsyLCBvdXRwdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAnLycrZmlyc3RzZWcrJy9AJyArIHdpbmRvdy4kQ1snQlVJTERfTlVNQkVSJ107XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy4kQ1snQlVJTERfUFVTSF9OVU1CRVInXSkgb3V0cHV0ICs9ICcuJyArIHdpbmRvdy4kQ1snQlVJTERfUFVTSF9OVU1CRVInXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHNbMl0gPT0gJ2FwcCcpXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSAnOicrdGhpcy5nZXRDb25maWdWYWx1ZSgnQVBQX0JVSUxEJywgMCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICcvJyArIHBvc3RmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdCA9IFNwbHVuay51dGlsLmdldENvbmZpZ1ZhbHVlKCdNUlNQQVJLTEVfUk9PVF9QQVRIJywgJy8nKTtcbiAgICAgICAgdmFyIGRqYW5nb1Jvb3QgPSBTcGx1bmsudXRpbC5nZXRDb25maWdWYWx1ZSgnREpBTkdPX1JPT1RfUEFUSCcsICcnKTtcbiAgICAgICAgdmFyIGxvY2FsZSA9IFNwbHVuay51dGlsLmdldENvbmZpZ1ZhbHVlKCdMT0NBTEUnLCAnZW4tVVMnKTtcblxuICAgICAgICB2YXIgY29tYmluZWRQYXRoID0gXCJcIjtcbiAgICAgICAgaWYgKGRqYW5nb1Jvb3QgJiYgb3V0cHV0LnN1YnN0cmluZygwLCBkamFuZ29Sb290Lmxlbmd0aCkgPT09IGRqYW5nb1Jvb3QpIHtcbiAgICAgICAgICAgIGNvbWJpbmVkUGF0aCA9IG91dHB1dC5yZXBsYWNlKGRqYW5nb1Jvb3QsIGRqYW5nb1Jvb3QgKyBcIi9cIiArIGxvY2FsZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbWJpbmVkUGF0aCA9IFwiL1wiICsgbG9jYWxlICsgb3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvb3QgPT0gJycgfHwgcm9vdCA9PSAnLycpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21iaW5lZFBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdCArIGNvbWJpbmVkUGF0aDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHBhdGggYW5kIGEgZGljdGlvbmFyeSBvZiBvcHRpb25zLCBidWlsZHMgYSBxdWFsaWZpZWQgcXVlcnkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSB7U3RyaW5nfSByZXF1aXJlZDsgcGF0aCB0byBlbmRwb2ludC4gZWcuIFwic2VhcmNoL2pvYnNcIlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IGtleSAvIHZhbHVlIHBhciBvZiBxdWVyeSBwYXJhbXMgZWcuIHsnZm9vJzogJ2Jhcid9XG4gICAgICovXG4gICAgbWFrZV9mdWxsX3VybDogZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHVybCA9IHRoaXMubWFrZV91cmwodXJsKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHVybCA9IHVybCArICc/JyArIHRoaXMucHJvcFRvUXVlcnlTdHJpbmcob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZGlyZWN0cyB1c2VyIHRvIGEgbmV3IHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJpIHtTdHJpbmd9IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gY29udGFpbmluZyBwYXJhbWV0ZXJzIGxpa2U6XG4gICAgICogICAgICAgICBzaWQgPT4gYXR0YWNoZXMgb3B0aW9uYWwgc2lkIGluIHZhbGlkIGZvcm1hdFxuICAgICAqICAgICAgICAgcyA9PiBhdHRhY2hlcyBvcHRpb25hbCBzYXZlZCBzZWFyY2ggbmFtZVxuICAgICAqICAgICAgICAgcSA9PiBhdHRhY2hlcyBvcHRpb25hbCBzZWFyY2ggc3RyaW5nIGluIHZhbGlkIGZvcm1hdFxuICAgICAqXG4gICAgICogICAgICAgICBFeGFtcGxlOlxuICAgICAqICAgICAgICAgICAgIHV0aWwucmVkaXJlY3RfdG8oJ2FwcC9jb3JlL3NlYXJjaCcsIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgJ3NpZCcgOiAxMjM0LFxuICAgICAqICAgICAgICAgICAgICAgICAnZm9vJyA6ICdiYXInXG4gICAgICogICAgICAgICAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICByZWRpcmVjdHMgdG8gJ3NwbHVuay9hcHAvY29yZS9zZWFyY2g/c2lkPTEyMzQmZm9vPWJhcidcbiAgICAgKiBAcGFyYW0gd2luZG93T2JqIHtXaW5kb3cgT2JqZWN0fSBhbiBvcHRpb25hbCB3aW5kb3cgb2JqZWN0IHRvIHRhcmdldCB0aGUgbG9jYXRpb24gY2hhbmdlXG4gICAgICogQHBhcmFtIGZvY3VzIHtCb29sZWFufSBpZiB0cnVlLCBmb2N1cyBpcyBjYWxsZWQgb24gd2luZG93T2JqXG4gICAgICovXG4gICAgcmVkaXJlY3RfdG86IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucywgd2luZG93T2JqLCBmb2N1cykge1xuICAgICAgICB1cmkgPSB0aGlzLm1ha2VfZnVsbF91cmwodXJpLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCF3aW5kb3dPYmopIHdpbmRvd09iaiA9IHdpbmRvdztcbiAgICAgICAgd2luZG93T2JqLmRvY3VtZW50LmxvY2F0aW9uID0gdXJpO1xuICAgICAgICBpZiAoZm9jdXMgJiYgd2luZG93T2JqLmZvY3VzKSB3aW5kb3dPYmouZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGFwcCBuYW1lIChub3QgbGFiZWwpLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRBcHA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJChkb2N1bWVudC5ib2R5KS5hdHRyKFwiczphcHBcIikgfHwgJ1VOS05PV05fQVBQJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB2aWV3IG5hbWUgKG5vdCBsYWJlbCkuXG4gICAgICovXG4gICAgZ2V0Q3VycmVudFZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJChkb2N1bWVudC5ib2R5KS5hdHRyKFwiczp2aWV3XCIpIHx8ICdVTktOT1dOX1ZJRVcnO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCAnZGlzcGxheVZpZXcnIG5hbWUgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSB2aWV3IG5hbWUsIGVsc2UgcmV0dXJucyB0aGUgY3VycmVudCB2aWV3IG5hbWUuXG4gICAgICovXG4gICAgZ2V0Q3VycmVudERpc3BsYXlWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICQoZG9jdW1lbnQuYm9keSkuYXR0cihcInM6ZGlzcGxheXZpZXdcIikgfHwgdGhpcy5nZXRDdXJyZW50VmlldygpO1xuICAgIH0sXG4gICAgZ2V0QXV0b0NhbmNlbEludGVydmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gJChkb2N1bWVudC5ib2R5KS5hdHRyKFwiczphdXRvQ2FuY2VsSW50ZXJ2YWxcIik7XG4gICAgICAgIGlmICghaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwibm8gYXV0b0NhbmNlbEludGVydmFsIGZvdW5kLiBSZXR1cm5pbmcgMFwiKTtcbiAgICAgICAgICAgIGludGVydmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZpZXdzdGF0ZSBJRCBhcyByZXF1ZXN0ZWQgdmlhIHRoZSBVUkkgcGFyYW1ldGVyXG4gICAgICogJ3ZzJy4gIFRoaXMgaXMgZW1iZWRkZWQgaW4gdGhlIDxib2R5PiB0YWcuXG4gICAgICpcbiAgICAgKiBJZiBubyB2aWV3c3RhdGUgaGFzIGJlZW4gcmVxdWVzdGVkLCB0aGVuIGFsbCBwYXJhbWV0ZXIgd3JpdGVzIHdpbGxcbiAgICAgKiBnbyB0byB0aGUgZGVmYXVsdCBzdGlja3kgc3RhdGUsIGtleWVkIGJ5IHRoZSByZXNlcnZlZCB0b2tlbiAnX2N1cnJlbnQnLlxuICAgICAqXG4gICAgICogTk9URTogdmlld3N0YXRlIGlzIGFsc28gcHJvdmlkZWQgdG8gdGhlIG1vZHVsZXMgdGhyb3VnaCBjb250ZXh0IHJlc3VycmVjdGlvbixcbiAgICAgKiBBbmQgdGhhdCBiZWluZyB0aGUgY2FzZSwgdGhlIHZhbHVlIG9mIHRoaXMgaXMgbWFyZ2luYWwuXG4gICAgICovXG4gICAgLy9nZXRDdXJyZW50Vmlld1N0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAvLyAgICByZXR1cm4gJChkb2N1bWVudC5ib2R5KS5hdHRyKFwiczp2aWV3c3RhdGVpZFwiKSB8fCBudWxsO1xuICAgIC8vfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkaWN0aW9uYXJ5IG9mIGFsbCB0aGUgYXBwLCB2aWV3LCBhbmQgc2F2ZWQgc2VhcmNoIGNvbmZpZ1xuICAgICAqIGRhdGEgdGhhdCBpcyBzcGVjaWZpZWQgaW4gdGhlIGN1cnJlbnQgdmlldy4gIEV4OlxuICAgICAqIHtcbiAgICAgKiAgICAndmlldyc6IHtcInRlbXBsYXRlXCI6IFwiYnVpbGRlci5odG1sXCIsIFwiZGlzcGxheVZpZXdcIjogXCJyZXBvcnRfYnVpbGRlcl9kaXNwbGF5XCIsIFwicmVmcmVzaFwiOiBudWxsLCBcImxhYmVsXCI6IFwiRGlzcGxheSBSZXBvcnRcIiwgXCJ2aWV3c3RhdGVJZFwiOiBcIio6ZnQxMGkwMnpcIiwgXCJvbnVubG9hZENhbmNlbEpvYnNcIjogZmFsc2UsIFwiaWRcIjogXCJyZXBvcnRfYnVpbGRlcl9kaXNwbGF5XCJ9LFxuICAgICAqICAgICdhcHAnOiB7XCJpZFwiOiBcInNlYXJjaFwiLCBcImxhYmVsXCI6IFwiU2VhcmNoXCJ9LFxuICAgICAqICAgICdzYXZlZFNlYXJjaCc6IHtcInNlYXJjaFwiOiBcImpvaG52ZXkgfCB0aW1lY2hhcnQgY291bnRcIiwgXCJuYW1lXCI6IFwianZyZXBvcnQzXCIsIFwidnNpZFwiOiBcIio6ZnQxMGkwMnpcIiwgXCJxdWFsaWZpZWRTZWFyY2hcIjogXCJzZWFyY2ggIGpvaG52ZXkgfCB0aW1lY2hhcnQgY291bnRcIn1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZ2V0Q3VycmVudFZpZXdDb25maWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJC5leHRlbmQoe30sIFNwbHVuay5WaWV3Q29uZmlnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXRoIHdpdGhvdXQgdGhlIGxvY2FsaXphdGlvbiBzZWdtZW50LlxuICAgICAqL1xuICAgIGdldFBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF0aCA9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmdldENvbmZpZ1ZhbHVlKCdMT0NBTEUnKS50b1N0cmluZygpO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHdheSB0byBmaWd1cmUgb3V0IHRoZSBsb2NhbGUsIGp1c3QgcmV0dXJuIHBhdGhuYW1lXG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWdWYWx1ZSgnTE9DQUxFJykgfHwgcGF0aC5pbmRleE9mKGxvY2FsZSkgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IGxvY2FsZS5sZW5ndGggKyBwYXRoLmluZGV4T2YobG9jYWxlKTtcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1bXVsYXRpdmUgb2Zmc2V0VG9wIGZvciBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgQSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRDdW1sYXRpdmVPZmZzZXRUb3A6IGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICBpZighZWxlbWVudCkgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFRvcCArIHRoaXMuZ2V0Q3VtbGF0aXZlT2Zmc2V0VG9wKGVsZW1lbnQub2Zmc2V0UGFyZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdW11bGF0aXZlIG9mZnNldExlZnQgZm9yIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBBIERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldEN1bWxhdGl2ZU9mZnNldExlZnQ6IGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICBpZighZWxlbWVudCkgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldExlZnQgKyB0aGlzLmdldEN1bWxhdGl2ZU9mZnNldExlZnQoZWxlbWVudC5vZmZzZXRQYXJlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgYW1vdW50IG9mIGNvbnRlbnQgdGhhdCBoYXMgYmVlbiBoaWRkZW4gYnkgc2Nyb2xsaW5nIGRvd24uXG4gICAgICpcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcmV0dXJuIDAtbiB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRQYWdlWU9mZnNldDogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHBhZ2VZT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYod2luZG93LnBhZ2VZT2Zmc2V0KXtcbiAgICAgICAgICAgIHBhZ2VZT2Zmc2V0ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB9ZWxzZSBpZihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCl7XG4gICAgICAgICAgICBwYWdlWU9mZnNldCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZ2VZT2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgaW5uZXIgZGltZW5zaW9ucyBvZiB0aGUgd2luZG93LiBUaGlzIGRvZXMgbm90IHdvcmsgaW4galF1ZXJ5LlxuICAgICAqXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHJldHVybiBBbiBvYmplY3QgbGl0ZXJhbCBoYXZpbmcgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIGdldFdpbmRvd0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDooIWlzTmFOKHdpbmRvdy5pbm5lcldpZHRoKSk/d2luZG93LmlubmVyV2lkdGg6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRofHwwLFxuICAgICAgICAgICAgaGVpZ2h0OighaXNOYU4od2luZG93LmlubmVySGVpZ2h0KSk/d2luZG93LmlubmVySGVpZ2h0OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHR8fDBcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGNvbXB1dGVkIHN0eWxlIGZyb20gYSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbFxuICAgICAqIEBwYXJhbSBzdHlsZVByb3BlcnR5XG4gICAgICogQHJldHVybiBUaGUgY29tcHV0ZWQgc3R5bGUgdmFsdWUuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZUhlbHBlcjogZnVuY3Rpb24oZWwsIHN0eWxlUHJvcGVydHkpe1xuICAgICAgICBpZihlbC5jdXJyZW50U3R5bGUpe1xuICAgICAgICAgICAgcmV0dXJuIGVsLmN1cnJlbnRTdHlsZVtzdHlsZVByb3BlcnR5XTtcbiAgICAgICAgfWVsc2UgaWYod2luZG93LmdldENvbXB1dGVkU3R5bGUpe1xuICAgICAgICAgICAgdmFyIGNzc1Byb3BlcnR5ID0gc3R5bGVQcm9wZXJ0eS5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoY3NzUHJvcGVydHkpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgR0VUIHBhcmFtZXRlciBmcm9tIHRoZSB3aW5kb3cubG9jYXRpb24uIFR5cGUgY2FzdGluZyBpcyBub3QgcGVyZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwIFRoZSBwYXJhbSB2YWx1ZSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcyBPcHRpb25hbCBzdHJpbmcgdG8gc2VhcmNoIHRocm91Z2ggaW5zdGVhZCBvZiB3aW5kb3cubG9jYXRpb24uc2VhcmNoXG4gICAgICogQHJldHVybiB7U3RyaW5nIHx8IG51bGx9IFRoZSBzdHJpbmcgdmFsdWUgb3IgbnVsbCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKHAsIHMpe1xuICAgICAgICBzID0gcyB8fCB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICAgICAgICBpZighcyl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZighKHMuaW5kZXhPZihwKyc9JykrMSkpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMuc3BsaXQocCsnPScpWzFdLnNwbGl0KCcmJylbMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2UgYW4gUkdCIHZhbHVlIGFuZCBjb252ZXJ0IHRvIEhFWCBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJnYiBBIFJHQiB2YWx1ZSBmb2xsb3dpbmcgcmdiKFhYWCwgWFhYLCBYWFgpIGNvbnZlbnRpb24uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHJldHVybiBBIEhFWCBlcXVpdmFsZW50IGZvciBhIGdpdmVuIFJHQiB2YWx1ZSB3aXRoIGEgbGVhZGluZyAnIycgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGdldEhFWDogZnVuY3Rpb24ocmdiKXtcbiAgICAgICAgdmFyIHBhcnRzID0gcmdiLm1hdGNoKC9ecmdiXFwoKFxcZCspLFxccyooXFxkKyksXFxzKihcXGQrKVxcKSQvKTtcbiAgICAgICAgdmFyIGhleCA9IChwYXJ0c1sxXTw8MTZ8cGFydHNbMl08PDh8cGFydHNbM10pLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmV0dXJuIFwiI1wiK0FycmF5KDYtaGV4Lmxlbmd0aCkuY29uY2F0KFtoZXhdKS50b1N0cmluZygpLnJlcGxhY2UoLywvZywgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2UgYW4gYXJiaXRyYXJ5IFJHQiBvciBIRVggaW4gbG9uZyBvciBzaG9ydGhhbmQgbm90YXRpb24gYW5kIG5vcm1hbGl6ZSB0byBzdGFuZGFyZCBsb25nIEhFWCBmb3JtIHdpdGggbGVhZGluZyAnIycgY2hhcmFjdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIEEgUkdCIG9yIEhFWCBjb2xvciB2YWx1ZSBpbiBsb25nIG9yIHNob3J0IG5vdGF0aW9uLlxuICAgICAqIEB0eXBlIFN0cmluZyBvciBudWxsXG4gICAgICogQHJldHVybiBBIGZ1bGx5IHF1YWxpZmllZCA2IGNoYXJhY3RlciBoZXhhZGVjaW1hbCB2YWx1ZSBvciB3aXRoIGxlYWRpbmcgJyMnIGNoYXJhY3RlciBvciBudWxsIGlmIGl0IGNhbid0IGJlIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBub3JtYWxpemVDb2xvcjogZnVuY3Rpb24oY29sb3Ipe1xuICAgICAgICBub3JtYWxpemVkQ29sb3IgPSBudWxsO1xuICAgICAgICBpZihjb2xvci5jaGFyQXQoMCk9PT1cIiNcIil7XG4gICAgICAgICAgICBpZihjb2xvci5sZW5ndGg9PT00KXtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkQ29sb3IgPSBjb2xvciArIGNvbG9yLmNoYXJBdCgxKSArIGNvbG9yLmNoYXJBdCgyKSArIGNvbG9yLmNoYXJBdCgzKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRDb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkQ29sb3IgPSB0aGlzLmdldEhFWChjb2xvcik7XG4gICAgICAgICAgICB9Y2F0Y2goZSl7fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkQ29sb3I7XG4gICAgfSxcblxuICAgIC8vICoqXG4gICAgLy8gKiB2YWxpZGF0ZSBhIGNyb24gc3RyaW5nXG4gICAgLy8gKiByZXR1cm5zIHRydWUgaWYgdGhlIGNyb24gc3RyaW5nIGhhcyBmaXZlIGVsZW1lbnRzIGFuZCBlYWNoIGVsZW1lbnQgY29udGFpbnMgb25lIG9yIG1vcmUgdmFsdWVzIChjb21tYSBzZXBhcmF0ZWQpIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0XG4gICAgLy8gKiBbWCwgKiwgKi9YLCBYL1ksIFgtWSwgWC1ZL1ogYW5kIFgsWV1cbiAgICAvLyAqIHRoZSBhbGxvd2VkIHJhbmdlIG9mIHZhbHVlcyBmb3IgZXZlcnkgZmllbGQgaXMgYXMgZm9sbG93czpcbiAgICAvLyAqIFtNSU5VVEVTIEhPVVJTIERBWV9PRl9NT05USCBNT05USCBEQVlfT0ZfV0VFS10gPSBbMC01OSAwLTIzIDEtMzEgMS0xMiAwLTddXG4gICAgLy8gKi9cbiAgICAvLyBwLnMuIG5lZWQgdG8gY29tbWVudCB0aGUgaGVhZGVyIGRpZmZlcmVudCB0byBub3QgZXhpdCB0aGUgY29tbWVudCBibG9jayBmb3IgdGhlICovWCBjYXNlXG4gICAgdmFsaWRhdGVDcm9uU3RyaW5nOiBmdW5jdGlvbihjcm9uU3RyaW5nKSB7XG4gICAgICAgIHZhciBjcm9uUmVnRXggPSAvXigoMCooWzAtOV18WzEtNV1bMC05XSl8XFwqKSgtMCooWzAtOV18WzEtNV1bMC05XSkpPyhcXC9cXGQrKT8sKSooMCooWzAtOV18WzEtNV1bMC05XSl8XFwqKSgtMCooWzAtOV18WzEtNV1bMC05XSkpPyhcXC9cXGQrKT9cXHMoKDAqKFswLTldfDFbMC05XXwyWzAtM10pfFxcKikoLTAqKFswLTldfDFbMC05XXwyWzAtM10pKT8oXFwvXFxkKyk/LCkqKDAqKFswLTldfDFbMC05XXwyWzAtM10pfFxcKikoLTAqKFswLTldfDFbMC05XXwyWzAtM10pKT8oXFwvXFxkKyk/XFxzKCgwKihbMS05XXxbMS0yXVswLTldfDNbMC0xXSl8XFwqKSgtMCooWzEtOV18WzEtMl1bMC05XXwzWzAtMV0pKT8oXFwvXFxkKyk/LCkqKDAqKFsxLTldfFsxLTJdWzAtOV18M1swLTFdKXxcXCopKC0wKihbMS05XXxbMS0yXVswLTldfDNbMC0xXSkpPyhcXC9cXGQrKT9cXHMoKDAqKFsxLTldfDFbMC0yXSl8XFwqKSgtMCooWzEtOV18MVswLTJdKSk/KFxcL1xcZCspPywpKigwKihbMS05XXwxWzAtMl0pfFxcKikoLTAqKFsxLTldfDFbMC0yXSkpPyhcXC9cXGQrKT9cXHMoKDAqWzAtN118XFwqKSgtMCpbMC03XSk/KFxcL1xcZCspPywpKigwKlswLTddfFxcKikoLTAqWzAtN10pPyhcXC9cXGQrKT8kLztcbiAgICAgICAgaWYgKCFjcm9uUmVnRXgudGVzdChjcm9uU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpbm5lckhUTUwgc3Vic3RpdHV0ZSB3aGVuIGl0IGlzIG5vdCBmYXN0IGVub3VnaC5cbiAgICAgKiBAcGFyYW0ge0hUTUxPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlcGxhY2UgaW5uZXJIVE1MIGNvbnRlbnQgd2l0aC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5uZXJIVE1MIFRoZSBpbm5lckhUTUwgc3RyaW5nIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJuIHtIVE1MT2JqZWN0fSBUaGUgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnQgYXMgaXQgbWF5IGhhdmUgYmVlbiBjbG9uZWQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgdHVyYm9Jbm5lckhUTUw6IGZ1bmN0aW9uKHRhcmdldCwgaW5uZXJIVE1MKSB7XG4gICAgICAgIC8qQGNjX29uIC8vaW5uZXJIVE1MIGlzIGZhc3RlciBmb3IgSUVcbiAgICAgICAgICAgIHRhcmdldC5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICBAKi9cbiAgICAgICAgdmFyIHRhcmdldENsb25lID0gdGFyZ2V0LmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIHRhcmdldENsb25lLmlubmVySFRNTCA9IGlubmVySFRNTDtcbiAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRhcmdldENsb25lLCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0Q2xvbmU7XG4gICAgfSxcbiAgICBub3JtYWxpemVCb29sZWFuOiBmdW5jdGlvbih0ZXN0LCBzdHJpY3RNb2RlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZih0ZXN0KSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGVzdCA9IHRlc3QudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGVzdCkge1xuICAgICAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgICBjYXNlICd5ZXMnOlxuICAgICAgICAgICAgY2FzZSAnb24nOlxuICAgICAgICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIGNhc2UgJ25vJzpcbiAgICAgICAgICAgIGNhc2UgJ29mZic6XG4gICAgICAgICAgICBjYXNlICdmYWxzZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3RNb2RlKSB0aHJvdyBUeXBlRXJyb3IoXCJVbmFibGUgdG8gY2FzdCB2YWx1ZSBpbnRvIGJvb2xlYW46IFwiICsgdGVzdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlc3Q7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldENvbW1hRm9ybWF0dGVkTnVtYmVyOiBmdW5jdGlvbihuU3RyKSB7XG4gICAgICAgIG5TdHIgKz0gJyc7XG4gICAgICAgIHZhciB4ID0gblN0ci5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgeDEgPSB4WzBdO1xuICAgICAgICB2YXIgeDIgPSB4Lmxlbmd0aCA+IDEgPyAnLicgKyB4WzFdIDogJyc7XG4gICAgICAgIHZhciByZ3ggPSAvKFxcZCspKFxcZHszfSkvO1xuICAgICAgICB3aGlsZSAocmd4LnRlc3QoeDEpKSB7XG4gICAgICAgICAgICB4MSA9IHgxLnJlcGxhY2Uocmd4LCAnJDEnICsgJywnICsgJyQyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHgxICsgeDI7XG4gICAgfSxcblxuXG4gICAgcmVMVHJpbTogL15bXFxzXFx0XFxyXFxuXSsvLFxuICAgIHJlTFRyaW1Db21tYW5kOiAvXltcXHNcXHRcXHJcXG5cXHxdKy8sXG4gICAgcmVSTm9ybWFsaXplOiAvW1xcc1xcdFxcclxcbl0rJC8sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVsbHkgcXVhbGlmaWVkIHNlYXJjaCBzdHJpbmcgYnkgcHJlcGVuZGluZyB0aGUgJ3NlYXJjaCdcbiAgICAgKiBjb21tYW5kIG9mIHVucXVhbGlmaWVkIHNlYXJjaGVzLiAgVGhpcyBtZXRob2QgZGVlbXMgc3RyaW5ncyBhcyB1bnF1YWxpZmllZFxuICAgICAqIGlmIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggYSB8IG9yICdzZWFyY2ggJ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1VzZXJFbnRlcmVkIEluZGljYXRlcyBpZiAncScgaXMgZXhwZWN0ZWQgdG8gYmUgdW5xdWFsaWZpZWRcbiAgICAgKi9cbiAgICBhZGRMZWFkaW5nU2VhcmNoQ29tbWFuZDogZnVuY3Rpb24ocSwgaXNVc2VyRW50ZXJlZCkge1xuICAgICAgICB2YXIgd29ya2luZ1EgPSAnJyArIHE7XG4gICAgICAgIHdvcmtpbmdRID0gd29ya2luZ1EucmVwbGFjZSh0aGlzLnJlTFRyaW0sICcnKS5yZXBsYWNlKHRoaXMucmVSTm9ybWFsaXplLCAnICcpO1xuICAgICAgICBpZiAod29ya2luZ1Euc3Vic3RyaW5nKDAsIDEpID09ICd8Jykge1xuICAgICAgICAgICAgcmV0dXJuIHE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzIGlzIHNwZWNpZmljIHRvIHRoZSBjYXNlIHdoZXJlIHNlYXJjaHN0cmluZyA9ICdzZWFyY2ggJyxcbiAgICAgICAgLy8gd2hpY2ggd2UgY29uc2VydmF0aXZlbHkgYXNzdW1lIGRvZXMgbm90IGNvbnN0aXR1dGUgYSBzZWFyY2ggY29tbWFuZFxuICAgICAgICBpZiAoIWlzVXNlckVudGVyZWRcbiAgICAgICAgICAgICYmICh3b3JraW5nUS5zdWJzdHJpbmcoMCwgNykgPT0gJ3NlYXJjaCAnICYmIHdvcmtpbmdRLmxlbmd0aCA+IDcpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3NlYXJjaCAnICsgd29ya2luZ1E7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gdW5xdWFsaWZpZWQgc2VhcmNoIHN0cmluZyBieSByZW1vdmluZyBhbnkgbGVhZGluZyAnc2VhcmNoICdcbiAgICAgKiBjb21tYW5kLiAgVGhpcyBtZXRob2QgZG9lcyBhIHNpbXBsZSBzZWFyY2ggYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgICAgKiBzZWFyY2guXG4gICAgICovXG4gICAgc3RyaXBMZWFkaW5nU2VhcmNoQ29tbWFuZDogZnVuY3Rpb24ocSkge1xuICAgICAgICB2YXIgd29ya2luZ1EgPSAnJyArIHE7XG4gICAgICAgIHdvcmtpbmdRID0gd29ya2luZ1EucmVwbGFjZSh0aGlzLnJlTFRyaW1Db21tYW5kLCAnJyk7XG4gICAgICAgIGlmICh3b3JraW5nUS5zdWJzdHJpbmcoMCwgNykgPT0gJ3NlYXJjaCAnKSB7XG4gICAgICAgICAgICByZXR1cm4gd29ya2luZ1Euc3Vic3RyaW5nKDcpLnJlcGxhY2UodGhpcy5yZUxUcmltQ29tbWFuZCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZXMgYSBzdHJpbmcgaW50byBhIGZpZWxkIGxpc3QuXG4gICAgICovXG4gICAgc3RyaW5nVG9GaWVsZExpc3Q6IGZ1bmN0aW9uKHN0ckxpc3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZihzdHJMaXN0KSAhPSAnc3RyaW5nJyB8fCAhc3RyTGlzdCkgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIGZpZWxkX25hbWVfYnVmZmVyID0gW107XG4gICAgICAgIHZhciBpbnF1b3RlID0gZmFsc2U7XG4gICAgICAgIHZhciBzdHIgPSAkLnRyaW0oc3RyTGlzdCk7XG4gICAgICAgIGZvciAodmFyIGk9MCxqPXN0ci5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmNoYXJBdChpKSA9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dGlkeCA9IGkrMTtcbiAgICAgICAgICAgICAgICBpZiAoaiA+IG5leHRpZHggJiYgKHN0ci5jaGFyQXQobmV4dGlkeCkgPT0gJ1xcXFwnIHx8IHN0ci5jaGFyQXQobmV4dGlkeCkgPT0gJ1wiJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRfbmFtZV9idWZmZXIucHVzaChzdHIuY2hhckF0KG5leHRpZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZF9uYW1lX2J1ZmZlci5wdXNoKHN0ci5jaGFyQXQoaSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHIuY2hhckF0KGkpID09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5xdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlucXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChmaWVsZF9uYW1lX2J1ZmZlci5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkX25hbWVfYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChzdHIuY2hhckF0KGkpID09ICcgJyB8fCBzdHIuY2hhckF0KGkpID09ICcsJykgJiYgIWlucXVvdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRfbmFtZV9idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGZpZWxkX25hbWVfYnVmZmVyLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmllbGRfbmFtZV9idWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpZWxkX25hbWVfYnVmZmVyLnB1c2goc3RyLmNoYXJBdChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkX25hbWVfYnVmZmVyLmxlbmd0aCA+IDApIGl0ZW1zLnB1c2goZmllbGRfbmFtZV9idWZmZXIuam9pbignJykpO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIGZpZWxkIGxpc3QgYXJyYXkgaW50byBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBfc2ZsUXVvdGFibGU6IC8oW1xcXFxcIixcXHNdKS8sXG4gICAgX3NmbEVzY2FwYWJsZTogLyhbXFxcXFwiXSkvZyxcbiAgICBmaWVsZExpc3RUb1N0cmluZzogZnVuY3Rpb24oZmllbGRBcnJheSkge1xuICAgICAgICBpZiAoIWZpZWxkQXJyYXkpIHJldHVybiAnJztcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTAsTD1maWVsZEFycmF5Lmxlbmd0aDsgaTxMOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gJC50cmltKGZpZWxkQXJyYXlbaV0pO1xuICAgICAgICAgICAgaWYgKHYgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBFc2NhcGUgYW55IGNoYXIgd2l0aCB0aGUgYmFja3NsYXNoLlxuICAgICAgICAgICAgICAgIGlmICh2LnNlYXJjaCh0aGlzLl9zZmxFc2NhcGFibGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHYucmVwbGFjZSh0aGlzLl9zZmxFc2NhcGFibGUsIFwiXFxcXCQxXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFF1b3RlIHRoZSBlbnRpcmUgc3RyaW5nIGlmIGEgYmFja3NsYXNoLCBjb21tYSwgc3BhY2VcbiAgICAgICAgICAgICAgICAvLyBvciBkb3VibGUgcXVvdGUgaXMgcHJlc2VudC5cbiAgICAgICAgICAgICAgICBpZiAodi5zZWFyY2godGhpcy5fc2ZsUXVvdGFibGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IFsnXCInLCB2LCAnXCInXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJywnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgYSBzdHJpbmcgZm9yIHVzZSBpbiB0aGUgc2VhcmNoIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0ciB7U3RyaW5nfSBzdHJpbmcgdG8gZXNjYXBlXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0ge1xuICAgICAqICAgICBmb3JjZVF1b3RlcyB7Qm9vbGVhbiwgZGVmYXVsdCBmYWxzZX0gYWRkcyBxdW90ZXMgYXJvdW5kIHRoZSBzdHJpbmcgZXZlbiBpZiBpdCBkb2Vzbid0IGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLFxuICAgICAqICAgICAgICAgICAgICAgICB1c2VmdWwgaWYgdGhlIHJlc3VsdCBpcyBiZWluZyB1c2VkIGFzIGEgc3RyaW5nIGxpdGVyYWwgaW4gdGhlIHNlYXJjaCBsYW5ndWFnZS5cbiAgICAgKiB9XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzZWFyY2hFc2NhcGU6IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXN0ci5tYXRjaCgvW1xcc1xcLD18XFxbXFxdXFxcIl0vKSlcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuZm9yY2VRdW90ZXMgPyAnXCInICsgc3RyICsgJ1wiJyA6IHN0cjtcblxuICAgICAgICByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKC8oXFxcInxcXFxcKS9nLCBcIlxcXFwkMVwiKSArICdcIic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuLWVzY2FwZXMgYSBzdHJpbmcgdGhhdCB3YXMgcHJldmlvdXNseSBlc2NhcGVkIHVzaW5nIGBzZWFyY2hFc2NhcGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0ciB7U3RyaW5nfVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgc2VhcmNoVW5lc2NhcGU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBpZiAoc3RyWzBdICE9PSAnXCInIHx8IHN0cltzdHIubGVuZ3RoIC0xXSAhPT0gJ1wiJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0aGUgbGlrZW5lc3Mgb2YgdHdvIG9iamVjdHMuIFBsZWFzZSB1c2Ugd2l0aCBkaXNjcmV0aW9uLlxuICAgICAqL1xuICAgIG9iamVjdFNpbWlsYXJpdHk6IGZ1bmN0aW9uKG9iajEsIG9iajIpe1xuICAgICAgICAgICAgaWYob2JqMSBpbnN0YW5jZW9mIEFycmF5ICYmIG9iajIgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKG9iajEubGVuZ3RoIT09b2JqMi5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8b2JqMS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMub2JqZWN0U2ltaWxhcml0eShvYmoxW2ldLCBvYmoyW2ldKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNlIGlmKG9iajEgaW5zdGFuY2VvZiBPYmplY3QgJiYgb2JqMiBpbnN0YW5jZW9mIE9iamVjdCl7XG4gICAgICAgICAgICAgICAgaWYob2JqMSE9b2JqMil7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiBpbiBvYmoyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvYmoxLmhhc093blByb3BlcnR5KGopKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrIGluIG9iajEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JqMS5oYXNPd25Qcm9wZXJ0eShrKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JqMi5oYXNPd25Qcm9wZXJ0eShrKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLm9iamVjdFNpbWlsYXJpdHkob2JqMVtrXSwgb2JqMltrXSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZSBpZih0eXBlb2Yob2JqMSk9PT1cImZ1bmN0aW9uXCIgJiYgdHlwZW9mKG9iajIpPT09XCJmdW5jdGlvblwiKXtcbiAgICAgICAgICAgICAgICBpZihvYmoxLnRvU3RyaW5nKCkhPT1vYmoyLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2UgaWYob2JqMSE9PW9iajIpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU3RvcCB3YXRjaCBjbGFzcy5cbiAgICAgKi9cbiAgICBTdG9wV2F0Y2g6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IG51bGwsXG4gICAgICAgICAgICBzdG9wVGltZSA9IG51bGwsXG4gICAgICAgICAgICB0aW1lcyA9IFtdO1xuICAgICAgICB2YXIgaXNTZXQgPSBmdW5jdGlvbihwcm9wKXtcbiAgICAgICAgICAgIHJldHVybiAocHJvcD09bnVsbCk/ZmFsc2U6dHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGlzU3RhcnRlZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gaXNTZXQoc3RhcnRUaW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGlzU3RvcHBlZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gaXNTZXQoc3RvcFRpbWUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc29mdFJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgICAgICBzdG9wVGltZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuc3RhcnQgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYoaXNTdGFydGVkKCkpe1xuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNhbGwgc3RhcnQsIHN0YXJ0IGFscmVhZHkgaW52b2tlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICBpZighaXNTdGFydGVkKCkpe1xuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNhbGwgc3RvcCwgc3RhcnQgbm90IGludm9rZWQuXCIpO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmKGlzU3RvcHBlZCgpKXtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjYWxsIHN0b3AsIHN0b3AgYWxyZWFkeSBpbnZva2VkLlwiKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBzdG9wVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgIHRpbWUgPSBzdG9wVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgdGltZXMucHVzaCh0aW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5wYXVzZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZighaXNTdGFydGVkKCkpe1xuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNhbGwgcGF1c2UsIHN0YXJ0IG5vdCBpbnZva2VkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGlzU3RvcHBlZCgpKXtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjYWxsIHBhdXNlLCBzdG9wIGFscmVhZHkgaW52b2tlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnN0b3AoKTtcbiAgICAgICAgICAgIHNvZnRSZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNvZnRSZXNldCgpO1xuICAgICAgICAgICAgdGltZXMgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi50aW1lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRpbWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSB0aW1lc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGlzU3RhcnRlZCgpICYmICFpc1N0b3BwZWQoKSl7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gKG5ldyBEYXRlKCkgLSBzdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsLzEwMDA7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGlzSW50OiBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgcmV0dXJuIG51bSE9PScnICYmICFpc05hTihwYXJzZUludChudW0sIDEwKSkgJiYgcGFyc2VJbnQobnVtLCAxMCk9PShudW0vMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgdHJpbW1lZCB0byBtYXhMZW5ndGggYnkgcmVtb3ZpbmcgY2hhcmFjdGVycyBmcm9tIHRoZVxuICAgICAqIG1pZGRsZSBvZiB0aGUgc3RyaW5nIGFuZCByZXBsYWNpbmcgd2l0aCBlbGxpcHNlcy5cbiAgICAgKlxuICAgICAqIEV4OiBTcGx1bmsudXRpbC5zbWFydFRyaW0oJzEyMzQ1Njc4OTAnLCA1KSA9PT4gJzEyLi4uODkwJ1xuICAgICAqXG4gICAgICovXG4gICAgc21hcnRUcmltOiBmdW5jdGlvbihzdHJpbmcsIG1heExlbmd0aCkge1xuICAgICAgICBpZiAoIXN0cmluZykgcmV0dXJuIHN0cmluZztcbiAgICAgICAgaWYgKG1heExlbmd0aCA8IDEpIHJldHVybiBzdHJpbmc7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IG1heExlbmd0aCkgcmV0dXJuIHN0cmluZztcbiAgICAgICAgaWYgKG1heExlbmd0aCA9PSAxKSByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLDEpICsgJy4uLic7XG5cbiAgICAgICAgdmFyIG1pZHBvaW50ID0gTWF0aC5jZWlsKHN0cmluZy5sZW5ndGggLyAyKTtcbiAgICAgICAgdmFyIHRvcmVtb3ZlID0gc3RyaW5nLmxlbmd0aCAtIG1heExlbmd0aDtcbiAgICAgICAgdmFyIGxzdHJpcCA9IE1hdGguY2VpbCh0b3JlbW92ZS8yKTtcbiAgICAgICAgdmFyIHJzdHJpcCA9IHRvcmVtb3ZlIC0gbHN0cmlwO1xuICAgICAgICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLCBtaWRwb2ludC1sc3RyaXApICsgJy4uLicgKyBzdHJpbmcuc3Vic3RyaW5nKG1pZHBvaW50K3JzdHJpcCk7XG4gICAgfSxcbiAgICBfdG9rZW5EaXNjb3ZlcmVyIDogL1xcJChbXiRdKylcXCQvZyxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGFsbCBpbnN0YW5jZXMgb2YgYW55IHN0cmluZyBsb29raW5nIGxpa2UgXCIkZm9vJFwiIGFueXdoZXJlIGluIHRoZSBnaXZlbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgZGlzdGluY3QgdmFsdWVzIGl0IGZvdW5kLCBlZyAnZm9vJy5cbiAgICAgKiBpZiBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgaW4gdGhlIHN0cnVjdCBoYXMgdHdvLCBsaWtlIFwiJGZvbyQgJGJhciRcIiwgZHVwbGljYXRlcyBhcmUgcmVtb3ZlZC5cbiAgICAgKiBUaGlzIHdpbGwgYWxzbyBkaXNjb3ZlciBhbnkgbnVtYmVyIG9mIFwiJGZvbyRcIiBzdWJzdHJpbmdzIHRoYXQgYXJlIGZvdW5kIHdpdGhpbiB0aGVcbiAgICAgKiBrZXlzIG9mIG9iamVjdCBsaXRlcmFscywgbm90IGp1c3QgdGhlIHZhbHVlcy5cbiAgICAgKi9cbiAgICBkaXNjb3ZlclJlcGxhY2VtZW50VG9rZW5zOiBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICB2YXIgdG9rZW5EaXNjb3ZlcmVyID0gU3BsdW5rLnV0aWwuX3Rva2VuRGlzY292ZXJlcjtcbiAgICAgICAgdmFyIGtleXNUb0FkZDtcblxuICAgICAgICBpZiAodHlwZW9mIGZyYWdtZW50ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQubWF0Y2godG9rZW5EaXNjb3ZlcmVyKSkge1xuICAgICAgICAgICAgICAgIGtleXNUb0FkZCA9IGZyYWdtZW50Lm1hdGNoKHRva2VuRGlzY292ZXJlcik7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIGltIHN1cmUgdGhlcmUncyBhIHdheSB0byB3cml0ZSB0aGUgcmUgc28gdGhhdCBpdCBkb2VzbnQgaW5jbHVkZSB0aGUgJyQnIGNoYXJzIGJ1dCBpbSBtb3Zpbmcgb24uXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGtleXNUb0FkZC5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAga2V5c1RvQWRkW2ldID0ga2V5c1RvQWRkW2ldLnN1YnN0cmluZygxLCBrZXlzVG9BZGRbaV0ubGVuZ3RoLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1RvQWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmcmFnbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZW4gZnJhZ21lbnQgaXMgbm90IGEgc3RyaW5nLlxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGtleXNUb0FkZCA9IFtdO1xuICAgICAgICAgICAga2V5c1RvQWRkID0gU3BsdW5rLnV0aWwuZGlzY292ZXJSZXBsYWNlbWVudFRva2VucyhmcmFnbWVudFtrZXldKTtcblxuICAgICAgICAgICAgLy8gdXAgdW50aWwgbm93IHdlJ3ZlIG9ubHkgbG9va2VkIGF0IHZhbHVlcy4gV2UgaGF2ZSB0byBhbHNvIGRpc2NvdmVyIGtleXMgaW4gdGhlIGtleSBpdHNlbGYuLlxuICAgICAgICAgICAgdmFyIG1hdGNoZXNJblRoZUtleUl0c2VsZiA9IGtleS5tYXRjaCh0b2tlbkRpc2NvdmVyZXIpIHx8IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPG1hdGNoZXNJblRoZUtleUl0c2VsZi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBpbSBzdXJlIHRoZXJlJ3MgYSB3YXkgdG8gd3JpdGUgdGhlIHJlIHNvIHRoYXQgaXQgZG9lc250IGluY2x1ZGUgdGhlICckJyBjaGFycyBidXQgaW0gbW92aW5nIG9uLlxuICAgICAgICAgICAgICAgIGtleXNUb0FkZC5wdXNoKG1hdGNoZXNJblRoZUtleUl0c2VsZltqXS5zdWJzdHJpbmcoMSwgbWF0Y2hlc0luVGhlS2V5SXRzZWxmW2pdLmxlbmd0aC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBhZ2FpbnN0IGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBrPTA7IGs8a2V5c1RvQWRkLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMuaW5kZXhPZihrZXlzVG9BZGRba10pID09LTEpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleXNUb0FkZFtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB3YWxrZWQgdGhyb3VnaCB0aGUgZW50aXJldHkgb2YgZnJhZ21lbnQgdG8gYWxsIGxldmVscyBvZiBuZXN0aW5nXG4gICAgICogIGFuZCB3aWxsIHJlcGxhY2UgYWxsIG1hdGNoZXMgb2YgdGhlIGdpdmVuIHNpbmdsZSByZWdleCB3aXRoIHRoZSBnaXZlblxuICAgICAqICBzaW5nbGUgdmFsdWUuXG4gICAgICogIHJlcGxhY2VtZW50IHdpbGwgb2NjdXIgaW4gYm90aCBrZXlzIGFuZCB2YWx1ZXMuXG4gICAgICovXG4gICAgcmVwbGFjZVRva2VuczogZnVuY3Rpb24oZnJhZ21lbnQsIHJlZywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmcmFnbWVudCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50Lm1hdGNoKHJlZykpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UocmVnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZyYWdtZW50ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhdGNoIG91dCBmb3IgaW5maW5pdGUgbG9vcHMuICBXZSBtYWtlIGFsbCBjaGFuZ2VzIHRvIHRoZSBhcnJheSBhZnRlciBpdGVyYXRpb24uXG5cbiAgICAgICAgdmFyIGtleXNUb1JlbmFtZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIC8vIHJlY3Vyc2VcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJhZ21lbnRba2V5XSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIFNwbHVuay51dGlsLnJlcGxhY2VUb2tlbnMoZnJhZ21lbnRba2V5XSwgcmVnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGhpdCBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmcmFnbWVudFtrZXldID09ICdzdHJpbmcnICYmIGZyYWdtZW50W2tleV0ubWF0Y2gocmVnKSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50W2tleV0gPSBmcmFnbWVudFtrZXldLnJlcGxhY2UocmVnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3cgdGhhdCB0aGUgdmFsdWUgaXMgY2hhbmdlZCB3ZSBjaGVjayB0aGUga2V5IGl0c2VsZlxuICAgICAgICAgICAgaWYgKGtleS5tYXRjaChyZWcpKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFyayB0aGlzIHRvIGJlIGNoYW5nZWQgYWZ0ZXIgd2UncmUgb3V0IG9mIHRoZSBpdGVyYXRvclxuICAgICAgICAgICAgICAgIGtleXNUb1JlbmFtZVtrZXldID0ga2V5LnJlcGxhY2UocmVnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgb2xkS2V5IGluIGtleXNUb1JlbmFtZSkge1xuICAgICAgICAgICAgdmFyIG5ld0tleSA9IGtleXNUb1JlbmFtZVtvbGRLZXldO1xuICAgICAgICAgICAgZnJhZ21lbnRbbmV3S2V5XSA9IGZyYWdtZW50W29sZEtleV07XG4gICAgICAgICAgICBkZWxldGUoZnJhZ21lbnRbb2xkS2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH0sXG5cblxuICAgIGdldFNlcnZlclRpbWV6b25lT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNwbHVuay51dGlsLmdldENvbmZpZ1ZhbHVlKCdTRVJWRVJfVElNRVpPTkVfT0ZGU0VUJyk7XG4gICAgfSxcblxuICAgIC8vIGNvbnN0YW50cyB1c2VkIGJ5IE1vZHVsZXMgYXMgd2VsbCBhcyBNb2R1bGVMb2FkZXIsIHRvIGRlbm90ZSBydW50aW1lIHN0YXRlc1xuICAgIC8vIFdBSVRJTkdfRk9SX0lOSVRJQUxJWkFUSU9OIGFuZCBXQUlUSU5HX0ZPUl9ISUVSQVJDSFkgbWVhbiB0aGF0IHRoZSBNb2R1bGVzXG4gICAgLy8gYXJlIHN0aWxsIGJlaW5nIGxvYWRlZCBieSBNb2R1bGVMb2FkZXIuXG4gICAgLy8gdGhlIHJlbWFpbmluZyB0d28gc3RhdGVzIGFyZSByZWxldmFudCBCT1RIIGR1cmluZyBwYWdlIGxvYWQsIGFuZCBpbiBnZW5lcmFsXG4gICAgLy8gYXQgcnVudGltZSB0aGVyZWFmdGVyLlxuICAgIC8vIHdoZXRoZXIgb3Igbm90IHRoZSBwYWdlIGlzIHN0aWxsIGxvYWRpbmcgaXMgYW4gb3J0aG9nb25hbCBwaWVjZSBvZiBpbmZvcm1hdGlvbixcbiAgICAvLyBhbmQgbW9kdWxlcyBjYW4gY2hlY2sgaXQgb24gZGVtYW5kIGJ5IGNhbGxpbmcgTW9kdWxlLmlzUGFnZUxvYWRDb21wbGV0ZSgpLlxuICAgIG1vZHVsZUxvYWRTdGF0ZXM6IHtcbiAgICAgICAgV0FJVElOR19GT1JfSU5JVElBTElaQVRJT04gICA6IDEsICAvLyB3YWl0aW5nIGZvciBJTklUSUFMSVpBVElPTlxuICAgICAgICBXQUlUSU5HX0ZPUl9ISUVSQVJDSFkgICA6IDIsICAvLyB3YWl0aW5nIGZvciBISUVSQVJDSFlcbiAgICAgICAgV0FJVElOR19GT1JfQ09OVEVYVDogNixcbiAgICAgICAgSEFTX0NPTlRFWFQgICAgICAgICA6IDdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHdhaXQgdGltZSAoc2VjKSBiYXNlZCBvbiB0aGUgY3VycmVudCB0aW1lIGVsYXBzZWQsIGFzIG1hcHBlZFxuICAgICAqIG9udG8gYSBjdWJpYyBlYXNpbmcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBlbGFwc2VkX3RpbWU6IG51bWJlciBvZiBzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBmaXJzdFxuICAgICAqICAgICBjYWxsIHRvIGdldFJldHJ5SW50ZXJ2YWwoKVxuICAgICAqXG4gICAgICogbWluX2ludGVydmFsOiBtaW5pbXVtIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZDsgYWxzbyB0aGUgaW50ZXJ2YWxcbiAgICAgKiAgICAgcmV0dXJuZWQgd2hlbiBlbGFwc2VkX3RpbWUgPSAwXG4gICAgICpcbiAgICAgKiBtYXhfaW50ZXJ2YWw6IG1heGltdW0gcmV0dXJuIHZhbHVlIG9mIHRoaXMgbWV0aG9kOyBhbHNvIHRoZSBpbnRlcnZhbFxuICAgICAqICAgICByZXR1cm5lZCB3aGVuIGVsYXBzZWRfdGltZSA+PSBjbGFtcF90aW1lXG4gICAgICpcbiAgICAgKiBjbGFtcF90aW1lOiB0b3RhbCBkdXJhdGlvbiBvdmVyIHdoaWNoIHRvIGNhbGN1bGF0ZSBhIHdhaXQgdGltZTsgd2hpbGVcbiAgICAgKiAgICAgZWxhcHNlZF90aW1lIDwgY2xhbXBfdGltZSwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGxlc3MgdGhhblxuICAgICAqICAgICBtYXhfaW50ZXJ2YWw7IHdoZW4gZWxhcHNlZF90aW1lID49IGNsYW1wX3RpbWUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbFxuICAgICAqICAgICBhbHdheXMgYmUgbWF4X2ludGVydmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRSZXRyeUludGVydmFsOiBmdW5jdGlvbihlbGFwc2VkX3RpbWUsIG1pbl9pbnRlcnZhbCwgbWF4X2ludGVydmFsLCBjbGFtcF90aW1lKSB7XG4gICAgICAgIGlmIChlbGFwc2VkX3RpbWUgPj0gY2xhbXBfdGltZSkgcmV0dXJuIHBhcnNlRmxvYXQobWF4X2ludGVydmFsKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1heF9pbnRlcnZhbCAqIE1hdGgucG93KGVsYXBzZWRfdGltZS9wYXJzZUZsb2F0KGNsYW1wX3RpbWUpLCAzKSArIG1pbl9pbnRlcnZhbCwgbWF4X2ludGVydmFsKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggSFRNTCBlbnRpdGllcyBlc2NhcGVkLlxuICAgICAqIE5PVEU6IElFIHdpbGwgbm90IGludGVycHJldCBcIlwiJmFwb3M7XCIsIG9wdGluZyB0byBqdXN0IHJlbmRlciBpdCBlbmNvZGVkXG4gICAgICogICAgICB3ZSB1c2UgdGhlIGFsdGVybmF0ZSBkZWNpbWFsIHZlcnNpb24gaW5zdGVhZFxuICAgICAqXG4gICAgICovXG4gICAgZXNjYXBlSHRtbDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcIlwiK2lucHV0KS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBiYWNrc2xhc2hlcyBlc2NhcGVkXG4gICAgICovXG4gICAgZXNjYXBlQmFja3NsYXNoOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFwiXCIraW5wdXQpLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBkb3VibGUgcXVvdGVzIGVzY2FwZWRcbiAgICAgKi9cbiAgICBlc2NhcGVRdW90ZXM6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXCJcIitpbnB1dCkucmVwbGFjZShcIlxcXCJcIixcIlxcXFxcXFwiXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggcmVnZXggY2hhcmFjdGVycyBlc2NhcGVkXG4gICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTkzNjM3XG4gICAgICovXG4gICAgZXNjYXBlUmVnZXg6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoaW5wdXQrJycpLnJlcGxhY2UoLyhbLj8qK14kW1xcXVxcXFwoKXt9fC1dKS9nLCBcIlxcXFwkMVwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyBhbnkgc3BlY2lhbCBjaGFyYWN0ZXJzIGZvciB1c2UgaW4gYSBqUXVlcnkgc2VsZWN0b3JcbiAgICAgKi9cbiAgICBlc2NhcGVTZWxlY3RvcjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcIlwiK2lucHV0KS5yZXBsYWNlKC8oWzsmLFxcLlxcK1xcKlxcfic6XCJcXCFcXF4jJCVAXFxbXFxdXFwoXFwpPT5cXHxdKS9nLCAnXFxcXCQxJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyaW0gb3V0IGFueSBzcGVjaWFsIGNoYXJhY3RlcnMsIGxlYXZpbmcgYWxwaGFudW1lcmljIGFuZCAtX3t9P1xuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICB0cmltVG9BbHBoYU51bWVyaWM6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXCJcIitpbnB1dCkucmVwbGFjZSgvKFtcXHM7JixcXC5cXCtcXCpcXH4nOlwiXFwhXFxeIyQlQFxcW1xcXVxcKFxcKT08PmBcXC9cXHxcXFxcXSkvZywgJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGcm9tIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9mYXN0ZXItdHJpbS1qYXZhc2NyaXB0XG4gICAgICogcHJvZmlsZXIgc2hvd3MgdGhpcyBpcyBtdWNoIGZhc3RlciB0aGFuIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbiBpbiBib3RoIElFIGFuZCBGaXJlZm94LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IChPcHRpb25hbCkgZGVsaW0gVGhlIGNoYXJhY3RlcnMgdG8gcmVtb3ZlIGZyb20gdGhlIHN0YXJ0L2VuZCBvZiB0aGUgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHJldHVybiBBIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIHRyaW06IGZ1bmN0aW9uKHN0ciwgZGVsaW0pIHtcbiAgICAgICAgaWYgKGRlbGltKSByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIl5bXFxcXHNcIiArIGRlbGltICsgXCJdK1wiKSwnJykucmVwbGFjZShuZXcgUmVnRXhwKFwiW1xcXFxzXCIgKyBkZWxpbSArIFwiXSskXCIpLCAnJyk7XG4gICAgICAgIGVsc2UgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2ltcGxlIG5vcm1hbGl6YXRpb24gZm9yIHVzZXIgaW5wdXQ6IHRyaW1zIHdoaXRlc3BhY2VzIGFuZCBsb3dlcmNhc2VzIHN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHN0ciB7U3RyaW5nfSBpbnB1dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGVmVmFsdWUge1N0cmluZ30gKG9wdGlvbmFsKSBkZWZhdWx0IHZhbHVlIGlmIHN0ciBpcyBudWxsXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBjbGVhbnNlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBsb3dlclRyaW1TdHI6IGZ1bmN0aW9uKHN0ciwgZGVmVmFsdWUpIHtcbiAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZWYWx1ZSA/IGRlZlZhbHVlIDogc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyaW0oc3RyKS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICBmb2N1c0ZpcnN0RmllbGQ6IGZ1bmN0aW9uKHBvcHVwKXsgLy90aGlzIHB1dHMgdGhlIGZvY3VzIG9uIHRoZSBmaXJzdCBmb3JtIGVsZW1lbnQgd2hldGhlciBhbiBpbnB1dCBvciBzZWxlY3QgZHJvcGRvd25cbiAgICAgICAgdmFyIGZpcnN0SW5wdXQgPSAkKFwiOmlucHV0OnZpc2libGU6ZW5hYmxlZDpmaXJzdFwiLHBvcHVwKSxcbiAgICAgICAgZmlyc3RTZWxlY3QgPSAkKFwic2VsZWN0OnZpc2libGU6ZW5hYmxlZDpmaXJzdFwiLHBvcHVwKTtcblxuICAgICAgICBpZihmaXJzdElucHV0LmlzKFwiOmJ1dHRvblwiKSAmJiBmaXJzdElucHV0Lmhhc0NsYXNzKCdzcGxCdXR0b24tc2Vjb25kYXJ5JykpIHtcbiAgICAgICAgICAgIGlmKCQoXCI6aW5wdXQ6YnV0dG9uLnNwbEJ1dHRvbi1wcmltYXJ5OmZpcnN0XCIsIHBvcHVwKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmaXJzdElucHV0ID0gJChcIjppbnB1dDpidXR0b24uc3BsQnV0dG9uLXByaW1hcnk6Zmlyc3RcIiwgcG9wdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0SW5wdXRPZmZzZXQgPSAoZmlyc3RJbnB1dC5sZW5ndGgpID8gZmlyc3RJbnB1dC5vZmZzZXQoKS50b3AgOiBmYWxzZSxcbiAgICAgICAgZmlyc3RTZWxlY3RPZmZzZXQgPSAoZmlyc3RTZWxlY3QubGVuZ3RoKSA/IGZpcnN0U2VsZWN0Lm9mZnNldCgpLnRvcCA6IGZhbHNlLFxuICAgICAgICBmaXJzdEVsZW0gPSBmaXJzdElucHV0O1xuXG4gICAgICAgIGlmKGZpcnN0SW5wdXRPZmZzZXQgJiYgZmlyc3RTZWxlY3RPZmZzZXQgJiYgKGZpcnN0U2VsZWN0T2Zmc2V0IDwgZmlyc3RJbnB1dE9mZnNldCkpe1xuICAgICAgICAgICAgZmlyc3RFbGVtID0gZmlyc3RTZWxlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RFbGVtLmZvY3VzKCk7XG4gICAgICAgIHZhciBpc0ZpcnN0RWxlbUZvY3VzZWQgPSBmaXJzdEVsZW0uaXMoXCI6Zm9jdXNcIik7XG5cbiAgICAgICAgLy9GaXggZm9yIElFOFxuICAgICAgICBpZighaXNGaXJzdEVsZW1Gb2N1c2VkKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZpcnN0RWxlbS5mb2N1cygpO1xuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhIHN0cmluZyBhZ2FpbnN0IHdpa2kgZm9ybWF0dGluZyBydWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcmV0dXJuIEEgSFRNTCBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldFdpa2lUcmFuc2Zvcm06IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgdGV4dCA9IFNwbHVuay51dGlsLmVzY2FwZUh0bWwoc3RyKTtcbiAgICAgICAgLy8gd2UgdG9rZW5pemUgdGhlIGNvbmRpdGlvbmFsICchJyBwcmVmaXggYW5kIHJlcGxhY2UgaXQgYWZ0ZXJcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxbKFxcIT8pKFxcdytcXDpcXC9cXC9bXlxcc10rKVxccysoW15cXF1dKylcXF0vZywgJzxhIGhyZWY9XCIkMlwiICN+IyQxI34jPiQzPC9hPicpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXFtcXFsoXFwhPykoW15cXHxdKylcXHwoW15cXF1dKylcXF1cXF0vZywgU3BsdW5rLnV0aWwuX2dlbmVyYXRlSW50ZXJuYWxMaW5rKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvI34jISN+Iy9nLCAndGFyZ2V0PVwiX2JsYW5rXCInKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKiN+IyN+Iy9nLCAnJyk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG5cbiAgICBfZ2VuZXJhdGVJbnRlcm5hbExpbms6IGZ1bmN0aW9uKHN0ciwgYmxhbmtfdG9rZW4sIHVybCwgdGV4dCkge1xuICAgICAgICB1cmwgPSBTcGx1bmsudXRpbC5tYWtlX3VybCh1cmwpO1xuICAgICAgICByZXR1cm4gJzxhIGhyZWY9XCInK3VybCsnXCIjfiMnK2JsYW5rX3Rva2VuKycjfiM+Jyt0ZXh0Kyc8L2E+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBnZXQgdGhlIGluZGljZXMgb2YgYWxsIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV4IHtSZWdFeHB9IHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBvblxuICAgICAqIEBwYXJhbSBzb3VyY2Uge3N0cmluZ30gdGhlIHRleHQgb24gd2hpY2ggdG8gZmluZCBtYXRjaGVzXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFsbCBvZiB0aGUgbWF0Y2hlc1xuICAgICAqICAgICAgICAgICAgIHtPYmplY3R9XG4gICAgICogICAgICAgICAgICAgICAgIG1hdGNoIHtzdHJpbmd9IHRoZSBzdWJzdHJpbmcgbWF0Y2ggZm91bmQgaW4gdGhlIHNvdXJjZVxuICAgICAqICAgICAgICAgICAgICAgICBzdGFydCB7bnVtYmVyfSB0aGUgaW5kZXggaW4gdGhlIHNvdXJjZSBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBtYXRjaFxuICAgICAqICAgICAgICAgICAgICAgICBlbmQge251bWJlcn0gdGhlIGluZGV4IGluIHRoZSBzb3VyY2UgZm9yIHRoZSBlbmQgb2YgdGhlIG1hdGNoXG4gICAgICovXG4gICAgZmluZE1hdGNoSW5kaWNlczogZnVuY3Rpb24ocmV4LCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBzb3VyY2UubWF0Y2gocmV4KTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG1hdGNoZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaV07XG4gICAgICAgICAgICBpbmRleCA9IHNvdXJjZS5pbmRleE9mKG1hdGNoLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe21hdGNoOiBtYXRjaCwgc3RhcnQ6IGluZGV4LCBlbmQ6IGluZGV4ICsgbWF0Y2gubGVuZ3RoIC0gMX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG5cbiAgICBpc1JhaW5tYWtyOiBmdW5jdGlvbihpc0RtY0VuYWJsZWQsIGlzQ2xvdWQpIHtcbiAgICAgICAgcmV0dXJuICghaXNEbWNFbmFibGVkICYmIGlzQ2xvdWQpO1xuICAgIH0sXG5cbiAgICBpc1N0YWNrbWFrcjogZnVuY3Rpb24oaXNEbWNFbmFibGVkLCBpc0Nsb3VkKSB7XG4gICAgICAgIHJldHVybiAoaXNEbWNFbmFibGVkICYmIGlzQ2xvdWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIElFIHZlcnNpb24gb3IgLTEgaWYgaXQncyBub3QgSUVcbiAgICAgKlxuICAgICAqL1xuICAgICBnZXRJRVZlcnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXlOYXYgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChteU5hdi5pbmRleE9mKCdtc2llJykgIT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChteU5hdi5zcGxpdCgnbXNpZScpWzFdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgSUUgPiAxMFxuICAgICAgICBpZiAobXlOYXYuaW5kZXhPZigndHJpZGVudCcpICE9IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobXlOYXYuc3BsaXQoJyBydjonKVsxXSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXN0YXJ0IHNwbHVua2Qvc3BsdW5rd2ViIGFuZCB1ZHBhdGUgdGhlIFVJIHdpdGggcHJvZ3Jlc3NcbiAgICAqL1xuICAgIHJlc3RhcnRfc2VydmVyOiBmdW5jdGlvbihyZXR1cm5fdG8pIHtcbiAgICAgICAgdmFyIHN0YXJ0X3RpbWU7XG4gICAgICAgIHZhciByZXN0YXJ0X3RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3RhcnRfdHJpZXMgPSAwO1xuICAgICAgICB2YXIgcmVzdGFydF91cmxfYmFzZTtcbiAgICAgICAgdmFyIHJlc3RhcnRfdXJsX3Byb3RvO1xuICAgICAgICB2YXIgcmVzdGFydF9kb25lID0gZmFsc2U7XG4gICAgICAgIHZhciByZXN0YXJ0X25vdGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHZhciBpbWdfbGlzdCA9IFtdO1xuICAgICAgICB2YXIgUkVTVEFSVF9NQVhfVFJJRVMgPSAxODA7IC8vIFdhaXQgbWF4IG9mIDMgbWludXRlcyBmb3IgcmVzdGFydFxuICAgICAgICB2YXIgUElOR19JTlRFUlZBTCA9IDIwMDA7XG5cbiAgICAgICAgdmFyIHJlc3RhcnRfZmFpbCA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgICAgU3BsdW5rLk1lc3Nlbmdlci5TeXN0ZW0uZ2V0SW5zdGFuY2UoKS5zZW5kKCdlcnJvcicsICdyZXN0YXJ0X3NlcnZlcicsIG1zZyk7XG4gICAgICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKCdyZXN0YXJ0X2ZhaWxlZCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXN0YXJ0X3N1Y2NlZWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFyZXN0YXJ0X25vdGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdGFydF9ub3RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWxlcnQoXygnUmVzdGFydCBzdWNjZXNzZnVsIC0gY2xpY2sgT0sgdG8gbG9nIGJhY2sgaW50byBTcGx1bmsnKSk7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5jZV91cmw7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybl90bykge1xuICAgICAgICAgICAgICAgICAgICBib3VuY2VfdXJsID0gcmVzdGFydF91cmxfYmFzZSArIHRoaXMubWFrZV9mdWxsX3VybCgnL2FjY291bnQvbG9naW4nLCB7IHJldHVybl90bzogcmV0dXJuX3RvIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5jZV91cmwgPSByZXN0YXJ0X3VybF9iYXNlICsgdGhpcy5tYWtlX3VybCgnLycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGJvdW5jZV91cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBUcmFjayB3aGVuIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBhcHBzZXJ2ZXIgd2FzIHN0YXJ0ZWQ7IGlmIGl0IGNoYW5nZXMgdGhlblxuICAgICAgICAqIHRoZSByZXN0YXJ0IGhhcyBmaW5pc2hlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlc3RhcnRfY2hlY2tfc3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJlc3RhcnRfZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmKHJlc3RhcnRfdHJpZXMrKyA+PSBSRVNUQVJUX01BWF9UUklFUykge1xuICAgICAgICAgICAgICAgIHJlc3RhcnRfZmFpbChfKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgcmVzdGFydCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdXJsOiByZXN0YXJ0X3VybF9iYXNlICsgdGhpcy5tYWtlX3VybCgnL2FwaS9jb25maWcvVUlfVU5JWF9TVEFSVF9USU1FJyksXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGFydF90aW1lID4gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGFydF9kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXN0YXJ0X3RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGFydF9zdWNjZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHNjcmlwdCBmYWlscyB0byBsb2FkIChpZS4gYmVjYXVzZSBzcGx1bmt3ZWIgaXMgc3RpbGwgZG93bilcbiAgICAgICAgICAgIC8vIGpxdWVyeSB3b24ndCBnaXZlIHVzIGFuIGVycm9yOyBpbnN0ZWFkIG5vdGhpbmcgd2lsbCBoYXBwZW4gaGVuY2Ugd2VcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVmaXJlIHRoZSBwb2xsXG4gICAgICAgICAgICByZXN0YXJ0X3RpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc3RhcnRfY2hlY2tfc3RhdHVzLCBQSU5HX0lOVEVSVkFMKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHZhciByZXN0YXJ0X2ltZ19sb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc3RhcnRfZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzdGFydF90aW1lb3V0KTtcbiAgICAgICAgICAgIHJlc3RhcnRfc3VjY2VlZGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogSW1nIGNoZWNraW5nIHdvcmtzIGJldHRlciB0aGFuIHRpbWVzdGFtcCBjaGVja2luZyBpZiB0aGUgcHJvdG9jb2wgaGFzIGJlZW4gY2hhbmdlZFxuICAgICAgICAqL1xuICAgICAgICB2YXIgcmVzdGFydF9jaGVja19zdGF0dXNfaW1nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocmVzdGFydF9kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGltID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbS5vbmxvYWQgPSByZXN0YXJ0X2ltZ19sb2FkZWQ7XG4gICAgICAgICAgICBpbS5zcmMgPSByZXN0YXJ0X3VybF9iYXNlICsgdGhpcy5tYWtlX3VybCgnL2NvbmZpZy9pbWc/cHJvdG89JytyZXN0YXJ0X3VybF9wcm90bysnJl89JysgTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICBpbWdfbGlzdC5wdXNoKGltKTtcbiAgICAgICAgICAgIHJlc3RhcnRfdGltZW91dCA9IHNldFRpbWVvdXQocmVzdGFydF9jaGVja19zdGF0dXNfaW1nLCBQSU5HX0lOVEVSVkFMKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICQucG9zdCh0aGlzLm1ha2VfdXJsKCcvYXBpL21hbmFnZXIvY29udHJvbCcpLCB7b3BlcmF0aW9uOiAncmVzdGFydF9zZXJ2ZXInfSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuc3RhdHVzPT0nT0snKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRfdGltZSA9IGRhdGEuc3RhcnRfdGltZTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNzbCA9PSAnd2luZG93JykgZGF0YS5zc2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT0gJ2h0dHBzOic7XG5cbiAgICAgICAgICAgICAgICByZXN0YXJ0X3VybF9wcm90byA9IGRhdGEuc3NsID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgICAgICAgICAgICAgICByZXN0YXJ0X3VybF9iYXNlID0gKGRhdGEuc3NsID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgKyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgKyAoZGF0YS5wb3J0PT04MCB8fCAoZGF0YS5zc2wgJiYgZGF0YS5wb3J0PT00NDMpID8gJycgOiAnOicrZGF0YS5wb3J0KTtcblxuICAgICAgICAgICAgICAgIC8vIFR1cm4gb2ZmIHN0dWZmIHRoYXQgY29udGludWVzIHRvIHRyeSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBhcHBzZXJ2ZXJcbiAgICAgICAgICAgICAgICBTcGx1bmsuTG9nZ2VyLm1vZGUuRGVmYXVsdCA9IFNwbHVuay5Mb2dnZXIubW9kZS5Ob25lO1xuICAgICAgICAgICAgICAgIGlmIChTcGx1bmsuTWVzc2VuZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIFNwbHVuay5NZXNzZW5nZXIuU3lzdGVtLmdldEluc3RhbmNlKCkuYWJvcnRSZXF1ZXN0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlbmQgYSBzaWduYWwgdG8gc3RvcCBhbGwgdGhlIHBvbGxlcnNcbiAgICAgICAgICAgICAgICBTcGx1bmsuU2Vzc2lvbi5nZXRJbnN0YW5jZSgpLnNpZ25hbFJlc3RhcnQoKTtcblxuICAgICAgICAgICAgICAgIHJlc3RhcnRfdHJpZXMgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X3BvcnQgPSB3aW5kb3cubG9jYXRpb24ucG9ydCB8fCAod2luZG93LmxvY2F0aW9uLnByb3RvY29sPT0naHR0cDonID8gODAgOiA0NDMpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X3NzbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PSAnaHR0cHM6JztcbiAgICAgICAgICAgICAgICBpZiAoKCFjdXJyZW50X3NzbCAmJiBkYXRhLnNzbCkgfHwgKGRhdGEuc3NsICYmIGN1cnJlbnRfcG9ydCE9ZGF0YS5wb3J0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTd2l0Y2hpbmcgaW50byBTU0wgb3IgY2hhbmdpbmcgcG9ydHMgd2l0aCBTU0wgZW5hYmxlZCBjYW4gY2F1c2UgcHJvYmxlbXMgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgdGhlIG5ldyBjZXJ0XG4gICAgICAgICAgICAgICAgICAgIC8vIChpZS4gYSBzZWxmIHNpZ25lZCwgb3IgdW50cnVzdGVkIGNlcnQgaXMgaW4gdXNlIHdoaWNoIGlzIGEgY29tbW9uIGNhc2UpXG4gICAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIoeyB0eXBlOiAncmVzdGFydF9zc2wnLCBzc2xCYXNlOiByZXN0YXJ0X3VybF9iYXNlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNzbCE9Y3VycmVudF9zc2wgfHwgY3VycmVudF9wb3J0IT1kYXRhLnBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydF9jaGVja19zdGF0dXNfaW1nKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydF9jaGVja19zdGF0dXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuc3RhdHVzID09ICdQRVJNUycpIHtcbiAgICAgICAgICAgICAgICByZXN0YXJ0X2ZhaWwoXygnUGVybWlzc2lvbiBEZW5pZWQgLSBZb3UgYXJlIG5vdCBhdXRob3JpemVkIHRvIHJlc3RhcnQgdGhlIHNlcnZlcicpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5zdGF0dXMgPT0gJ0FVVEgnKSB7XG4gICAgICAgICAgICAgICAgcmVzdGFydF9mYWlsKF8oJ1Jlc3RhcnQgZmFpbGVkJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnN0YXR1cyA9PSAnRkFJTCcpIHtcbiAgICAgICAgICAgICAgICByZXN0YXJ0X2ZhaWwoXygnUmVzdGFydCBmYWlsZWQ6ICcrZGF0YS5yZWFzb24pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdGFydF9mYWlsKF8oJ1Jlc3RhcnQgZmFpbGVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyksICdqc29uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFB1c2ggZGF0YSB0byBTcGx1bmsgV2ViIEFuYWx5dGljcyAoU1dBKVxuICAgICAqL1xuICAgIHRyYWNrRXZlbnQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh3aW5kb3cuX3NwbHVua19tZXRyaWNzX2V2ZW50cyAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5fc3BsdW5rX21ldHJpY3NfZXZlbnRzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJsYWNrIG1hZ2ljIGZvciBQcm90b3R5cGUncyBiaW5kKCkgbWV0aG9kIHdoaWNoIHdlJ3JlIHN0aWxsIHVzaW5nLlxuICpcbiAqL1xuXG5pZighRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgdmFyICRBID0gZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gW107XG4gICAgaWYgKGl0ZXJhYmxlLnRvQXJyYXkpIHtcbiAgICAgIHJldHVybiBpdGVyYWJsZS50b0FycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaXRlcmFibGUubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdHMucHVzaChpdGVyYWJsZVtpXSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH07XG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9fbWV0aG9kID0gdGhpcywgYXJncyA9ICRBKGFyZ3VtZW50cyksIG9iamVjdCA9IGFyZ3Muc2hpZnQoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX19tZXRob2QuYXBwbHkob2JqZWN0LCBhcmdzLmNvbmNhdCgkQShhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgfTtcbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUHJvdG90eXBlIGF1Z21lbnRhdGlvbi5cbiAqIFRPRE8gLSBmaW5kIGFub3RoZXIgd2F5LlxuICpcbiAqL1xuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUucmVwZWF0KSB7XG4gICAgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KGNvdW50KzEpLmpvaW4odGhpcyk7XG4gICAgfTtcbn1cblxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnJldmVyc2UpIHtcbiAgICBTdHJpbmcucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICB9O1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUucnNwbGl0KSB7XG4gICAgU3RyaW5nLnByb3RvdHlwZS5yc3BsaXQgPSBmdW5jdGlvbihzZXAsIGxpbWl0KSB7XG4gICAgICAgIHZhciBzcCA9IHRoaXMuc3BsaXQoc2VwKTtcbiAgICAgICAgaWYgKGxpbWl0ICYmIHNwLmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8bGltaXQ7IGkrKylcbiAgICAgICAgICAgICAgICByW2ldID0gc3Bbc3AubGVuZ3RoLWxpbWl0K2ldO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwO1xuICAgIH07XG59XG5cbmlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaCwgZnJvbUluZGV4KSB7XG4gICAgICAgIGlmICghZnJvbUluZGV4KSBmcm9tSW5kZXggPSAwO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gc2VhcmNoKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuXG5pZiAoIUFycmF5LnByb3RvdHlwZS5leHRlbmQpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucHVzaChhcnJbaV0pO1xuICAgIH07XG59XG5cbi8qKlxuKiBzcHJpbnRmIHJvdXRpbmUgYm9ycm93ZWQgZnJvbSBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldC90ZWNoYmxvZy9hcnRpY2xlL2phdmFzY3JpcHRfZXF1aXZhbGVudF9mb3JfcGhwc19zcHJpbnRmL1xuKiBMaWNlbnNlZCB1bmRlciBHUEwgYW5kIE1JVCBsaWNlbnNlc1xuKlxuKiBNb2RpZmllZCBieSBHYXJldGggdG8gYWRkIHN1cHBvcnQgZm9yIFB5dGhvbiBzdHlsZSBhcmd1bWVudCBzcGVjaWZpZXJzOlxuKiBzcHJpbnRmKFwiSGkgJShuYW1lKXMsIHdlbGNvbWUgdG8gJShhcHBsaWNhdGlvbilzXCIsIHsgbmFtZTogJ0dhcmV0aCcsIGFwcDogJ1NwbHVuayB9KVxuKiBPYmplY3RzIGhvbGRpbmcgbmFtZWQgYXJndW1lbnRzIGNhbiBhbHNvIGltcGxlbWVudCBhIHB5dGhvbiBzdHlsZSBfX2dldGl0ZW1fXyBtZXRob2QgdG8gcmV0dXJuIGR5bmFtaWMgdmFsdWVzXG4qL1xudmFyIHNwcmludGYgPSBnbG9iYWwuc3ByaW50ZiA9IGZ1bmN0aW9uKCApIHtcbiAgICAvLyBSZXR1cm4gYSBmb3JtYXR0ZWQgc3RyaW5nXG4gICAgLy9cbiAgICAvLyArICAgIGRpc2N1c3MgYXQ6IGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0L3RlY2hibG9nL2FydGljbGUvamF2YXNjcmlwdF9lcXVpdmFsZW50X2Zvcl9waHBzX3NwcmludGYvXG4gICAgLy8gKyAgICAgICB2ZXJzaW9uOiA4MTAuMTAxNVxuICAgIC8vICsgICBvcmlnaW5hbCBieTogQXNoIFNlYXJsZSAoaHR0cDovL2hleG1lbi5jb20vYmxvZy8pXG4gICAgLy8gKyBuYW1lc3BhY2VkIGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vZ2V0c3ByaW5rLmNvbSlcbiAgICAvLyArICAgIHR3ZWFrZWQgYnk6IEphY2tcbiAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgIC8vICogICAgIGV4YW1wbGUgMTogc3ByaW50ZihcIiUwMS4yZlwiLCAxMjMuMSk7XG4gICAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjMuMTBcblxuICAgIHZhciByZWdleCA9IC8lJXwlKFxcZCtcXCQpPyhcXChbXildK1xcKSk/KFstKyMwIF0qKShcXCpcXGQrXFwkfFxcKnxcXGQrKT8oXFwuKFxcKlxcZCtcXCR8XFwqfFxcZCspKT8oW3NjYm94WHVpZGZlZ0VHXSkvZztcbiAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGZvcm1hdCA9IGFbaV07XG4gICAgaSsrO1xuXG4gICAgLy8gcGFkKClcbiAgICB2YXIgcGFkID0gZnVuY3Rpb24oc3RyLCBsZW4sIGNociwgbGVmdEp1c3RpZnkpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAoc3RyLmxlbmd0aCA+PSBsZW4pID8gJycgOiBBcnJheSgxICsgbGVuIC0gc3RyLmxlbmd0aCA+Pj4gMCkuam9pbihjaHIpO1xuICAgICAgICByZXR1cm4gbGVmdEp1c3RpZnkgPyBzdHIgKyBwYWRkaW5nIDogcGFkZGluZyArIHN0cjtcbiAgICB9O1xuXG4gICAgLy8ganVzdGlmeSgpXG4gICAgdmFyIGp1c3RpZnkgPSBmdW5jdGlvbih2YWx1ZSwgcHJlZml4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHplcm9QYWQpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBtaW5XaWR0aCAtIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAobGVmdEp1c3RpZnkgfHwgIXplcm9QYWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhZCh2YWx1ZSwgbWluV2lkdGgsICcgJywgbGVmdEp1c3RpZnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIHByZWZpeC5sZW5ndGgpICsgcGFkKCcnLCBkaWZmLCAnMCcsIHRydWUpICsgdmFsdWUuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBmb3JtYXRCYXNlWCgpXG4gICAgdmFyIGZvcm1hdEJhc2VYID0gZnVuY3Rpb24odmFsdWUsIGJhc2UsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpIHtcbiAgICAgICAgLy8gTm90ZTogY2FzdHMgbmVnYXRpdmUgbnVtYmVycyB0byBwb3NpdGl2ZSBvbmVzXG4gICAgICAgIHZhciBudW1iZXIgPSB2YWx1ZSA+Pj4gMDtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4ICYmIG51bWJlciAmJiB7JzInOiAnMGInLCAnOCc6ICcwJywgJzE2JzogJzB4J31bYmFzZV0gfHwgJyc7XG4gICAgICAgIHZhbHVlID0gcHJlZml4ICsgcGFkKG51bWJlci50b1N0cmluZyhiYXNlKSwgcHJlY2lzaW9uIHx8IDAsICcwJywgZmFsc2UpO1xuICAgICAgICByZXR1cm4ganVzdGlmeSh2YWx1ZSwgcHJlZml4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHplcm9QYWQpO1xuICAgIH07XG5cbiAgICAvLyBmb3JtYXRTdHJpbmcoKVxuICAgIHZhciBmb3JtYXRTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIHByZWNpc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGp1c3RpZnkodmFsdWUsICcnLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHplcm9QYWQpO1xuICAgIH07XG5cbiAgICAvLyBmaW5hbEZvcm1hdCgpXG4gICAgdmFyIGRvRm9ybWF0ID0gZnVuY3Rpb24oc3Vic3RyaW5nLCB2YWx1ZUluZGV4LCB2YWx1ZU5hbWUsIGZsYWdzLCBtaW5XaWR0aCwgXywgcHJlY2lzaW9uLCB0eXBlKSB7XG4gICAgICAgIGlmIChzdWJzdHJpbmcgPT0gJyUlJykgcmV0dXJuICclJztcblxuICAgICAgICAvLyBwYXJzZSBmbGFnc1xuICAgICAgICB2YXIgbGVmdEp1c3RpZnkgPSBmYWxzZSwgcG9zaXRpdmVQcmVmaXggPSAnJywgemVyb1BhZCA9IGZhbHNlLCBwcmVmaXhCYXNlWCA9IGZhbHNlO1xuICAgICAgICB2YXIgZmxhZ3NsID0gZmxhZ3MubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgZmxhZ3MgJiYgaiA8IGZsYWdzbDsgaisrKSBzd2l0Y2ggKGZsYWdzLmNoYXJBdChqKSkge1xuICAgICAgICAgICAgY2FzZSAnICc6IHBvc2l0aXZlUHJlZml4ID0gJyAnOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJysnOiBwb3NpdGl2ZVByZWZpeCA9ICcrJzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICctJzogbGVmdEp1c3RpZnkgPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzAnOiB6ZXJvUGFkID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcjJzogcHJlZml4QmFzZVggPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyYW1ldGVycyBtYXkgYmUgbnVsbCwgdW5kZWZpbmVkLCBlbXB0eS1zdHJpbmcgb3IgcmVhbCB2YWx1ZWRcbiAgICAgICAgLy8gd2Ugd2FudCB0byBpZ25vcmUgbnVsbCwgdW5kZWZpbmVkIGFuZCBlbXB0eS1zdHJpbmcgdmFsdWVzXG4gICAgICAgIGlmICghbWluV2lkdGgpIHtcbiAgICAgICAgICAgIG1pbldpZHRoID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChtaW5XaWR0aCA9PSAnKicpIHtcbiAgICAgICAgICAgIG1pbldpZHRoID0gK2FbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSBpZiAobWluV2lkdGguY2hhckF0KDApID09ICcqJykge1xuICAgICAgICAgICAgbWluV2lkdGggPSArYVttaW5XaWR0aC5zbGljZSgxLCAtMSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluV2lkdGggPSArbWluV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlOiB1bmRvY3VtZW50ZWQgcGVybCBmZWF0dXJlOlxuICAgICAgICBpZiAobWluV2lkdGggPCAwKSB7XG4gICAgICAgICAgICBtaW5XaWR0aCA9IC1taW5XaWR0aDtcbiAgICAgICAgICAgIGxlZnRKdXN0aWZ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNGaW5pdGUobWluV2lkdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwcmludGY6IChtaW5pbXVtLSl3aWR0aCBtdXN0IGJlIGZpbml0ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9ICdmRmVFJy5pbmRleE9mKHR5cGUpID4gLTEgPyA2IDogKHR5cGUgPT0gJ2QnKSA/IDAgOiB2b2lkKDApO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWNpc2lvbiA9PSAnKicpIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9ICthW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWNpc2lvbi5jaGFyQXQoMCkgPT0gJyonKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSArYVtwcmVjaXNpb24uc2xpY2UoMSwgLTEpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9ICtwcmVjaXNpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBncmFiIHZhbHVlIHVzaW5nIHZhbHVlSW5kZXggaWYgcmVxdWlyZWQ/XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlTmFtZSkge1xuICAgICAgICAgICAgdmFsdWVOYW1lID0gdmFsdWVOYW1lLnN1YnN0cigxLCB2YWx1ZU5hbWUubGVuZ3RoLTIpO1xuICAgICAgICAgICAgdmFsdWUgPSBhWzFdLl9fZ2V0aXRlbV9fID8gYVsxXS5fX2dldGl0ZW1fXyh2YWx1ZU5hbWUpIDogYVsxXVt2YWx1ZU5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlSW5kZXgpe1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYVt2YWx1ZUluZGV4LnNsaWNlKDAsIC0xKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhW2ldO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudW1iZXI7XG4gICAgICAgIHZhciBwcmVmaXg7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncyc6IHJldHVybiBmb3JtYXRTdHJpbmcoU3RyaW5nKHZhbHVlKSwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuICAgICAgICAgICAgY2FzZSAnYyc6IHJldHVybiBmb3JtYXRTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgrdmFsdWUpLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCk7XG4gICAgICAgICAgICBjYXNlICdiJzogcmV0dXJuIGZvcm1hdEJhc2VYKHZhbHVlLCAyLCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuICAgICAgICAgICAgY2FzZSAnbyc6IHJldHVybiBmb3JtYXRCYXNlWCh2YWx1ZSwgOCwgcHJlZml4QmFzZVgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCB6ZXJvUGFkKTtcbiAgICAgICAgICAgIGNhc2UgJ3gnOiByZXR1cm4gZm9ybWF0QmFzZVgodmFsdWUsIDE2LCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuICAgICAgICAgICAgY2FzZSAnWCc6IHJldHVybiBmb3JtYXRCYXNlWCh2YWx1ZSwgMTYsIHByZWZpeEJhc2VYLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ3UnOiByZXR1cm4gZm9ybWF0QmFzZVgodmFsdWUsIDEwLCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBjYXNlICdkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyID0gcGFyc2VJbnQoK3ZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBudW1iZXIgPCAwID8gJy0nIDogcG9zaXRpdmVQcmVmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByZWZpeCArIHBhZChTdHJpbmcoTWF0aC5hYnMobnVtYmVyKSksIHByZWNpc2lvbiwgJzAnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ganVzdGlmeSh2YWx1ZSwgcHJlZml4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHplcm9QYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBudW1iZXIgPCAwID8gJy0nIDogcG9zaXRpdmVQcmVmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gWyd0b0V4cG9uZW50aWFsJywgJ3RvRml4ZWQnLCAndG9QcmVjaXNpb24nXVsnZWZnJy5pbmRleE9mKHR5cGUudG9Mb3dlckNhc2UoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRUcmFuc2Zvcm0gPSBbJ3RvU3RyaW5nJywgJ3RvVXBwZXJDYXNlJ11bJ2VFZkZnRycuaW5kZXhPZih0eXBlKSAlIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVmaXggKyBNYXRoLmFicyhudW1iZXIpW21ldGhvZF0ocHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqdXN0aWZ5KHZhbHVlLCBwcmVmaXgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgemVyb1BhZClbdGV4dFRyYW5zZm9ybV0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHN1YnN0cmluZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UocmVnZXgsIGRvRm9ybWF0KTtcbn07Ly8gfX19XG5cbn0pKHRoaXMpO1xuXG59LmNhbGwod2luZG93KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ltcG9ydHMtbG9hZGVyPyQ9anF1ZXJ5LHRoaXM9PndpbmRvdyEuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "util/console_dev":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){\n    function bind(fn, context) {\n        return function(){ fn.apply(context, arguments);  };\n    }\n    var orig = window.console, console = orig,\n        CONSOLE_METHODS = ['log','trace','error','warn', 'info', 'debug'],\n        EMPTY = function(){},i;\n    try {\n        console.DEBUG_ENABLED = true;\n    } catch(e) {\n        console = { DEBUG_ENABLED: true };\n    }\n    for (i = 0; i < CONSOLE_METHODS.length; i++) {\n        var fn = CONSOLE_METHODS[i];\n        if(typeof console[fn] !== 'function') {\n            if(orig !== undefined && typeof orig[fn] == 'function') {\n                console[fn] = bind(orig[fn], orig);\n            } else {\n                console[fn] = EMPTY;\n            }\n        }\n    }\n    return console;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvY29uc29sZV9kZXYuanM/MzFiZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoidXRpbC9jb25zb2xlX2Rldi5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXSxmdW5jdGlvbigpe1xuICAgIGZ1bmN0aW9uIGJpbmQoZm4sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7ICB9O1xuICAgIH1cbiAgICB2YXIgb3JpZyA9IHdpbmRvdy5jb25zb2xlLCBjb25zb2xlID0gb3JpZyxcbiAgICAgICAgQ09OU09MRV9NRVRIT0RTID0gWydsb2cnLCd0cmFjZScsJ2Vycm9yJywnd2FybicsICdpbmZvJywgJ2RlYnVnJ10sXG4gICAgICAgIEVNUFRZID0gZnVuY3Rpb24oKXt9LGk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5ERUJVR19FTkFCTEVEID0gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgY29uc29sZSA9IHsgREVCVUdfRU5BQkxFRDogdHJ1ZSB9O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgQ09OU09MRV9NRVRIT0RTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbiA9IENPTlNPTEVfTUVUSE9EU1tpXTtcbiAgICAgICAgaWYodHlwZW9mIGNvbnNvbGVbZm5dICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZihvcmlnICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9yaWdbZm5dID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlW2ZuXSA9IGJpbmQob3JpZ1tmbl0sIG9yaWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlW2ZuXSA9IEVNUFRZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25zb2xlO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvY29uc29sZV9kZXYuanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvY29uc29sZV9kZXZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "shim/splunk.logger":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/splunk\"), __webpack_require__(\"shim/splunk.util\"), __webpack_require__(\"logger\")], __WEBPACK_AMD_DEFINE_RESULT__ = function(Splunk) {\n    return Splunk.Logger;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vc3BsdW5rLmxvZ2dlci5qcz9jZmQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJzaGltL3NwbHVuay5sb2dnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydzcGx1bmsnLCAnc3BsdW5rLnV0aWwnLCAnbG9nZ2VyJ10sIGZ1bmN0aW9uKFNwbHVuaykge1xuICAgIHJldHVybiBTcGx1bmsuTG9nZ2VyO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvc2hpbS9zcGx1bmsubG9nZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSBzaGltL3NwbHVuay5sb2dnZXJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "logger":
/***/ (function(module, exports) {

	eval("(function(global) {\n\nSplunk.namespace(\"Splunk.Logger\");\n/**\n * The getLogger factory provides a standard interface for implementing a logger program mode. Dependency on utils.js\n *\n * var logger = Splunk.Logger.getLogger(\"logger.js\");\n * logger.info(\"This is a log message at \", new Date(), \"showing a log!\");\n *\n *\n * @param {String} fileName The name of the source file to log.\n * @param {Function} mode (Optional) The logging programming interface you wish to implement, defaults to Splunk.Logger.mode.Default if not defined.\n */\nSplunk.Logger.getLogger = function(fileName, mode){\n    var self;\n    mode = mode || Splunk.Logger.mode.Default;\n    try {\n        self = new (mode)(fileName);\n    }catch(err){\n        self = this;\n        throw(new Error(\"Splunk.Logger mode is undefined, not callable or thrown an exception. mode=\" + mode + \" and fileName=\" + fileName + \". Check to make sure the mode you are defining exist (see: web.conf js_logger_mode) and is a proper closure. Stack trace:\" + err));\n    }\n    return self;\n};\n\n/**\n * Exposes if a browser has firebug installed or not.\n *\n * @method hasFirebug\n * @return Boolean\n */\nSplunk.Logger.hasFirebug = function(){\n    return (typeof(console)!=\"undefined\" && console.firebug)?true:false;\n};\n/**\n * Exposes if a browser has a window console object.\n *\n * @method hasConsole\n * @return Boolean\n */\nSplunk.Logger.hasConsole = function(){\n    return (typeof(console)!=\"undefined\")?true:false;\n};\n/**\n * Object to store logger program mode.\n */\nSplunk.Logger.mode = {};\n/**\n * A mode logger program that does nothing.\n */\nSplunk.Logger.mode.None = function(){\n    var self = this;\n    self.info = self.log = self.debug = self.warn = self.error = self.trace = function(){};\n};\n/**\n * A mode logger program that calls a console object and a closure matching method if defined.\n */\nSplunk.Logger.mode.Firebug = function(fileName){\n    var self = this;\n    var generateArguments = function(args){\n        var arr = [];\n        for(var i=0; i<args.length; i++){\n            arr.push(args[i]);\n        }\n        arr.push(fileName);\n        return arr;\n    };\n    var bindConsole = function(args, method){\n        args = generateArguments(args);\n        if(Splunk.Logger.hasConsole()){\n            method = console[method] || console.info || function(){};\n            //>=ie8 console object does not have an apply method (they are not instanceof functions!)\n            if(method.apply){\n                method.apply(console, args);\n            }else{\n                method(args.join(\" \"));\n            }\n        }\n    };\n\n    if (Splunk.Logger.hasFirebug() && console.firebug != '1.3.0') {\n        self.log = console.log;\n        self.info = console.info;\n        self.debug = console.debug;\n        self.warn = console.warn;\n        self.error = console.error;\n        self.trace = console.trace;\n    }\n    else {\n        self.info = function(){\n            bindConsole(arguments, \"info\");\n        };\n        self.log = function(){\n            bindConsole(arguments, \"log\");\n        };\n        self.debug = function(){\n            bindConsole(arguments, \"debug\");\n        };\n        self.warn = function(){\n            bindConsole(arguments, \"warn\");\n        };\n        self.error = function(){\n            bindConsole(arguments, \"error\");\n        };\n        self.trace = function(){\n            bindConsole(arguments, \"trace\");\n        };\n    }\n};\n/**\n * A mode logger program that implements logging to a server/splunk. Dependency on contrib/swfobject.js\n */\nSplunk.Logger.mode.Server = function(fileName){\n    var self = this,\n        buffer = Splunk.Logger.mode.Server.Buffer.getInstance();\n    /**\n     * Formats a console call and pushes it to buffer.\n     *\n     * @method bufferPush\n     * @param {arguments} args The arguments object from the original closure handler.\n     * @param {String} level The console level called.\n     */\n    var bufferPush = function(args, level){\n        args = args || [];\n        for(var i = 0; i < args.length; i++) {\n            if(typeof args[i] === 'object') {\n                try {\n                    args[i] = JSON.stringify(args[i]);\n                }\n                catch(e) { }\n            }\n        }\n        var message = Array.apply(null, args).join(\" \");\n        var data = {level: level, 'class': fileName, message: message};\n        buffer.push(data);\n    };\n    /**\n     * The handlers for (new Splunk.Logger(fileName, [mode]))[level](arguments) calls.\n     */\n    self.info = function(){\n        bufferPush(arguments, \"info\");\n    };\n    self.log = function(){\n        bufferPush(arguments, \"log\");\n    };\n    self.debug = function(){\n        bufferPush(arguments, \"debug\");\n    };\n    self.warn = function(){\n        bufferPush(arguments, \"warn\");\n    };\n    self.error = function(){\n        bufferPush(arguments, \"error\");\n    };\n    self.trace = function(){\n        // try to generate a stack trace that can be sent to the server with log-level DEBUG\n        // this will not actually give any meaningful information in IE, in which case this is a no-op\n        var trace = '';\n        try {\n            var err = new Error();\n            trace = err.stack.replace(/^Error/, '');\n        }\n        catch(e) { }\n        if(trace) {\n            bufferPush([trace], \"debug\");\n        }\n    };\n};\n/**\n * A buffer class to take care of purging and posting of logged messages.\n */\nSplunk.Logger.mode.Server.Buffer = function(){\n    var self = this,\n        thread,\n        buffer = [];\n    /**\n     * Posts buffer asynchronously to Splunk.Logger.Mode.Server.END_POINT,\n     *\n     * @method serverPost\n     */\n    var serverPost = function(){\n        var data = JSON.stringify(buffer);\n        $.post(Splunk.Logger.mode.Server.END_POINT, {\"data\":data});\n    };\n    /**\n     * Posts and purges the existing buffer.\n     *\n     * @method purge\n     */\n    var purge = function(){\n        serverPost();\n        buffer = [];\n    };\n    /**\n     * Checks the buffer, posts and purges if necessary.\n     *\n     * @method check\n     */\n    var check = function(){\n        if(buffer.length>Splunk.Logger.mode.Server.MAX_BUFFER){\n            purge();\n        }\n    };\n    self.push = function(str){\n        buffer.push(str);\n        check();\n    };\n    /**\n     * Checks the buffer at set interval and posts and purges if data exists.\n     *\n     * @method poller\n     */\n    self.poller = function(){\n        if(buffer.length>0){\n            purge();\n        }\n    };\n    self.size = function(){\n        return buffer.length;\n    };\n    self.Buffer = function(){\n        thread = setInterval(self.poller, Splunk.Logger.mode.Server.POLL_BUFFER);\n    }();\n};\nSplunk.Logger.mode.Server.Buffer.instance = null;\n/**\n * Singleton reference to a shared buffer.\n *\n * @method getInstance\n */\nSplunk.Logger.mode.Server.Buffer.getInstance = function(){\n    if(Splunk.Logger.mode.Server.Buffer.instance==null){\n        Splunk.Logger.mode.Server.Buffer.instance = new Splunk.Logger.mode.Server.Buffer();\n    }\n    return Splunk.Logger.mode.Server.Buffer.instance;\n};\nSplunk.Logger.mode.Server.END_POINT = Splunk.util.make_url(Splunk.util.getConfigValue(\"JS_LOGGER_MODE_SERVER_END_POINT\", \"util/log/js\"));\nSplunk.Logger.mode.Server.POLL_BUFFER = Splunk.util.getConfigValue(\"JS_LOGGER_MODE_SERVER_POLL_BUFFER\", 1000);\nSplunk.Logger.mode.Server.MAX_BUFFER = Splunk.util.getConfigValue(\"JS_LOGGER_MODE_SERVER_MAX_BUFFER\", 100);\n/**\n * The default system mode logger program, see web.conf js_logger_mode.\n */\nSplunk.Logger.mode.Default = Splunk.Logger.mode[Splunk.util.getConfigValue(\"JS_LOGGER_MODE\", \"None\")];\n/**\n * Legacy Splunk.log compatibility\n */\nSplunk.log = function(msg, category, src){\n    Splunk.Logger.getLogger(\"logger.js\").warn(\"WARNING! Splunk.log is now deprecated. See Splunk.Logger class for more details.\", \"Original Message:\", msg, \" Original Category:\", category, \"Original Source:\", src);\n};\n/**\n * Legacy Backwards compatibility with 3.X\n */\nvar D = global.D = {};\nD.logger = Splunk.Logger.getLogger(\"logger.js\");\nD.wrapper = function(str, level){\n    D.logger.warn(\"WARNING! D.\", level, \"is now deprecated. See Splunk.Logger class for more details.\", str);\n};\nD.debug = function(str){D.wrapper(str, \"debug\");};\nD.error = function(str){D.wrapper(str, \"error\");};\nD.warn = function(str){D.wrapper(str, \"warn\");};\n/**\n * Augment util.logger to standard logger.\n */\nSplunk.util.logger = Splunk.Logger.getLogger(\"util.js\");\n\n})(this);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2xvZ2dlci5qcz8xZWE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsImZpbGUiOiJsb2dnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZ2xvYmFsKSB7XG5cblNwbHVuay5uYW1lc3BhY2UoXCJTcGx1bmsuTG9nZ2VyXCIpO1xuLyoqXG4gKiBUaGUgZ2V0TG9nZ2VyIGZhY3RvcnkgcHJvdmlkZXMgYSBzdGFuZGFyZCBpbnRlcmZhY2UgZm9yIGltcGxlbWVudGluZyBhIGxvZ2dlciBwcm9ncmFtIG1vZGUuIERlcGVuZGVuY3kgb24gdXRpbHMuanNcbiAqXG4gKiB2YXIgbG9nZ2VyID0gU3BsdW5rLkxvZ2dlci5nZXRMb2dnZXIoXCJsb2dnZXIuanNcIik7XG4gKiBsb2dnZXIuaW5mbyhcIlRoaXMgaXMgYSBsb2cgbWVzc2FnZSBhdCBcIiwgbmV3IERhdGUoKSwgXCJzaG93aW5nIGEgbG9nIVwiKTtcbiAqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZSB0byBsb2cuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RlIChPcHRpb25hbCkgVGhlIGxvZ2dpbmcgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlIHlvdSB3aXNoIHRvIGltcGxlbWVudCwgZGVmYXVsdHMgdG8gU3BsdW5rLkxvZ2dlci5tb2RlLkRlZmF1bHQgaWYgbm90IGRlZmluZWQuXG4gKi9cblNwbHVuay5Mb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24oZmlsZU5hbWUsIG1vZGUpe1xuICAgIHZhciBzZWxmO1xuICAgIG1vZGUgPSBtb2RlIHx8IFNwbHVuay5Mb2dnZXIubW9kZS5EZWZhdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHNlbGYgPSBuZXcgKG1vZGUpKGZpbGVOYW1lKTtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRocm93KG5ldyBFcnJvcihcIlNwbHVuay5Mb2dnZXIgbW9kZSBpcyB1bmRlZmluZWQsIG5vdCBjYWxsYWJsZSBvciB0aHJvd24gYW4gZXhjZXB0aW9uLiBtb2RlPVwiICsgbW9kZSArIFwiIGFuZCBmaWxlTmFtZT1cIiArIGZpbGVOYW1lICsgXCIuIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgbW9kZSB5b3UgYXJlIGRlZmluaW5nIGV4aXN0IChzZWU6IHdlYi5jb25mIGpzX2xvZ2dlcl9tb2RlKSBhbmQgaXMgYSBwcm9wZXIgY2xvc3VyZS4gU3RhY2sgdHJhY2U6XCIgKyBlcnIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59O1xuXG4vKipcbiAqIEV4cG9zZXMgaWYgYSBicm93c2VyIGhhcyBmaXJlYnVnIGluc3RhbGxlZCBvciBub3QuXG4gKlxuICogQG1ldGhvZCBoYXNGaXJlYnVnXG4gKiBAcmV0dXJuIEJvb2xlYW5cbiAqL1xuU3BsdW5rLkxvZ2dlci5oYXNGaXJlYnVnID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gKHR5cGVvZihjb25zb2xlKSE9XCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLmZpcmVidWcpP3RydWU6ZmFsc2U7XG59O1xuLyoqXG4gKiBFeHBvc2VzIGlmIGEgYnJvd3NlciBoYXMgYSB3aW5kb3cgY29uc29sZSBvYmplY3QuXG4gKlxuICogQG1ldGhvZCBoYXNDb25zb2xlXG4gKiBAcmV0dXJuIEJvb2xlYW5cbiAqL1xuU3BsdW5rLkxvZ2dlci5oYXNDb25zb2xlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gKHR5cGVvZihjb25zb2xlKSE9XCJ1bmRlZmluZWRcIik/dHJ1ZTpmYWxzZTtcbn07XG4vKipcbiAqIE9iamVjdCB0byBzdG9yZSBsb2dnZXIgcHJvZ3JhbSBtb2RlLlxuICovXG5TcGx1bmsuTG9nZ2VyLm1vZGUgPSB7fTtcbi8qKlxuICogQSBtb2RlIGxvZ2dlciBwcm9ncmFtIHRoYXQgZG9lcyBub3RoaW5nLlxuICovXG5TcGx1bmsuTG9nZ2VyLm1vZGUuTm9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuaW5mbyA9IHNlbGYubG9nID0gc2VsZi5kZWJ1ZyA9IHNlbGYud2FybiA9IHNlbGYuZXJyb3IgPSBzZWxmLnRyYWNlID0gZnVuY3Rpb24oKXt9O1xufTtcbi8qKlxuICogQSBtb2RlIGxvZ2dlciBwcm9ncmFtIHRoYXQgY2FsbHMgYSBjb25zb2xlIG9iamVjdCBhbmQgYSBjbG9zdXJlIG1hdGNoaW5nIG1ldGhvZCBpZiBkZWZpbmVkLlxuICovXG5TcGx1bmsuTG9nZ2VyLm1vZGUuRmlyZWJ1ZyA9IGZ1bmN0aW9uKGZpbGVOYW1lKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGdlbmVyYXRlQXJndW1lbnRzID0gZnVuY3Rpb24oYXJncyl7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8YXJncy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBhcnIucHVzaChhcmdzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBhcnIucHVzaChmaWxlTmFtZSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgICB2YXIgYmluZENvbnNvbGUgPSBmdW5jdGlvbihhcmdzLCBtZXRob2Qpe1xuICAgICAgICBhcmdzID0gZ2VuZXJhdGVBcmd1bWVudHMoYXJncyk7XG4gICAgICAgIGlmKFNwbHVuay5Mb2dnZXIuaGFzQ29uc29sZSgpKXtcbiAgICAgICAgICAgIG1ldGhvZCA9IGNvbnNvbGVbbWV0aG9kXSB8fCBjb25zb2xlLmluZm8gfHwgZnVuY3Rpb24oKXt9O1xuICAgICAgICAgICAgLy8+PWllOCBjb25zb2xlIG9iamVjdCBkb2VzIG5vdCBoYXZlIGFuIGFwcGx5IG1ldGhvZCAodGhleSBhcmUgbm90IGluc3RhbmNlb2YgZnVuY3Rpb25zISlcbiAgICAgICAgICAgIGlmKG1ldGhvZC5hcHBseSl7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgbWV0aG9kKGFyZ3Muam9pbihcIiBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmIChTcGx1bmsuTG9nZ2VyLmhhc0ZpcmVidWcoKSAmJiBjb25zb2xlLmZpcmVidWcgIT0gJzEuMy4wJykge1xuICAgICAgICBzZWxmLmxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgICBzZWxmLmluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHNlbGYuZGVidWcgPSBjb25zb2xlLmRlYnVnO1xuICAgICAgICBzZWxmLndhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgIHNlbGYuZXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBzZWxmLnRyYWNlID0gY29uc29sZS50cmFjZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlbGYuaW5mbyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBiaW5kQ29uc29sZShhcmd1bWVudHMsIFwiaW5mb1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5sb2cgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgYmluZENvbnNvbGUoYXJndW1lbnRzLCBcImxvZ1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5kZWJ1ZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBiaW5kQ29uc29sZShhcmd1bWVudHMsIFwiZGVidWdcIik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYud2FybiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBiaW5kQ29uc29sZShhcmd1bWVudHMsIFwid2FyblwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5lcnJvciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBiaW5kQ29uc29sZShhcmd1bWVudHMsIFwiZXJyb3JcIik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYudHJhY2UgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgYmluZENvbnNvbGUoYXJndW1lbnRzLCBcInRyYWNlXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIEEgbW9kZSBsb2dnZXIgcHJvZ3JhbSB0aGF0IGltcGxlbWVudHMgbG9nZ2luZyB0byBhIHNlcnZlci9zcGx1bmsuIERlcGVuZGVuY3kgb24gY29udHJpYi9zd2ZvYmplY3QuanNcbiAqL1xuU3BsdW5rLkxvZ2dlci5tb2RlLlNlcnZlciA9IGZ1bmN0aW9uKGZpbGVOYW1lKXtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGJ1ZmZlciA9IFNwbHVuay5Mb2dnZXIubW9kZS5TZXJ2ZXIuQnVmZmVyLmdldEluc3RhbmNlKCk7XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIGNvbnNvbGUgY2FsbCBhbmQgcHVzaGVzIGl0IHRvIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVmZmVyUHVzaFxuICAgICAqIEBwYXJhbSB7YXJndW1lbnRzfSBhcmdzIFRoZSBhcmd1bWVudHMgb2JqZWN0IGZyb20gdGhlIG9yaWdpbmFsIGNsb3N1cmUgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWwgVGhlIGNvbnNvbGUgbGV2ZWwgY2FsbGVkLlxuICAgICAqL1xuICAgIHZhciBidWZmZXJQdXNoID0gZnVuY3Rpb24oYXJncywgbGV2ZWwpe1xuICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBhcmdzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBKU09OLnN0cmluZ2lmeShhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2goZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBBcnJheS5hcHBseShudWxsLCBhcmdzKS5qb2luKFwiIFwiKTtcbiAgICAgICAgdmFyIGRhdGEgPSB7bGV2ZWw6IGxldmVsLCAnY2xhc3MnOiBmaWxlTmFtZSwgbWVzc2FnZTogbWVzc2FnZX07XG4gICAgICAgIGJ1ZmZlci5wdXNoKGRhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXJzIGZvciAobmV3IFNwbHVuay5Mb2dnZXIoZmlsZU5hbWUsIFttb2RlXSkpW2xldmVsXShhcmd1bWVudHMpIGNhbGxzLlxuICAgICAqL1xuICAgIHNlbGYuaW5mbyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGJ1ZmZlclB1c2goYXJndW1lbnRzLCBcImluZm9cIik7XG4gICAgfTtcbiAgICBzZWxmLmxvZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGJ1ZmZlclB1c2goYXJndW1lbnRzLCBcImxvZ1wiKTtcbiAgICB9O1xuICAgIHNlbGYuZGVidWcgPSBmdW5jdGlvbigpe1xuICAgICAgICBidWZmZXJQdXNoKGFyZ3VtZW50cywgXCJkZWJ1Z1wiKTtcbiAgICB9O1xuICAgIHNlbGYud2FybiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGJ1ZmZlclB1c2goYXJndW1lbnRzLCBcIndhcm5cIik7XG4gICAgfTtcbiAgICBzZWxmLmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgYnVmZmVyUHVzaChhcmd1bWVudHMsIFwiZXJyb3JcIik7XG4gICAgfTtcbiAgICBzZWxmLnRyYWNlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gdHJ5IHRvIGdlbmVyYXRlIGEgc3RhY2sgdHJhY2UgdGhhdCBjYW4gYmUgc2VudCB0byB0aGUgc2VydmVyIHdpdGggbG9nLWxldmVsIERFQlVHXG4gICAgICAgIC8vIHRoaXMgd2lsbCBub3QgYWN0dWFsbHkgZ2l2ZSBhbnkgbWVhbmluZ2Z1bCBpbmZvcm1hdGlvbiBpbiBJRSwgaW4gd2hpY2ggY2FzZSB0aGlzIGlzIGEgbm8tb3BcbiAgICAgICAgdmFyIHRyYWNlID0gJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICB0cmFjZSA9IGVyci5zdGFjay5yZXBsYWNlKC9eRXJyb3IvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkgeyB9XG4gICAgICAgIGlmKHRyYWNlKSB7XG4gICAgICAgICAgICBidWZmZXJQdXNoKFt0cmFjZV0sIFwiZGVidWdcIik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8qKlxuICogQSBidWZmZXIgY2xhc3MgdG8gdGFrZSBjYXJlIG9mIHB1cmdpbmcgYW5kIHBvc3Rpbmcgb2YgbG9nZ2VkIG1lc3NhZ2VzLlxuICovXG5TcGx1bmsuTG9nZ2VyLm1vZGUuU2VydmVyLkJ1ZmZlciA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0aHJlYWQsXG4gICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgIC8qKlxuICAgICAqIFBvc3RzIGJ1ZmZlciBhc3luY2hyb25vdXNseSB0byBTcGx1bmsuTG9nZ2VyLk1vZGUuU2VydmVyLkVORF9QT0lOVCxcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VydmVyUG9zdFxuICAgICAqL1xuICAgIHZhciBzZXJ2ZXJQb3N0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeShidWZmZXIpO1xuICAgICAgICAkLnBvc3QoU3BsdW5rLkxvZ2dlci5tb2RlLlNlcnZlci5FTkRfUE9JTlQsIHtcImRhdGFcIjpkYXRhfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQb3N0cyBhbmQgcHVyZ2VzIHRoZSBleGlzdGluZyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHB1cmdlXG4gICAgICovXG4gICAgdmFyIHB1cmdlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VydmVyUG9zdCgpO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgYnVmZmVyLCBwb3N0cyBhbmQgcHVyZ2VzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY2hlY2tcbiAgICAgKi9cbiAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZihidWZmZXIubGVuZ3RoPlNwbHVuay5Mb2dnZXIubW9kZS5TZXJ2ZXIuTUFYX0JVRkZFUil7XG4gICAgICAgICAgICBwdXJnZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLnB1c2ggPSBmdW5jdGlvbihzdHIpe1xuICAgICAgICBidWZmZXIucHVzaChzdHIpO1xuICAgICAgICBjaGVjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBidWZmZXIgYXQgc2V0IGludGVydmFsIGFuZCBwb3N0cyBhbmQgcHVyZ2VzIGlmIGRhdGEgZXhpc3RzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwb2xsZXJcbiAgICAgKi9cbiAgICBzZWxmLnBvbGxlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGJ1ZmZlci5sZW5ndGg+MCl7XG4gICAgICAgICAgICBwdXJnZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLnNpemUgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gYnVmZmVyLmxlbmd0aDtcbiAgICB9O1xuICAgIHNlbGYuQnVmZmVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhyZWFkID0gc2V0SW50ZXJ2YWwoc2VsZi5wb2xsZXIsIFNwbHVuay5Mb2dnZXIubW9kZS5TZXJ2ZXIuUE9MTF9CVUZGRVIpO1xuICAgIH0oKTtcbn07XG5TcGx1bmsuTG9nZ2VyLm1vZGUuU2VydmVyLkJ1ZmZlci5pbnN0YW5jZSA9IG51bGw7XG4vKipcbiAqIFNpbmdsZXRvbiByZWZlcmVuY2UgdG8gYSBzaGFyZWQgYnVmZmVyLlxuICpcbiAqIEBtZXRob2QgZ2V0SW5zdGFuY2VcbiAqL1xuU3BsdW5rLkxvZ2dlci5tb2RlLlNlcnZlci5CdWZmZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbigpe1xuICAgIGlmKFNwbHVuay5Mb2dnZXIubW9kZS5TZXJ2ZXIuQnVmZmVyLmluc3RhbmNlPT1udWxsKXtcbiAgICAgICAgU3BsdW5rLkxvZ2dlci5tb2RlLlNlcnZlci5CdWZmZXIuaW5zdGFuY2UgPSBuZXcgU3BsdW5rLkxvZ2dlci5tb2RlLlNlcnZlci5CdWZmZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIFNwbHVuay5Mb2dnZXIubW9kZS5TZXJ2ZXIuQnVmZmVyLmluc3RhbmNlO1xufTtcblNwbHVuay5Mb2dnZXIubW9kZS5TZXJ2ZXIuRU5EX1BPSU5UID0gU3BsdW5rLnV0aWwubWFrZV91cmwoU3BsdW5rLnV0aWwuZ2V0Q29uZmlnVmFsdWUoXCJKU19MT0dHRVJfTU9ERV9TRVJWRVJfRU5EX1BPSU5UXCIsIFwidXRpbC9sb2cvanNcIikpO1xuU3BsdW5rLkxvZ2dlci5tb2RlLlNlcnZlci5QT0xMX0JVRkZFUiA9IFNwbHVuay51dGlsLmdldENvbmZpZ1ZhbHVlKFwiSlNfTE9HR0VSX01PREVfU0VSVkVSX1BPTExfQlVGRkVSXCIsIDEwMDApO1xuU3BsdW5rLkxvZ2dlci5tb2RlLlNlcnZlci5NQVhfQlVGRkVSID0gU3BsdW5rLnV0aWwuZ2V0Q29uZmlnVmFsdWUoXCJKU19MT0dHRVJfTU9ERV9TRVJWRVJfTUFYX0JVRkZFUlwiLCAxMDApO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBzeXN0ZW0gbW9kZSBsb2dnZXIgcHJvZ3JhbSwgc2VlIHdlYi5jb25mIGpzX2xvZ2dlcl9tb2RlLlxuICovXG5TcGx1bmsuTG9nZ2VyLm1vZGUuRGVmYXVsdCA9IFNwbHVuay5Mb2dnZXIubW9kZVtTcGx1bmsudXRpbC5nZXRDb25maWdWYWx1ZShcIkpTX0xPR0dFUl9NT0RFXCIsIFwiTm9uZVwiKV07XG4vKipcbiAqIExlZ2FjeSBTcGx1bmsubG9nIGNvbXBhdGliaWxpdHlcbiAqL1xuU3BsdW5rLmxvZyA9IGZ1bmN0aW9uKG1zZywgY2F0ZWdvcnksIHNyYyl7XG4gICAgU3BsdW5rLkxvZ2dlci5nZXRMb2dnZXIoXCJsb2dnZXIuanNcIikud2FybihcIldBUk5JTkchIFNwbHVuay5sb2cgaXMgbm93IGRlcHJlY2F0ZWQuIFNlZSBTcGx1bmsuTG9nZ2VyIGNsYXNzIGZvciBtb3JlIGRldGFpbHMuXCIsIFwiT3JpZ2luYWwgTWVzc2FnZTpcIiwgbXNnLCBcIiBPcmlnaW5hbCBDYXRlZ29yeTpcIiwgY2F0ZWdvcnksIFwiT3JpZ2luYWwgU291cmNlOlwiLCBzcmMpO1xufTtcbi8qKlxuICogTGVnYWN5IEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMy5YXG4gKi9cbnZhciBEID0gZ2xvYmFsLkQgPSB7fTtcbkQubG9nZ2VyID0gU3BsdW5rLkxvZ2dlci5nZXRMb2dnZXIoXCJsb2dnZXIuanNcIik7XG5ELndyYXBwZXIgPSBmdW5jdGlvbihzdHIsIGxldmVsKXtcbiAgICBELmxvZ2dlci53YXJuKFwiV0FSTklORyEgRC5cIiwgbGV2ZWwsIFwiaXMgbm93IGRlcHJlY2F0ZWQuIFNlZSBTcGx1bmsuTG9nZ2VyIGNsYXNzIGZvciBtb3JlIGRldGFpbHMuXCIsIHN0cik7XG59O1xuRC5kZWJ1ZyA9IGZ1bmN0aW9uKHN0cil7RC53cmFwcGVyKHN0ciwgXCJkZWJ1Z1wiKTt9O1xuRC5lcnJvciA9IGZ1bmN0aW9uKHN0cil7RC53cmFwcGVyKHN0ciwgXCJlcnJvclwiKTt9O1xuRC53YXJuID0gZnVuY3Rpb24oc3RyKXtELndyYXBwZXIoc3RyLCBcIndhcm5cIik7fTtcbi8qKlxuICogQXVnbWVudCB1dGlsLmxvZ2dlciB0byBzdGFuZGFyZCBsb2dnZXIuXG4gKi9cblNwbHVuay51dGlsLmxvZ2dlciA9IFNwbHVuay5Mb2dnZXIuZ2V0TG9nZ2VyKFwidXRpbC5qc1wiKTtcblxufSkodGhpcyk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9sb2dnZXIuanNcbi8vIG1vZHVsZSBpZCA9IGxvZ2dlclxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 9:
/***/ (function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(__filename) {module.exports = {\n    resolve: {\n        alias: {\n            'coreAliases': __filename,\n            // contrib libraries\n            'jquery$': 'shim/jquery',\n            'numeral': 'shim/numeral',\n            'highcharts.runtime_patches': 'contrib/highcharts-4.0.4/runtime_patches',\n            'backbone_validation': 'contrib/backbone-validation-amd',\n            'intro': 'shim/intro',\n            'document-register-element': 'contrib/polyfills/document-register-element.max.amd',\n\n            /* augments builtin prototype */\n            'strftime': 'contrib/strftime',\n            'jg': 'contrib/jg_lib', // TODO Do we need to shim this?\n            'spin': 'contrib/spin',\n            'sax': 'contrib/sax',\n            'ace/ace$': 'shim/ace-editor',\n            'ace/spl_tools': 'shim/ace-spl_tools',\n            'ace/mode-spl': 'shim/mode-spl',\n\n            // splunkjs\n            'async': 'splunkjs/contrib/requirejs-plugins/async', // TODO We should not use splunkjs in core! Move this to core?\n\n            // Begin shimmed modules\n\n            /* augments builtin prototype */\n            'leaflet': 'shim/leaflet',\n            'jg_global$': 'shim/jg_global',\n            'jgatt$': 'shim/jgatt',\n            'lowpro': 'shim/lowpro',\n\n            // other contrib libraries\n            'underscore': 'require/underscore', // shim shared with requirejs config\n            'backbone': 'require/backbone', // shim shared with requirejs config\n            'highcharts': 'shim/highcharts',\n            'prettify': 'shim/prettify',\n            'requirejs': 'shim/requirejs',\n\n            'jquery.history$': 'shim/jquery.history',\n            'jquery.bgiframe$': 'shim/jquery.bgiframe',\n            'jquery.cookie$': 'shim/jquery.cookie',\n            'jquery.deparam$': 'shim/jquery.deparam',\n            'jquery.fileupload$': 'shim/jquery.fileupload',\n            'jquery.iframe-transport$': 'shim/jquery.iframe-transport',\n\n            // jQuery UI plugins\n            'jquery.ui.core': 'shim/jquery.ui.core',\n            'jquery.ui.widget': 'shim/jquery.ui.widget',\n            'jquery.ui.datepicker': 'shim/jquery.ui.datepicker',\n            'jquery.ui.position': 'shim/jquery.ui.position',\n            'jquery.ui.mouse': 'shim/jquery.ui.mouse',\n            'jquery.ui.draggable': 'shim/jquery.ui.draggable',\n            'jquery.ui.droppable': 'shim/jquery.ui.droppable',\n            'jquery.ui.sortable': 'shim/jquery.ui.sortable',\n            'jquery.ui.resizable': 'shim/jquery.ui.resizable',\n            'jquery.ui.button': 'shim/jquery.ui.button',\n            'jquery.ui.spinner': 'shim/jquery.ui.spinner',\n            'jquery.ui.effect': 'shim/jquery.ui.effect',\n            'jquery.ui.effect-slide': 'shim/jquery.ui.effect-slide',\n            'tree.jquery': 'shim/tree.jquery',\n            'jquery.resize': 'shim/jquery.resize',\n            'jquery.sparkline$': 'shim/jquery.sparkline',\n\n            // bootstrap components\n            // FIXME: bootstrap.button collides with jquery.ui.button on the jQuery prototype !!\n            'bootstrap.affix': 'shim/bootstrap.affix',\n            'bootstrap.alert': 'shim/bootstrap.alert',\n            'bootstrap.button': 'shim/bootstrap.button',\n            'bootstrap.carousel': 'shim/bootstrap.carousel',\n            'bootstrap.collapse': 'shim/bootstrap.collapse',\n            'bootstrap.dropdown': 'shim/bootstrap.dropdown',\n            'bootstrap.modal': 'shim/bootstrap.modal',\n            'bootstrap.popover': 'shim/bootstrap.popover',\n            'bootstrap.scrollspy': 'shim/bootstrap.scrollspy',\n            'bootstrap.tab': 'shim/bootstrap.tab',\n            'bootstrap.tooltip': 'shim/bootstrap.tooltip',\n            'bootstrap.transition': 'shim/bootstrap.transition',\n            'bootstrap.typeahead': 'shim/bootstrap.typeahead',\n\n            // Splunk legacy\n            'splunk$': 'shim/splunk',\n            'splunk.legend': 'shim/splunk.legend',\n            'splunk.logger': 'shim/splunk.logger',\n            'splunk.error': 'shim/splunk.error',\n            'splunk.util': 'shim/splunk.util',\n            'splunk.pdf': 'shim/splunk.pdf',\n            'splunk.i18n': 'stubs/i18n', // shim shared with requirejs config\n            'splunk.config': 'stubs/splunk.config', // shim shared with requirejs config\n            'splunk.paginator': 'shim/splunk.paginator',\n            'splunk.messenger': 'shim/splunk.messenger',\n            'splunk.time': 'shim/splunk.time',\n            'splunk.timerange': 'shim/splunk.timerange',\n            'splunk.window': 'shim/splunk.window',\n            'splunk.jabridge': 'shim/splunk.jabridge', // Do we need this still?\n            'splunk.print': 'shim/splunk.print',\n            'splunk.session': 'shim/splunk.session',\n            'splunk.jquery.csrf$': 'shim/splunk.jquery.csrf',\n\n            'select2/select2$': 'shim/select2',\n\n            'splunkjs/splunk$': 'shim/splunkjs'\n        }\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, \"/index.js\"))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvYnVpbGRfdG9vbHMvcHJvZmlsZXMvY29tbW9uL2NvcmVBbGlhc2VzLmNvbmZpZy5qcz85ZWRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlc29sdmU6IHtcbiAgICAgICAgYWxpYXM6IHtcbiAgICAgICAgICAgICdjb3JlQWxpYXNlcyc6IF9fZmlsZW5hbWUsXG4gICAgICAgICAgICAvLyBjb250cmliIGxpYnJhcmllc1xuICAgICAgICAgICAgJ2pxdWVyeSQnOiAnc2hpbS9qcXVlcnknLFxuICAgICAgICAgICAgJ251bWVyYWwnOiAnc2hpbS9udW1lcmFsJyxcbiAgICAgICAgICAgICdoaWdoY2hhcnRzLnJ1bnRpbWVfcGF0Y2hlcyc6ICdjb250cmliL2hpZ2hjaGFydHMtNC4wLjQvcnVudGltZV9wYXRjaGVzJyxcbiAgICAgICAgICAgICdiYWNrYm9uZV92YWxpZGF0aW9uJzogJ2NvbnRyaWIvYmFja2JvbmUtdmFsaWRhdGlvbi1hbWQnLFxuICAgICAgICAgICAgJ2ludHJvJzogJ3NoaW0vaW50cm8nLFxuICAgICAgICAgICAgJ2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQnOiAnY29udHJpYi9wb2x5ZmlsbHMvZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudC5tYXguYW1kJyxcblxuICAgICAgICAgICAgLyogYXVnbWVudHMgYnVpbHRpbiBwcm90b3R5cGUgKi9cbiAgICAgICAgICAgICdzdHJmdGltZSc6ICdjb250cmliL3N0cmZ0aW1lJyxcbiAgICAgICAgICAgICdqZyc6ICdjb250cmliL2pnX2xpYicsIC8vIFRPRE8gRG8gd2UgbmVlZCB0byBzaGltIHRoaXM/XG4gICAgICAgICAgICAnc3Bpbic6ICdjb250cmliL3NwaW4nLFxuICAgICAgICAgICAgJ3NheCc6ICdjb250cmliL3NheCcsXG4gICAgICAgICAgICAnYWNlL2FjZSQnOiAnc2hpbS9hY2UtZWRpdG9yJyxcbiAgICAgICAgICAgICdhY2Uvc3BsX3Rvb2xzJzogJ3NoaW0vYWNlLXNwbF90b29scycsXG4gICAgICAgICAgICAnYWNlL21vZGUtc3BsJzogJ3NoaW0vbW9kZS1zcGwnLFxuXG4gICAgICAgICAgICAvLyBzcGx1bmtqc1xuICAgICAgICAgICAgJ2FzeW5jJzogJ3NwbHVua2pzL2NvbnRyaWIvcmVxdWlyZWpzLXBsdWdpbnMvYXN5bmMnLCAvLyBUT0RPIFdlIHNob3VsZCBub3QgdXNlIHNwbHVua2pzIGluIGNvcmUhIE1vdmUgdGhpcyB0byBjb3JlP1xuXG4gICAgICAgICAgICAvLyBCZWdpbiBzaGltbWVkIG1vZHVsZXNcblxuICAgICAgICAgICAgLyogYXVnbWVudHMgYnVpbHRpbiBwcm90b3R5cGUgKi9cbiAgICAgICAgICAgICdsZWFmbGV0JzogJ3NoaW0vbGVhZmxldCcsXG4gICAgICAgICAgICAnamdfZ2xvYmFsJCc6ICdzaGltL2pnX2dsb2JhbCcsXG4gICAgICAgICAgICAnamdhdHQkJzogJ3NoaW0vamdhdHQnLFxuICAgICAgICAgICAgJ2xvd3Bybyc6ICdzaGltL2xvd3BybycsXG5cbiAgICAgICAgICAgIC8vIG90aGVyIGNvbnRyaWIgbGlicmFyaWVzXG4gICAgICAgICAgICAndW5kZXJzY29yZSc6ICdyZXF1aXJlL3VuZGVyc2NvcmUnLCAvLyBzaGltIHNoYXJlZCB3aXRoIHJlcXVpcmVqcyBjb25maWdcbiAgICAgICAgICAgICdiYWNrYm9uZSc6ICdyZXF1aXJlL2JhY2tib25lJywgLy8gc2hpbSBzaGFyZWQgd2l0aCByZXF1aXJlanMgY29uZmlnXG4gICAgICAgICAgICAnaGlnaGNoYXJ0cyc6ICdzaGltL2hpZ2hjaGFydHMnLFxuICAgICAgICAgICAgJ3ByZXR0aWZ5JzogJ3NoaW0vcHJldHRpZnknLFxuICAgICAgICAgICAgJ3JlcXVpcmVqcyc6ICdzaGltL3JlcXVpcmVqcycsXG5cbiAgICAgICAgICAgICdqcXVlcnkuaGlzdG9yeSQnOiAnc2hpbS9qcXVlcnkuaGlzdG9yeScsXG4gICAgICAgICAgICAnanF1ZXJ5LmJnaWZyYW1lJCc6ICdzaGltL2pxdWVyeS5iZ2lmcmFtZScsXG4gICAgICAgICAgICAnanF1ZXJ5LmNvb2tpZSQnOiAnc2hpbS9qcXVlcnkuY29va2llJyxcbiAgICAgICAgICAgICdqcXVlcnkuZGVwYXJhbSQnOiAnc2hpbS9qcXVlcnkuZGVwYXJhbScsXG4gICAgICAgICAgICAnanF1ZXJ5LmZpbGV1cGxvYWQkJzogJ3NoaW0vanF1ZXJ5LmZpbGV1cGxvYWQnLFxuICAgICAgICAgICAgJ2pxdWVyeS5pZnJhbWUtdHJhbnNwb3J0JCc6ICdzaGltL2pxdWVyeS5pZnJhbWUtdHJhbnNwb3J0JyxcblxuICAgICAgICAgICAgLy8galF1ZXJ5IFVJIHBsdWdpbnNcbiAgICAgICAgICAgICdqcXVlcnkudWkuY29yZSc6ICdzaGltL2pxdWVyeS51aS5jb3JlJyxcbiAgICAgICAgICAgICdqcXVlcnkudWkud2lkZ2V0JzogJ3NoaW0vanF1ZXJ5LnVpLndpZGdldCcsXG4gICAgICAgICAgICAnanF1ZXJ5LnVpLmRhdGVwaWNrZXInOiAnc2hpbS9qcXVlcnkudWkuZGF0ZXBpY2tlcicsXG4gICAgICAgICAgICAnanF1ZXJ5LnVpLnBvc2l0aW9uJzogJ3NoaW0vanF1ZXJ5LnVpLnBvc2l0aW9uJyxcbiAgICAgICAgICAgICdqcXVlcnkudWkubW91c2UnOiAnc2hpbS9qcXVlcnkudWkubW91c2UnLFxuICAgICAgICAgICAgJ2pxdWVyeS51aS5kcmFnZ2FibGUnOiAnc2hpbS9qcXVlcnkudWkuZHJhZ2dhYmxlJyxcbiAgICAgICAgICAgICdqcXVlcnkudWkuZHJvcHBhYmxlJzogJ3NoaW0vanF1ZXJ5LnVpLmRyb3BwYWJsZScsXG4gICAgICAgICAgICAnanF1ZXJ5LnVpLnNvcnRhYmxlJzogJ3NoaW0vanF1ZXJ5LnVpLnNvcnRhYmxlJyxcbiAgICAgICAgICAgICdqcXVlcnkudWkucmVzaXphYmxlJzogJ3NoaW0vanF1ZXJ5LnVpLnJlc2l6YWJsZScsXG4gICAgICAgICAgICAnanF1ZXJ5LnVpLmJ1dHRvbic6ICdzaGltL2pxdWVyeS51aS5idXR0b24nLFxuICAgICAgICAgICAgJ2pxdWVyeS51aS5zcGlubmVyJzogJ3NoaW0vanF1ZXJ5LnVpLnNwaW5uZXInLFxuICAgICAgICAgICAgJ2pxdWVyeS51aS5lZmZlY3QnOiAnc2hpbS9qcXVlcnkudWkuZWZmZWN0JyxcbiAgICAgICAgICAgICdqcXVlcnkudWkuZWZmZWN0LXNsaWRlJzogJ3NoaW0vanF1ZXJ5LnVpLmVmZmVjdC1zbGlkZScsXG4gICAgICAgICAgICAndHJlZS5qcXVlcnknOiAnc2hpbS90cmVlLmpxdWVyeScsXG4gICAgICAgICAgICAnanF1ZXJ5LnJlc2l6ZSc6ICdzaGltL2pxdWVyeS5yZXNpemUnLFxuICAgICAgICAgICAgJ2pxdWVyeS5zcGFya2xpbmUkJzogJ3NoaW0vanF1ZXJ5LnNwYXJrbGluZScsXG5cbiAgICAgICAgICAgIC8vIGJvb3RzdHJhcCBjb21wb25lbnRzXG4gICAgICAgICAgICAvLyBGSVhNRTogYm9vdHN0cmFwLmJ1dHRvbiBjb2xsaWRlcyB3aXRoIGpxdWVyeS51aS5idXR0b24gb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgISFcbiAgICAgICAgICAgICdib290c3RyYXAuYWZmaXgnOiAnc2hpbS9ib290c3RyYXAuYWZmaXgnLFxuICAgICAgICAgICAgJ2Jvb3RzdHJhcC5hbGVydCc6ICdzaGltL2Jvb3RzdHJhcC5hbGVydCcsXG4gICAgICAgICAgICAnYm9vdHN0cmFwLmJ1dHRvbic6ICdzaGltL2Jvb3RzdHJhcC5idXR0b24nLFxuICAgICAgICAgICAgJ2Jvb3RzdHJhcC5jYXJvdXNlbCc6ICdzaGltL2Jvb3RzdHJhcC5jYXJvdXNlbCcsXG4gICAgICAgICAgICAnYm9vdHN0cmFwLmNvbGxhcHNlJzogJ3NoaW0vYm9vdHN0cmFwLmNvbGxhcHNlJyxcbiAgICAgICAgICAgICdib290c3RyYXAuZHJvcGRvd24nOiAnc2hpbS9ib290c3RyYXAuZHJvcGRvd24nLFxuICAgICAgICAgICAgJ2Jvb3RzdHJhcC5tb2RhbCc6ICdzaGltL2Jvb3RzdHJhcC5tb2RhbCcsXG4gICAgICAgICAgICAnYm9vdHN0cmFwLnBvcG92ZXInOiAnc2hpbS9ib290c3RyYXAucG9wb3ZlcicsXG4gICAgICAgICAgICAnYm9vdHN0cmFwLnNjcm9sbHNweSc6ICdzaGltL2Jvb3RzdHJhcC5zY3JvbGxzcHknLFxuICAgICAgICAgICAgJ2Jvb3RzdHJhcC50YWInOiAnc2hpbS9ib290c3RyYXAudGFiJyxcbiAgICAgICAgICAgICdib290c3RyYXAudG9vbHRpcCc6ICdzaGltL2Jvb3RzdHJhcC50b29sdGlwJyxcbiAgICAgICAgICAgICdib290c3RyYXAudHJhbnNpdGlvbic6ICdzaGltL2Jvb3RzdHJhcC50cmFuc2l0aW9uJyxcbiAgICAgICAgICAgICdib290c3RyYXAudHlwZWFoZWFkJzogJ3NoaW0vYm9vdHN0cmFwLnR5cGVhaGVhZCcsXG5cbiAgICAgICAgICAgIC8vIFNwbHVuayBsZWdhY3lcbiAgICAgICAgICAgICdzcGx1bmskJzogJ3NoaW0vc3BsdW5rJyxcbiAgICAgICAgICAgICdzcGx1bmsubGVnZW5kJzogJ3NoaW0vc3BsdW5rLmxlZ2VuZCcsXG4gICAgICAgICAgICAnc3BsdW5rLmxvZ2dlcic6ICdzaGltL3NwbHVuay5sb2dnZXInLFxuICAgICAgICAgICAgJ3NwbHVuay5lcnJvcic6ICdzaGltL3NwbHVuay5lcnJvcicsXG4gICAgICAgICAgICAnc3BsdW5rLnV0aWwnOiAnc2hpbS9zcGx1bmsudXRpbCcsXG4gICAgICAgICAgICAnc3BsdW5rLnBkZic6ICdzaGltL3NwbHVuay5wZGYnLFxuICAgICAgICAgICAgJ3NwbHVuay5pMThuJzogJ3N0dWJzL2kxOG4nLCAvLyBzaGltIHNoYXJlZCB3aXRoIHJlcXVpcmVqcyBjb25maWdcbiAgICAgICAgICAgICdzcGx1bmsuY29uZmlnJzogJ3N0dWJzL3NwbHVuay5jb25maWcnLCAvLyBzaGltIHNoYXJlZCB3aXRoIHJlcXVpcmVqcyBjb25maWdcbiAgICAgICAgICAgICdzcGx1bmsucGFnaW5hdG9yJzogJ3NoaW0vc3BsdW5rLnBhZ2luYXRvcicsXG4gICAgICAgICAgICAnc3BsdW5rLm1lc3Nlbmdlcic6ICdzaGltL3NwbHVuay5tZXNzZW5nZXInLFxuICAgICAgICAgICAgJ3NwbHVuay50aW1lJzogJ3NoaW0vc3BsdW5rLnRpbWUnLFxuICAgICAgICAgICAgJ3NwbHVuay50aW1lcmFuZ2UnOiAnc2hpbS9zcGx1bmsudGltZXJhbmdlJyxcbiAgICAgICAgICAgICdzcGx1bmsud2luZG93JzogJ3NoaW0vc3BsdW5rLndpbmRvdycsXG4gICAgICAgICAgICAnc3BsdW5rLmphYnJpZGdlJzogJ3NoaW0vc3BsdW5rLmphYnJpZGdlJywgLy8gRG8gd2UgbmVlZCB0aGlzIHN0aWxsP1xuICAgICAgICAgICAgJ3NwbHVuay5wcmludCc6ICdzaGltL3NwbHVuay5wcmludCcsXG4gICAgICAgICAgICAnc3BsdW5rLnNlc3Npb24nOiAnc2hpbS9zcGx1bmsuc2Vzc2lvbicsXG4gICAgICAgICAgICAnc3BsdW5rLmpxdWVyeS5jc3JmJCc6ICdzaGltL3NwbHVuay5qcXVlcnkuY3NyZicsXG5cbiAgICAgICAgICAgICdzZWxlY3QyL3NlbGVjdDIkJzogJ3NoaW0vc2VsZWN0MicsXG5cbiAgICAgICAgICAgICdzcGx1bmtqcy9zcGx1bmskJzogJ3NoaW0vc3BsdW5ranMnXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9idWlsZF90b29scy9wcm9maWxlcy9jb21tb24vY29yZUFsaWFzZXMuY29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "util/env":
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n__webpack_require__(10);\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Use this flag to conditionally run code only for debugging, such as setting global variables\n * for access via the browser console.\n * @type {boolean}\n */\nvar DEBUG = exports.DEBUG = ('development') !== 'production';\n\n/**\n * Use this flag to conditionally run code only in production, such as disabling load timeouts.\n * @type {boolean}\n */\nvar PRODUCTION = exports.PRODUCTION = ('development') === 'production';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvZW52LmVzPzg1OTYiXSwibmFtZXMiOlsiREVCVUciLCJQUk9EVUNUSU9OIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7O0FBS08sSUFBTUEsd0JBQVEsb0JBQXlCLFlBQXZDOztBQUVQOzs7O0FBSU8sSUFBTUMsa0NBQWEsb0JBQXlCLFlBQTVDIiwiZmlsZSI6InV0aWwvZW52LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2UgdGhpcyBmbGFnIHRvIGNvbmRpdGlvbmFsbHkgcnVuIGNvZGUgb25seSBmb3IgZGVidWdnaW5nLCBzdWNoIGFzIHNldHRpbmcgZ2xvYmFsIHZhcmlhYmxlc1xuICogZm9yIGFjY2VzcyB2aWEgdGhlIGJyb3dzZXIgY29uc29sZS5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgREVCVUcgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuXG4vKipcbiAqIFVzZSB0aGlzIGZsYWcgdG8gY29uZGl0aW9uYWxseSBydW4gY29kZSBvbmx5IGluIHByb2R1Y3Rpb24sIHN1Y2ggYXMgZGlzYWJsaW5nIGxvYWQgdGltZW91dHMuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBST0RVQ1RJT04gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvdXRpbC9lbnYuZXMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 10:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(11);\n__webpack_require__(59);\n__webpack_require__(60);\n__webpack_require__(61);\n__webpack_require__(62);\n__webpack_require__(64);\n__webpack_require__(67);\n__webpack_require__(68);\n__webpack_require__(69);\n__webpack_require__(70);\n__webpack_require__(71);\n__webpack_require__(72);\n__webpack_require__(73);\n__webpack_require__(74);\n__webpack_require__(75);\n__webpack_require__(77);\n__webpack_require__(79);\n__webpack_require__(81);\n__webpack_require__(83);\n__webpack_require__(86);\n__webpack_require__(87);\n__webpack_require__(88);\n__webpack_require__(92);\n__webpack_require__(94);\n__webpack_require__(96);\n__webpack_require__(99);\n__webpack_require__(100);\n__webpack_require__(101);\n__webpack_require__(102);\n__webpack_require__(104);\n__webpack_require__(105);\n__webpack_require__(106);\n__webpack_require__(107);\n__webpack_require__(108);\n__webpack_require__(109);\n__webpack_require__(110);\n__webpack_require__(112);\n__webpack_require__(113);\n__webpack_require__(114);\n__webpack_require__(116);\n__webpack_require__(117);\n__webpack_require__(118);\n__webpack_require__(120);\n__webpack_require__(122);\n__webpack_require__(123);\n__webpack_require__(124);\n__webpack_require__(125);\n__webpack_require__(126);\n__webpack_require__(127);\n__webpack_require__(128);\n__webpack_require__(129);\n__webpack_require__(130);\n__webpack_require__(131);\n__webpack_require__(132);\n__webpack_require__(133);\n__webpack_require__(134);\n__webpack_require__(139);\n__webpack_require__(140);\n__webpack_require__(144);\n__webpack_require__(145);\n__webpack_require__(146);\n__webpack_require__(147);\n__webpack_require__(149);\n__webpack_require__(150);\n__webpack_require__(151);\n__webpack_require__(152);\n__webpack_require__(153);\n__webpack_require__(154);\n__webpack_require__(155);\n__webpack_require__(156);\n__webpack_require__(157);\n__webpack_require__(158);\n__webpack_require__(159);\n__webpack_require__(160);\n__webpack_require__(161);\n__webpack_require__(162);\n__webpack_require__(163);\n__webpack_require__(165);\n__webpack_require__(166);\n__webpack_require__(168);\n__webpack_require__(169);\n__webpack_require__(175);\n__webpack_require__(176);\n__webpack_require__(178);\n__webpack_require__(179);\n__webpack_require__(180);\n__webpack_require__(184);\n__webpack_require__(185);\n__webpack_require__(186);\n__webpack_require__(187);\n__webpack_require__(188);\n__webpack_require__(190);\n__webpack_require__(191);\n__webpack_require__(192);\n__webpack_require__(193);\n__webpack_require__(196);\n__webpack_require__(198);\n__webpack_require__(199);\n__webpack_require__(200);\n__webpack_require__(202);\n__webpack_require__(204);\n__webpack_require__(206);\n__webpack_require__(207);\n__webpack_require__(208);\n__webpack_require__(210);\n__webpack_require__(211);\n__webpack_require__(212);\n__webpack_require__(213);\n__webpack_require__(223);\n__webpack_require__(227);\n__webpack_require__(228);\n__webpack_require__(230);\n__webpack_require__(231);\n__webpack_require__(235);\n__webpack_require__(236);\n__webpack_require__(238);\n__webpack_require__(239);\n__webpack_require__(240);\n__webpack_require__(241);\n__webpack_require__(242);\n__webpack_require__(243);\n__webpack_require__(244);\n__webpack_require__(245);\n__webpack_require__(246);\n__webpack_require__(247);\n__webpack_require__(248);\n__webpack_require__(249);\n__webpack_require__(250);\n__webpack_require__(251);\n__webpack_require__(252);\n__webpack_require__(253);\n__webpack_require__(254);\n__webpack_require__(255);\n__webpack_require__(256);\n__webpack_require__(258);\n__webpack_require__(259);\n__webpack_require__(260);\nmodule.exports = __webpack_require__(17);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvZXM2L2luZGV4LmpzP2JkMjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2VzNi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 11:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// ECMAScript 6 symbols shim\nvar global = __webpack_require__(12);\nvar has = __webpack_require__(13);\nvar DESCRIPTORS = __webpack_require__(14);\nvar $export = __webpack_require__(16);\nvar redefine = __webpack_require__(26);\nvar META = __webpack_require__(30).KEY;\nvar $fails = __webpack_require__(15);\nvar shared = __webpack_require__(31);\nvar setToStringTag = __webpack_require__(32);\nvar uid = __webpack_require__(27);\nvar wks = __webpack_require__(33);\nvar wksExt = __webpack_require__(34);\nvar wksDefine = __webpack_require__(35);\nvar enumKeys = __webpack_require__(37);\nvar isArray = __webpack_require__(52);\nvar anObject = __webpack_require__(20);\nvar toIObject = __webpack_require__(40);\nvar toPrimitive = __webpack_require__(24);\nvar createDesc = __webpack_require__(25);\nvar _create = __webpack_require__(53);\nvar gOPNExt = __webpack_require__(56);\nvar $GOPD = __webpack_require__(58);\nvar $DP = __webpack_require__(19);\nvar $keys = __webpack_require__(38);\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function';\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  __webpack_require__(57).f = gOPNExt.f = $getOwnPropertyNames;\n  __webpack_require__(51).f = $propertyIsEnumerable;\n  __webpack_require__(50).f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !__webpack_require__(36)) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    replacer = args[1];\n    if (typeof replacer == 'function') $replacer = replacer;\n    if ($replacer || !isArray(replacer)) replacer = function (key, value) {\n      if ($replacer) value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(18)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzP2E2NTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCLHVCQUF1QixXQUFXLElBQUk7QUFDNUQsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pELEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQ0FBZ0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxrQkFBa0I7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7O0FBRTNDLG9EQUFvRCw2QkFBNkI7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLDBCQUEwQixnQkFBZ0I7QUFDMUMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU8sUUFBUSxpQ0FBaUM7QUFDcEcsQ0FBQztBQUNEO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgaWYgKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSAkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZiAoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCRyZXBsYWNlcikgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 12:
/***/ (function(module, exports) {

	eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzP2Q0MjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 13:
/***/ (function(module, exports) {

	eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzPzc0MTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 14:
/***/ (function(module, exports, __webpack_require__) {

	eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(15)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanM/ODJiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsbUJBQW1CLFVBQVUsRUFBRSxFQUFFO0FBQzFFLENBQUMiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 15:
/***/ (function(module, exports) {

	eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanM/MmYzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 16:
/***/ (function(module, exports, __webpack_require__) {

	eval("var global = __webpack_require__(12);\nvar core = __webpack_require__(17);\nvar hide = __webpack_require__(18);\nvar redefine = __webpack_require__(26);\nvar ctx = __webpack_require__(28);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzPzM4NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRix1QkFBdUI7QUFDekcsaUVBQWlFO0FBQ2pFLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 17:
/***/ (function(module, exports) {

	eval("var core = module.exports = { version: '2.5.1' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcz9hMDMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZCQUE2QjtBQUM3Qix1Q0FBdUMiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 18:
/***/ (function(module, exports, __webpack_require__) {

	eval("var dP = __webpack_require__(19);\nvar createDesc = __webpack_require__(25);\nmodule.exports = __webpack_require__(14) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcz83MTcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 19:
/***/ (function(module, exports, __webpack_require__) {

	eval("var anObject = __webpack_require__(20);\nvar IE8_DOM_DEFINE = __webpack_require__(22);\nvar toPrimitive = __webpack_require__(24);\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(14) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzP2M0MjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 20:
/***/ (function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(21);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzP2EwYjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 21:
/***/ (function(module, exports) {

	eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzPzZlZjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 22:
/***/ (function(module, exports, __webpack_require__) {

	eval("module.exports = !__webpack_require__(14) && !__webpack_require__(15)(function () {\n  return Object.defineProperty(__webpack_require__(23)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanM/ZGU2MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHFFQUFzRSxtQkFBbUIsVUFBVSxFQUFFLEVBQUU7QUFDdkcsQ0FBQyIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 23:
/***/ (function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(21);\nvar document = __webpack_require__(12).document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcz9iMDNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 24:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(21);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzP2Q2MmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 25:
/***/ (function(module, exports) {

	eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcz83NjZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 26:
/***/ (function(module, exports, __webpack_require__) {

	eval("var global = __webpack_require__(12);\nvar hide = __webpack_require__(18);\nvar has = __webpack_require__(13);\nvar SRC = __webpack_require__(27)('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\n__webpack_require__(17).inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanM/MjEzZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 27:
/***/ (function(module, exports) {

	eval("var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzPzM3ODciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 28:
/***/ (function(module, exports, __webpack_require__) {

	eval("// optional / simple context binding\nvar aFunction = __webpack_require__(29);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzPzIzNzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 29:
/***/ (function(module, exports) {

	eval("module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcz81YzE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 30:
/***/ (function(module, exports, __webpack_require__) {

	eval("var META = __webpack_require__(27)('meta');\nvar isObject = __webpack_require__(21);\nvar has = __webpack_require__(13);\nvar setDesc = __webpack_require__(19).f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !__webpack_require__(15)(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcz9kM2NjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxDQUFDO0FBQ0Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxTQUFTO0FBQ1QsR0FBRyxFQUFFO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 31:
/***/ (function(module, exports, __webpack_require__) {

	eval("var global = __webpack_require__(12);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function (key) {\n  return store[key] || (store[key] = {});\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzP2FiOGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHVDQUF1QztBQUN2QyIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 32:
/***/ (function(module, exports, __webpack_require__) {

	eval("var def = __webpack_require__(19).f;\nvar has = __webpack_require__(13);\nvar TAG = __webpack_require__(33)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanM/YzAyZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsaUNBQWlDO0FBQ3JHIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 33:
/***/ (function(module, exports, __webpack_require__) {

	eval("var store = __webpack_require__(31)('wks');\nvar uid = __webpack_require__(27);\nvar Symbol = __webpack_require__(12).Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzPzJlOWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL193a3MuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

	eval("exports.f = __webpack_require__(33);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcz85ZjViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjM0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 35:
/***/ (function(module, exports, __webpack_require__) {

	eval("var global = __webpack_require__(12);\nvar core = __webpack_require__(17);\nvar LIBRARY = __webpack_require__(36);\nvar wksExt = __webpack_require__(34);\nvar defineProperty = __webpack_require__(19).f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcz84ODM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxzQkFBc0I7QUFDaEYsa0ZBQWtGLHdCQUF3QjtBQUMxRyIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 36:
/***/ (function(module, exports) {

	eval("module.exports = false;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcz8xYjljIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 37:
/***/ (function(module, exports, __webpack_require__) {

	eval("// all enumerable object keys, includes symbols\nvar getKeys = __webpack_require__(38);\nvar gOPS = __webpack_require__(50);\nvar pIE = __webpack_require__(51);\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzPzgzMGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 38:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(39);\nvar enumBugKeys = __webpack_require__(49);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanM/MjAyOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 39:
/***/ (function(module, exports, __webpack_require__) {

	eval("var has = __webpack_require__(13);\nvar toIObject = __webpack_require__(40);\nvar arrayIndexOf = __webpack_require__(44)(false);\nvar IE_PROTO = __webpack_require__(48)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanM/MTFiOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 40:
/***/ (function(module, exports, __webpack_require__) {

	eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(41);\nvar defined = __webpack_require__(43);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcz83MmZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 41:
/***/ (function(module, exports, __webpack_require__) {

	eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(42);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcz85NTIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 42:
/***/ (function(module, exports) {

	eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzPzExYmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EiLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 43:
/***/ (function(module, exports) {

	eval("// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcz80MjllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 44:
/***/ (function(module, exports, __webpack_require__) {

	eval("// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(40);\nvar toLength = __webpack_require__(45);\nvar toAbsoluteIndex = __webpack_require__(47);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanM/NzllZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVksZUFBZTtBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBIiwiZmlsZSI6IjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 45:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(46);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzP2YwODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QiLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 46:
/***/ (function(module, exports) {

	eval("// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcz8yYTUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 47:
/***/ (function(module, exports, __webpack_require__) {

	eval("var toInteger = __webpack_require__(46);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanM/YjAwYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 48:
/***/ (function(module, exports, __webpack_require__) {

	eval("var shared = __webpack_require__(31)('keys');\nvar uid = __webpack_require__(27);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcz8xOTVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 49:
/***/ (function(module, exports) {

	eval("// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcz8xNDgyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 50:
/***/ (function(module, exports) {

	eval("exports.f = Object.getOwnPropertySymbols;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanM/MzJjMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 51:
/***/ (function(module, exports) {

	eval("exports.f = {}.propertyIsEnumerable;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcz83OWNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGNBQWMiLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 52:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(42);\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanM/NmMwMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 53:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(20);\nvar dPs = __webpack_require__(54);\nvar enumBugKeys = __webpack_require__(49);\nvar IE_PROTO = __webpack_require__(48)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(23)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(55).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcz84Yjg3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwiZmlsZSI6IjUzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 54:
/***/ (function(module, exports, __webpack_require__) {

	eval("var dP = __webpack_require__(19);\nvar anObject = __webpack_require__(20);\nvar getKeys = __webpack_require__(38);\n\nmodule.exports = __webpack_require__(14) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcz9jYmFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 55:
/***/ (function(module, exports, __webpack_require__) {

	eval("var document = __webpack_require__(12).document;\nmodule.exports = document && document.documentElement;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcz8xZmQ2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EiLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 56:
/***/ (function(module, exports, __webpack_require__) {

	eval("// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = __webpack_require__(40);\nvar gOPN = __webpack_require__(57).f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzP2NjMjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjU2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 57:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __webpack_require__(39);\nvar hiddenKeys = __webpack_require__(49).concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanM/OTU3NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjU3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 58:
/***/ (function(module, exports, __webpack_require__) {

	eval("var pIE = __webpack_require__(51);\nvar createDesc = __webpack_require__(25);\nvar toIObject = __webpack_require__(40);\nvar toPrimitive = __webpack_require__(24);\nvar has = __webpack_require__(13);\nvar IE8_DOM_DEFINE = __webpack_require__(22);\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(14) ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanM/OWE3ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZO0FBQ2Y7QUFDQSIsImZpbGUiOiI1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 59:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: __webpack_require__(53) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcz9iMzE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQXNDIiwiZmlsZSI6IjU5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 60:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !__webpack_require__(14), 'Object', { defineProperty: __webpack_require__(19).f });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcz8wN2I3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxxRUFBdUUsNENBQTRDIiwiZmlsZSI6IjYwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 61:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\n// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)\n$export($export.S + $export.F * !__webpack_require__(14), 'Object', { defineProperties: __webpack_require__(54) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzPzU3NDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLHFFQUF1RSw0Q0FBNkMiLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 62:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject = __webpack_require__(40);\nvar $getOwnPropertyDescriptor = __webpack_require__(58).f;\n\n__webpack_require__(63)('getOwnPropertyDescriptor', function () {\n  return function getOwnPropertyDescriptor(it, key) {\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcz9mYWI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 63:
/***/ (function(module, exports, __webpack_require__) {

	eval("// most Object methods by ES6 should accept primitives\nvar $export = __webpack_require__(16);\nvar core = __webpack_require__(17);\nvar fails = __webpack_require__(15);\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcz9lODFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFEQUFxRCxPQUFPLEVBQUU7QUFDOUQiLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 64:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject = __webpack_require__(65);\nvar $getPrototypeOf = __webpack_require__(66);\n\n__webpack_require__(63)('getPrototypeOf', function () {\n  return function getPrototypeOf(it) {\n    return $getPrototypeOf(toObject(it));\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanM/OWI4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 65:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(43);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzPzBjNzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 66:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(13);\nvar toObject = __webpack_require__(65);\nvar IE_PROTO = __webpack_require__(48)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcz8xZDU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiI2Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 67:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.14 Object.keys(O)\nvar toObject = __webpack_require__(65);\nvar $keys = __webpack_require__(38);\n\n__webpack_require__(63)('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanM/Njk1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjY3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 68:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.7 Object.getOwnPropertyNames(O)\n__webpack_require__(63)('getOwnPropertyNames', function () {\n  return __webpack_require__(56).f;\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanM/OThjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 69:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.5 Object.freeze(O)\nvar isObject = __webpack_require__(21);\nvar meta = __webpack_require__(30).onFreeze;\n\n__webpack_require__(63)('freeze', function ($freeze) {\n  return function freeze(it) {\n    return $freeze && isObject(it) ? $freeze(meta(it)) : it;\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcz80NjhlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uICgkZnJlZXplKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpIHtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 70:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.17 Object.seal(O)\nvar isObject = __webpack_require__(21);\nvar meta = __webpack_require__(30).onFreeze;\n\n__webpack_require__(63)('seal', function ($seal) {\n  return function seal(it) {\n    return $seal && isObject(it) ? $seal(meta(it)) : it;\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanM/MDViNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbiAoJHNlYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpIHtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 71:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.15 Object.preventExtensions(O)\nvar isObject = __webpack_require__(21);\nvar meta = __webpack_require__(30).onFreeze;\n\n__webpack_require__(63)('preventExtensions', function ($preventExtensions) {\n  return function preventExtensions(it) {\n    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcz9iN2U2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24gKCRwcmV2ZW50RXh0ZW5zaW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpIHtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 72:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.12 Object.isFrozen(O)\nvar isObject = __webpack_require__(21);\n\n__webpack_require__(63)('isFrozen', function ($isFrozen) {\n  return function isFrozen(it) {\n    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcz9kYWFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbiAoJGlzRnJvemVuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 73:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.13 Object.isSealed(O)\nvar isObject = __webpack_require__(21);\n\n__webpack_require__(63)('isSealed', function ($isSealed) {\n  return function isSealed(it) {\n    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcz82ZjU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjczLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbiAoJGlzU2VhbGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 74:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.2.11 Object.isExtensible(O)\nvar isObject = __webpack_require__(21);\n\n__webpack_require__(63)('isExtensible', function ($isExtensible) {\n  return function isExtensible(it) {\n    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanM/ZWQ4MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbiAoJGlzRXh0ZW5zaWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 75:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.3.1 Object.assign(target, source)\nvar $export = __webpack_require__(16);\n\n$export($export.S + $export.F, 'Object', { assign: __webpack_require__(76) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcz9iMWJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsMENBQTBDLGtDQUFzQyIsImZpbGUiOiI3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 76:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = __webpack_require__(38);\nvar gOPS = __webpack_require__(50);\nvar pIE = __webpack_require__(51);\nvar toObject = __webpack_require__(65);\nvar IObject = __webpack_require__(41);\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || __webpack_require__(15)(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcz81MjMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVLEVBQUU7QUFDaEQsbUJBQW1CLHNDQUFzQztBQUN6RCxDQUFDLHFDQUFxQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsImZpbGUiOiI3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 77:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.3.10 Object.is(value1, value2)\nvar $export = __webpack_require__(16);\n$export($export.S, 'Object', { is: __webpack_require__(78) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzP2FmNzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBK0IiLCJmaWxlIjoiNzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 78:
/***/ (function(module, exports) {

	eval("// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y) {\n  // eslint-disable-next-line no-self-compare\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcz80N2RhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 79:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = __webpack_require__(16);\n$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(80).set });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanM/YzU1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QyIsImZpbGUiOiI3OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 80:
/***/ (function(module, exports, __webpack_require__) {

	eval("// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = __webpack_require__(21);\nvar anObject = __webpack_require__(20);\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = __webpack_require__(28)(Function.call, __webpack_require__(58).f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzPzI3OGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFlBQVksY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBIiwiZmlsZSI6IjgwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 81:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 19.1.3.6 Object.prototype.toString()\nvar classof = __webpack_require__(82);\nvar test = {};\ntest[__webpack_require__(33)('toStringTag')] = 'z';\nif (test + '' != '[object z]') {\n  __webpack_require__(26)(Object.prototype, 'toString', function toString() {\n    return '[object ' + classof(this) + ']';\n  }, true);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcz80MTU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYgKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 82:
/***/ (function(module, exports, __webpack_require__) {

	eval("// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(42);\nvar TAG = __webpack_require__(33)('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcz82NGNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQixFQUFFOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjgyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 83:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)\nvar $export = __webpack_require__(16);\n\n$export($export.P, 'Function', { bind: __webpack_require__(84) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcz85MWNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsZ0NBQWdDLGdDQUEyQiIsImZpbGUiOiI4My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7IGJpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 84:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar aFunction = __webpack_require__(29);\nvar isObject = __webpack_require__(21);\nvar invoke = __webpack_require__(85);\nvar arraySlice = [].slice;\nvar factories = {};\n\nvar construct = function (F, len, args) {\n  if (!(len in factories)) {\n    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';\n    // eslint-disable-next-line no-new-func\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /* , ...args */) {\n  var fn = aFunction(this);\n  var partArgs = arraySlice.call(arguments, 1);\n  var bound = function (/* args... */) {\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if (isObject(fn.prototype)) bound.prototype = fn.prototype;\n  return bound;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcz9kMzlhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSBuW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uICgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 85:
/***/ (function(module, exports) {

	eval("// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzPzJiNDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiI4NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 86:
/***/ (function(module, exports, __webpack_require__) {

	eval("var dP = __webpack_require__(19).f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || __webpack_require__(14) && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcz85ZDcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ijg2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 87:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar isObject = __webpack_require__(21);\nvar getPrototypeOf = __webpack_require__(66);\nvar HAS_INSTANCE = __webpack_require__(33)('hasInstance');\nvar FunctionProto = Function.prototype;\n// 19.2.3.6 Function.prototype[@@hasInstance](V)\nif (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(19).f(FunctionProto, HAS_INSTANCE, { value: function (O) {\n  if (typeof this != 'function' || !isObject(O)) return false;\n  if (!isObject(this.prototype)) return O instanceof this;\n  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:\n  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;\n  return false;\n} });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzPzQ4ZTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUiLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBIQVNfSU5TVEFOQ0UgPSByZXF1aXJlKCcuL193a3MnKSgnaGFzSW5zdGFuY2UnKTtcbnZhciBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZiAoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7IHZhbHVlOiBmdW5jdGlvbiAoTykge1xuICBpZiAodHlwZW9mIHRoaXMgIT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpIHJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcbiAgd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSkgaWYgKHRoaXMucHJvdG90eXBlID09PSBPKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 88:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\nvar $parseInt = __webpack_require__(89);\n// 18.2.5 parseInt(string, radix)\n$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtaW50LmpzP2E0ZWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHNCQUFzQiIsImZpbGUiOiI4OC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHsgcGFyc2VJbnQ6ICRwYXJzZUludCB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 89:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $parseInt = __webpack_require__(12).parseInt;\nvar $trim = __webpack_require__(90).trim;\nvar ws = __webpack_require__(91);\nvar hex = /^[-+]?0[xX]/;\n\nmodule.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {\n  var string = $trim(String(str), 3);\n  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));\n} : $parseInt;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzPzE4ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludDtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcbnZhciB3cyA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpO1xudmFyIGhleCA9IC9eWy0rXT8wW3hYXS87XG5cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 90:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\nvar defined = __webpack_require__(43);\nvar fails = __webpack_require__(15);\nvar spaces = __webpack_require__(91);\nvar space = '[' + spaces + ']';\nvar non = '\\u200b\\u0085';\nvar ltrim = RegExp('^' + space + space + '*');\nvar rtrim = RegExp(space + space + '*$');\n\nvar exporter = function (KEY, exec, ALIAS) {\n  var exp = {};\n  var FORCE = fails(function () {\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if (ALIAS) exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function (string, TYPE) {\n  string = String(defined(string));\n  if (TYPE & 1) string = string.replace(ltrim, '');\n  if (TYPE & 2) string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanM/ZjNiMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI5MC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc3BhY2VzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgc3BhY2UgPSAnWycgKyBzcGFjZXMgKyAnXSc7XG52YXIgbm9uID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEFMSUFTKSB7XG4gIHZhciBleHAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZiAoQUxJQVMpIGV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 91:
/***/ (function(module, exports) {

	eval("module.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzPzIzYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSIsImZpbGUiOiI5MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 92:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\nvar $parseFloat = __webpack_require__(93);\n// 18.2.4 parseFloat(string)\n$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanM/NjI2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMEJBQTBCIiwiZmlsZSI6IjkyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 93:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $parseFloat = __webpack_require__(12).parseFloat;\nvar $trim = __webpack_require__(90).trim;\n\nmodule.exports = 1 / $parseFloat(__webpack_require__(91) + '-0') !== -Infinity ? function parseFloat(str) {\n  var string = $trim(String(str), 3);\n  var result = $parseFloat(string);\n  return result === 0 && string.charAt(0) == '-' ? -0 : result;\n} : $parseFloat;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanM/NTJmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI5My5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHZhciByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 94:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar global = __webpack_require__(12);\nvar has = __webpack_require__(13);\nvar cof = __webpack_require__(42);\nvar inheritIfRequired = __webpack_require__(95);\nvar toPrimitive = __webpack_require__(24);\nvar fails = __webpack_require__(15);\nvar gOPN = __webpack_require__(57).f;\nvar gOPD = __webpack_require__(58).f;\nvar dP = __webpack_require__(19).f;\nvar $trim = __webpack_require__(90).trim;\nvar NUMBER = 'Number';\nvar $Number = global[NUMBER];\nvar Base = $Number;\nvar proto = $Number.prototype;\n// Opera ~12 has broken Object#toString\nvar BROKEN_COF = cof(__webpack_require__(53)(proto)) == NUMBER;\nvar TRIM = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, false);\n  if (typeof it == 'string' && it.length > 2) {\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0);\n    var third, radix, maxCode;\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default: return +it;\n      }\n      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {\n  $Number = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);\n  };\n  for (var keys = __webpack_require__(14) ? gOPN(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(Base, key = keys[j]) && !has($Number, key)) {\n      dP($Number, key, gOPD(Base, key));\n    }\n  }\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  __webpack_require__(26)(global, NUMBER, $Number);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzPzM5YjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0MsY0FBYyxPQUFPO0FBQ3pELHFDQUFxQyxjQUFjLE9BQU87QUFDMUQ7QUFDQTtBQUNBLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwQkFBMEIsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijk0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgJE51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIEJhc2UgPSAkTnVtYmVyO1xudmFyIHByb3RvID0gJE51bWJlci5wcm90b3R5cGU7XG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ09GID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUjtcbnZhciBUUklNID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgY2FzZSA2NjogY2FzZSA5ODogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5OiBjYXNlIDExMTogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYgKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSkge1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWU7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uICgpIHsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHtcbiAgICBpZiAoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSkge1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 95:
/***/ (function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(21);\nvar setPrototypeOf = __webpack_require__(80).set;\nmodule.exports = function (that, target, C) {\n  var S = target.constructor;\n  var P;\n  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\n    setPrototypeOf(that, P);\n  } return that;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcz83NTllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ijk1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 96:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar toInteger = __webpack_require__(46);\nvar aNumberValue = __webpack_require__(97);\nvar repeat = __webpack_require__(98);\nvar $toFixed = 1.0.toFixed;\nvar floor = Math.floor;\nvar data = [0, 0, 0, 0, 0, 0];\nvar ERROR = 'Number.toFixed: incorrect invocation!';\nvar ZERO = '0';\n\nvar multiply = function (n, c) {\n  var i = -1;\n  var c2 = c;\n  while (++i < 6) {\n    c2 += n * data[i];\n    data[i] = c2 % 1e7;\n    c2 = floor(c2 / 1e7);\n  }\n};\nvar divide = function (n) {\n  var i = 6;\n  var c = 0;\n  while (--i >= 0) {\n    c += data[i];\n    data[i] = floor(c / n);\n    c = (c % n) * 1e7;\n  }\n};\nvar numToString = function () {\n  var i = 6;\n  var s = '';\n  while (--i >= 0) {\n    if (s !== '' || i === 0 || data[i] !== 0) {\n      var t = String(data[i]);\n      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;\n    }\n  } return s;\n};\nvar pow = function (x, n, acc) {\n  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);\n};\nvar log = function (x) {\n  var n = 0;\n  var x2 = x;\n  while (x2 >= 4096) {\n    n += 12;\n    x2 /= 4096;\n  }\n  while (x2 >= 2) {\n    n += 1;\n    x2 /= 2;\n  } return n;\n};\n\n$export($export.P + $export.F * (!!$toFixed && (\n  0.00008.toFixed(3) !== '0.000' ||\n  0.9.toFixed(0) !== '1' ||\n  1.255.toFixed(2) !== '1.25' ||\n  1000000000000000128.0.toFixed(0) !== '1000000000000000128'\n) || !__webpack_require__(15)(function () {\n  // V8 ~ Android 4.3-\n  $toFixed.call({});\n})), 'Number', {\n  toFixed: function toFixed(fractionDigits) {\n    var x = aNumberValue(this, ERROR);\n    var f = toInteger(fractionDigits);\n    var s = '';\n    var m = ZERO;\n    var e, z, j, k;\n    if (f < 0 || f > 20) throw RangeError(ERROR);\n    // eslint-disable-next-line no-self-compare\n    if (x != x) return 'NaN';\n    if (x <= -1e21 || x >= 1e21) return String(x);\n    if (x < 0) {\n      s = '-';\n      x = -x;\n    }\n    if (x > 1e-21) {\n      e = log(x * pow(2, 69, 1)) - 69;\n      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);\n      z *= 0x10000000000000;\n      e = 52 - e;\n      if (e > 0) {\n        multiply(0, z);\n        j = f;\n        while (j >= 7) {\n          multiply(1e7, 0);\n          j -= 7;\n        }\n        multiply(pow(10, j, 1), 0);\n        j = e - 1;\n        while (j >= 23) {\n          divide(1 << 23);\n          j -= 23;\n        }\n        divide(1 << j);\n        multiply(1, 1);\n        divide(2);\n        m = numToString();\n      } else {\n        multiply(0, z);\n        multiply(1 << -e, 0);\n        m = numToString() + repeat.call(ZERO, f);\n      }\n    }\n    if (f > 0) {\n      k = m.length;\n      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));\n    } else {\n      m = s + m;\n    } return m;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzPzc3ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMiLCJmaWxlIjoiOTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciAkdG9GaXhlZCA9IDEuMC50b0ZpeGVkO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBkYXRhID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xudmFyIEVSUk9SID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnO1xudmFyIFpFUk8gPSAnMCc7XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciBjMiA9IGM7XG4gIHdoaWxlICgrK2kgPCA2KSB7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIGMgPSAwO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBjICs9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcbiAgICBjID0gKGMgJSBuKSAqIDFlNztcbiAgfVxufTtcbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgcyA9ICcnO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKSB7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbiAoeCwgbiwgYWNjKSB7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG52YXIgbG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG4gPSAwO1xuICB2YXIgeDIgPSB4O1xuICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSAoeDIgPj0gMikge1xuICAgIG4gKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gIDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAxMDAwMDAwMDAwMDAwMDAwMTI4LjAudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICB2YXIgeCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCBFUlJPUik7XG4gICAgdmFyIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIG0gPSBaRVJPO1xuICAgIHZhciBlLCB6LCBqLCBrO1xuICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHRocm93IFJhbmdlRXJyb3IoRVJST1IpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoeCAhPSB4KSByZXR1cm4gJ05hTic7XG4gICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSByZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG4gICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoWkVSTywgZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmID4gMCkge1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH0gcmV0dXJuIG07XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 97:
/***/ (function(module, exports, __webpack_require__) {

	eval("var cof = __webpack_require__(42);\nmodule.exports = function (it, msg) {\n  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);\n  return +it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanM/N2U5NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijk3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIG1zZykge1xuICBpZiAodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 98:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar toInteger = __webpack_require__(46);\nvar defined = __webpack_require__(43);\n\nmodule.exports = function repeat(count) {\n  var str = String(defined(this));\n  var res = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError(\"Count can't be negative\");\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;\n  return res;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcz82YzU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNO0FBQ2Q7QUFDQSIsImZpbGUiOiI5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKTtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbiA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 99:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $fails = __webpack_require__(15);\nvar aNumberValue = __webpack_require__(97);\nvar $toPrecision = 1.0.toPrecision;\n\n$export($export.P + $export.F * ($fails(function () {\n  // IE7-\n  return $toPrecision.call(1, undefined) !== '1';\n}) || !$fails(function () {\n  // V8 ~ Android 4.3-\n  $toPrecision.call({});\n})), 'Number', {\n  toPrecision: function toPrecision(precision) {\n    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');\n    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qcz85MDg1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCO0FBQ3RCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcbnZhciAkdG9QcmVjaXNpb24gPSAxLjAudG9QcmVjaXNpb247XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 100:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.1.2.1 Number.EPSILON\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanM/NmVkMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLDhCQUE4Qiw0QkFBNEIiLCJmaWxlIjoiMTAwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 101:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.1.2.2 Number.isFinite(number)\nvar $export = __webpack_require__(16);\nvar _isFinite = __webpack_require__(12).isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it) {\n    return typeof it == 'number' && _isFinite(it);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcz80NzFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTAxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 102:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.1.2.3 Number.isInteger(number)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Number', { isInteger: __webpack_require__(103) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanM/ZGY3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLDhCQUE4QixzQ0FBc0MiLCJmaWxlIjoiMTAyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgaXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 103:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.1.2.3 Number.isInteger(number)\nvar isObject = __webpack_require__(21);\nvar floor = Math.floor;\nmodule.exports = function isInteger(it) {\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcz81YzQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 104:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.1.2.4 Number.isNaN(number)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare\n    return number != number;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcz80MTgzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTA0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 105:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.1.2.5 Number.isSafeInteger(number)\nvar $export = __webpack_require__(16);\nvar isInteger = __webpack_require__(103);\nvar abs = Math.abs;\n\n$export($export.S, 'Number', {\n  isSafeInteger: function isSafeInteger(number) {\n    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qcz9lN2JmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 106:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanM/NmI1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLDhCQUE4QixxQ0FBcUMiLCJmaWxlIjoiMTA2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 107:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.1.2.10 Number.MIN_SAFE_INTEGER\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanM/NzgxMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLDhCQUE4QixzQ0FBc0MiLCJmaWxlIjoiMTA3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmYgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 108:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\nvar $parseFloat = __webpack_require__(93);\n// 20.1.2.12 Number.parseFloat(string)\n$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzPzY0YzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDBCQUEwQiIsImZpbGUiOiIxMDguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7IHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 109:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\nvar $parseInt = __webpack_require__(89);\n// 20.1.2.13 Number.parseInt(string, radix)\n$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcz8wZTBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxzQkFBc0IiLCJmaWxlIjoiMTA5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywgeyBwYXJzZUludDogJHBhcnNlSW50IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 110:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.3 Math.acosh(x)\nvar $export = __webpack_require__(16);\nvar log1p = __webpack_require__(111);\nvar sqrt = Math.sqrt;\nvar $acosh = Math.acosh;\n\n$export($export.S + $export.F * !($acosh\n  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n  && Math.floor($acosh(Number.MAX_VALUE)) == 710\n  // Tor Browser bug: Math.acosh(Infinity) -> NaN\n  && $acosh(Infinity) == Infinity\n), 'Math', {\n  acosh: function acosh(x) {\n    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n      ? Math.log(x) + Math.LN2\n      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcz83Mzk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBsb2cxcCA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKTtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyICRhY29zaCA9IE1hdGguYWNvc2g7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2hcbiAgLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuICAmJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 111:
/***/ (function(module, exports) {

	eval("// 20.2.2.20 Math.log1p(x)\nmodule.exports = Math.log1p || function log1p(x) {\n  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcz9hZGMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjExMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCkge1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 112:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.5 Math.asinh(x)\nvar $export = __webpack_require__(16);\nvar $asinh = Math.asinh;\n\nfunction asinh(x) {\n  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n}\n\n// Tor Browser bug: Math.asinh(0) -> -0\n$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcz84NmZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsZUFBZSIsImZpbGUiOiIxMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHsgYXNpbmg6IGFzaW5oIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 113:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.7 Math.atanh(x)\nvar $export = __webpack_require__(16);\nvar $atanh = Math.atanh;\n\n// Tor Browser bug: Math.atanh(-0) -> 0\n$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {\n  atanh: function atanh(x) {\n    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcz8xODNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdGFuaCA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 114:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.9 Math.cbrt(x)\nvar $export = __webpack_require__(16);\nvar sign = __webpack_require__(115);\n\n$export($export.S, 'Math', {\n  cbrt: function cbrt(x) {\n    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzPzQ5YjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCkge1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 115:
/***/ (function(module, exports) {

	eval("// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzPzQyNGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 116:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.11 Math.clz32(x)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Math', {\n  clz32: function clz32(x) {\n    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcz8yM2EzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjExNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 117:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.12 Math.cosh(x)\nvar $export = __webpack_require__(16);\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  cosh: function cosh(x) {\n    return (exp(x = +x) + exp(-x)) / 2;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzPzMwOTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCkge1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 118:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.14 Math.expm1(x)\nvar $export = __webpack_require__(16);\nvar $expm1 = __webpack_require__(119);\n\n$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcz83Y2NhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUUsZ0JBQWdCIiwiZmlsZSI6IjExOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoJGV4cG0xICE9IE1hdGguZXhwbTEpLCAnTWF0aCcsIHsgZXhwbTE6ICRleHBtMSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 119:
/***/ (function(module, exports) {

	eval("// 20.2.2.14 Math.expm1(x)\nvar $expm1 = Math.expm1;\nmodule.exports = (!$expm1\n  // Old FF bug\n  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168\n  // Tor Browser bug\n  || $expm1(-2e-17) != -2e-17\n) ? function expm1(x) {\n  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n} : $expm1;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcz82NzM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwbTEgPSBNYXRoLmV4cG0xO1xubW9kdWxlLmV4cG9ydHMgPSAoISRleHBtMVxuICAvLyBPbGQgRkYgYnVnXG4gIHx8ICRleHBtMSgxMCkgPiAyMjAyNS40NjU3OTQ4MDY3MTkgfHwgJGV4cG0xKDEwKSA8IDIyMDI1LjQ2NTc5NDgwNjcxNjUxNjhcbiAgLy8gVG9yIEJyb3dzZXIgYnVnXG4gIHx8ICRleHBtMSgtMmUtMTcpICE9IC0yZS0xN1xuKSA/IGZ1bmN0aW9uIGV4cG0xKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn0gOiAkZXhwbTE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 120:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.16 Math.fround(x)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Math', { fround: __webpack_require__(121) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanM/YjdjNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLDRCQUE0QixtQ0FBb0MiLCJmaWxlIjoiMTIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGZyb3VuZDogcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 121:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.16 Math.fround(x)\nvar sign = __webpack_require__(115);\nvar pow = Math.pow;\nvar EPSILON = pow(2, -52);\nvar EPSILON32 = pow(2, -23);\nvar MAX32 = pow(2, 127) * (2 - EPSILON32);\nvar MIN32 = pow(2, -126);\n\nvar roundTiesToEven = function (n) {\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\nmodule.exports = Math.fround || function fround(x) {\n  var $abs = Math.abs(x);\n  var $sign = sign(x);\n  var a, result;\n  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n  a = (1 + EPSILON32 / EPSILON) * $abs;\n  result = a - (a - $abs);\n  // eslint-disable-next-line no-self-compare\n  if (result > MAX32 || result != result) return $sign * Infinity;\n  return $sign * result;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanM/YmZkMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgRVBTSUxPTiA9IHBvdygyLCAtNTIpO1xudmFyIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpO1xudmFyIE1BWDMyID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMik7XG52YXIgTUlOMzIgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZnJvdW5kIHx8IGZ1bmN0aW9uIGZyb3VuZCh4KSB7XG4gIHZhciAkYWJzID0gTWF0aC5hYnMoeCk7XG4gIHZhciAkc2lnbiA9IHNpZ24oeCk7XG4gIHZhciBhLCByZXN1bHQ7XG4gIGlmICgkYWJzIDwgTUlOMzIpIHJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpIHJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 122:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])\nvar $export = __webpack_require__(16);\nvar abs = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcz85ZmRlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 123:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.18 Math.imul(x, y)\nvar $export = __webpack_require__(16);\nvar $imul = Math.imul;\n\n// some WebKit versions fails with big numbers, some has wrong arity\n$export($export.S + $export.F * __webpack_require__(15)(function () {\n  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n}), 'Math', {\n  imul: function imul(x, y) {\n    var UINT16 = 0xffff;\n    var xn = +x;\n    var yn = +y;\n    var xl = UINT16 & xn;\n    var yl = UINT16 & yn;\n    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzPzUzMzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbXVsID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciB4biA9ICt4O1xuICAgIHZhciB5biA9ICt5O1xuICAgIHZhciB4bCA9IFVJTlQxNiAmIHhuO1xuICAgIHZhciB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 124:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.21 Math.log10(x)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Math', {\n  log10: function log10(x) {\n    return Math.log(x) * Math.LOG10E;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcz9kYmUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjEyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 125:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.20 Math.log1p(x)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Math', { log1p: __webpack_require__(111) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcz9hODA1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsNEJBQTRCLGtDQUFrQyIsImZpbGUiOiIxMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 126:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.22 Math.log2(x)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Math', {\n  log2: function log2(x) {\n    return Math.log(x) / Math.LN2;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzP2YzMDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 127:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.28 Math.sign(x)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Math', { sign: __webpack_require__(115) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzP2U5ZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSw0QkFBNEIsaUNBQWdDIiwiZmlsZSI6IjEyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 128:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.30 Math.sinh(x)\nvar $export = __webpack_require__(16);\nvar expm1 = __webpack_require__(119);\nvar exp = Math.exp;\n\n// V8 near Chromium 38 has a problem with very small numbers\n$export($export.S + $export.F * __webpack_require__(15)(function () {\n  return !Math.sinh(-2e-17) != -2e-17;\n}), 'Math', {\n  sinh: function sinh(x) {\n    return Math.abs(x = +x) < 1\n      ? (expm1(x) - expm1(-x)) / 2\n      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzPzRlNDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjEyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCkge1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 129:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.33 Math.tanh(x)\nvar $export = __webpack_require__(16);\nvar expm1 = __webpack_require__(119);\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  tanh: function tanh(x) {\n    var a = expm1(x = +x);\n    var b = expm1(-x);\n    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzPzcxNjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KTtcbiAgICB2YXIgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 130:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.2.2.34 Math.trunc(x)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Math', {\n  trunc: function trunc(it) {\n    return (it > 0 ? Math.floor : Math.ceil)(it);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcz82ZTE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjEzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCkge1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 131:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\nvar toAbsoluteIndex = __webpack_require__(47);\nvar fromCharCode = String.fromCharCode;\nvar $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars\n    var res = [];\n    var aLen = arguments.length;\n    var i = 0;\n    var code;\n    while (aLen > i) {\n      code = +arguments[i++];\n      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcz8wYjMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY29kZTtcbiAgICB3aGlsZSAoYUxlbiA+IGkpIHtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZiAodG9BYnNvbHV0ZUluZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSkgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 132:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\nvar toIObject = __webpack_require__(40);\nvar toLength = __webpack_require__(45);\n\n$export($export.S, 'String', {\n  // 21.1.2.4 String.raw(callSite, ...substitutions)\n  raw: function raw(callSite) {\n    var tpl = toIObject(callSite.raw);\n    var len = toLength(tpl.length);\n    var aLen = arguments.length;\n    var res = [];\n    var i = 0;\n    while (len > i) {\n      res.push(String(tpl[i++]));\n      if (i < aLen) res.push(String(arguments[i]));\n    } return res.join('');\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcz9iZGQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpIHtcbiAgICB2YXIgdHBsID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdyk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsZW4gPiBpKSB7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmIChpIDwgYUxlbikgcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 133:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 21.1.3.25 String.prototype.trim()\n__webpack_require__(90)('trim', function ($trim) {\n  return function trim() {\n    return $trim(this, 3);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanM/NGJlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjEzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 134:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $at = __webpack_require__(135)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(136)(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzPzIzZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGNBQWM7QUFDZDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFVBQVU7QUFDVixDQUFDIiwiZmlsZSI6IjEzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 135:
/***/ (function(module, exports, __webpack_require__) {

	eval("var toInteger = __webpack_require__(46);\nvar defined = __webpack_require__(43);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzPzdlNWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 136:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar LIBRARY = __webpack_require__(36);\nvar $export = __webpack_require__(16);\nvar redefine = __webpack_require__(26);\nvar hide = __webpack_require__(18);\nvar has = __webpack_require__(13);\nvar Iterators = __webpack_require__(137);\nvar $iterCreate = __webpack_require__(138);\nvar setToStringTag = __webpack_require__(32);\nvar getPrototypeOf = __webpack_require__(66);\nvar ITERATOR = __webpack_require__(33)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanM/NGVlMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsYUFBYTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQ0FBb0M7QUFDN0UsNkNBQTZDLG9DQUFvQztBQUNqRixLQUFLLDRCQUE0QixvQ0FBb0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwiZmlsZSI6IjEzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 137:
/***/ (function(module, exports) {

	eval("module.exports = {};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzP2EyMzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 138:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar create = __webpack_require__(53);\nvar descriptor = __webpack_require__(25);\nvar setToStringTag = __webpack_require__(32);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(18)(IteratorPrototype, __webpack_require__(33)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanM/OWI2OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkZBQWtGLGFBQWEsRUFBRTs7QUFFakc7QUFDQSxxREFBcUQsNEJBQTRCO0FBQ2pGO0FBQ0EiLCJmaWxlIjoiMTM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 139:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $at = __webpack_require__(135)(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos) {\n    return $at(this, pos);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanM/Yzc5ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 140:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n'use strict';\nvar $export = __webpack_require__(16);\nvar toLength = __webpack_require__(45);\nvar context = __webpack_require__(141);\nvar ENDS_WITH = 'endsWith';\nvar $endsWith = ''[ENDS_WITH];\n\n$export($export.P + $export.F * __webpack_require__(143)(ENDS_WITH), 'String', {\n  endsWith: function endsWith(searchString /* , endPosition = @length */) {\n    var that = context(this, searchString, ENDS_WITH);\n    var endPosition = arguments.length > 1 ? arguments[1] : undefined;\n    var len = toLength(that.length);\n    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);\n    var search = String(searchString);\n    return $endsWith\n      ? $endsWith.call(that, search, end)\n      : that.slice(end - search.length, end) === search;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcz82M2RmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBFTkRTX1dJVEggPSAnZW5kc1dpdGgnO1xudmFyICRlbmRzV2l0aCA9ICcnW0VORFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoRU5EU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLykge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSCk7XG4gICAgdmFyIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKTtcbiAgICB2YXIgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRlbmRzV2l0aFxuICAgICAgPyAkZW5kc1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGVuZClcbiAgICAgIDogdGhhdC5zbGljZShlbmQgLSBzZWFyY2gubGVuZ3RoLCBlbmQpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 141:
/***/ (function(module, exports, __webpack_require__) {

	eval("// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = __webpack_require__(142);\nvar defined = __webpack_require__(43);\n\nmodule.exports = function (that, searchString, NAME) {\n  if (isRegExp(searchString)) throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanM/MjhlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7XG4gIGlmIChpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 142:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 7.2.8 IsRegExp(argument)\nvar isObject = __webpack_require__(21);\nvar cof = __webpack_require__(42);\nvar MATCH = __webpack_require__(33)('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzP2E0YjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 143:
/***/ (function(module, exports, __webpack_require__) {

	eval("var MATCH = __webpack_require__(33)('match');\nmodule.exports = function (KEY) {\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch (e) {\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch (f) { /* empty */ }\n  } return true;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzPzdhOGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakIsR0FBRztBQUNIIiwiZmlsZSI6IjE0My5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaCAoZikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 144:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n'use strict';\nvar $export = __webpack_require__(16);\nvar context = __webpack_require__(141);\nvar INCLUDES = 'includes';\n\n$export($export.P + $export.F * __webpack_require__(143)(INCLUDES), 'String', {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzPzk1ZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 145:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: __webpack_require__(98)\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcz81MGYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTQ1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 146:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n'use strict';\nvar $export = __webpack_require__(16);\nvar toLength = __webpack_require__(45);\nvar context = __webpack_require__(141);\nvar STARTS_WITH = 'startsWith';\nvar $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * __webpack_require__(143)(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = context(this, searchString, STARTS_WITH);\n    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzPzY3MmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnO1xudmFyICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSCk7XG4gICAgdmFyIGluZGV4ID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 147:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.2 String.prototype.anchor(name)\n__webpack_require__(148)('anchor', function (createHTML) {\n  return function anchor(name) {\n    return createHTML(this, 'a', 'name', name);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcz84Y2ExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 148:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\nvar fails = __webpack_require__(15);\nvar defined = __webpack_require__(43);\nvar quot = /\"/g;\n// B.2.3.2.1 CreateHTML(string, tag, attribute, value)\nvar createHTML = function (string, tag, attribute, value) {\n  var S = String(defined(string));\n  var p1 = '<' + tag;\n  if (attribute !== '') p1 += ' ' + attribute + '=\"' + String(value).replace(quot, '&quot;') + '\"';\n  return p1 + '>' + S + '</' + tag + '>';\n};\nmodule.exports = function (NAME, exec) {\n  var O = {};\n  O[NAME] = exec(createHTML);\n  $export($export.P + $export.F * fails(function () {\n    var test = ''[NAME]('\"');\n    return test !== test.toLowerCase() || test.split('\"').length > 3;\n  }), 'String', O);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanM/NWU5YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiMTQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBxdW90ID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24gKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIGV4ZWMpIHtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 149:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.3 String.prototype.big()\n__webpack_require__(148)('big', function (createHTML) {\n  return function big() {\n    return createHTML(this, 'big', '', '');\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcz9lYjMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMyBTdHJpbmcucHJvdG90eXBlLmJpZygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdiaWcnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiaWcnLCAnJywgJycpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 150:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.4 String.prototype.blink()\n__webpack_require__(148)('blink', function (createHTML) {\n  return function blink() {\n    return createHTML(this, 'blink', '', '');\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzPzJkZmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxNTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy40IFN0cmluZy5wcm90b3R5cGUuYmxpbmsoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmxpbmsnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmxpbmsoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JsaW5rJywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 151:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.5 String.prototype.bold()\n__webpack_require__(148)('bold', function (createHTML) {\n  return function bold() {\n    return createHTML(this, 'b', '', '');\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanM/Y2VlOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 152:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.6 String.prototype.fixed()\n__webpack_require__(148)('fixed', function (createHTML) {\n  return function fixed() {\n    return createHTML(this, 'tt', '', '');\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzPzA0MWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxNTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 153:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.7 String.prototype.fontcolor(color)\n__webpack_require__(148)('fontcolor', function (createHTML) {\n  return function fontcolor(color) {\n    return createHTML(this, 'font', 'color', color);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcz85N2Q0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTUzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 154:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.8 String.prototype.fontsize(size)\n__webpack_require__(148)('fontsize', function (createHTML) {\n  return function fontsize(size) {\n    return createHTML(this, 'font', 'size', size);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzPzJjZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxNTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 155:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.9 String.prototype.italics()\n__webpack_require__(148)('italics', function (createHTML) {\n  return function italics() {\n    return createHTML(this, 'i', '', '');\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanM/Y2NkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE1NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjkgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2l0YWxpY3MnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnaScsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 156:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.10 String.prototype.link(url)\n__webpack_require__(148)('link', function (createHTML) {\n  return function link(url) {\n    return createHTML(this, 'a', 'href', url);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanM/MjlmNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE1Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 157:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.11 String.prototype.small()\n__webpack_require__(148)('small', function (createHTML) {\n  return function small() {\n    return createHTML(this, 'small', '', '');\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzP2NkNDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxNTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 158:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.12 String.prototype.strike()\n__webpack_require__(148)('strike', function (createHTML) {\n  return function strike() {\n    return createHTML(this, 'strike', '', '');\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcz8xYjgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTU4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTIgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2UoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3RyaWtlJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3RyaWtlJywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 159:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.13 String.prototype.sub()\n__webpack_require__(148)('sub', function (createHTML) {\n  return function sub() {\n    return createHTML(this, 'sub', '', '');\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcz8wNGViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTU5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5zdWIoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3ViJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1YigpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 160:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// B.2.3.14 String.prototype.sup()\n__webpack_require__(148)('sup', function (createHTML) {\n  return function sup() {\n    return createHTML(this, 'sup', '', '');\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcz9hN2ZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTYwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 161:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.3.3.1 / 15.9.4.4 Date.now()\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanM/ZDRiMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLDRCQUE0QixtQkFBbUIsNkJBQTZCLEVBQUUsRUFBRSIsImZpbGUiOiIxNjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHsgbm93OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 162:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar toObject = __webpack_require__(65);\nvar toPrimitive = __webpack_require__(24);\n\n$export($export.P + $export.F * __webpack_require__(15)(function () {\n  return new Date(NaN).toJSON() !== null\n    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;\n}), 'Date', {\n  // eslint-disable-next-line no-unused-vars\n  toJSON: function toJSON(key) {\n    var O = toObject(this);\n    var pv = toPrimitive(O);\n    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzP2MzOTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkIsVUFBVSxFQUFFLEVBQUU7QUFDNUUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTYyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsXG4gICAgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyB0b0lTT1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSB9KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 163:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()\nvar $export = __webpack_require__(16);\nvar toISOString = __webpack_require__(164);\n\n// PhantomJS / old WebKit has a broken implementations\n$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {\n  toISOString: toISOString\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzP2Y5N2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JU09TdHJpbmcgPSByZXF1aXJlKCcuL19kYXRlLXRvLWlzby1zdHJpbmcnKTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAhPT0gdG9JU09TdHJpbmcpLCAnRGF0ZScsIHtcbiAgdG9JU09TdHJpbmc6IHRvSVNPU3RyaW5nXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 164:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()\nvar fails = __webpack_require__(15);\nvar getTime = Date.prototype.getTime;\nvar $toISOString = Date.prototype.toISOString;\n\nvar lz = function (num) {\n  return num > 9 ? num : '0' + num;\n};\n\n// PhantomJS / old WebKit has a broken implementations\nmodule.exports = (fails(function () {\n  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';\n}) || !fails(function () {\n  $toISOString.call(new Date(NaN));\n})) ? function toISOString() {\n  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');\n  var d = this;\n  var y = d.getUTCFullYear();\n  var m = d.getUTCMilliseconds();\n  var s = y < 0 ? '-' : y > 9999 ? '+' : '';\n  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +\n    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +\n    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +\n    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';\n} : $toISOString;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzPzNlMDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZ2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG52YXIgJHRvSVNPU3RyaW5nID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBseiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59O1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbm1vZHVsZS5leHBvcnRzID0gKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICR0b0lTT1N0cmluZy5jYWxsKG5ldyBEYXRlKC01ZTEzIC0gMSkpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoTmFOKSk7XG59KSkgPyBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgaWYgKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKSB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgdmFyIGQgPSB0aGlzO1xuICB2YXIgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICB2YXIgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcbiAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbn0gOiAkdG9JU09TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLWlzby1zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "shim/jquery":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"contrib/jquery-2.1.0\")], __WEBPACK_AMD_DEFINE_RESULT__ = function($) {\n    // These globals are needed for backward compatibility. Some user javascript\n    // depends on jQuery being available globally.\n    if (!window.$) {\n        window.$ = $;\n        window.jQuery = $;\n    }\n    return $;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vanF1ZXJ5LmpzPzY2NmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InNoaW0vanF1ZXJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFsnY29udHJpYi9qcXVlcnktMi4xLjAuanMnXSwgZnVuY3Rpb24oJCkge1xuICAgIC8vIFRoZXNlIGdsb2JhbHMgYXJlIG5lZWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gU29tZSB1c2VyIGphdmFzY3JpcHRcbiAgICAvLyBkZXBlbmRzIG9uIGpRdWVyeSBiZWluZyBhdmFpbGFibGUgZ2xvYmFsbHkuXG4gICAgaWYgKCF3aW5kb3cuJCkge1xuICAgICAgICB3aW5kb3cuJCA9ICQ7XG4gICAgICAgIHdpbmRvdy5qUXVlcnkgPSAkO1xuICAgIH1cbiAgICByZXR1cm4gJDtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSBzaGltL2pxdWVyeVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 166:
/***/ (function(module, exports, __webpack_require__) {

	eval("var TO_PRIMITIVE = __webpack_require__(33)('toPrimitive');\nvar proto = Date.prototype;\n\nif (!(TO_PRIMITIVE in proto)) __webpack_require__(18)(proto, TO_PRIMITIVE, __webpack_require__(167));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanM/YmI3OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE2Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKTtcbnZhciBwcm90byA9IERhdGUucHJvdG90eXBlO1xuXG5pZiAoIShUT19QUklNSVRJVkUgaW4gcHJvdG8pKSByZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 167:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar anObject = __webpack_require__(20);\nvar toPrimitive = __webpack_require__(24);\nvar NUMBER = 'number';\n\nmodule.exports = function (hint) {\n  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');\n  return toPrimitive(anObject(this), hint != NUMBER);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanM/NWRiOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIE5VTUJFUiA9ICdudW1iZXInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoaW50KSB7XG4gIGlmIChoaW50ICE9PSAnc3RyaW5nJyAmJiBoaW50ICE9PSBOVU1CRVIgJiYgaGludCAhPT0gJ2RlZmF1bHQnKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 168:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Array', { isArray: __webpack_require__(52) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanM/OTVkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLDZCQUE2QixtQ0FBa0MiLCJmaWxlIjoiMTY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7IGlzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5JykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 169:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar ctx = __webpack_require__(28);\nvar $export = __webpack_require__(16);\nvar toObject = __webpack_require__(65);\nvar call = __webpack_require__(170);\nvar isArrayIter = __webpack_require__(171);\nvar toLength = __webpack_require__(45);\nvar createProperty = __webpack_require__(172);\nvar getIterFn = __webpack_require__(173);\n\n$export($export.S + $export.F * !__webpack_require__(174)(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcz9jNTg2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyRUFBNEUsa0JBQWtCLEVBQUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0NBQWdDO0FBQ3ZGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 170:
/***/ (function(module, exports, __webpack_require__) {

	eval("// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(20);\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzP2UyN2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 171:
/***/ (function(module, exports, __webpack_require__) {

	eval("// check on default Array iterator\nvar Iterators = __webpack_require__(137);\nvar ITERATOR = __webpack_require__(33)('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcz8zMzkwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 172:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $defineProperty = __webpack_require__(19);\nvar createDesc = __webpack_require__(25);\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzP2RlY2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE3Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggaW4gb2JqZWN0KSAkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 173:
/***/ (function(module, exports, __webpack_require__) {

	eval("var classof = __webpack_require__(82);\nvar ITERATOR = __webpack_require__(33)('iterator');\nvar Iterators = __webpack_require__(137);\nmodule.exports = __webpack_require__(17).getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanM/NjkzYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE3My5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 174:
/***/ (function(module, exports, __webpack_require__) {

	eval("var ITERATOR = __webpack_require__(33)('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanM/MTVkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0EsaUNBQWlDLFNBQVMsRUFBRTtBQUM1QyxDQUFDLFlBQVk7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVMscUJBQXFCO0FBQzNELGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0EsR0FBRyxZQUFZO0FBQ2Y7QUFDQSIsImZpbGUiOiIxNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 175:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar createProperty = __webpack_require__(172);\n\n// WebKit Array.of isn't generic\n$export($export.S + $export.F * __webpack_require__(15)(function () {\n  function F() { /* empty */ }\n  return !(Array.of.call(F) instanceof F);\n}), 'Array', {\n  // 22.1.2.3 Array.of( ...items)\n  of: function of(/* ...args */) {\n    var index = 0;\n    var aLen = arguments.length;\n    var result = new (typeof this == 'function' ? this : Array)(aLen);\n    while (aLen > index) createProperty(result, index, arguments[index++]);\n    result.length = aLen;\n    return result;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanM/ZTg3NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlIChhTGVuID4gaW5kZXgpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 176:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 22.1.3.13 Array.prototype.join(separator)\nvar $export = __webpack_require__(16);\nvar toIObject = __webpack_require__(40);\nvar arrayJoin = [].join;\n\n// fallback for not array-like strings\n$export($export.P + $export.F * (__webpack_require__(41) != Object || !__webpack_require__(177)(arrayJoin)), 'Array', {\n  join: function join(separator) {\n    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcz82ZWVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTc2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 177:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar fails = __webpack_require__(15);\n\nmodule.exports = function (method, arg) {\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call\n    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcz8xOTIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQsR0FBRztBQUNIIiwiZmlsZSI6IjE3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbFxuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 178:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar html = __webpack_require__(55);\nvar cof = __webpack_require__(42);\nvar toAbsoluteIndex = __webpack_require__(47);\nvar toLength = __webpack_require__(45);\nvar arraySlice = [].slice;\n\n// fallback for not array-like ES3 strings and DOM objects\n$export($export.P + $export.F * __webpack_require__(15)(function () {\n  if (html) arraySlice.call(html);\n}), 'Array', {\n  slice: function slice(begin, end) {\n    var len = toLength(this.length);\n    var klass = cof(this);\n    end = end === undefined ? len : end;\n    if (klass == 'Array') return arraySlice.call(this, begin, end);\n    var start = toAbsoluteIndex(begin, len);\n    var upTo = toAbsoluteIndex(end, len);\n    var size = toLength(upTo - start);\n    var cloned = Array(size);\n    var i = 0;\n    for (; i < size; i++) cloned[i] = klass == 'String'\n      ? this.charAt(start + i)\n      : this[start + i];\n    return cloned;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanM/NjM4MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE3OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBpZiAoaHRtbCkgYXJyYXlTbGljZS5jYWxsKGh0bWwpO1xufSksICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpO1xuICAgIHZhciBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZiAoa2xhc3MgPT0gJ0FycmF5JykgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbik7XG4gICAgdmFyIHVwVG8gPSB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pO1xuICAgIHZhciBzaXplID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KTtcbiAgICB2YXIgY2xvbmVkID0gQXJyYXkoc2l6ZSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgc2l6ZTsgaSsrKSBjbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 179:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar aFunction = __webpack_require__(29);\nvar toObject = __webpack_require__(65);\nvar fails = __webpack_require__(15);\nvar $sort = [].sort;\nvar test = [1, 2, 3];\n\n$export($export.P + $export.F * (fails(function () {\n  // IE8-\n  test.sort(undefined);\n}) || !fails(function () {\n  // V8 bug\n  test.sort(null);\n  // Old WebKit\n}) || !__webpack_require__(177)($sort)), 'Array', {\n  // 22.1.3.25 Array.prototype.sort(comparefn)\n  sort: function sort(comparefn) {\n    return comparefn === undefined\n      ? $sort.call(toObject(this))\n      : $sort.call(toObject(this), aFunction(comparefn));\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qcz9hZTcyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxNzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkc29ydCA9IFtdLnNvcnQ7XG52YXIgdGVzdCA9IFsxLCAyLCAzXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggYnVnXG4gIHRlc3Quc29ydChudWxsKTtcbiAgLy8gT2xkIFdlYktpdFxufSkgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkc29ydCkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yNSBBcnJheS5wcm90b3R5cGUuc29ydChjb21wYXJlZm4pXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 180:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $forEach = __webpack_require__(181)(0);\nvar STRICT = __webpack_require__(177)([].forEach, true);\n\n$export($export.P + $export.F * !STRICT, 'Array', {\n  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])\n  forEach: function forEach(callbackfn /* , thisArg */) {\n    return $forEach(this, callbackfn, arguments[1]);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanM/NGQ5MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxODAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIFNUUklDVCA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 181:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx = __webpack_require__(28);\nvar IObject = __webpack_require__(41);\nvar toObject = __webpack_require__(65);\nvar toLength = __webpack_require__(45);\nvar asc = __webpack_require__(182);\nmodule.exports = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || asc;\n  return function ($this, callbackfn, that) {\n    var O = toObject($this);\n    var self = IObject(O);\n    var f = ctx(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcz8zYzIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyxTQUFTLGlDQUFpQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE4MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 182:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = __webpack_require__(183);\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanM/YTdlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIxODIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 183:
/***/ (function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(21);\nvar isArray = __webpack_require__(52);\nvar SPECIES = __webpack_require__(33)('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcz84YTFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIxODMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 184:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $map = __webpack_require__(181)(1);\n\n$export($export.P + $export.F * !__webpack_require__(177)([].map, true), 'Array', {\n  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments[1]);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubWFwLmpzP2UwNWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE4NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJG1hcCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 185:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $filter = __webpack_require__(181)(2);\n\n$export($export.P + $export.F * !__webpack_require__(177)([].filter, true), 'Array', {\n  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments[1]);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzP2RjYjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE4NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 186:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $some = __webpack_require__(181)(3);\n\n$export($export.P + $export.F * !__webpack_require__(177)([].some, true), 'Array', {\n  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])\n  some: function some(callbackfn /* , thisArg */) {\n    return $some(this, callbackfn, arguments[1]);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcz8wMmZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxODYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRzb21lID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 187:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $every = __webpack_require__(181)(4);\n\n$export($export.P + $export.F * !__webpack_require__(177)([].every, true), 'Array', {\n  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])\n  every: function every(callbackfn /* , thisArg */) {\n    return $every(this, callbackfn, arguments[1]);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanM/ZWI2YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTg3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXZlcnkgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 188:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $reduce = __webpack_require__(189);\n\n$export($export.P + $export.F * !__webpack_require__(177)([].reduce, true), 'Array', {\n  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    return $reduce(this, callbackfn, arguments.length, arguments[1], false);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzPzRmNDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE4OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 189:
/***/ (function(module, exports, __webpack_require__) {

	eval("var aFunction = __webpack_require__(29);\nvar toObject = __webpack_require__(65);\nvar IObject = __webpack_require__(41);\nvar toLength = __webpack_require__(45);\n\nmodule.exports = function (that, callbackfn, aLen, memo, isRight) {\n  aFunction(callbackfn);\n  var O = toObject(that);\n  var self = IObject(O);\n  var length = toLength(O.length);\n  var index = isRight ? length - 1 : 0;\n  var i = isRight ? -1 : 1;\n  if (aLen < 2) for (;;) {\n    if (index in self) {\n      memo = self[index];\n      index += i;\n      break;\n    }\n    index += i;\n    if (isRight ? index < 0 : length <= index) {\n      throw TypeError('Reduce of empty array with no initial value');\n    }\n  }\n  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {\n    memo = callbackfn(memo, self[index], index, O);\n  }\n  return memo;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzP2FhMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNDQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxODkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KSB7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgaW5kZXggPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDA7XG4gIHZhciBpID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYgKGFMZW4gPCAyKSBmb3IgKDs7KSB7XG4gICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggKz0gaTtcbiAgICBpZiAoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvciAoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDE4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 190:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $reduce = __webpack_require__(189);\n\n$export($export.P + $export.F * !__webpack_require__(177)([].reduceRight, true), 'Array', {\n  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])\n  reduceRight: function reduceRight(callbackfn /* , initialValue */) {\n    return $reduce(this, callbackfn, arguments.length, arguments[1], true);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzP2FmNDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE5MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 191:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $indexOf = __webpack_require__(44)(false);\nvar $native = [].indexOf;\nvar NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', {\n  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])\n  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? $native.apply(this, arguments) || 0\n      : $indexOf(this, searchElement, arguments[1]);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanM/OTlhNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE5MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciAkbmF0aXZlID0gW10uaW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 192:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar toIObject = __webpack_require__(40);\nvar toInteger = __webpack_require__(46);\nvar toLength = __webpack_require__(45);\nvar $native = [].lastIndexOf;\nvar NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', {\n  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])\n  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {\n    // convert -0 to +0\n    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;\n    var O = toIObject(this);\n    var length = toLength(O.length);\n    var index = length - 1;\n    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));\n    if (index < 0) index = length + index;\n    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;\n    return -1;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qcz8wODg5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyICRuYXRpdmUgPSBbXS5sYXN0SW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTQgLyAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pIHtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYgKE5FR0FUSVZFX1pFUk8pIHJldHVybiAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICBmb3IgKDtpbmRleCA+PSAwOyBpbmRleC0tKSBpZiAoaW5kZXggaW4gTykgaWYgKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KSByZXR1cm4gaW5kZXggfHwgMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 193:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\nvar $export = __webpack_require__(16);\n\n$export($export.P, 'Array', { copyWithin: __webpack_require__(194) });\n\n__webpack_require__(195)('copyWithin');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanM/ZmU3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLDZCQUE2Qix1Q0FBOEM7O0FBRTNFIiwiZmlsZSI6IjE5My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHsgY29weVdpdGhpbjogcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 194:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n'use strict';\nvar toObject = __webpack_require__(65);\nvar toAbsoluteIndex = __webpack_require__(47);\nvar toLength = __webpack_require__(45);\n\nmodule.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {\n  var O = toObject(this);\n  var len = toLength(O.length);\n  var to = toAbsoluteIndex(target, len);\n  var from = toAbsoluteIndex(start, len);\n  var end = arguments.length > 2 ? arguments[2] : undefined;\n  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);\n  var inc = 1;\n  if (from < to && to < from + count) {\n    inc = -1;\n    from += count - 1;\n    to += count - 1;\n  }\n  while (count-- > 0) {\n    if (from in O) O[to] = O[from];\n    else delete O[to];\n    to += inc;\n    from += inc;\n  } return O;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktY29weS13aXRoaW4uanM/ZDJhYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIxOTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0IC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciB0byA9IHRvQWJzb2x1dGVJbmRleCh0YXJnZXQsIGxlbik7XG4gIHZhciBmcm9tID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pO1xuICB2YXIgaW5jID0gMTtcbiAgaWYgKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCkge1xuICAgIGluYyA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgdG8gKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 195:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = __webpack_require__(33)('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(18)(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzP2YyZjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsNkZBQXdGO0FBQ3hGO0FBQ0E7QUFDQSIsImZpbGUiOiIxOTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 196:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = __webpack_require__(16);\n\n$export($export.P, 'Array', { fill: __webpack_require__(197) });\n\n__webpack_require__(195)('fill');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcz9jNzk1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsNkJBQTZCLGlDQUFpQzs7QUFFOUQiLCJmaWxlIjoiMTk2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 197:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = __webpack_require__(65);\nvar toAbsoluteIndex = __webpack_require__(47);\nvar toLength = __webpack_require__(45);\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var aLen = arguments.length;\n  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);\n  var end = aLen > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qcz9mZWJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxOTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 198:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = __webpack_require__(16);\nvar $find = __webpack_require__(181)(5);\nvar KEY = 'find';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n__webpack_require__(195)(KEY);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcz8wZDY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQixFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwiZmlsZSI6IjE5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSk7XG52YXIgS0VZID0gJ2ZpbmQnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 199:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = __webpack_require__(16);\nvar $find = __webpack_require__(181)(6);\nvar KEY = 'findIndex';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n__webpack_require__(195)(KEY);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcz83ZjY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQixFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwiZmlsZSI6IjE5OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg2KTtcbnZhciBLRVkgPSAnZmluZEluZGV4JztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 200:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(201)('Array');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcz8wMDc1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjIwMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 201:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar global = __webpack_require__(12);\nvar dP = __webpack_require__(19);\nvar DESCRIPTORS = __webpack_require__(14);\nvar SPECIES = __webpack_require__(33)('species');\n\nmodule.exports = function (KEY) {\n  var C = global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanM/YjM3MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsR0FBRztBQUNIIiwiZmlsZSI6IjIwMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 202:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar addToUnscopables = __webpack_require__(195);\nvar step = __webpack_require__(203);\nvar Iterators = __webpack_require__(137);\nvar toIObject = __webpack_require__(40);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(136)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanM/NzA4YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsY0FBYztBQUNkLGlCQUFpQjtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjAyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 203:
/***/ (function(module, exports) {

	eval("module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzPzAwMzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxVQUFVO0FBQ1YiLCJmaWxlIjoiMjAzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 204:
/***/ (function(module, exports, __webpack_require__) {

	eval("var global = __webpack_require__(12);\nvar inheritIfRequired = __webpack_require__(95);\nvar dP = __webpack_require__(19).f;\nvar gOPN = __webpack_require__(57).f;\nvar isRegExp = __webpack_require__(142);\nvar $flags = __webpack_require__(205);\nvar $RegExp = global.RegExp;\nvar Base = $RegExp;\nvar proto = $RegExp.prototype;\nvar re1 = /a/g;\nvar re2 = /a/g;\n// \"new\" creates a new object, old webkit buggy here\nvar CORRECT_NEW = new $RegExp(re1) !== re1;\n\nif (__webpack_require__(14) && (!CORRECT_NEW || __webpack_require__(15)(function () {\n  re2[__webpack_require__(33)('match')] = false;\n  // RegExp constructor can alter flags and IsRegExp works correct with @@match\n  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';\n}))) {\n  $RegExp = function RegExp(p, f) {\n    var tiRE = this instanceof $RegExp;\n    var piRE = isRegExp(p);\n    var fiU = f === undefined;\n    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p\n      : inheritIfRequired(CORRECT_NEW\n        ? new Base(piRE && !fiU ? p.source : p, f)\n        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)\n      , tiRE ? this : proto, $RegExp);\n  };\n  var proxy = function (key) {\n    key in $RegExp || dP($RegExp, key, {\n      configurable: true,\n      get: function () { return Base[key]; },\n      set: function (it) { Base[key] = it; }\n    });\n  };\n  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);\n  proto.constructor = $RegExp;\n  $RegExp.prototype = proto;\n  __webpack_require__(26)(global, 'RegExp', $RegExp);\n}\n\n__webpack_require__(201)('RegExp');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzPzBkM2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCLEVBQUU7QUFDNUMsMEJBQTBCLGdCQUFnQjtBQUMxQyxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIwNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgJFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgQmFzZSA9ICRSZWdFeHA7XG52YXIgcHJvdG8gPSAkUmVnRXhwLnByb3RvdHlwZTtcbnZhciByZTEgPSAvYS9nO1xudmFyIHJlMiA9IC9hL2c7XG4vLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbnZhciBDT1JSRUNUX05FVyA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSkge1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpIHtcbiAgICB2YXIgdGlSRSA9IHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwO1xuICAgIHZhciBwaVJFID0gaXNSZWdFeHAocCk7XG4gICAgdmFyIGZpVSA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAoJFJlZ0V4cCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGl0KSB7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOykgcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 205:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = __webpack_require__(20);\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanM/ZTU2OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 206:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n__webpack_require__(207);\nvar anObject = __webpack_require__(20);\nvar $flags = __webpack_require__(205);\nvar DESCRIPTORS = __webpack_require__(14);\nvar TO_STRING = 'toString';\nvar $toString = /./[TO_STRING];\n\nvar define = function (fn) {\n  __webpack_require__(26)(RegExp.prototype, TO_STRING, fn, true);\n};\n\n// 21.2.5.14 RegExp.prototype.toString()\nif (__webpack_require__(15)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {\n  define(function toString() {\n    var R = anObject(this);\n    return '/'.concat(R.source, '/',\n      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);\n  });\n// FF44- RegExp#toString has a wrong name\n} else if ($toString.name != TO_STRING) {\n  define(function toString() {\n    return $toString.call(this);\n  });\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcz9jMTk4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUFxQyx3QkFBd0IsMEJBQTBCLFlBQVksRUFBRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjIwNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYgKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZiAoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 207:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 21.2.5.3 get RegExp.prototype.flags()\nif (__webpack_require__(14) && /./g.flags != 'g') __webpack_require__(19).f(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: __webpack_require__(205)\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzPzgzYjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjIwNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 208:
/***/ (function(module, exports, __webpack_require__) {

	eval("// @@match logic\n__webpack_require__(209)('match', 1, function (defined, MATCH, $match) {\n  // 21.1.3.11 String.prototype.match(regexp)\n  return [function match(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[MATCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n  }, $match];\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzPzgwYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjIwOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCkge1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJG1hdGNoXTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 209:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar hide = __webpack_require__(18);\nvar redefine = __webpack_require__(26);\nvar fails = __webpack_require__(15);\nvar defined = __webpack_require__(43);\nvar wks = __webpack_require__(33);\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n  var fns = exec(defined, SYMBOL, ''[KEY]);\n  var strfn = fns[0];\n  var rxfn = fns[1];\n  if (fails(function () {\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  })) {\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcz8wNjQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFDQUFxQztBQUNyRTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0EiLCJmaWxlIjoiMjA5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYykge1xuICB2YXIgU1lNQk9MID0gd2tzKEtFWSk7XG4gIHZhciBmbnMgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSk7XG4gIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgdmFyIHJ4Zm4gPSBmbnNbMV07XG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKSB7XG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 210:
/***/ (function(module, exports, __webpack_require__) {

	eval("// @@replace logic\n__webpack_require__(209)('replace', 2, function (defined, REPLACE, $replace) {\n  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n  return [function replace(searchValue, replaceValue) {\n    'use strict';\n    var O = defined(this);\n    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n    return fn !== undefined\n      ? fn.call(searchValue, O, replaceValue)\n      : $replace.call(String(O), searchValue, replaceValue);\n  }, $replace];\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanM/ZGQxOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKSB7XG4gIC8vIDIxLjEuMy4xNCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSlcbiAgcmV0dXJuIFtmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAkcmVwbGFjZV07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 211:
/***/ (function(module, exports, __webpack_require__) {

	eval("// @@search logic\n__webpack_require__(209)('search', 1, function (defined, SEARCH, $search) {\n  // 21.1.3.15 String.prototype.search(regexp)\n  return [function search(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[SEARCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n  }, $search];\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcz9hZmY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsImZpbGUiOiIyMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKSB7XG4gIC8vIDIxLjEuMy4xNSBTdHJpbmcucHJvdG90eXBlLnNlYXJjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJHNlYXJjaF07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 212:
/***/ (function(module, exports, __webpack_require__) {

	eval("// @@split logic\n__webpack_require__(209)('split', 2, function (defined, SPLIT, $split) {\n  'use strict';\n  var isRegExp = __webpack_require__(142);\n  var _split = $split;\n  var $push = [].push;\n  var $SPLIT = 'split';\n  var LENGTH = 'length';\n  var LAST_INDEX = 'lastIndex';\n  if (\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ) {\n    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group\n    // based on es5-shim implementation, need to rework it\n    $split = function (separator, limit) {\n      var string = String(this);\n      if (separator === undefined && limit === 0) return [];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) return _split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var separator2, match, lastIndex, lastLength, i;\n      // Doesn't need flags gy, but they don't hurt\n      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\\\s)', flags);\n      while (match = separatorCopy.exec(string)) {\n        // `separatorCopy.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0][LENGTH];\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG\n          // eslint-disable-next-line no-loop-func\n          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {\n            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;\n          });\n          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if (output[LENGTH] >= splitLimit) break;\n        }\n        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string[LENGTH]) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {\n    $split = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);\n    };\n  }\n  // 21.1.3.17 String.prototype.split(separator, limit)\n  return [function split(separator, limit) {\n    var O = defined(this);\n    var fn = separator == undefined ? undefined : separator[SPLIT];\n    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);\n  }, $split];\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzPzRhMDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuICB2YXIgX3NwbGl0ID0gJHNwbGl0O1xuICB2YXIgJHB1c2ggPSBbXS5wdXNoO1xuICB2YXIgJFNQTElUID0gJ3NwbGl0JztcbiAgdmFyIExFTkdUSCA9ICdsZW5ndGgnO1xuICB2YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZiAoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICkge1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmICghTlBDRykgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgIGlmICghTlBDRyAmJiBtYXRjaFtMRU5HVEhdID4gMSkgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfVxuICAvLyAyMS4xLjMuMTcgU3RyaW5nLnByb3RvdHlwZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KVxuICByZXR1cm4gW2Z1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 213:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar LIBRARY = __webpack_require__(36);\nvar global = __webpack_require__(12);\nvar ctx = __webpack_require__(28);\nvar classof = __webpack_require__(82);\nvar $export = __webpack_require__(16);\nvar isObject = __webpack_require__(21);\nvar aFunction = __webpack_require__(29);\nvar anInstance = __webpack_require__(214);\nvar forOf = __webpack_require__(215);\nvar speciesConstructor = __webpack_require__(216);\nvar task = __webpack_require__(217).set;\nvar microtask = __webpack_require__(218)();\nvar newPromiseCapabilityModule = __webpack_require__(219);\nvar perform = __webpack_require__(220);\nvar promiseResolve = __webpack_require__(221);\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[__webpack_require__(33)('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value);\n            if (domain) domain.exit();\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  if (promise._h == 1) return false;\n  var chain = promise._a || promise._c;\n  var i = 0;\n  var reaction;\n  while (chain.length > i) {\n    reaction = chain[i++];\n    if (reaction.fail || !isUnhandled(reaction.promise)) return false;\n  } return true;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = __webpack_require__(222)($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\n__webpack_require__(32)($Promise, PROMISE);\n__webpack_require__(201)(PROMISE);\nWrapper = __webpack_require__(17)[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(174)(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcz9iYzAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZO0FBQ2YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQixrQ0FBa0M7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsdUNBQXVDO0FBQ3REO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLHlCQUF5QixLQUFLO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsd0JBQXdCO0FBQ3hCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsb0JBQW9CO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5faCA9PSAxKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYztcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVhY3Rpb247XG4gIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSB7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmIChyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSkgcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 214:
/***/ (function(module, exports) {

	eval("module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanM/Yzc4NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiMjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 215:
/***/ (function(module, exports, __webpack_require__) {

	eval("var ctx = __webpack_require__(28);\nvar call = __webpack_require__(170);\nvar isArrayIter = __webpack_require__(171);\nvar anObject = __webpack_require__(20);\nvar toLength = __webpack_require__(45);\nvar getIterFn = __webpack_require__(173);\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzPzA3NWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQixFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQSxHQUFHLDRDQUE0QyxnQ0FBZ0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanNcbi8vIG1vZHVsZSBpZCA9IDIxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 216:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = __webpack_require__(20);\nvar aFunction = __webpack_require__(29);\nvar SPECIES = __webpack_require__(33)('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcz8wOGZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 217:
/***/ (function(module, exports, __webpack_require__) {

	eval("var ctx = __webpack_require__(28);\nvar invoke = __webpack_require__(85);\nvar html = __webpack_require__(55);\nvar cel = __webpack_require__(23);\nvar global = __webpack_require__(12);\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (__webpack_require__(42)(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcz8zNmZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdGFzay5qc1xuLy8gbW9kdWxlIGlkID0gMjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 218:
/***/ (function(module, exports, __webpack_require__) {

	eval("var global = __webpack_require__(12);\nvar macrotask = __webpack_require__(217).set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = __webpack_require__(42)(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if (Observer) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    var promise = Promise.resolve();\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzP2Q5MDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQixFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIyMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYgKE9ic2VydmVyKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 219:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = __webpack_require__(29);\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcz9iNjg2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 220:
/***/ (function(module, exports) {

	eval("module.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcz80ZGZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNILFlBQVk7QUFDWjtBQUNBIiwiZmlsZSI6IjIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19wZXJmb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 221:
/***/ (function(module, exports, __webpack_require__) {

	eval("var anObject = __webpack_require__(20);\nvar isObject = __webpack_require__(21);\nvar newPromiseCapability = __webpack_require__(219);\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzP2YzOTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 222:
/***/ (function(module, exports, __webpack_require__) {

	eval("var redefine = __webpack_require__(26);\nmodule.exports = function (target, src, safe) {\n  for (var key in src) redefine(target, key, src[key], safe);\n  return target;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzPzgwNjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 223:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar strong = __webpack_require__(224);\nvar validate = __webpack_require__(225);\nvar MAP = 'Map';\n\n// 23.1 Map Objects\nmodule.exports = __webpack_require__(226)(MAP, function (get) {\n  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key) {\n    var entry = strong.getEntry(validate(this, MAP), key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value) {\n    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzP2ZjYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtRUFBbUU7QUFDNUYsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 224:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar dP = __webpack_require__(19).f;\nvar create = __webpack_require__(53);\nvar redefineAll = __webpack_require__(222);\nvar ctx = __webpack_require__(28);\nvar anInstance = __webpack_require__(214);\nvar forOf = __webpack_require__(215);\nvar $iterDefine = __webpack_require__(136);\nvar step = __webpack_require__(203);\nvar setSpecies = __webpack_require__(201);\nvar DESCRIPTORS = __webpack_require__(14);\nvar fastKey = __webpack_require__(30).fastKey;\nvar validate = __webpack_require__(225);\nvar SIZE = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function (that, key) {\n  // fast case\n  var index = fastKey(key);\n  var entry;\n  if (index !== 'F') return that._i[index];\n  // frozen object case\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;         // collection type\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = validate(this, NAME);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.n;\n          var prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        validate(this, NAME);\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while (entry && entry.r) entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(validate(this, NAME), key);\n      }\n    });\n    if (DESCRIPTORS) dP(C.prototype, 'size', {\n      get: function () {\n        return validate(this, NAME)[SIZE];\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var entry = getEntry(that, key);\n    var prev, index;\n    // change existing entry\n    if (entry) {\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if (index !== 'F') that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function (C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function (iterated, kind) {\n      this._t = validate(iterated, NAME); // target\n      this._k = kind;                     // kind\n      this._l = undefined;                // previous\n    }, function () {\n      var that = this;\n      var kind = that._k;\n      var entry = that._l;\n      // revert to the last existing entry\n      while (entry && entry.r) entry = entry.p;\n      // get next entry\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if (kind == 'keys') return step(0, entry.k);\n      if (kind == 'values') return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanM/ZDEwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsT0FBTztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 225:
/***/ (function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(21);\nmodule.exports = function (it, TYPE) {\n  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\n  return it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcz9iZjk5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 226:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar global = __webpack_require__(12);\nvar $export = __webpack_require__(16);\nvar redefine = __webpack_require__(26);\nvar redefineAll = __webpack_require__(222);\nvar meta = __webpack_require__(30);\nvar forOf = __webpack_require__(215);\nvar anInstance = __webpack_require__(214);\nvar isObject = __webpack_require__(21);\nvar fails = __webpack_require__(15);\nvar $iterDetect = __webpack_require__(174);\nvar setToStringTag = __webpack_require__(32);\nvar inheritIfRequired = __webpack_require__(95);\n\nmodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\n  var Base = global[NAME];\n  var C = Base;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var proto = C && C.prototype;\n  var O = {};\n  var fixMethod = function (KEY) {\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function (a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a) {\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {\n    new C().entries().next();\n  }))) {\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    var instance = new C();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n    // most early implementations doesn't supports iterables, most modern - not close it correctly\n    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new C();\n      var index = 5;\n      while (index--) $instance[ADDER](index, index);\n      return !$instance.has(-0);\n    });\n    if (!ACCEPT_ITERABLES) {\n      C = wrapper(function (target, iterable) {\n        anInstance(target, C, NAME);\n        var that = inheritIfRequired(new Base(), target, C);\n        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if (IS_WEAK && proto.clear) delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcz82MzE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPLG1DQUFtQyxnQ0FBZ0MsYUFBYTtBQUN2Riw4QkFBOEIsbUNBQW1DLGFBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLGtEQUFrRCxpQkFBaUIsRUFBRTtBQUNyRTtBQUNBLHdEQUF3RCxhQUFhLEVBQUUsRUFBRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiIyMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 227:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar strong = __webpack_require__(224);\nvar validate = __webpack_require__(225);\nvar SET = 'Set';\n\n// 23.2 Set Objects\nmodule.exports = __webpack_require__(226)(SET, function (get) {\n  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value) {\n    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);\n  }\n}, strong);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzPzk4YjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtRUFBbUU7QUFDNUYsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanNcbi8vIG1vZHVsZSBpZCA9IDIyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 228:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar each = __webpack_require__(181)(0);\nvar redefine = __webpack_require__(26);\nvar meta = __webpack_require__(30);\nvar assign = __webpack_require__(76);\nvar weak = __webpack_require__(229);\nvar isObject = __webpack_require__(21);\nvar fails = __webpack_require__(15);\nvar validate = __webpack_require__(225);\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = weak.ufstore;\nvar tmp = {};\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return weak.def(validate(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = __webpack_require__(226)(WEAK_MAP, wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanM/Mjc1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw0RUFBNEUsRUFBRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIIiwiZmlsZSI6IjIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgdG1wID0ge307XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmIChmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3OyB9KSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDIyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 229:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar redefineAll = __webpack_require__(222);\nvar getWeak = __webpack_require__(30).getWeak;\nvar anObject = __webpack_require__(20);\nvar isObject = __webpack_require__(21);\nvar anInstance = __webpack_require__(214);\nvar forOf = __webpack_require__(215);\nvar createArrayMethod = __webpack_require__(181);\nvar $has = __webpack_require__(13);\nvar validate = __webpack_require__(225);\nvar arrayFind = createArrayMethod(5);\nvar arrayFindIndex = createArrayMethod(6);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzPzk1MmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJmaWxlIjoiMjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanNcbi8vIG1vZHVsZSBpZCA9IDIyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 230:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar weak = __webpack_require__(229);\nvar validate = __webpack_require__(225);\nvar WEAK_SET = 'WeakSet';\n\n// 23.4 WeakSet Objects\n__webpack_require__(226)(WEAK_SET, function (get) {\n  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.4.3.1 WeakSet.prototype.add(value)\n  add: function add(value) {\n    return weak.def(validate(this, WEAK_SET), value, true);\n  }\n}, weak, false, true);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanM/Nzc5ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLG1FQUFtRTtBQUNoRyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19TRVQgPSAnV2Vha1NldCc7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19TRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfU0VUKSwgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 231:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $export = __webpack_require__(16);\nvar $typed = __webpack_require__(232);\nvar buffer = __webpack_require__(233);\nvar anObject = __webpack_require__(20);\nvar toAbsoluteIndex = __webpack_require__(47);\nvar toLength = __webpack_require__(45);\nvar isObject = __webpack_require__(21);\nvar ArrayBuffer = __webpack_require__(12).ArrayBuffer;\nvar speciesConstructor = __webpack_require__(216);\nvar $ArrayBuffer = buffer.ArrayBuffer;\nvar $DataView = buffer.DataView;\nvar $isView = $typed.ABV && ArrayBuffer.isView;\nvar $slice = $ArrayBuffer.prototype.slice;\nvar VIEW = $typed.VIEW;\nvar ARRAY_BUFFER = 'ArrayBuffer';\n\n$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });\n\n$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {\n  // 24.1.3.1 ArrayBuffer.isView(arg)\n  isView: function isView(it) {\n    return $isView && $isView(it) || isObject(it) && VIEW in it;\n  }\n});\n\n$export($export.P + $export.U + $export.F * __webpack_require__(15)(function () {\n  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;\n}), ARRAY_BUFFER, {\n  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)\n  slice: function slice(start, end) {\n    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix\n    var len = anObject(this).byteLength;\n    var first = toAbsoluteIndex(start, len);\n    var final = toAbsoluteIndex(end === undefined ? len : end, len);\n    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));\n    var viewS = new $DataView(this);\n    var viewT = new $DataView(result);\n    var index = 0;\n    while (first < final) {\n      viewT.setUint8(index++, viewS.getUint8(first++));\n    } return result;\n  }\n});\n\n__webpack_require__(201)(ARRAY_BUFFER);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzPzI0YWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkVBQTZFLDRCQUE0Qjs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiMjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5BcnJheUJ1ZmZlcjtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyO1xudmFyICREYXRhVmlldyA9IGJ1ZmZlci5EYXRhVmlldztcbnZhciAkaXNWaWV3ID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXc7XG52YXIgJHNsaWNlID0gJEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbnZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQXJyYXlCdWZmZXIgIT09ICRBcnJheUJ1ZmZlciksIHsgQXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlciB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KSB7XG4gICAgcmV0dXJuICRpc1ZpZXcgJiYgJGlzVmlldyhpdCkgfHwgaXNPYmplY3QoaXQpICYmIFZJRVcgaW4gaXQ7XG4gIH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuVSArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpIHJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB2YXIgbGVuID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aDtcbiAgICB2YXIgZmlyc3QgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gICAgdmFyIGZpbmFsID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW5hbCAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTID0gbmV3ICREYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1QgPSBuZXcgJERhdGFWaWV3KHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoZmlyc3QgPCBmaW5hbCkge1xuICAgICAgdmlld1Quc2V0VWludDgoaW5kZXgrKywgdmlld1MuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 232:
/***/ (function(module, exports, __webpack_require__) {

	eval("var global = __webpack_require__(12);\nvar hide = __webpack_require__(18);\nvar uid = __webpack_require__(27);\nvar TYPED = uid('typed_array');\nvar VIEW = uid('view');\nvar ABV = !!(global.ArrayBuffer && global.DataView);\nvar CONSTR = ABV;\nvar i = 0;\nvar l = 9;\nvar Typed;\n\nvar TypedArrayConstructors = (\n  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n).split(',');\n\nwhile (i < l) {\n  if (Typed = global[TypedArrayConstructors[i++]]) {\n    hide(Typed.prototype, TYPED, true);\n    hide(Typed.prototype, VIEW, true);\n  } else CONSTR = false;\n}\n\nmodule.exports = {\n  ABV: ABV,\n  CONSTR: CONSTR,\n  TYPED: TYPED,\n  VIEW: VIEW\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanM/YzI2YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFRZUEVEID0gdWlkKCd0eXBlZF9hcnJheScpO1xudmFyIFZJRVcgPSB1aWQoJ3ZpZXcnKTtcbnZhciBBQlYgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KTtcbnZhciBDT05TVFIgPSBBQlY7XG52YXIgaSA9IDA7XG52YXIgbCA9IDk7XG52YXIgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlIChpIDwgbCkge1xuICBpZiAoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSkge1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6IEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiBUWVBFRCxcbiAgVklFVzogVklFV1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 233:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar global = __webpack_require__(12);\nvar DESCRIPTORS = __webpack_require__(14);\nvar LIBRARY = __webpack_require__(36);\nvar $typed = __webpack_require__(232);\nvar hide = __webpack_require__(18);\nvar redefineAll = __webpack_require__(222);\nvar fails = __webpack_require__(15);\nvar anInstance = __webpack_require__(214);\nvar toInteger = __webpack_require__(46);\nvar toLength = __webpack_require__(45);\nvar toIndex = __webpack_require__(234);\nvar gOPN = __webpack_require__(57).f;\nvar dP = __webpack_require__(19).f;\nvar arrayFill = __webpack_require__(197);\nvar setToStringTag = __webpack_require__(32);\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH = 'Wrong length!';\nvar WRONG_INDEX = 'Wrong index!';\nvar $ArrayBuffer = global[ARRAY_BUFFER];\nvar $DataView = global[DATA_VIEW];\nvar Math = global.Math;\nvar RangeError = global.RangeError;\n// eslint-disable-next-line no-shadow-restricted-names\nvar Infinity = global.Infinity;\nvar BaseBuffer = $ArrayBuffer;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\nvar BUFFER = 'buffer';\nvar BYTE_LENGTH = 'byteLength';\nvar BYTE_OFFSET = 'byteOffset';\nvar $BUFFER = DESCRIPTORS ? '_b' : BUFFER;\nvar $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;\nvar $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nfunction packIEEE754(value, mLen, nBytes) {\n  var buffer = Array(nBytes);\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var i = 0;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  var e, m, c;\n  value = abs(value);\n  // eslint-disable-next-line no-self-compare\n  if (value != value || value === Infinity) {\n    // eslint-disable-next-line no-self-compare\n    m = value != value ? 1 : 0;\n    e = eMax;\n  } else {\n    e = floor(log(value) / LN2);\n    if (value * (c = pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * pow(2, eBias - 1) * pow(2, mLen);\n      e = 0;\n    }\n  }\n  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n  buffer[--i] |= s * 128;\n  return buffer;\n}\nfunction unpackIEEE754(buffer, mLen, nBytes) {\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = eLen - 7;\n  var i = nBytes - 1;\n  var s = buffer[i--];\n  var e = s & 127;\n  var m;\n  s >>= 7;\n  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : s ? -Infinity : Infinity;\n  } else {\n    m = m + pow(2, mLen);\n    e = e - eBias;\n  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n}\n\nfunction unpackI32(bytes) {\n  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n}\nfunction packI8(it) {\n  return [it & 0xff];\n}\nfunction packI16(it) {\n  return [it & 0xff, it >> 8 & 0xff];\n}\nfunction packI32(it) {\n  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n}\nfunction packF64(it) {\n  return packIEEE754(it, 52, 8);\n}\nfunction packF32(it) {\n  return packIEEE754(it, 23, 4);\n}\n\nfunction addGetter(C, key, internal) {\n  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });\n}\n\nfunction get(view, bytes, index, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = store.slice(start, start + bytes);\n  return isLittleEndian ? pack : pack.reverse();\n}\nfunction set(view, bytes, index, conversion, value, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = conversion(+value);\n  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n}\n\nif (!$typed.ABV) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\n    var byteLength = toIndex(length);\n    this._b = arrayFill.call(Array(byteLength), 0);\n    this[$LENGTH] = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = buffer[$LENGTH];\n    var offset = toInteger(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\n    this[$BUFFER] = buffer;\n    this[$OFFSET] = offset;\n    this[$LENGTH] = byteLength;\n  };\n\n  if (DESCRIPTORS) {\n    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n    addGetter($DataView, BUFFER, '_b');\n    addGetter($DataView, BYTE_LENGTH, '_l');\n    addGetter($DataView, BYTE_OFFSET, '_o');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packF32, value, arguments[2]);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packF64, value, arguments[2]);\n    }\n  });\n} else {\n  if (!fails(function () {\n    $ArrayBuffer(1);\n  }) || !fails(function () {\n    new $ArrayBuffer(-1); // eslint-disable-line no-new\n  }) || fails(function () {\n    new $ArrayBuffer(); // eslint-disable-line no-new\n    new $ArrayBuffer(1.5); // eslint-disable-line no-new\n    new $ArrayBuffer(NaN); // eslint-disable-line no-new\n    return $ArrayBuffer.name != ARRAY_BUFFER;\n  })) {\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance(this, $ArrayBuffer);\n      return new BaseBuffer(toIndex(length));\n    };\n    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);\n    }\n    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;\n  }\n  // iOS Safari 7.x bug\n  var view = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = $DataView[PROTOTYPE].setInt8;\n  view.setInt8(0, 2147483648);\n  view.setInt8(1, 2147483649);\n  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, true);\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nhide($DataView[PROTOTYPE], $typed.VIEW, true);\nexports[ARRAY_BUFFER] = $ArrayBuffer;\nexports[DATA_VIEW] = $DataView;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzPzEyOGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQW1CLHVCQUF1QixFQUFFLEVBQUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekIsR0FBRztBQUNILHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4ISc7XG52YXIgJEFycmF5QnVmZmVyID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl07XG52YXIgJERhdGFWaWV3ID0gZ2xvYmFsW0RBVEFfVklFV107XG52YXIgTWF0aCA9IGdsb2JhbC5NYXRoO1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1xudmFyIEluZmluaXR5ID0gZ2xvYmFsLkluZmluaXR5O1xudmFyIEJhc2VCdWZmZXIgPSAkQXJyYXlCdWZmZXI7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xudmFyIEJVRkZFUiA9ICdidWZmZXInO1xudmFyIEJZVEVfTEVOR1RIID0gJ2J5dGVMZW5ndGgnO1xudmFyIEJZVEVfT0ZGU0VUID0gJ2J5dGVPZmZzZXQnO1xudmFyICRCVUZGRVIgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVI7XG52YXIgJExFTkdUSCA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIO1xudmFyICRPRkZTRVQgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbmZ1bmN0aW9uIHBhY2tJRUVFNzU0KHZhbHVlLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9IEFycmF5KG5CeXRlcyk7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChidWZmZXIsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZUxlbiAtIDc7XG4gIHZhciBpID0gbkJ5dGVzIC0gMTtcbiAgdmFyIHMgPSBidWZmZXJbaS0tXTtcbiAgdmFyIGUgPSBzICYgMTI3O1xuICB2YXIgbTtcbiAgcyA+Pj0gNztcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59XG5cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykge1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn1cbmZ1bmN0aW9uIHBhY2tJOChpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTE2KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTMyKGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0Y2NChpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn1cbmZ1bmN0aW9uIHBhY2tGMzIoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59XG5cbmZ1bmN0aW9uIGFkZEdldHRlcihDLCBrZXksIGludGVybmFsKSB7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH0gfSk7XG59XG5cbmZ1bmN0aW9uIGdldCh2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIHNldCh2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufVxuXG5pZiAoISR0eXBlZC5BQlYpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgdGhpcy5fYiA9IGFycmF5RmlsbC5jYWxsKEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBidWZmZXJbJExFTkdUSF07XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyLCA4KTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAkQXJyYXlCdWZmZXIoMSk7XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gJEFycmF5QnVmZmVyLm5hbWUgIT0gQVJSQVlfQlVGRkVSO1xuICB9KSkge1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHRvSW5kZXgobGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSBoaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH1cbiAgICBpZiAoIUxJQlJBUlkpIEFycmF5QnVmZmVyUHJvdG8uY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKTtcbiAgdmFyICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSkgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 234:
/***/ (function(module, exports, __webpack_require__) {

	eval("// https://tc39.github.io/ecma262/#sec-toindex\nvar toInteger = __webpack_require__(46);\nvar toLength = __webpack_require__(45);\nmodule.exports = function (it) {\n  if (it === undefined) return 0;\n  var number = toInteger(it);\n  var length = toLength(number);\n  if (number !== length) throw RangeError('Wrong length!');\n  return length;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanM/YzMxNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGghJyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 235:
/***/ (function(module, exports, __webpack_require__) {

	eval("var $export = __webpack_require__(16);\n$export($export.G + $export.W + $export.F * !__webpack_require__(232).ABV, {\n  DataView: __webpack_require__(233).DataView\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzPzA1ZDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 236:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(237)('Int8', 1, function (init) {\n  return function Int8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcz82MzYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 237:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\nif (__webpack_require__(14)) {\n  var LIBRARY = __webpack_require__(36);\n  var global = __webpack_require__(12);\n  var fails = __webpack_require__(15);\n  var $export = __webpack_require__(16);\n  var $typed = __webpack_require__(232);\n  var $buffer = __webpack_require__(233);\n  var ctx = __webpack_require__(28);\n  var anInstance = __webpack_require__(214);\n  var propertyDesc = __webpack_require__(25);\n  var hide = __webpack_require__(18);\n  var redefineAll = __webpack_require__(222);\n  var toInteger = __webpack_require__(46);\n  var toLength = __webpack_require__(45);\n  var toIndex = __webpack_require__(234);\n  var toAbsoluteIndex = __webpack_require__(47);\n  var toPrimitive = __webpack_require__(24);\n  var has = __webpack_require__(13);\n  var classof = __webpack_require__(82);\n  var isObject = __webpack_require__(21);\n  var toObject = __webpack_require__(65);\n  var isArrayIter = __webpack_require__(171);\n  var create = __webpack_require__(53);\n  var getPrototypeOf = __webpack_require__(66);\n  var gOPN = __webpack_require__(57).f;\n  var getIterFn = __webpack_require__(173);\n  var uid = __webpack_require__(27);\n  var wks = __webpack_require__(33);\n  var createArrayMethod = __webpack_require__(181);\n  var createArrayIncludes = __webpack_require__(44);\n  var speciesConstructor = __webpack_require__(216);\n  var ArrayIterators = __webpack_require__(202);\n  var Iterators = __webpack_require__(137);\n  var $iterDetect = __webpack_require__(174);\n  var setSpecies = __webpack_require__(201);\n  var arrayFill = __webpack_require__(197);\n  var arrayCopyWithin = __webpack_require__(194);\n  var $DP = __webpack_require__(19);\n  var $GOPD = __webpack_require__(58);\n  var dP = $DP.f;\n  var gOPD = $GOPD.f;\n  var RangeError = global.RangeError;\n  var TypeError = global.TypeError;\n  var Uint8Array = global.Uint8Array;\n  var ARRAY_BUFFER = 'ArrayBuffer';\n  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;\n  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\n  var PROTOTYPE = 'prototype';\n  var ArrayProto = Array[PROTOTYPE];\n  var $ArrayBuffer = $buffer.ArrayBuffer;\n  var $DataView = $buffer.DataView;\n  var arrayForEach = createArrayMethod(0);\n  var arrayFilter = createArrayMethod(2);\n  var arraySome = createArrayMethod(3);\n  var arrayEvery = createArrayMethod(4);\n  var arrayFind = createArrayMethod(5);\n  var arrayFindIndex = createArrayMethod(6);\n  var arrayIncludes = createArrayIncludes(true);\n  var arrayIndexOf = createArrayIncludes(false);\n  var arrayValues = ArrayIterators.values;\n  var arrayKeys = ArrayIterators.keys;\n  var arrayEntries = ArrayIterators.entries;\n  var arrayLastIndexOf = ArrayProto.lastIndexOf;\n  var arrayReduce = ArrayProto.reduce;\n  var arrayReduceRight = ArrayProto.reduceRight;\n  var arrayJoin = ArrayProto.join;\n  var arraySort = ArrayProto.sort;\n  var arraySlice = ArrayProto.slice;\n  var arrayToString = ArrayProto.toString;\n  var arrayToLocaleString = ArrayProto.toLocaleString;\n  var ITERATOR = wks('iterator');\n  var TAG = wks('toStringTag');\n  var TYPED_CONSTRUCTOR = uid('typed_constructor');\n  var DEF_CONSTRUCTOR = uid('def_constructor');\n  var ALL_CONSTRUCTORS = $typed.CONSTR;\n  var TYPED_ARRAY = $typed.TYPED;\n  var VIEW = $typed.VIEW;\n  var WRONG_LENGTH = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function (O, length) {\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function () {\n    // eslint-disable-next-line no-undef\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {\n    new Uint8Array(1).set({});\n  });\n\n  var toOffset = function (it, BYTES) {\n    var offset = toInteger(it);\n    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function (it) {\n    if (isObject(it) && TYPED_ARRAY in it) return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function (C, length) {\n    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function (O, list) {\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function (C, list) {\n    var index = 0;\n    var length = list.length;\n    var result = allocate(C, length);\n    while (length > index) result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function (it, key, internal) {\n    dP(it, key, { get: function () { return this._d[internal]; } });\n  };\n\n  var $from = function from(source /* , mapfn, thisArg */) {\n    var O = toObject(source);\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var iterFn = getIterFn(O);\n    var i, length, values, result, step, iterator;\n    if (iterFn != undefined && !isArrayIter(iterFn)) {\n      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {\n        values.push(step.value);\n      } O = values;\n    }\n    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);\n    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/* ...items */) {\n    var index = 0;\n    var length = arguments.length;\n    var result = allocate(this, length);\n    while (length > index) result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString() {\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /* , end */) {\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /* , thisArg */) {\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /* , thisArg */) {\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /* , thisArg */) {\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /* , thisArg */) {\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /* , thisArg */) {\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /* , fromIndex */) {\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /* , fromIndex */) {\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator) { // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /* , thisArg */) {\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse() {\n      var that = this;\n      var length = validate(that).length;\n      var middle = Math.floor(length / 2);\n      var index = 0;\n      var value;\n      while (index < middle) {\n        value = that[index];\n        that[index++] = that[--length];\n        that[length] = value;\n      } return that;\n    },\n    some: function some(callbackfn /* , thisArg */) {\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn) {\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end) {\n      var O = validate(this);\n      var length = O.length;\n      var $begin = toAbsoluteIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end) {\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /* , offset */) {\n    validate(this);\n    var offset = toOffset(arguments[1], 1);\n    var length = this.length;\n    var src = toObject(arrayLike);\n    var len = toLength(src.length);\n    var index = 0;\n    if (len + offset > length) throw RangeError(WRONG_LENGTH);\n    while (index < len) this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries() {\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys() {\n      return arrayKeys.call(validate(this));\n    },\n    values: function values() {\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function (target, key) {\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key) {\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc) {\n    if (isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ) {\n      target[key] = desc.value;\n      return target;\n    } return dP(target, key, desc);\n  };\n\n  if (!ALL_CONSTRUCTORS) {\n    $GOPD.f = $getDesc;\n    $DP.f = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty: $setDesc\n  });\n\n  if (fails(function () { arrayToString.call({}); })) {\n    arrayToString = arrayToLocaleString = function toString() {\n      return arrayJoin.call(this);\n    };\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice: $slice,\n    set: $set,\n    constructor: function () { /* noop */ },\n    toString: arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function () { return this[TYPED_ARRAY]; }\n  });\n\n  // eslint-disable-next-line max-statements\n  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {\n    CLAMPED = !!CLAMPED;\n    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + KEY;\n    var SETTER = 'set' + KEY;\n    var TypedArray = global[NAME];\n    var Base = TypedArray || {};\n    var TAC = TypedArray && getPrototypeOf(TypedArray);\n    var FORCED = !TypedArray || !$typed.ABV;\n    var O = {};\n    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function (that, index) {\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function (that, index, value) {\n      var data = that._d;\n      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function (that, index) {\n      dP(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if (FORCED) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME, '_d');\n        var index = 0;\n        var offset = 0;\n        var buffer, byteLength, length, klass;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new $ArrayBuffer(byteLength);\n        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (TYPED_ARRAY in data) {\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if (!fails(function () {\n      TypedArray(1);\n    }) || !fails(function () {\n      new TypedArray(-1); // eslint-disable-line no-new\n    }) || !$iterDetect(function (iter) {\n      new TypedArray(); // eslint-disable-line no-new\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(1.5); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if (!isObject(data)) return new Base(toIndex(data));\n        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if (TYPED_ARRAY in data) return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {\n        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator = TypedArrayPrototype[ITERATOR];\n    var CORRECT_ITER_NAME = !!$nativeIterator\n      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);\n    var $iterator = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {\n      dP(TypedArrayPrototype, TAG, {\n        get: function () { return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES\n    });\n\n    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {\n      from: $from,\n      of: $of\n    });\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;\n\n    $export($export.P + $export.F * fails(function () {\n      new TypedArray(1).slice();\n    }), NAME, { slice: $slice });\n\n    $export($export.P + $export.F * (fails(function () {\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();\n    }) || !fails(function () {\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, { toLocaleString: $toLocaleString });\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function () { /* empty */ };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanM/ZDZjNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsNEJBQTRCO0FBQzVCLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQiwwQkFBMEIsRUFBRSxFQUFFO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0NBQWdDO0FBQ3pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCw2Q0FBNkMsRUFBRTs7QUFFeEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLG1EQUFtRDtBQUNuRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLG9DQUFvQztBQUNwQztBQUNBLEtBQUs7QUFDTCx3RUFBd0U7QUFDeEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCw4REFBOEQ7QUFDOUQ7QUFDQSxLQUFLO0FBQ0wsd0VBQXdFO0FBQ3hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCx5QkFBeUIsc0JBQXNCLEVBQUUsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLHlCQUF5QjtBQUN6QixLQUFLO0FBQ0wsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QyxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUwsdURBQXVELDZCQUE2QixFQUFFO0FBQ3RGO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLHVEQUF1RCxZQUFZOztBQUVuRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxVQUFVLGdCQUFnQjs7QUFFL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUssV0FBVyxrQ0FBa0M7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DIiwiZmlsZSI6IjIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKSB7XG4gIHZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuICB2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG4gIHZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG4gIHZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4gIHZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xuICB2YXIgJGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xuICB2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG4gIHZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbiAgdmFyIHByb3BlcnR5RGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbiAgdmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4gIHZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuICB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuICB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbiAgdmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xuICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbiAgdmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbiAgdmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG4gIHZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbiAgdmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xuICB2YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG4gIHZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuICB2YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuICB2YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4gIHZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbiAgdmFyIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpO1xuICB2YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuICB2YXIgQXJyYXlJdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xuICB2YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG4gIHZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG4gIHZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbiAgdmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbiAgdmFyIGFycmF5Q29weVdpdGhpbiA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyk7XG4gIHZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbiAgdmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbiAgdmFyIGRQID0gJERQLmY7XG4gIHZhciBnT1BEID0gJEdPUEQuZjtcbiAgdmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbiAgdmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG4gIHZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuICB2YXIgU0hBUkVEX0JVRkZFUiA9ICdTaGFyZWQnICsgQVJSQVlfQlVGRkVSO1xuICB2YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xuICB2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXlbUFJPVE9UWVBFXTtcbiAgdmFyICRBcnJheUJ1ZmZlciA9ICRidWZmZXIuQXJyYXlCdWZmZXI7XG4gIHZhciAkRGF0YVZpZXcgPSAkYnVmZmVyLkRhdGFWaWV3O1xuICB2YXIgYXJyYXlGb3JFYWNoID0gY3JlYXRlQXJyYXlNZXRob2QoMCk7XG4gIHZhciBhcnJheUZpbHRlciA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpO1xuICB2YXIgYXJyYXlTb21lID0gY3JlYXRlQXJyYXlNZXRob2QoMyk7XG4gIHZhciBhcnJheUV2ZXJ5ID0gY3JlYXRlQXJyYXlNZXRob2QoNCk7XG4gIHZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbiAgdmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG4gIHZhciBhcnJheUluY2x1ZGVzID0gY3JlYXRlQXJyYXlJbmNsdWRlcyh0cnVlKTtcbiAgdmFyIGFycmF5SW5kZXhPZiA9IGNyZWF0ZUFycmF5SW5jbHVkZXMoZmFsc2UpO1xuICB2YXIgYXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXM7XG4gIHZhciBhcnJheUtleXMgPSBBcnJheUl0ZXJhdG9ycy5rZXlzO1xuICB2YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcbiAgdmFyIGFycmF5TGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mO1xuICB2YXIgYXJyYXlSZWR1Y2UgPSBBcnJheVByb3RvLnJlZHVjZTtcbiAgdmFyIGFycmF5UmVkdWNlUmlnaHQgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0O1xuICB2YXIgYXJyYXlKb2luID0gQXJyYXlQcm90by5qb2luO1xuICB2YXIgYXJyYXlTb3J0ID0gQXJyYXlQcm90by5zb3J0O1xuICB2YXIgYXJyYXlTbGljZSA9IEFycmF5UHJvdG8uc2xpY2U7XG4gIHZhciBhcnJheVRvU3RyaW5nID0gQXJyYXlQcm90by50b1N0cmluZztcbiAgdmFyIGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBBcnJheVByb3RvLnRvTG9jYWxlU3RyaW5nO1xuICB2YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG4gIHZhciBUQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG4gIHZhciBUWVBFRF9DT05TVFJVQ1RPUiA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKTtcbiAgdmFyIERFRl9DT05TVFJVQ1RPUiA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBBTExfQ09OU1RSVUNUT1JTID0gJHR5cGVkLkNPTlNUUjtcbiAgdmFyIFRZUEVEX0FSUkFZID0gJHR5cGVkLlRZUEVEO1xuICB2YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xuICB2YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT09IDE7XG4gIH0pO1xuXG4gIHZhciBGT1JDRURfU0VUID0gISFVaW50OEFycmF5ICYmICEhVWludDhBcnJheVtQUk9UT1RZUEVdLnNldCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBpZiAoaXNPYmplY3QoaXQpICYmIFRZUEVEX0FSUkFZIGluIGl0KSByZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiAoQywgbGVuZ3RoKSB7XG4gICAgaWYgKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24gKE8sIGxpc3QpIHtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSwgaW50ZXJuYWwpIHtcbiAgICBkUChpdCwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH0gfSk7XG4gIH07XG5cbiAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3Qoc291cmNlKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspIHtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmIChtYXBwaW5nICYmIGFMZW4gPiAyKSBtYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoLyogLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbiAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSkgOiB2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG8gPSB7XG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qICwgZW5kICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCwgZW5kICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbGlkYXRlKHRoYXQpLmxlbmd0aDtcbiAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IG1pZGRsZSkge1xuICAgICAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheVNvbWUodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIE8gPSB2YWxpZGF0ZSh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcbiAgICAgIHZhciAkYmVnaW4gPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciAkc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyogLCBvZmZzZXQgKi8pIHtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIHNyYyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbiArIG9mZnNldCA+IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldClcbiAgICAgICYmIHRhcmdldFtUWVBFRF9BUlJBWV1cbiAgICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcbiAgICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcbiAgdmFyICRnZXREZXNjID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgaWYgKGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICAmJiBpc09iamVjdChkZXNjKVxuICAgICAgJiYgaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgICAmJiAhaGFzKGRlc2MsICdnZXQnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnc2V0JylcbiAgICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgICAmJiAhZGVzYy5jb25maWd1cmFibGVcbiAgICAgICYmICghaGFzKGRlc2MsICd3cml0YWJsZScpIHx8IGRlc2Mud3JpdGFibGUpXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSlcbiAgICApIHtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmICghQUxMX0NPTlNUUlVDVE9SUykge1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAkc2V0RGVzY1xuICB9KTtcblxuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSkge1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICRzbGljZSxcbiAgICBzZXQ6ICRzZXQsXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTsgfVxuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIENMQU1QRUQgPSAhIUNMQU1QRUQ7XG4gICAgdmFyIE5BTUUgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSc7XG4gICAgdmFyIEdFVFRFUiA9ICdnZXQnICsgS0VZO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIEtFWTtcbiAgICB2YXIgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXTtcbiAgICB2YXIgQmFzZSA9IFR5cGVkQXJyYXkgfHwge307XG4gICAgdmFyIFRBQyA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSk7XG4gICAgdmFyIEZPUkNFRCA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWO1xuICAgIHZhciBPID0ge307XG4gICAgdmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5ICYmIFR5cGVkQXJyYXlbUFJPVE9UWVBFXTtcbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4ZmYgPyAweGZmIDogdmFsdWUgJiAweGZmO1xuICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheSgxKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0pIHx8ICEkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgQmFzZSh0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheSkpIGhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYgKCFMSUJSQVJZKSBUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdO1xuICAgIHZhciBDT1JSRUNUX0lURVJfTkFNRSA9ICEhJG5hdGl2ZUl0ZXJhdG9yXG4gICAgICAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcbiAgICB2YXIgJGl0ZXJhdG9yID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgaGlkZShUeXBlZEFycmF5LCBUWVBFRF9DT05TVFJVQ1RPUiwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBUWVBFRF9BUlJBWSwgTkFNRSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIERFRl9DT05TVFJVQ1RPUiwgVHlwZWRBcnJheSk7XG5cbiAgICBpZiAoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSB7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFU1xuICAgIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IEJhc2Uub2YuY2FsbChUeXBlZEFycmF5LCAxKTsgfSksIE5BTUUsIHtcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QLCBOQU1FLCBwcm90byk7XG5cbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRURfU0VULCBOQU1FLCB7IHNldDogJHNldCB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgIGlmICghTElCUkFSWSAmJiBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgPSBhcnJheVRvU3RyaW5nO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7IHNsaWNlOiAkc2xpY2UgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHsgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZyB9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmICghTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 238:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(237)('Uint8', 1, function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanM/ZGQzYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 239:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(237)('Uint8', 1, function (init) {\n  return function Uint8ClampedArray(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n}, true);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qcz9lYmExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 240:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(237)('Int16', 2, function (init) {\n  return function Int16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanM/MjkyOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMjQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 241:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(237)('Uint16', 2, function (init) {\n  return function Uint16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzPzIzMzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 242:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(237)('Int32', 4, function (init) {\n  return function Int32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanM/NTYyNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 243:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(237)('Uint32', 4, function (init) {\n  return function Uint32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzPzgyZWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 244:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(237)('Float32', 4, function (init) {\n  return function Float32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcz9lOGQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 245:
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(237)('Float64', 8, function (init) {\n  return function Float64Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcz8yNDAwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 246:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar $export = __webpack_require__(16);\nvar aFunction = __webpack_require__(29);\nvar anObject = __webpack_require__(20);\nvar rApply = (__webpack_require__(12).Reflect || {}).apply;\nvar fApply = Function.apply;\n// MS Edge argumentsList argument is optional\n$export($export.S + $export.F * !__webpack_require__(15)(function () {\n  rApply(function () { /* empty */ });\n}), 'Reflect', {\n  apply: function apply(target, thisArgument, argumentsList) {\n    var T = aFunction(target);\n    var L = anObject(argumentsList);\n    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcz8xOTcwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgckFwcGx5ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5O1xudmFyIGZBcHBseSA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgckFwcGx5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCkge1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldCk7XG4gICAgdmFyIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 247:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar $export = __webpack_require__(16);\nvar create = __webpack_require__(53);\nvar aFunction = __webpack_require__(29);\nvar anObject = __webpack_require__(20);\nvar isObject = __webpack_require__(21);\nvar fails = __webpack_require__(15);\nvar bind = __webpack_require__(84);\nvar rConstruct = (__webpack_require__(12).Reflect || {}).construct;\n\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails(function () {\n  function F() { /* empty */ }\n  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function () {\n  rConstruct(function () { /* empty */ });\n});\n\n$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {\n  construct: function construct(Target, args /* , newTarget */) {\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);\n    if (Target == newTarget) {\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch (args.length) {\n        case 0: return new Target();\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (bind.apply(Target, $args))();\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto = newTarget.prototype;\n    var instance = create(isObject(proto) ? proto : Object.prototype);\n    var result = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanM/YTAwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsbUNBQW1DLGNBQWM7QUFDakQsQ0FBQztBQUNEO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9fYmluZCcpO1xudmFyIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0O1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyogLCBuZXdUYXJnZXQgKi8pIHtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 248:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\nvar dP = __webpack_require__(19);\nvar $export = __webpack_require__(16);\nvar anObject = __webpack_require__(20);\nvar toPrimitive = __webpack_require__(24);\n\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n$export($export.S + $export.F * __webpack_require__(15)(function () {\n  // eslint-disable-next-line no-undef\n  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });\n}), 'Reflect', {\n  defineProperty: function defineProperty(target, propertyKey, attributes) {\n    anObject(target);\n    propertyKey = toPrimitive(propertyKey, true);\n    anObject(attributes);\n    try {\n      dP.f(target, propertyKey, attributes);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanM/YzI5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxNQUFNLFdBQVcsT0FBTyxXQUFXO0FBQ25FLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjI0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7IHZhbHVlOiAxIH0pLCAxLCB7IHZhbHVlOiAyIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 249:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar $export = __webpack_require__(16);\nvar gOPD = __webpack_require__(58).f;\nvar anObject = __webpack_require__(20);\n\n$export($export.S, 'Reflect', {\n  deleteProperty: function deleteProperty(target, propertyKey) {\n    var desc = gOPD(anObject(target), propertyKey);\n    return desc && !desc.configurable ? false : delete target[propertyKey];\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanM/NTFkMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 250:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 26.1.5 Reflect.enumerate(target)\nvar $export = __webpack_require__(16);\nvar anObject = __webpack_require__(20);\nvar Enumerate = function (iterated) {\n  this._t = anObject(iterated); // target\n  this._i = 0;                  // next index\n  var keys = this._k = [];      // keys\n  var key;\n  for (key in iterated) keys.push(key);\n};\n__webpack_require__(138)(Enumerate, 'Object', function () {\n  var that = this;\n  var keys = that._k;\n  var key;\n  do {\n    if (that._i >= keys.length) return { value: undefined, done: true };\n  } while (!((key = keys[that._i++]) in that._t));\n  return { value: key, done: false };\n});\n\n$export($export.S, 'Reflect', {\n  enumerate: function enumerate(target) {\n    return new Enumerate(target);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanM/NTRlYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGNBQWM7QUFDZCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxHQUFHO0FBQ0gsVUFBVTtBQUNWLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjI1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgRW51bWVyYXRlID0gZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdOyAgICAgIC8vIGtleXNcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gaXRlcmF0ZWQpIGtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBrZXlzID0gdGhhdC5faztcbiAgdmFyIGtleTtcbiAgZG8ge1xuICAgIGlmICh0aGF0Ll9pID49IGtleXMubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH0gd2hpbGUgKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4geyB2YWx1ZToga2V5LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 251:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nvar gOPD = __webpack_require__(58);\nvar getPrototypeOf = __webpack_require__(66);\nvar has = __webpack_require__(13);\nvar $export = __webpack_require__(16);\nvar isObject = __webpack_require__(21);\nvar anObject = __webpack_require__(20);\n\nfunction get(target, propertyKey /* , receiver */) {\n  var receiver = arguments.length < 3 ? target : arguments[2];\n  var desc, proto;\n  if (anObject(target) === receiver) return target[propertyKey];\n  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')\n    ? desc.value\n    : desc.get !== undefined\n      ? desc.get.call(receiver)\n      : undefined;\n  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);\n}\n\n$export($export.S, 'Reflect', { get: get });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanM/MmQwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixXQUFXIiwiZmlsZSI6IjI1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzYywgcHJvdG87XG4gIGlmIChhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmIChkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKSByZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgZ2V0OiBnZXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 252:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\nvar gOPD = __webpack_require__(58);\nvar $export = __webpack_require__(16);\nvar anObject = __webpack_require__(20);\n\n$export($export.S, 'Reflect', {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {\n    return gOPD.f(anObject(target), propertyKey);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanM/NzQxNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 253:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.8 Reflect.getPrototypeOf(target)\nvar $export = __webpack_require__(16);\nvar getProto = __webpack_require__(66);\nvar anObject = __webpack_require__(20);\n\n$export($export.S, 'Reflect', {\n  getPrototypeOf: function getPrototypeOf(target) {\n    return getProto(anObject(target));\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mLmpzPzQ4NTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjI1My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 254:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.9 Reflect.has(target, propertyKey)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Reflect', {\n  has: function has(target, propertyKey) {\n    return propertyKey in target;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanM/ZWQyMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDI1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 255:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.10 Reflect.isExtensible(target)\nvar $export = __webpack_require__(16);\nvar anObject = __webpack_require__(20);\nvar $isExtensible = Object.isExtensible;\n\n$export($export.S, 'Reflect', {\n  isExtensible: function isExtensible(target) {\n    anObject(target);\n    return $isExtensible ? $isExtensible(target) : true;\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzP2Q4MDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMjU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 256:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.11 Reflect.ownKeys(target)\nvar $export = __webpack_require__(16);\n\n$export($export.S, 'Reflect', { ownKeys: __webpack_require__(257) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcz81ZmZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsK0JBQStCLG9DQUFrQyIsImZpbGUiOiIyNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IG93bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 257:
/***/ (function(module, exports, __webpack_require__) {

	eval("// all object keys, includes non-enumerable and symbols\nvar gOPN = __webpack_require__(57);\nvar gOPS = __webpack_require__(50);\nvar anObject = __webpack_require__(20);\nvar Reflect = __webpack_require__(12).Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = gOPN.f(anObject(it));\n  var getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanM/N2Y0ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdPUE4uZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 258:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.12 Reflect.preventExtensions(target)\nvar $export = __webpack_require__(16);\nvar anObject = __webpack_require__(20);\nvar $preventExtensions = Object.preventExtensions;\n\n$export($export.S, 'Reflect', {\n  preventExtensions: function preventExtensions(target) {\n    anObject(target);\n    try {\n      if ($preventExtensions) $preventExtensions(target);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanM/NTU4NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYgKCRwcmV2ZW50RXh0ZW5zaW9ucykgJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAyNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 259:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nvar dP = __webpack_require__(19);\nvar gOPD = __webpack_require__(58);\nvar getPrototypeOf = __webpack_require__(66);\nvar has = __webpack_require__(13);\nvar $export = __webpack_require__(16);\nvar createDesc = __webpack_require__(25);\nvar anObject = __webpack_require__(20);\nvar isObject = __webpack_require__(21);\n\nfunction set(target, propertyKey, V /* , receiver */) {\n  var receiver = arguments.length < 4 ? target : arguments[3];\n  var ownDesc = gOPD.f(anObject(target), propertyKey);\n  var existingDescriptor, proto;\n  if (!ownDesc) {\n    if (isObject(proto = getPrototypeOf(target))) {\n      return set(proto, propertyKey, V, receiver);\n    }\n    ownDesc = createDesc(0);\n  }\n  if (has(ownDesc, 'value')) {\n    if (ownDesc.writable === false || !isObject(receiver)) return false;\n    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);\n    existingDescriptor.value = V;\n    dP.f(receiver, propertyKey, existingDescriptor);\n    return true;\n  }\n  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n}\n\n$export($export.S, 'Reflect', { set: set });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanM/NmUxOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFdBQVciLCJmaWxlIjoiMjU5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXTtcbiAgdmFyIG93bkRlc2MgPSBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB2YXIgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcbiAgaWYgKCFvd25EZXNjKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmIChoYXMob3duRGVzYywgJ3ZhbHVlJykpIHtcbiAgICBpZiAob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGNyZWF0ZURlc2MoMCk7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBzZXQ6IHNldCB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 260:
/***/ (function(module, exports, __webpack_require__) {

	eval("// 26.1.14 Reflect.setPrototypeOf(target, proto)\nvar $export = __webpack_require__(16);\nvar setProto = __webpack_require__(80);\n\nif (setProto) $export($export.S, 'Reflect', {\n  setPrototypeOf: function setPrototypeOf(target, proto) {\n    setProto.check(target, proto);\n    try {\n      setProto.set(target, proto);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzPzYyNWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjI2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZiAoc2V0UHJvdG8pICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pIHtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 261:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {\n    return {\n        'views/shared/singlevalue/Master': __webpack_require__(\"views/shared/singlevalue/Master\"),\n        'models/Base': __webpack_require__(\"models/Base\")\n    };\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvYnVpbGRfdG9vbHMvcHJvZmlsZXMvc2luZ2xlX3ZhbHVlL2V4cG9zZWRNb2R1bGVzLmpzP2M3ZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImtDQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjI2MS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9NYXN0ZXInOiByZXF1aXJlKCd2aWV3cy9zaGFyZWQvc2luZ2xldmFsdWUvTWFzdGVyJyksXG4gICAgICAgICdtb2RlbHMvQmFzZSc6IHJlcXVpcmUoJ21vZGVscy9CYXNlJylcbiAgICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9idWlsZF90b29scy9wcm9maWxlcy9zaW5nbGVfdmFsdWUvZXhwb3NlZE1vZHVsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "views/shared/singlevalue/Master":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\"),\n        module,\n        __webpack_require__(\"views/shared/viz/Base\"),\n        __webpack_require__(\"views/shared/singlevalue/Sparkline\"),\n        __webpack_require__(\"views/shared/singlevalue/MainBody\"),\n        __webpack_require__(\"views/shared/singlevalue/UnderLabel\"),\n        __webpack_require__(\"models/Base\"),\n        __webpack_require__(\"shim/splunk.util\"),\n        __webpack_require__(\"util/svg\"),\n        __webpack_require__(\"uri/route\"),\n        __webpack_require__(\"util/drilldown\"),\n        __webpack_require__(\"util/time\"),\n        __webpack_require__(\"util/color_utils\"),\n        __webpack_require__(\"util/general_utils\"),\n        __webpack_require__(\"util/moment/relative\"),\n        __webpack_require__(\"util/theme_utils\"),\n        __webpack_require__(\"util/numeral\"),\n        __webpack_require__(\"splunk/palettes/ColorCodes\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n        $,\n        _,\n        module,\n        VisualizationBase,\n        Sparkline,\n        MainBodyView,\n        UnderLabelView,\n        BaseModel,\n        splunkUtil,\n        svgUtil,\n        route,\n        drilldownUtil,\n        timeUtil,\n        colorUtil,\n        generalUtil,\n        relativeMomentUtil,\n        themeUtils,\n        numeral,\n        ColorCodes\n    ) {\n\n        var THEMES = {\n            enterprise: {\n                SEVERITY_COLORS: {\n                    severe: ColorCodes.SEMANTIC_BY_NAME.error,\n                    high: ColorCodes.SEMANTIC_BY_NAME.alert,\n                    elevated: ColorCodes.SEMANTIC_BY_NAME.warning,\n                    guarded: ColorCodes.SEMANTIC_BY_NAME.info,\n                    low: ColorCodes.SEMANTIC_BY_NAME.success,\n                    none: ColorCodes.DARK_GREY\n                },\n                SEVERITIES: ['none', 'low', 'guarded', 'elevated', 'high', 'severe'],\n                BLOCK_DEFAULT_FONT_COLOR: '#FFFFFF',\n                BLOCK_DEFAULT_BACKGROUND_COLOR: '#333333',\n                DEFAULT_FONT_COLOR: '#333333',\n                DEFAULT_BACKGROUND_COLOR: '#FFFFFF',\n                UNDERLABEL_COLOR: ColorCodes.DARK_GREY,\n                NEUTRAL_CHANGE_COLOR: ColorCodes.DARK_GREY,\n                NEUTRAL_CHANGE_BACKGROUND_COLOR: ColorCodes.DARK_GREY,\n                DELTA_GREEN: ColorCodes.SEMANTIC_BY_NAME.success,\n                DELTA_RED: ColorCodes.SEMANTIC_BY_NAME.error,\n                EDGE_PADDING: 32,\n                NEUTRAL_SPARKLINE_COLOR: '#999999'\n            },\n            dark: {\n                SEVERITY_COLORS: {\n                    severe: ColorCodes.SEMANTIC_BY_NAME.error,\n                    high: ColorCodes.SEMANTIC_BY_NAME.alert,\n                    elevated: ColorCodes.SEMANTIC_BY_NAME.warning,\n                    guarded: ColorCodes.SEMANTIC_BY_NAME.info,\n                    low: ColorCodes.SEMANTIC_BY_NAME.success,\n                    none: '#FFFFFF'\n                },\n                SEVERITIES: ['none', 'low', 'guarded', 'elevated', 'high', 'severe'],\n                BLOCK_DEFAULT_FONT_COLOR: '#FFFFFF', // $white\n                BLOCK_DEFAULT_BACKGROUND_COLOR: '#212527', // $gray21\n                DEFAULT_FONT_COLOR: '#FFFFFF', // $white\n                DEFAULT_BACKGROUND_COLOR: '#212527', // $gray21\n                UNDERLABEL_COLOR: '#C3CBD4', // $gray80\n                NEUTRAL_CHANGE_COLOR: '#FFFFFF', // $white\n                NEUTRAL_CHANGE_BACKGROUND_COLOR: '#212527', // $gray21\n                DELTA_GREEN: ColorCodes.SEMANTIC_BY_NAME.success,\n                DELTA_RED: ColorCodes.SEMANTIC_BY_NAME.error,\n                EDGE_PADDING: 32,\n                NEUTRAL_SPARKLINE_COLOR: '#FFFFFF'\n            }\n        };\n\n        return VisualizationBase.extend(_.extend({\n            moduleId: module.id,\n            className: \"single-value\",\n\n            MAX_RESULT_COUNT: 1000,\n\n            initialize: function(options) {\n                VisualizationBase.prototype.initialize.apply(this, arguments);\n\n                this.$el.width(this.options.width || '100%');\n                this.$el.height(this.options.height || '100%');\n                this.$el.css('position', 'relative');\n\n                // setup searchData and searchParam model\n                if (this.getPrimaryDataSource()) {\n                    this.model.searchData = this.getPrimaryDataSource().searchResults;\n                    this.model.searchDataParams = this.getPrimaryDataSource().fetchParams;\n                } else {\n                    this.listenTo(this.model.searchData, 'change', this.onDataChange);\n                }\n\n                this.model.results = new BaseModel({\n                    searchResultsColumn: this.model.searchData,\n                    resultField: '',\n                    resultFieldValue: ''\n                });\n\n                this.model.presentation = new BaseModel();\n\n                this.updateContainerDimensions();\n\n                this.originalHeight = this.$el.height();\n\n                this.model.presentation.set({\n                    fontColor: this.getFontColor(),\n                    scaleRatio: 1,\n                    edgePadding: this.EDGE_PADDING\n                });\n\n\n                this.$inlineMessage = $('<div class=\"inline-message\"></div>').css({\n                        \"text-align\":\"center\",\n                        \"height\":\"32px\",\n                        \"width\":\"100%\",\n                        \"position\":\"absolute\",\n                        \"bottom\":\"0\"})\n                    .addClass(this.options.messageContainerClass || '');\n\n            },\n\n            getRequiredDataSources: function() {\n                return [];\n            },\n\n            onConfigChange: function(changedAttributes) {\n                var shouldInvalidate = _(changedAttributes).chain().keys()\n                    .any(function(key) {\n                        return key.indexOf('display.visualizations.singlevalue.') === 0;\n                    })\n                    .value();\n\n                if (shouldInvalidate) {\n                    this.invalidate('formatDataPass');\n                }\n            },\n\n            updateResultState: function() {\n                var resultField = this.determineResultFieldName(this.model.config.get(\"display.visualizations.singlevalue.field\")),\n                    resultFieldValue = this.getFieldValue(resultField),\n                    fontColor,\n                    sparklineData,\n                    sparklineColor,\n                    deltaIndicatorColor;\n                // If the first column is _time, then it is a timechart and contains\n                // multiple result rows, and therefore should display a sparkline.\n                // Else, it should just display a standard single result value\n                this.model.results.set('resultField', resultField);\n                this.model.results.set('resultFieldValue', resultFieldValue);\n\n                if (this.isTimeSeries() && !isNaN(resultFieldValue)) {\n                    sparklineData = this.getFieldValues(resultField);\n                    this.model.results.set('sparkline', sparklineData);\n                    this.setDeltaValue(resultFieldValue);\n                    // In-mem config attribute - tell Viz Editor that time series viz controls should be displayed\n                    this.model.config.set('is_timeseries', true, {'transient': true});\n                } else {\n                    this.model.results.unset('sparkline');\n                    this.model.results.unset('deltaValue');\n                    this.model.results.unset('deltaBacktrack');\n\n                    // In-mem config attribute - tell Viz Editor that time series viz controls should be hidden\n                    this.model.config.set('is_timeseries', false, {'transient': true});\n                }\n\n                this.severityColor = this.getSeverityColor(resultFieldValue);\n                this.severityBackgroundColor = this.getSeverityColor(resultFieldValue, { isBackground: true });\n                this.deltaColor = this.getDeltaColor();\n                this.deltaBackgroundColor = this.getDeltaColor({ isBackground: true });\n\n                deltaIndicatorColor = this.getDeltaIndicatorColor();\n                if ((this.useColors() && this.model.config.get('display.visualizations.singlevalue.colorBy') === 'trend')\n                    || this.hasBackground()) {\n                    sparklineColor = deltaIndicatorColor;\n                } else {\n                    sparklineColor = this.NEUTRAL_SPARKLINE_COLOR;\n                }\n                this.model.presentation.set('deltaColor', deltaIndicatorColor);\n                this.model.presentation.set('sparklineColor', sparklineColor);\n                this.model.presentation.set('fontColor', this.getFontColor());\n                this.model.presentation.set('formatPattern', this.getFormatPattern());\n            },\n\n            getDeltaColor: function(options) {\n                var deltaMode = this.model.config.get('display.visualizations.singlevalue.trendColorInterpretation') || 'standard', // defaults to standard\n                    deltaValue = this.model.results.get('deltaValue'),\n                    deltaIncreased = deltaValue === 'percentageIncrease' || deltaValue > 0;\n                if (deltaValue === 0) {\n                    return options && options.isBackground ? this.NEUTRAL_CHANGE_BACKGROUND_COLOR : this.NEUTRAL_CHANGE_COLOR;\n                }\n                if (deltaMode === 'inverse') {\n                    if (deltaIncreased) {\n                        return this.DELTA_RED;\n                    }\n                    return this.DELTA_GREEN;\n                } else {\n                    if (deltaIncreased) {\n                        return this.DELTA_GREEN;\n                    }\n                    return this.DELTA_RED;\n                }\n            },\n\n            getSeverityColor: function(resultFieldValue, options) {\n                var ranges = this.model.config.get('display.visualizations.singlevalue.rangeValues'),\n                    colors = this.model.config.get('display.visualizations.singlevalue.rangeColors'),\n                    useColors = splunkUtil.normalizeBoolean(this.model.config.get('display.visualizations.singlevalue.useColors')) || false,\n                    defaultColor = options && options.isBackground ? this.BLOCK_DEFAULT_BACKGROUND_COLOR : this.DEFAULT_FONT_COLOR,\n                    rangeMapValue = this.getResultField('range'),\n                    parsedRanges,\n                    parsedColors,\n                    colorsDefined,\n                    severities;\n\n                // Legacy single value behavior dictates that if there is a rangemap in the results, that will color the viz.\n                // We also check that useColors is false. If it is true, the user is explicitly using the rangeColors\n                if (rangeMapValue && !useColors) {\n                    // If the classField is used and the range field contains is a valid severity, use this as the severity\n                    return this.SEVERITY_COLORS[rangeMapValue] || defaultColor;\n                }\n                if (ranges) {\n                    parsedRanges = generalUtil.stringToArray(ranges);\n                    parsedColors = generalUtil.stringToArray(colors);\n                    colorsDefined = parsedColors.length > 0;\n                    if (parsedRanges.length === 0 || isNaN(resultFieldValue)) {\n                        return defaultColor;\n                    }\n                    severities = this.SEVERITIES.slice(1, 6); // discard 'none'\n                    for (var i = 0; i < parsedRanges.length; i++) {\n                        if(isNaN(parsedRanges[i])){\n                            return defaultColor;\n                        }\n                        if (parseFloat(resultFieldValue) <= parseFloat(parsedRanges[i])) {\n                            // As soon as we encounter a range that is greater than or equal to the resultFieldValue,\n                            // that is the severity range that the resultFieldValue falls into, so we exit the loop and function.\n                            if (colorsDefined) {\n                                return colorUtil.replaceSymbols(parsedColors[i], '#') || defaultColor;\n                            }\n                            return this.SEVERITY_COLORS[severities[i]];\n                        }\n                    }\n                    if (colorsDefined) {\n                        // If there are more ranges than colors, assign the default grey color\n                        return colorUtil.replaceSymbols(parsedColors[parsedRanges.length], '#') || defaultColor;\n                    }\n                    return this.SEVERITY_COLORS[severities[severities.length - 1]]; // if no severity has yet been assigned, has fallen through to highest severity\n                }\n\n                return defaultColor; // fall through to default\n            },\n\n            getDeltaIndicatorColor: function() {\n                var colorBy = this.model.config.get('display.visualizations.singlevalue.colorBy');\n                if (this.hasBackground()) {\n                    return this.BLOCK_DEFAULT_FONT_COLOR;\n                }\n                if (colorBy === 'value' || !this.useColors()) {\n                    return this.DEFAULT_FONT_COLOR;\n                }\n                return this.deltaColor;\n            },\n\n            getFontColor: function() {\n                var colorBy = this.model.config.get('display.visualizations.singlevalue.colorBy');\n                if (this.hasBackground()) {\n                    return this.BLOCK_DEFAULT_FONT_COLOR;\n                }\n                if ((colorBy === 'trend' && this.isTimeSeries()) || !this.useColors()) {\n                    return this.DEFAULT_FONT_COLOR;\n                }\n                return this.severityColor;\n            },\n\n            useColors: function() {\n                var useColors = splunkUtil.normalizeBoolean(this.model.config.get('display.visualizations.singlevalue.useColors')) || false, // default to false\n                    rangeMapValue = this.getFieldValues('range');\n                // Default to use old Rangemap command result if useColors is not set.\n                if (rangeMapValue && !useColors) {\n                    return true;\n                }\n                return useColors;\n            },\n\n            hasBackground: function() {\n                var backgroundMode = this.model.config.get('display.visualizations.singlevalue.colorMode');\n                return (backgroundMode === 'block' && this.useColors() && this.getBackgroundColor());\n            },\n\n            getBackgroundColor: function() {\n                var colorBy = this.model.config.get('display.visualizations.singlevalue.colorBy');\n                if (this.useColors()) {\n                    if (colorBy === 'trend') {\n                        return this.deltaBackgroundColor;\n                    }\n                    return this.severityBackgroundColor;\n                }\n                return this.BLOCK_DEFAULT_BACKGROUND_COLOR;\n            },\n\n            getFormatPattern: function() {\n                var formatPattern = '0',\n                    matchedPrecision,\n                    decimalPlaces,\n                    numberPrecision = this.model.config.get('display.visualizations.singlevalue.numberPrecision'),\n                    useThousandSeparators = splunkUtil.normalizeBoolean(this.model.config.get('display.visualizations.singlevalue.useThousandSeparators'));\n                if (useThousandSeparators !== false) {\n                    formatPattern += ',0';\n                }\n                if (numberPrecision) {\n                    matchedPrecision = numberPrecision.match(/^0\\.?(0*)$/);\n                    if (matchedPrecision && matchedPrecision.length === 2) {\n                        decimalPlaces = matchedPrecision[1];\n                        if (decimalPlaces.length > 4) {\n                            // User wants a large d.p. value, so revert them to the allowed max\n                            decimalPlaces = '0000';\n                        }\n                        if (decimalPlaces.length > 0) {\n                            formatPattern = formatPattern +  '.' + decimalPlaces;\n                        }\n                    }\n                }\n                return formatPattern;\n            },\n\n            setDeltaValue: function(currentValue) {\n                var deltaTimeRange = this.model.config.get('display.visualizations.singlevalue.trendInterval'),\n                    deltaFormat = this.model.config.get('display.visualizations.singlevalue.trendDisplayMode'),\n                    times = this.getFieldValues('_time'),\n                    parsedTimeArr,\n                    parsedTime,\n                    deltaValue,\n                    deltaBacktrack,\n                    formattedDeltaValue,\n                    resultField = this.model.results.get('resultField'),\n                    timeToBacktrackInSeconds,\n                    dataPointsToBacktrack,\n                    mostRecentDate,\n                    secondMostRecentDate,\n                    deltaDate,\n                    timeGranularityInSeconds,\n                    timeAmount,\n                    timeUnit,\n                    formatPattern = this.getFormatPattern(),\n                    createRecentDateObject = function(offset) {\n                        return timeUtil.bdTimeToDateObject(timeUtil.extractBdTime(times[times.length - offset]));\n                    };\n                if (deltaTimeRange && deltaTimeRange !== 'auto') {\n                    // Calculate diff between values at most recent _time (minus) deltaTimeRange\n                    try {\n                        parsedTimeArr = relativeMomentUtil.parseRelativeTimeExpression(deltaTimeRange);\n                    } catch(err) {\n                        return;\n                    }\n                    if (parsedTimeArr && parsedTimeArr[0]) {\n                        parsedTime = parsedTimeArr[0];\n                    }\n                    if (times.length >= 2 && parsedTime && parsedTime.unit && !isNaN(parsedTime.amount)) {\n                        timeUnit = timeUtil.normalizeUnit(parsedTime.unit);\n                        timeAmount = Math.abs(parsedTime.amount);\n                        // Create 2 copies of the most recent Date object - only deltaDate will be mutated\n                        mostRecentDate = createRecentDateObject(1);\n                        deltaDate = createRecentDateObject(1);\n                        //Compare both granularity of elements in the _time array and\n                        //deltaTimeRange by converting them both to the same units - seconds\n                        secondMostRecentDate = createRecentDateObject(2);\n                        // Compare both granularity of elements in the _time array and\n                        // deltaTimeRange by converting them both to the same units - seconds\n                        timeGranularityInSeconds = (mostRecentDate.getTime() - secondMostRecentDate.getTime()) / 1000; // Convert from milliseconds to seconds by dividing by 1000\n                        if (_.indexOf(['s', 'm', 'h'], timeUnit) !== -1) {\n                            // Seconds, minutes, and hours are affected by Daylight Savings Time, so should NOT use the JS Date() object.\n                            // Instead, they should use BDTime.\n                            timeToBacktrackInSeconds = timeUtil.convertAmountAndUnitToSeconds(timeAmount, timeUnit);\n                        } else {\n                            // Can use the JS Date() object's setter and getter methods as months have irregular numbers of days\n                            // and the Date() object internally handles these inconsistencies when calculating time deltas.\n                            switch (timeUnit) {\n                                case 'y':\n                                    deltaDate.setFullYear(deltaDate.getFullYear() - timeAmount);\n                                    break;\n                                case 'q':\n                                    deltaDate.setMonth(deltaDate.getMonth() - (timeAmount * 3));\n                                    break;\n                                case 'mon':\n                                    deltaDate.setMonth(deltaDate.getMonth() - timeAmount);\n                                    break;\n                                case 'w':\n                                    deltaDate.setDate(deltaDate.getDate() - (timeAmount * 7));\n                                    break;\n                                case 'd':\n                                    deltaDate.setDate(deltaDate.getDate() - timeAmount);\n                                    break;\n                                default:\n                                    deltaDate = undefined;\n                                    return deltaDate;\n                            }\n                            if (deltaDate) {\n                                timeToBacktrackInSeconds = (mostRecentDate.getTime() - deltaDate) / 1000; // Convert form milliseconds to seconds by dividing by 1000\n                            }\n                        }\n\n                        if (timeToBacktrackInSeconds) {\n                            // How many elements back in the _time array we should compare the currentValue to\n                            dataPointsToBacktrack = Math.round(timeToBacktrackInSeconds / timeGranularityInSeconds);\n                            if (dataPointsToBacktrack < times.length) {\n                                deltaValue = this.calculateDeltaValue(resultField, dataPointsToBacktrack, deltaFormat, currentValue);\n                                deltaBacktrack = dataPointsToBacktrack;\n                            }\n                        }\n                    }\n                }\n\n                // Default: if deltaTimeRange is not specified or invalid, delta spans range between most recent and 2nd-most-recent data points\n                if ((!deltaValue && deltaValue !== 0)) {\n                    // If the field is a '_time' field, take the most recent 'count' data point as the field value,\n                    // which is the last element in the 'count' array.\n                    deltaValue = this.calculateDeltaValue(resultField, 1, deltaFormat, currentValue);\n                    deltaBacktrack = 1;\n                }\n\n                if (formatPattern && !isNaN(deltaValue)) {\n                    formattedDeltaValue = numeral(deltaValue).format(formatPattern);\n                    this.model.results.set('formattedDeltaValue', formattedDeltaValue);\n                }\n\n                this.model.results.set('deltaValue', deltaValue);\n                this.model.results.set('deltaBacktrack', deltaBacktrack);\n            },\n\n            calculateDeltaValue: function(resultField, dataPointsToBacktrack, deltaFormat, currentValue) {\n                var previousValue = this.getFieldValue(resultField, dataPointsToBacktrack);\n                if (deltaFormat && deltaFormat.toLowerCase() === 'percent') {\n                    if (previousValue === \"0\") {\n                        if (currentValue === \"0\") {\n                            return 0;\n                        }\n                        // Would return a percentage change value of Infinity, which we must display as 'N/A'\n                        return (currentValue > previousValue) ? 'percentageIncrease' : 'percentageDecrease';\n                    }\n                    return (currentValue - previousValue) / previousValue * 100;\n                }\n                return currentValue - previousValue;\n            },\n\n            onAddedToDocument: function() {\n                VisualizationBase.prototype.onAddedToDocument.apply(this, arguments);\n                this.validateReflow(true);\n            },\n\n            reflow: function() {\n                this.updateContainerDimensions();\n                this.updateBackgroundDimensions();\n                this.invokeOnChildren('validateReflow', true);\n            },\n\n            updateContainerDimensions: function() {\n                var $svgContainer = this.getSvgContainer(),\n                    scaleRatio;\n\n                // For PDF: $el has undefined height and width so set manually to passed in height and width options\n                if (this.model.config.get('exportMode')) {\n                    this.svgWidth = this.options.width;\n                    this.svgHeight = this.options.height;\n                } else {\n                    this.svgHeight = this.$el.height();\n                    this.svgWidth = this.$el.width();\n                }\n\n                if(this.$el.find(this.$inlineMessage).length == 1) {\n                    this.svgHeight = this.svgHeight - this.$inlineMessage.height();\n                }\n\n                if (generalUtil.valuesAreNumericAndFinite([this.svgHeight, this.svgWidth])) {\n                    $svgContainer\n                        .height(this.svgHeight)\n                        .width(this.svgWidth);\n\n                    scaleRatio = this.svgHeight / this.originalHeight;\n                    if (!generalUtil.valuesAreNumericAndFinite([scaleRatio]) || scaleRatio === 0) {\n                        scaleRatio = 1;\n                    }\n\n                    this.model.presentation.set({\n                        svgWidth: this.svgWidth,\n                        svgHeight: this.svgHeight,\n                        scaleRatio: scaleRatio\n                    });\n                }\n            },\n\n            getResultField: function(field) {\n                var resultFieldValue = this.getFieldValue(this.determineResultFieldName(field));\n                if (!resultFieldValue) {\n                    return _('N/A').t();\n                }\n                return resultFieldValue;\n            },\n\n            // Fields can either be a list of strings or a list of dictionaries each with a 'name' entry\n            // depending on whether 'show_metadata' is enabled\n            getFieldNames: function() {\n                var fields = this.model.searchData.get('fields');\n\n                if (!fields || fields.length === 0) {\n                    return [];\n                }\n                if (_.isObject(fields[0])) {\n                    return _(fields).pluck('name');\n                }\n                return $.extend([], fields);\n            },\n\n            getFieldValue: function(field, idx) {\n                var column = this.getFieldValues(field);\n                if (!idx) {\n                    // idx should be 0 unless calculating backtracked delta value\n                    idx = 0;\n                }\n                if (!(column && column.length)) {\n                    return '';\n                }\n                // If data is time series, then result value should be the most recent, which is at the end\n                if (this.isTimeSeries()) {\n                    return column[(column.length - idx - 1)];\n                }\n                // If data is not time series, then result value should be the first in the list\n                return column[idx];\n            },\n\n            getFieldValues: function(fieldName) {\n                var fields = this.getFieldNames(),\n                    columns = this.model.searchData.get('columns') || [],\n                    countIdx = _(fields).indexOf(fieldName);\n                return columns[countIdx];\n            },\n\n            determineResultFieldName: function(configuredField) {\n                var fields = this.getFieldNames();\n                if (configuredField && _(fields).contains(configuredField)) {\n                    return configuredField;\n                }\n                return _(fields).find(function(f) {\n                    return f === '_raw' || f[0] !== '_'; // Does not allow '_time' either\n                });\n            },\n\n            // Is using Timechart command\n            isTimeSeries: function() {\n                var fields = this.getFieldNames();\n                return _(fields).some(function(f) {\n                    return f === '_time';\n                });\n            },\n\n            getSvgContainer: function() {\n                return this.$('.svg-container');\n            },\n\n            getBackgroundMode: function() {\n                return this.model.config.get('display.visualizations.singlevalue.colorMode') || 'none';\n            },\n\n            updateBackgroundDimensions: function() {\n                var background;\n                if (this.hasBackground()) {\n                    background = this.getSvgContainer().find('.block-background');\n                    if (background.length > 0) {\n                        background.attr('width', this.svgWidth);\n                        background.attr('height', this.svgHeight);\n                    }\n                }\n            },\n\n            drawSeverityBackground: function($svgContainer) {\n                if (this.hasBackground()) {\n                    $svgContainer.append(\n                        svgUtil.createElement('rect')\n                            .attr({\n                                x: 0,\n                                y: 0,\n                                width: this.svgWidth,\n                                height: this.svgHeight,\n                                'class': 'block-background',\n                                fill: this.getBackgroundColor()\n                            })\n                    );\n                }\n            },\n\n            drawSvgContainer: function() {\n                var $svgContainer = this.getSvgContainer();\n                if ($svgContainer.length > 0) {\n                    $svgContainer.remove();\n                }\n\n                $svgContainer = svgUtil.createElement('svg')\n                    .width(this.svgWidth)\n                    .height(this.svgHeight)\n                    .attr('class', 'svg-container')\n                    .css('position', 'absolute')\n                    .css('top', '0')\n                    .css('left', '0');\n                $svgContainer.appendTo(this.el);\n                return $svgContainer;\n            },\n\n            drawSparkline: function($svgContainer) {\n                if (this.children.sparkline) {\n                    this.children.sparkline.detach();\n                    this.children.sparkline.remove();\n                }\n                if (this.hasSparkline) {\n                    this.model.results.set({\n                        sparklineData: this.model.results.get('sparkline').slice(0)\n                    });\n\n                    this.model.presentation.set({\n                       sparklineOpacity: 1\n                    });\n\n                    this.children.sparkline = new Sparkline({\n                        model: {\n                            presentation: this.model.presentation,\n                            results: this.model.results,\n                            state: this.model.config\n                        }\n                    });\n                    this.children.sparkline.render().appendTo($svgContainer);\n                } else {\n                    this.model.results.unset('sparklineData');\n                }\n            },\n\n            setDisplayMode: function(displayMode) {\n                this.model.presentation.set('displayMode', displayMode);\n            },\n\n            drawMainBody: function($svgContainer) {\n                var mainBodyPadding,\n                    deltaFontSize,\n                    deltaScale,\n                    singleValueFont,\n                    sideLabelFont,\n                    hasUnderLabel = this.model.config.get('display.visualizations.singlevalue.underLabel'),\n                    displayMode = this.model.presentation.get('displayMode'),\n                    displayModeSimpleMultiplier = 0.5;\n\n                if (this.hasSparkline && hasUnderLabel) {\n                    singleValueFont = 50;\n                    sideLabelFont = 28;\n                    mainBodyPadding = 50;\n                    deltaFontSize = 20;\n                    deltaScale = 0.85;\n                } else {\n                    singleValueFont = 66;\n                    sideLabelFont = 37;\n                    deltaFontSize = 26;\n                    deltaScale = 1.1;\n                    if (!this.hasSparkline && !hasUnderLabel) {\n                        mainBodyPadding = 70;\n                    } else {\n                        mainBodyPadding = 60;\n                    }\n                }\n\n                if (displayMode === 'simple') {\n                    // displayMode simple uses smaller values\n                    // to decrease the chance of re-fitting of labels\n                    // as re-fitting is disabled in simple display mode\n                    singleValueFont *= displayModeSimpleMultiplier;\n                    sideLabelFont *= displayModeSimpleMultiplier;\n                    deltaFontSize *= displayModeSimpleMultiplier;\n                    deltaScale *= displayModeSimpleMultiplier;\n                    mainBodyPadding -= 6;\n                }\n\n                if (this.children.mainBody) {\n                    this.children.mainBody.detach();\n                    this.children.mainBody.remove();\n                }\n\n                this.model.presentation.set({\n                    singleValueFontSize: singleValueFont,\n                    sideLabelFontSize: sideLabelFont,\n                    mainBodyPadding: mainBodyPadding,\n                    deltaFontSize: deltaFontSize,\n                    deltaScale: deltaScale\n                });\n\n                this.children.mainBody = new MainBodyView({\n                    model: {\n                        application: this.model.application,\n                        state: this.model.config,\n                        results: this.model.results,\n                        presentation: this.model.presentation\n                    }\n                });\n\n                this.listenTo(this.children.mainBody, 'singleDrilldownClicked', function(params) {\n                    this.handleSingleDrilldownClicked(params);\n                });\n                this.listenTo(this.children.mainBody, 'anchorTagClicked', function(e) {\n                    this.handleAnchorTagClicked(e);\n                });\n\n                this.children.mainBody.render().appendTo($svgContainer);\n            },\n\n            handleSingleDrilldownClicked: function(params) {\n                this.trigger(params.specificEventNames, params.drilldownInfo);\n            },\n\n            handleAnchorTagClicked: function(e) {\n                // xlink:href does not work for SVG anchors in our case, so we must handle redirect manually\n                var href = $(e.currentTarget).attr('href');\n                if (href) {\n                    route.redirectTo(href, drilldownUtil.shouldDrilldownInNewTab(e));\n                }\n            },\n\n            drawUnderLabel: function($svgContainer) {\n                var underLabelColor = this.hasBackground() ? this.BLOCK_DEFAULT_FONT_COLOR : this.UNDERLABEL_COLOR,\n                    underLabelOpacity = this.hasBackground() ? 0.8 : 1,\n                    underLabelY;\n\n                if (this.hasSparkline) {\n                    underLabelY = 72;\n                } else {\n                    underLabelY = 85;\n                }\n\n                if (this.children.underLabel) {\n                    this.children.underLabel.detach();\n                    this.children.underLabel.remove();\n                }\n                this.model.presentation.set({\n                    underLabelY: underLabelY,\n                    underLabelColor: underLabelColor,\n                    underLabelOpacity: underLabelOpacity\n                });\n                    this.children.underLabel = new UnderLabelView({\n                    model: {\n                        state: this.model.config,\n                        results: this.model.results,\n                        presentation: this.model.presentation,\n                        application: this.model.application\n                    }\n                });\n\n                this.listenTo(this.children.underLabel, 'singleDrilldownClicked', function(params) {\n                    this.handleSingleDrilldownClicked(params);\n                });\n                this.listenTo(this.children.underLabel, 'anchorTagClicked', function(e) {\n                    this.handleAnchorTagClicked(e);\n                });\n\n                this.children.underLabel.render().appendTo($svgContainer);\n            },\n\n            drawComponents: function() {\n                var $svgContainer = this.drawSvgContainer();\n\n                this.hasSparkline = this.model.results.get('sparkline') && splunkUtil.normalizeBoolean(this.model.config.get('display.visualizations.singlevalue.showSparkline')) !== false;\n                this.model.presentation.set('hasSparkline', this.hasSparkline);\n\n                this.drawSeverityBackground($svgContainer);\n\n                this.drawMainBody($svgContainer);\n\n                if (this.model.config.get(\"display.visualizations.singlevalue.underLabel\")) {\n                    this.drawUnderLabel($svgContainer);\n                }\n\n                this.drawSparkline($svgContainer);\n            },\n\n            renderMaxResultCountMessage: function(resultCount) {\n                var message = splunkUtil.sprintf(\n                    _('These results may be truncated. This visualization is configured to display a maximum of %s results per series, and that limit has been reached.').t(),\n                    resultCount\n                );\n                this.$inlineMessage.html(_(this.inlineMessageTemplate).template({ message: message, level: 'warning' }));\n            },\n            inlineMessageTemplate: '\\\n                <div class=\"alert alert-inline alert-<%= level %> alert-inline\"> \\\n                    <i class=\"icon-alert\"></i> \\\n                    <%- message %> \\\n                </div> \\\n            ',\n\n            updateView: function() {\n                this.updateResultState();\n\n                this.$el.removeClass(this._dynamicClasses || '');\n                this._dynamicClasses = [\n                    this.model.config.get('display.visualizations.singlevalue.additionalClass'),\n                    this.getFieldValue(this.model.config.get('display.visualizations.singlevalue.classField'))\n                ].join(' ');\n                this.$el.addClass(this._dynamicClasses);\n\n                this.drawComponents();\n\n                this.$inlineMessage.remove();\n                if(this.model.searchDataParams) {\n                    this.MAX_RESULT_COUNT = this.model.searchDataParams.get('count');\n                }\n\n                if(this.model.results.get('sparkline') && this.model.results.get('sparkline').length >= this.MAX_RESULT_COUNT) {\n                    this.renderMaxResultCountMessage(this.MAX_RESULT_COUNT);\n                    this.$inlineMessage.insertAfter(this.$('.svg-container'));\n                }\n\n                if (this.isAddedToDocument()) {\n                    this.reflow();\n                }\n            }\n        }, themeUtils.getCurrentTheme() === 'dark' ? THEMES.dark : THEMES.enterprise));\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9NYXN0ZXIuanM/M2I2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUEsaUNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7OztBQUdqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxrQkFBa0I7QUFDcEYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRSxrQkFBa0I7QUFDckY7O0FBRUE7QUFDQSx3RkFBd0YscUJBQXFCO0FBQzdHO0FBQ0EsZ0VBQWdFLHFCQUFxQjs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsbUNBQW1DLHlCQUF5QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjs7QUFFQSxvQ0FBb0M7QUFDcEMsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0g7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHFDQUFxQztBQUN0SCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9KQUNBIiwiZmlsZSI6InZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9NYXN0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoXG4gICAgW1xuICAgICAgICAnanF1ZXJ5JyxcbiAgICAgICAgJ3VuZGVyc2NvcmUnLFxuICAgICAgICAnbW9kdWxlJyxcbiAgICAgICAgJ3ZpZXdzL3NoYXJlZC92aXovQmFzZScsXG4gICAgICAgICcuL1NwYXJrbGluZScsXG4gICAgICAgICcuL01haW5Cb2R5JyxcbiAgICAgICAgJy4vVW5kZXJMYWJlbCcsXG4gICAgICAgICdtb2RlbHMvQmFzZScsXG4gICAgICAgICdzcGx1bmsudXRpbCcsXG4gICAgICAgICd1dGlsL3N2ZycsXG4gICAgICAgICd1cmkvcm91dGUnLFxuICAgICAgICAndXRpbC9kcmlsbGRvd24nLFxuICAgICAgICAndXRpbC90aW1lJyxcbiAgICAgICAgJ3V0aWwvY29sb3JfdXRpbHMnLFxuICAgICAgICAndXRpbC9nZW5lcmFsX3V0aWxzJyxcbiAgICAgICAgJ3V0aWwvbW9tZW50L3JlbGF0aXZlJyxcbiAgICAgICAgJ3V0aWwvdGhlbWVfdXRpbHMnLFxuICAgICAgICAndXRpbC9udW1lcmFsJyxcbiAgICAgICAgJ3NwbHVuay9wYWxldHRlcy9Db2xvckNvZGVzJ1xuICAgIF0sXG4gICAgZnVuY3Rpb24oXG4gICAgICAgICQsXG4gICAgICAgIF8sXG4gICAgICAgIG1vZHVsZSxcbiAgICAgICAgVmlzdWFsaXphdGlvbkJhc2UsXG4gICAgICAgIFNwYXJrbGluZSxcbiAgICAgICAgTWFpbkJvZHlWaWV3LFxuICAgICAgICBVbmRlckxhYmVsVmlldyxcbiAgICAgICAgQmFzZU1vZGVsLFxuICAgICAgICBzcGx1bmtVdGlsLFxuICAgICAgICBzdmdVdGlsLFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgZHJpbGxkb3duVXRpbCxcbiAgICAgICAgdGltZVV0aWwsXG4gICAgICAgIGNvbG9yVXRpbCxcbiAgICAgICAgZ2VuZXJhbFV0aWwsXG4gICAgICAgIHJlbGF0aXZlTW9tZW50VXRpbCxcbiAgICAgICAgdGhlbWVVdGlscyxcbiAgICAgICAgbnVtZXJhbCxcbiAgICAgICAgQ29sb3JDb2Rlc1xuICAgICkge1xuXG4gICAgICAgIHZhciBUSEVNRVMgPSB7XG4gICAgICAgICAgICBlbnRlcnByaXNlOiB7XG4gICAgICAgICAgICAgICAgU0VWRVJJVFlfQ09MT1JTOiB7XG4gICAgICAgICAgICAgICAgICAgIHNldmVyZTogQ29sb3JDb2Rlcy5TRU1BTlRJQ19CWV9OQU1FLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBoaWdoOiBDb2xvckNvZGVzLlNFTUFOVElDX0JZX05BTUUuYWxlcnQsXG4gICAgICAgICAgICAgICAgICAgIGVsZXZhdGVkOiBDb2xvckNvZGVzLlNFTUFOVElDX0JZX05BTUUud2FybmluZyxcbiAgICAgICAgICAgICAgICAgICAgZ3VhcmRlZDogQ29sb3JDb2Rlcy5TRU1BTlRJQ19CWV9OQU1FLmluZm8sXG4gICAgICAgICAgICAgICAgICAgIGxvdzogQ29sb3JDb2Rlcy5TRU1BTlRJQ19CWV9OQU1FLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIG5vbmU6IENvbG9yQ29kZXMuREFSS19HUkVZXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBTRVZFUklUSUVTOiBbJ25vbmUnLCAnbG93JywgJ2d1YXJkZWQnLCAnZWxldmF0ZWQnLCAnaGlnaCcsICdzZXZlcmUnXSxcbiAgICAgICAgICAgICAgICBCTE9DS19ERUZBVUxUX0ZPTlRfQ09MT1I6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICAgICBCTE9DS19ERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1I6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgICAgICBERUZBVUxUX0ZPTlRfQ09MT1I6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgICAgICBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1I6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICAgICBVTkRFUkxBQkVMX0NPTE9SOiBDb2xvckNvZGVzLkRBUktfR1JFWSxcbiAgICAgICAgICAgICAgICBORVVUUkFMX0NIQU5HRV9DT0xPUjogQ29sb3JDb2Rlcy5EQVJLX0dSRVksXG4gICAgICAgICAgICAgICAgTkVVVFJBTF9DSEFOR0VfQkFDS0dST1VORF9DT0xPUjogQ29sb3JDb2Rlcy5EQVJLX0dSRVksXG4gICAgICAgICAgICAgICAgREVMVEFfR1JFRU46IENvbG9yQ29kZXMuU0VNQU5USUNfQllfTkFNRS5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIERFTFRBX1JFRDogQ29sb3JDb2Rlcy5TRU1BTlRJQ19CWV9OQU1FLmVycm9yLFxuICAgICAgICAgICAgICAgIEVER0VfUEFERElORzogMzIsXG4gICAgICAgICAgICAgICAgTkVVVFJBTF9TUEFSS0xJTkVfQ09MT1I6ICcjOTk5OTk5J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhcms6IHtcbiAgICAgICAgICAgICAgICBTRVZFUklUWV9DT0xPUlM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJlOiBDb2xvckNvZGVzLlNFTUFOVElDX0JZX05BTUUuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGhpZ2g6IENvbG9yQ29kZXMuU0VNQU5USUNfQllfTkFNRS5hbGVydCxcbiAgICAgICAgICAgICAgICAgICAgZWxldmF0ZWQ6IENvbG9yQ29kZXMuU0VNQU5USUNfQllfTkFNRS53YXJuaW5nLFxuICAgICAgICAgICAgICAgICAgICBndWFyZGVkOiBDb2xvckNvZGVzLlNFTUFOVElDX0JZX05BTUUuaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgbG93OiBDb2xvckNvZGVzLlNFTUFOVElDX0JZX05BTUUuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgbm9uZTogJyNGRkZGRkYnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBTRVZFUklUSUVTOiBbJ25vbmUnLCAnbG93JywgJ2d1YXJkZWQnLCAnZWxldmF0ZWQnLCAnaGlnaCcsICdzZXZlcmUnXSxcbiAgICAgICAgICAgICAgICBCTE9DS19ERUZBVUxUX0ZPTlRfQ09MT1I6ICcjRkZGRkZGJywgLy8gJHdoaXRlXG4gICAgICAgICAgICAgICAgQkxPQ0tfREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9SOiAnIzIxMjUyNycsIC8vICRncmF5MjFcbiAgICAgICAgICAgICAgICBERUZBVUxUX0ZPTlRfQ09MT1I6ICcjRkZGRkZGJywgLy8gJHdoaXRlXG4gICAgICAgICAgICAgICAgREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9SOiAnIzIxMjUyNycsIC8vICRncmF5MjFcbiAgICAgICAgICAgICAgICBVTkRFUkxBQkVMX0NPTE9SOiAnI0MzQ0JENCcsIC8vICRncmF5ODBcbiAgICAgICAgICAgICAgICBORVVUUkFMX0NIQU5HRV9DT0xPUjogJyNGRkZGRkYnLCAvLyAkd2hpdGVcbiAgICAgICAgICAgICAgICBORVVUUkFMX0NIQU5HRV9CQUNLR1JPVU5EX0NPTE9SOiAnIzIxMjUyNycsIC8vICRncmF5MjFcbiAgICAgICAgICAgICAgICBERUxUQV9HUkVFTjogQ29sb3JDb2Rlcy5TRU1BTlRJQ19CWV9OQU1FLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgREVMVEFfUkVEOiBDb2xvckNvZGVzLlNFTUFOVElDX0JZX05BTUUuZXJyb3IsXG4gICAgICAgICAgICAgICAgRURHRV9QQURESU5HOiAzMixcbiAgICAgICAgICAgICAgICBORVVUUkFMX1NQQVJLTElORV9DT0xPUjogJyNGRkZGRkYnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFZpc3VhbGl6YXRpb25CYXNlLmV4dGVuZChfLmV4dGVuZCh7XG4gICAgICAgICAgICBtb2R1bGVJZDogbW9kdWxlLmlkLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInNpbmdsZS12YWx1ZVwiLFxuXG4gICAgICAgICAgICBNQVhfUkVTVUxUX0NPVU5UOiAxMDAwLFxuXG4gICAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgVmlzdWFsaXphdGlvbkJhc2UucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuJGVsLndpZHRoKHRoaXMub3B0aW9ucy53aWR0aCB8fCAnMTAwJScpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmhlaWdodCh0aGlzLm9wdGlvbnMuaGVpZ2h0IHx8ICcxMDAlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0dXAgc2VhcmNoRGF0YSBhbmQgc2VhcmNoUGFyYW0gbW9kZWxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRQcmltYXJ5RGF0YVNvdXJjZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2VhcmNoRGF0YSA9IHRoaXMuZ2V0UHJpbWFyeURhdGFTb3VyY2UoKS5zZWFyY2hSZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNlYXJjaERhdGFQYXJhbXMgPSB0aGlzLmdldFByaW1hcnlEYXRhU291cmNlKCkuZmV0Y2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLnNlYXJjaERhdGEsICdjaGFuZ2UnLCB0aGlzLm9uRGF0YUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5yZXN1bHRzID0gbmV3IEJhc2VNb2RlbCh7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlc3VsdHNDb2x1bW46IHRoaXMubW9kZWwuc2VhcmNoRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmllbGQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRGaWVsZFZhbHVlOiAnJ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wcmVzZW50YXRpb24gPSBuZXcgQmFzZU1vZGVsKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lckRpbWVuc2lvbnMoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxIZWlnaHQgPSB0aGlzLiRlbC5oZWlnaHQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucHJlc2VudGF0aW9uLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogdGhpcy5nZXRGb250Q29sb3IoKSxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVSYXRpbzogMSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZVBhZGRpbmc6IHRoaXMuRURHRV9QQURESU5HXG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgIHRoaXMuJGlubGluZU1lc3NhZ2UgPSAkKCc8ZGl2IGNsYXNzPVwiaW5saW5lLW1lc3NhZ2VcIj48L2Rpdj4nKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWFsaWduXCI6XCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6XCIzMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6XCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6XCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJib3R0b21cIjpcIjBcIn0pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubWVzc2FnZUNvbnRhaW5lckNsYXNzIHx8ICcnKTtcblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVxdWlyZWREYXRhU291cmNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25Db25maWdDaGFuZ2U6IGZ1bmN0aW9uKGNoYW5nZWRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZEludmFsaWRhdGUgPSBfKGNoYW5nZWRBdHRyaWJ1dGVzKS5jaGFpbigpLmtleXMoKVxuICAgICAgICAgICAgICAgICAgICAuYW55KGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5pbmRleE9mKCdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLicpID09PSAwO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudmFsdWUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRJbnZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgnZm9ybWF0RGF0YVBhc3MnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1cGRhdGVSZXN1bHRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdEZpZWxkID0gdGhpcy5kZXRlcm1pbmVSZXN1bHRGaWVsZE5hbWUodGhpcy5tb2RlbC5jb25maWcuZ2V0KFwiZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS5maWVsZFwiKSksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEZpZWxkVmFsdWUgPSB0aGlzLmdldEZpZWxkVmFsdWUocmVzdWx0RmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBmb250Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHNwYXJrbGluZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIHNwYXJrbGluZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YUluZGljYXRvckNvbG9yO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBjb2x1bW4gaXMgX3RpbWUsIHRoZW4gaXQgaXMgYSB0aW1lY2hhcnQgYW5kIGNvbnRhaW5zXG4gICAgICAgICAgICAgICAgLy8gbXVsdGlwbGUgcmVzdWx0IHJvd3MsIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGRpc3BsYXkgYSBzcGFya2xpbmUuXG4gICAgICAgICAgICAgICAgLy8gRWxzZSwgaXQgc2hvdWxkIGp1c3QgZGlzcGxheSBhIHN0YW5kYXJkIHNpbmdsZSByZXN1bHQgdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnJlc3VsdHMuc2V0KCdyZXN1bHRGaWVsZCcsIHJlc3VsdEZpZWxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnJlc3VsdHMuc2V0KCdyZXN1bHRGaWVsZFZhbHVlJywgcmVzdWx0RmllbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1RpbWVTZXJpZXMoKSAmJiAhaXNOYU4ocmVzdWx0RmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhcmtsaW5lRGF0YSA9IHRoaXMuZ2V0RmllbGRWYWx1ZXMocmVzdWx0RmllbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnJlc3VsdHMuc2V0KCdzcGFya2xpbmUnLCBzcGFya2xpbmVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXREZWx0YVZhbHVlKHJlc3VsdEZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbi1tZW0gY29uZmlnIGF0dHJpYnV0ZSAtIHRlbGwgVml6IEVkaXRvciB0aGF0IHRpbWUgc2VyaWVzIHZpeiBjb250cm9scyBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuY29uZmlnLnNldCgnaXNfdGltZXNlcmllcycsIHRydWUsIHsndHJhbnNpZW50JzogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucmVzdWx0cy51bnNldCgnc3BhcmtsaW5lJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucmVzdWx0cy51bnNldCgnZGVsdGFWYWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnJlc3VsdHMudW5zZXQoJ2RlbHRhQmFja3RyYWNrJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4tbWVtIGNvbmZpZyBhdHRyaWJ1dGUgLSB0ZWxsIFZpeiBFZGl0b3IgdGhhdCB0aW1lIHNlcmllcyB2aXogY29udHJvbHMgc2hvdWxkIGJlIGhpZGRlblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZy5zZXQoJ2lzX3RpbWVzZXJpZXMnLCBmYWxzZSwgeyd0cmFuc2llbnQnOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXZlcml0eUNvbG9yID0gdGhpcy5nZXRTZXZlcml0eUNvbG9yKHJlc3VsdEZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V2ZXJpdHlCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldFNldmVyaXR5Q29sb3IocmVzdWx0RmllbGRWYWx1ZSwgeyBpc0JhY2tncm91bmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWx0YUNvbG9yID0gdGhpcy5nZXREZWx0YUNvbG9yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWx0YUJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0RGVsdGFDb2xvcih7IGlzQmFja2dyb3VuZDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGRlbHRhSW5kaWNhdG9yQ29sb3IgPSB0aGlzLmdldERlbHRhSW5kaWNhdG9yQ29sb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMudXNlQ29sb3JzKCkgJiYgdGhpcy5tb2RlbC5jb25maWcuZ2V0KCdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLmNvbG9yQnknKSA9PT0gJ3RyZW5kJylcbiAgICAgICAgICAgICAgICAgICAgfHwgdGhpcy5oYXNCYWNrZ3JvdW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhcmtsaW5lQ29sb3IgPSBkZWx0YUluZGljYXRvckNvbG9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYXJrbGluZUNvbG9yID0gdGhpcy5ORVVUUkFMX1NQQVJLTElORV9DT0xPUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uc2V0KCdkZWx0YUNvbG9yJywgZGVsdGFJbmRpY2F0b3JDb2xvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uc2V0KCdzcGFya2xpbmVDb2xvcicsIHNwYXJrbGluZUNvbG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5zZXQoJ2ZvbnRDb2xvcicsIHRoaXMuZ2V0Rm9udENvbG9yKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucHJlc2VudGF0aW9uLnNldCgnZm9ybWF0UGF0dGVybicsIHRoaXMuZ2V0Rm9ybWF0UGF0dGVybigpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldERlbHRhQ29sb3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFNb2RlID0gdGhpcy5tb2RlbC5jb25maWcuZ2V0KCdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLnRyZW5kQ29sb3JJbnRlcnByZXRhdGlvbicpIHx8ICdzdGFuZGFyZCcsIC8vIGRlZmF1bHRzIHRvIHN0YW5kYXJkXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSB0aGlzLm1vZGVsLnJlc3VsdHMuZ2V0KCdkZWx0YVZhbHVlJyksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhSW5jcmVhc2VkID0gZGVsdGFWYWx1ZSA9PT0gJ3BlcmNlbnRhZ2VJbmNyZWFzZScgfHwgZGVsdGFWYWx1ZSA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhVmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5pc0JhY2tncm91bmQgPyB0aGlzLk5FVVRSQUxfQ0hBTkdFX0JBQ0tHUk9VTkRfQ09MT1IgOiB0aGlzLk5FVVRSQUxfQ0hBTkdFX0NPTE9SO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFNb2RlID09PSAnaW52ZXJzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhSW5jcmVhc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ERUxUQV9SRUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuREVMVEFfR1JFRU47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhSW5jcmVhc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ERUxUQV9HUkVFTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ERUxUQV9SRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0U2V2ZXJpdHlDb2xvcjogZnVuY3Rpb24ocmVzdWx0RmllbGRWYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGlzLm1vZGVsLmNvbmZpZy5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUucmFuZ2VWYWx1ZXMnKSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzID0gdGhpcy5tb2RlbC5jb25maWcuZ2V0KCdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLnJhbmdlQ29sb3JzJyksXG4gICAgICAgICAgICAgICAgICAgIHVzZUNvbG9ycyA9IHNwbHVua1V0aWwubm9ybWFsaXplQm9vbGVhbih0aGlzLm1vZGVsLmNvbmZpZy5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUudXNlQ29sb3JzJykpIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q29sb3IgPSBvcHRpb25zICYmIG9wdGlvbnMuaXNCYWNrZ3JvdW5kID8gdGhpcy5CTE9DS19ERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1IgOiB0aGlzLkRFRkFVTFRfRk9OVF9DT0xPUixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VNYXBWYWx1ZSA9IHRoaXMuZ2V0UmVzdWx0RmllbGQoJ3JhbmdlJyksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcnNEZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0aWVzO1xuXG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5IHNpbmdsZSB2YWx1ZSBiZWhhdmlvciBkaWN0YXRlcyB0aGF0IGlmIHRoZXJlIGlzIGEgcmFuZ2VtYXAgaW4gdGhlIHJlc3VsdHMsIHRoYXQgd2lsbCBjb2xvciB0aGUgdml6LlxuICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gY2hlY2sgdGhhdCB1c2VDb2xvcnMgaXMgZmFsc2UuIElmIGl0IGlzIHRydWUsIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHkgdXNpbmcgdGhlIHJhbmdlQ29sb3JzXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlTWFwVmFsdWUgJiYgIXVzZUNvbG9ycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2xhc3NGaWVsZCBpcyB1c2VkIGFuZCB0aGUgcmFuZ2UgZmllbGQgY29udGFpbnMgaXMgYSB2YWxpZCBzZXZlcml0eSwgdXNlIHRoaXMgYXMgdGhlIHNldmVyaXR5XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlNFVkVSSVRZX0NPTE9SU1tyYW5nZU1hcFZhbHVlXSB8fCBkZWZhdWx0Q29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmFuZ2VzID0gZ2VuZXJhbFV0aWwuc3RyaW5nVG9BcnJheShyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRDb2xvcnMgPSBnZW5lcmFsVXRpbC5zdHJpbmdUb0FycmF5KGNvbG9ycyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSBwYXJzZWRDb2xvcnMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZFJhbmdlcy5sZW5ndGggPT09IDAgfHwgaXNOYU4ocmVzdWx0RmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdGllcyA9IHRoaXMuU0VWRVJJVElFUy5zbGljZSgxLCA2KTsgLy8gZGlzY2FyZCAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWRSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzTmFOKHBhcnNlZFJhbmdlc1tpXSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChyZXN1bHRGaWVsZFZhbHVlKSA8PSBwYXJzZUZsb2F0KHBhcnNlZFJhbmdlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcyBzb29uIGFzIHdlIGVuY291bnRlciBhIHJhbmdlIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZXN1bHRGaWVsZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgdGhlIHNldmVyaXR5IHJhbmdlIHRoYXQgdGhlIHJlc3VsdEZpZWxkVmFsdWUgZmFsbHMgaW50bywgc28gd2UgZXhpdCB0aGUgbG9vcCBhbmQgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yc0RlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yVXRpbC5yZXBsYWNlU3ltYm9scyhwYXJzZWRDb2xvcnNbaV0sICcjJykgfHwgZGVmYXVsdENvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5TRVZFUklUWV9DT0xPUlNbc2V2ZXJpdGllc1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yc0RlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHJhbmdlcyB0aGFuIGNvbG9ycywgYXNzaWduIHRoZSBkZWZhdWx0IGdyZXkgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvclV0aWwucmVwbGFjZVN5bWJvbHMocGFyc2VkQ29sb3JzW3BhcnNlZFJhbmdlcy5sZW5ndGhdLCAnIycpIHx8IGRlZmF1bHRDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5TRVZFUklUWV9DT0xPUlNbc2V2ZXJpdGllc1tzZXZlcml0aWVzLmxlbmd0aCAtIDFdXTsgLy8gaWYgbm8gc2V2ZXJpdHkgaGFzIHlldCBiZWVuIGFzc2lnbmVkLCBoYXMgZmFsbGVuIHRocm91Z2ggdG8gaGlnaGVzdCBzZXZlcml0eVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q29sb3I7IC8vIGZhbGwgdGhyb3VnaCB0byBkZWZhdWx0XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXREZWx0YUluZGljYXRvckNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JCeSA9IHRoaXMubW9kZWwuY29uZmlnLmdldCgnZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS5jb2xvckJ5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQmFja2dyb3VuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkJMT0NLX0RFRkFVTFRfRk9OVF9DT0xPUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yQnkgPT09ICd2YWx1ZScgfHwgIXRoaXMudXNlQ29sb3JzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuREVGQVVMVF9GT05UX0NPTE9SO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWx0YUNvbG9yO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Rm9udENvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JCeSA9IHRoaXMubW9kZWwuY29uZmlnLmdldCgnZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS5jb2xvckJ5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQmFja2dyb3VuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkJMT0NLX0RFRkFVTFRfRk9OVF9DT0xPUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChjb2xvckJ5ID09PSAndHJlbmQnICYmIHRoaXMuaXNUaW1lU2VyaWVzKCkpIHx8ICF0aGlzLnVzZUNvbG9ycygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkRFRkFVTFRfRk9OVF9DT0xPUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V2ZXJpdHlDb2xvcjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVzZUNvbG9yczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVzZUNvbG9ycyA9IHNwbHVua1V0aWwubm9ybWFsaXplQm9vbGVhbih0aGlzLm1vZGVsLmNvbmZpZy5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUudXNlQ29sb3JzJykpIHx8IGZhbHNlLCAvLyBkZWZhdWx0IHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlTWFwVmFsdWUgPSB0aGlzLmdldEZpZWxkVmFsdWVzKCdyYW5nZScpO1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdXNlIG9sZCBSYW5nZW1hcCBjb21tYW5kIHJlc3VsdCBpZiB1c2VDb2xvcnMgaXMgbm90IHNldC5cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VNYXBWYWx1ZSAmJiAhdXNlQ29sb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlQ29sb3JzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGFzQmFja2dyb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhY2tncm91bmRNb2RlID0gdGhpcy5tb2RlbC5jb25maWcuZ2V0KCdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLmNvbG9yTW9kZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoYmFja2dyb3VuZE1vZGUgPT09ICdibG9jaycgJiYgdGhpcy51c2VDb2xvcnMoKSAmJiB0aGlzLmdldEJhY2tncm91bmRDb2xvcigpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQnkgPSB0aGlzLm1vZGVsLmNvbmZpZy5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUuY29sb3JCeScpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZUNvbG9ycygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvckJ5ID09PSAndHJlbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWx0YUJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXZlcml0eUJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQkxPQ0tfREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9SO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Rm9ybWF0UGF0dGVybjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdFBhdHRlcm4gPSAnMCcsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRQcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICAgICAgICAgICAgICAgIG51bWJlclByZWNpc2lvbiA9IHRoaXMubW9kZWwuY29uZmlnLmdldCgnZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS5udW1iZXJQcmVjaXNpb24nKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlVGhvdXNhbmRTZXBhcmF0b3JzID0gc3BsdW5rVXRpbC5ub3JtYWxpemVCb29sZWFuKHRoaXMubW9kZWwuY29uZmlnLmdldCgnZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS51c2VUaG91c2FuZFNlcGFyYXRvcnMnKSk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVRob3VzYW5kU2VwYXJhdG9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0UGF0dGVybiArPSAnLDAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyUHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRQcmVjaXNpb24gPSBudW1iZXJQcmVjaXNpb24ubWF0Y2goL14wXFwuPygwKikkLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkUHJlY2lzaW9uICYmIG1hdGNoZWRQcmVjaXNpb24ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFsUGxhY2VzID0gbWF0Y2hlZFByZWNpc2lvblsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsUGxhY2VzLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VyIHdhbnRzIGEgbGFyZ2UgZC5wLiB2YWx1ZSwgc28gcmV2ZXJ0IHRoZW0gdG8gdGhlIGFsbG93ZWQgbWF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbFBsYWNlcyA9ICcwMDAwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsUGxhY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRQYXR0ZXJuID0gZm9ybWF0UGF0dGVybiArICAnLicgKyBkZWNpbWFsUGxhY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRQYXR0ZXJuO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0RGVsdGFWYWx1ZTogZnVuY3Rpb24oY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhVGltZVJhbmdlID0gdGhpcy5tb2RlbC5jb25maWcuZ2V0KCdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLnRyZW5kSW50ZXJ2YWwnKSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFGb3JtYXQgPSB0aGlzLm1vZGVsLmNvbmZpZy5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUudHJlbmREaXNwbGF5TW9kZScpLFxuICAgICAgICAgICAgICAgICAgICB0aW1lcyA9IHRoaXMuZ2V0RmllbGRWYWx1ZXMoJ190aW1lJyksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFRpbWVBcnIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhQmFja3RyYWNrLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWREZWx0YVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRGaWVsZCA9IHRoaXMubW9kZWwucmVzdWx0cy5nZXQoJ3Jlc3VsdEZpZWxkJyksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVUb0JhY2t0cmFja0luU2Vjb25kcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVBvaW50c1RvQmFja3RyYWNrLFxuICAgICAgICAgICAgICAgICAgICBtb3N0UmVjZW50RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kTW9zdFJlY2VudERhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdGltZUdyYW51bGFyaXR5SW5TZWNvbmRzLFxuICAgICAgICAgICAgICAgICAgICB0aW1lQW1vdW50LFxuICAgICAgICAgICAgICAgICAgICB0aW1lVW5pdCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0UGF0dGVybiA9IHRoaXMuZ2V0Rm9ybWF0UGF0dGVybigpLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZWNlbnREYXRlT2JqZWN0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZVV0aWwuYmRUaW1lVG9EYXRlT2JqZWN0KHRpbWVVdGlsLmV4dHJhY3RCZFRpbWUodGltZXNbdGltZXMubGVuZ3RoIC0gb2Zmc2V0XSkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YVRpbWVSYW5nZSAmJiBkZWx0YVRpbWVSYW5nZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBkaWZmIGJldHdlZW4gdmFsdWVzIGF0IG1vc3QgcmVjZW50IF90aW1lIChtaW51cykgZGVsdGFUaW1lUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFRpbWVBcnIgPSByZWxhdGl2ZU1vbWVudFV0aWwucGFyc2VSZWxhdGl2ZVRpbWVFeHByZXNzaW9uKGRlbHRhVGltZVJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkVGltZUFyciAmJiBwYXJzZWRUaW1lQXJyWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRUaW1lID0gcGFyc2VkVGltZUFyclswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXMubGVuZ3RoID49IDIgJiYgcGFyc2VkVGltZSAmJiBwYXJzZWRUaW1lLnVuaXQgJiYgIWlzTmFOKHBhcnNlZFRpbWUuYW1vdW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZVVuaXQgPSB0aW1lVXRpbC5ub3JtYWxpemVVbml0KHBhcnNlZFRpbWUudW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lQW1vdW50ID0gTWF0aC5hYnMocGFyc2VkVGltZS5hbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIDIgY29waWVzIG9mIHRoZSBtb3N0IHJlY2VudCBEYXRlIG9iamVjdCAtIG9ubHkgZGVsdGFEYXRlIHdpbGwgYmUgbXV0YXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9zdFJlY2VudERhdGUgPSBjcmVhdGVSZWNlbnREYXRlT2JqZWN0KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFEYXRlID0gY3JlYXRlUmVjZW50RGF0ZU9iamVjdCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQ29tcGFyZSBib3RoIGdyYW51bGFyaXR5IG9mIGVsZW1lbnRzIGluIHRoZSBfdGltZSBhcnJheSBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVsdGFUaW1lUmFuZ2UgYnkgY29udmVydGluZyB0aGVtIGJvdGggdG8gdGhlIHNhbWUgdW5pdHMgLSBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRNb3N0UmVjZW50RGF0ZSA9IGNyZWF0ZVJlY2VudERhdGVPYmplY3QoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGJvdGggZ3JhbnVsYXJpdHkgb2YgZWxlbWVudHMgaW4gdGhlIF90aW1lIGFycmF5IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsdGFUaW1lUmFuZ2UgYnkgY29udmVydGluZyB0aGVtIGJvdGggdG8gdGhlIHNhbWUgdW5pdHMgLSBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lR3JhbnVsYXJpdHlJblNlY29uZHMgPSAobW9zdFJlY2VudERhdGUuZ2V0VGltZSgpIC0gc2Vjb25kTW9zdFJlY2VudERhdGUuZ2V0VGltZSgpKSAvIDEwMDA7IC8vIENvbnZlcnQgZnJvbSBtaWxsaXNlY29uZHMgdG8gc2Vjb25kcyBieSBkaXZpZGluZyBieSAxMDAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5pbmRleE9mKFsncycsICdtJywgJ2gnXSwgdGltZVVuaXQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlY29uZHMsIG1pbnV0ZXMsIGFuZCBob3VycyBhcmUgYWZmZWN0ZWQgYnkgRGF5bGlnaHQgU2F2aW5ncyBUaW1lLCBzbyBzaG91bGQgTk9UIHVzZSB0aGUgSlMgRGF0ZSgpIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkLCB0aGV5IHNob3VsZCB1c2UgQkRUaW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVUb0JhY2t0cmFja0luU2Vjb25kcyA9IHRpbWVVdGlsLmNvbnZlcnRBbW91bnRBbmRVbml0VG9TZWNvbmRzKHRpbWVBbW91bnQsIHRpbWVVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FuIHVzZSB0aGUgSlMgRGF0ZSgpIG9iamVjdCdzIHNldHRlciBhbmQgZ2V0dGVyIG1ldGhvZHMgYXMgbW9udGhzIGhhdmUgaXJyZWd1bGFyIG51bWJlcnMgb2YgZGF5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgRGF0ZSgpIG9iamVjdCBpbnRlcm5hbGx5IGhhbmRsZXMgdGhlc2UgaW5jb25zaXN0ZW5jaWVzIHdoZW4gY2FsY3VsYXRpbmcgdGltZSBkZWx0YXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhRGF0ZS5zZXRGdWxsWWVhcihkZWx0YURhdGUuZ2V0RnVsbFllYXIoKSAtIHRpbWVBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFEYXRlLnNldE1vbnRoKGRlbHRhRGF0ZS5nZXRNb250aCgpIC0gKHRpbWVBbW91bnQgKiAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhRGF0ZS5zZXRNb250aChkZWx0YURhdGUuZ2V0TW9udGgoKSAtIHRpbWVBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFEYXRlLnNldERhdGUoZGVsdGFEYXRlLmdldERhdGUoKSAtICh0aW1lQW1vdW50ICogNykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFEYXRlLnNldERhdGUoZGVsdGFEYXRlLmdldERhdGUoKSAtIHRpbWVBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YURhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsdGFEYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVUb0JhY2t0cmFja0luU2Vjb25kcyA9IChtb3N0UmVjZW50RGF0ZS5nZXRUaW1lKCkgLSBkZWx0YURhdGUpIC8gMTAwMDsgLy8gQ29udmVydCBmb3JtIG1pbGxpc2Vjb25kcyB0byBzZWNvbmRzIGJ5IGRpdmlkaW5nIGJ5IDEwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lVG9CYWNrdHJhY2tJblNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIb3cgbWFueSBlbGVtZW50cyBiYWNrIGluIHRoZSBfdGltZSBhcnJheSB3ZSBzaG91bGQgY29tcGFyZSB0aGUgY3VycmVudFZhbHVlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVBvaW50c1RvQmFja3RyYWNrID0gTWF0aC5yb3VuZCh0aW1lVG9CYWNrdHJhY2tJblNlY29uZHMgLyB0aW1lR3JhbnVsYXJpdHlJblNlY29uZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhUG9pbnRzVG9CYWNrdHJhY2sgPCB0aW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFWYWx1ZSA9IHRoaXMuY2FsY3VsYXRlRGVsdGFWYWx1ZShyZXN1bHRGaWVsZCwgZGF0YVBvaW50c1RvQmFja3RyYWNrLCBkZWx0YUZvcm1hdCwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFCYWNrdHJhY2sgPSBkYXRhUG9pbnRzVG9CYWNrdHJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdDogaWYgZGVsdGFUaW1lUmFuZ2UgaXMgbm90IHNwZWNpZmllZCBvciBpbnZhbGlkLCBkZWx0YSBzcGFucyByYW5nZSBiZXR3ZWVuIG1vc3QgcmVjZW50IGFuZCAybmQtbW9zdC1yZWNlbnQgZGF0YSBwb2ludHNcbiAgICAgICAgICAgICAgICBpZiAoKCFkZWx0YVZhbHVlICYmIGRlbHRhVmFsdWUgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmaWVsZCBpcyBhICdfdGltZScgZmllbGQsIHRha2UgdGhlIG1vc3QgcmVjZW50ICdjb3VudCcgZGF0YSBwb2ludCBhcyB0aGUgZmllbGQgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlICdjb3VudCcgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSB0aGlzLmNhbGN1bGF0ZURlbHRhVmFsdWUocmVzdWx0RmllbGQsIDEsIGRlbHRhRm9ybWF0LCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YUJhY2t0cmFjayA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdFBhdHRlcm4gJiYgIWlzTmFOKGRlbHRhVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZERlbHRhVmFsdWUgPSBudW1lcmFsKGRlbHRhVmFsdWUpLmZvcm1hdChmb3JtYXRQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5yZXN1bHRzLnNldCgnZm9ybWF0dGVkRGVsdGFWYWx1ZScsIGZvcm1hdHRlZERlbHRhVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucmVzdWx0cy5zZXQoJ2RlbHRhVmFsdWUnLCBkZWx0YVZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnJlc3VsdHMuc2V0KCdkZWx0YUJhY2t0cmFjaycsIGRlbHRhQmFja3RyYWNrKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNhbGN1bGF0ZURlbHRhVmFsdWU6IGZ1bmN0aW9uKHJlc3VsdEZpZWxkLCBkYXRhUG9pbnRzVG9CYWNrdHJhY2ssIGRlbHRhRm9ybWF0LCBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuZ2V0RmllbGRWYWx1ZShyZXN1bHRGaWVsZCwgZGF0YVBvaW50c1RvQmFja3RyYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFGb3JtYXQgJiYgZGVsdGFGb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gJ3BlcmNlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvdWxkIHJldHVybiBhIHBlcmNlbnRhZ2UgY2hhbmdlIHZhbHVlIG9mIEluZmluaXR5LCB3aGljaCB3ZSBtdXN0IGRpc3BsYXkgYXMgJ04vQSdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3VycmVudFZhbHVlID4gcHJldmlvdXNWYWx1ZSkgPyAncGVyY2VudGFnZUluY3JlYXNlJyA6ICdwZXJjZW50YWdlRGVjcmVhc2UnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3VycmVudFZhbHVlIC0gcHJldmlvdXNWYWx1ZSkgLyBwcmV2aW91c1ZhbHVlICogMTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlIC0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uQWRkZWRUb0RvY3VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBWaXN1YWxpemF0aW9uQmFzZS5wcm90b3R5cGUub25BZGRlZFRvRG9jdW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUmVmbG93KHRydWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVmbG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lckRpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJhY2tncm91bmREaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZva2VPbkNoaWxkcmVuKCd2YWxpZGF0ZVJlZmxvdycsIHRydWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdXBkYXRlQ29udGFpbmVyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyICRzdmdDb250YWluZXIgPSB0aGlzLmdldFN2Z0NvbnRhaW5lcigpLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZVJhdGlvO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIFBERjogJGVsIGhhcyB1bmRlZmluZWQgaGVpZ2h0IGFuZCB3aWR0aCBzbyBzZXQgbWFudWFsbHkgdG8gcGFzc2VkIGluIGhlaWdodCBhbmQgd2lkdGggb3B0aW9uc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLmNvbmZpZy5nZXQoJ2V4cG9ydE1vZGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN2Z1dpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN2Z0hlaWdodCA9IHRoaXMub3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdmdIZWlnaHQgPSB0aGlzLiRlbC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdmdXaWR0aCA9IHRoaXMuJGVsLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYodGhpcy4kZWwuZmluZCh0aGlzLiRpbmxpbmVNZXNzYWdlKS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN2Z0hlaWdodCA9IHRoaXMuc3ZnSGVpZ2h0IC0gdGhpcy4kaW5saW5lTWVzc2FnZS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhbFV0aWwudmFsdWVzQXJlTnVtZXJpY0FuZEZpbml0ZShbdGhpcy5zdmdIZWlnaHQsIHRoaXMuc3ZnV2lkdGhdKSkge1xuICAgICAgICAgICAgICAgICAgICAkc3ZnQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KHRoaXMuc3ZnSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpZHRoKHRoaXMuc3ZnV2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlUmF0aW8gPSB0aGlzLnN2Z0hlaWdodCAvIHRoaXMub3JpZ2luYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2VuZXJhbFV0aWwudmFsdWVzQXJlTnVtZXJpY0FuZEZpbml0ZShbc2NhbGVSYXRpb10pIHx8IHNjYWxlUmF0aW8gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlUmF0aW8gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1dpZHRoOiB0aGlzLnN2Z1dpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnSGVpZ2h0OiB0aGlzLnN2Z0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlUmF0aW86IHNjYWxlUmF0aW9cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVzdWx0RmllbGQ6IGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdEZpZWxkVmFsdWUgPSB0aGlzLmdldEZpZWxkVmFsdWUodGhpcy5kZXRlcm1pbmVSZXN1bHRGaWVsZE5hbWUoZmllbGQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdEZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8oJ04vQScpLnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdEZpZWxkVmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBGaWVsZHMgY2FuIGVpdGhlciBiZSBhIGxpc3Qgb2Ygc3RyaW5ncyBvciBhIGxpc3Qgb2YgZGljdGlvbmFyaWVzIGVhY2ggd2l0aCBhICduYW1lJyBlbnRyeVxuICAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHdoZXRoZXIgJ3Nob3dfbWV0YWRhdGEnIGlzIGVuYWJsZWRcbiAgICAgICAgICAgIGdldEZpZWxkTmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLm1vZGVsLnNlYXJjaERhdGEuZ2V0KCdmaWVsZHMnKTtcblxuICAgICAgICAgICAgICAgIGlmICghZmllbGRzIHx8IGZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXy5pc09iamVjdChmaWVsZHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfKGZpZWxkcykucGx1Y2soJ25hbWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKFtdLCBmaWVsZHMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RmllbGRWYWx1ZTogZnVuY3Rpb24oZmllbGQsIGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldEZpZWxkVmFsdWVzKGZpZWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkeCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZHggc2hvdWxkIGJlIDAgdW5sZXNzIGNhbGN1bGF0aW5nIGJhY2t0cmFja2VkIGRlbHRhIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGNvbHVtbiAmJiBjb2x1bW4ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGRhdGEgaXMgdGltZSBzZXJpZXMsIHRoZW4gcmVzdWx0IHZhbHVlIHNob3VsZCBiZSB0aGUgbW9zdCByZWNlbnQsIHdoaWNoIGlzIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1RpbWVTZXJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uWyhjb2x1bW4ubGVuZ3RoIC0gaWR4IC0gMSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBkYXRhIGlzIG5vdCB0aW1lIHNlcmllcywgdGhlbiByZXN1bHQgdmFsdWUgc2hvdWxkIGJlIHRoZSBmaXJzdCBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5baWR4XTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEZpZWxkVmFsdWVzOiBmdW5jdGlvbihmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5nZXRGaWVsZE5hbWVzKCksXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnMgPSB0aGlzLm1vZGVsLnNlYXJjaERhdGEuZ2V0KCdjb2x1bW5zJykgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIGNvdW50SWR4ID0gXyhmaWVsZHMpLmluZGV4T2YoZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uc1tjb3VudElkeF07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZXRlcm1pbmVSZXN1bHRGaWVsZE5hbWU6IGZ1bmN0aW9uKGNvbmZpZ3VyZWRGaWVsZCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkTmFtZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlndXJlZEZpZWxkICYmIF8oZmllbGRzKS5jb250YWlucyhjb25maWd1cmVkRmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWd1cmVkRmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfKGZpZWxkcykuZmluZChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmID09PSAnX3JhdycgfHwgZlswXSAhPT0gJ18nOyAvLyBEb2VzIG5vdCBhbGxvdyAnX3RpbWUnIGVpdGhlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gSXMgdXNpbmcgVGltZWNoYXJ0IGNvbW1hbmRcbiAgICAgICAgICAgIGlzVGltZVNlcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0RmllbGROYW1lcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfKGZpZWxkcykuc29tZShmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmID09PSAnX3RpbWUnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0U3ZnQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kKCcuc3ZnLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0QmFja2dyb3VuZE1vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNvbmZpZy5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUuY29sb3JNb2RlJykgfHwgJ25vbmUnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdXBkYXRlQmFja2dyb3VuZERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0JhY2tncm91bmQoKSkge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gdGhpcy5nZXRTdmdDb250YWluZXIoKS5maW5kKCcuYmxvY2stYmFja2dyb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFja2dyb3VuZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLmF0dHIoJ3dpZHRoJywgdGhpcy5zdmdXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLmF0dHIoJ2hlaWdodCcsIHRoaXMuc3ZnSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRyYXdTZXZlcml0eUJhY2tncm91bmQ6IGZ1bmN0aW9uKCRzdmdDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNCYWNrZ3JvdW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHN2Z0NvbnRhaW5lci5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdmdVdGlsLmNyZWF0ZUVsZW1lbnQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc3ZnV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5zdmdIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdibG9jay1iYWNrZ3JvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5nZXRCYWNrZ3JvdW5kQ29sb3IoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZHJhd1N2Z0NvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyICRzdmdDb250YWluZXIgPSB0aGlzLmdldFN2Z0NvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgIGlmICgkc3ZnQ29udGFpbmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJHN2Z0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkc3ZnQ29udGFpbmVyID0gc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCdzdmcnKVxuICAgICAgICAgICAgICAgICAgICAud2lkdGgodGhpcy5zdmdXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodCh0aGlzLnN2Z0hlaWdodClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3N2Zy1jb250YWluZXInKVxuICAgICAgICAgICAgICAgICAgICAuY3NzKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXG4gICAgICAgICAgICAgICAgICAgIC5jc3MoJ3RvcCcsICcwJylcbiAgICAgICAgICAgICAgICAgICAgLmNzcygnbGVmdCcsICcwJyk7XG4gICAgICAgICAgICAgICAgJHN2Z0NvbnRhaW5lci5hcHBlbmRUbyh0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHN2Z0NvbnRhaW5lcjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRyYXdTcGFya2xpbmU6IGZ1bmN0aW9uKCRzdmdDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5zcGFya2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGFya2xpbmUuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BhcmtsaW5lLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNTcGFya2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5yZXN1bHRzLnNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFya2xpbmVEYXRhOiB0aGlzLm1vZGVsLnJlc3VsdHMuZ2V0KCdzcGFya2xpbmUnKS5zbGljZSgwKVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5zZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICBzcGFya2xpbmVPcGFjaXR5OiAxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BhcmtsaW5lID0gbmV3IFNwYXJrbGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRhdGlvbjogdGhpcy5tb2RlbC5wcmVzZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogdGhpcy5tb2RlbC5yZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLm1vZGVsLmNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGFya2xpbmUucmVuZGVyKCkuYXBwZW5kVG8oJHN2Z0NvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5yZXN1bHRzLnVuc2V0KCdzcGFya2xpbmVEYXRhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0RGlzcGxheU1vZGU6IGZ1bmN0aW9uKGRpc3BsYXlNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uc2V0KCdkaXNwbGF5TW9kZScsIGRpc3BsYXlNb2RlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRyYXdNYWluQm9keTogZnVuY3Rpb24oJHN2Z0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBtYWluQm9keVBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhRm9udFNpemUsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhU2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVZhbHVlRm9udCxcbiAgICAgICAgICAgICAgICAgICAgc2lkZUxhYmVsRm9udCxcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5kZXJMYWJlbCA9IHRoaXMubW9kZWwuY29uZmlnLmdldCgnZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS51bmRlckxhYmVsJyksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNb2RlID0gdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uZ2V0KCdkaXNwbGF5TW9kZScpLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZVNpbXBsZU11bHRpcGxpZXIgPSAwLjU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNTcGFya2xpbmUgJiYgaGFzVW5kZXJMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVWYWx1ZUZvbnQgPSA1MDtcbiAgICAgICAgICAgICAgICAgICAgc2lkZUxhYmVsRm9udCA9IDI4O1xuICAgICAgICAgICAgICAgICAgICBtYWluQm9keVBhZGRpbmcgPSA1MDtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFGb250U2l6ZSA9IDIwO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVNjYWxlID0gMC44NTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVWYWx1ZUZvbnQgPSA2NjtcbiAgICAgICAgICAgICAgICAgICAgc2lkZUxhYmVsRm9udCA9IDM3O1xuICAgICAgICAgICAgICAgICAgICBkZWx0YUZvbnRTaXplID0gMjY7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhU2NhbGUgPSAxLjE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNTcGFya2xpbmUgJiYgIWhhc1VuZGVyTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5Cb2R5UGFkZGluZyA9IDcwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkJvZHlQYWRkaW5nID0gNjA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheU1vZGUgPT09ICdzaW1wbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc3BsYXlNb2RlIHNpbXBsZSB1c2VzIHNtYWxsZXIgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGRlY3JlYXNlIHRoZSBjaGFuY2Ugb2YgcmUtZml0dGluZyBvZiBsYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcmUtZml0dGluZyBpcyBkaXNhYmxlZCBpbiBzaW1wbGUgZGlzcGxheSBtb2RlXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVZhbHVlRm9udCAqPSBkaXNwbGF5TW9kZVNpbXBsZU11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVMYWJlbEZvbnQgKj0gZGlzcGxheU1vZGVTaW1wbGVNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YUZvbnRTaXplICo9IGRpc3BsYXlNb2RlU2ltcGxlTXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFTY2FsZSAqPSBkaXNwbGF5TW9kZVNpbXBsZU11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIG1haW5Cb2R5UGFkZGluZyAtPSA2O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLm1haW5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubWFpbkJvZHkuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubWFpbkJvZHkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlVmFsdWVGb250U2l6ZTogc2luZ2xlVmFsdWVGb250LFxuICAgICAgICAgICAgICAgICAgICBzaWRlTGFiZWxGb250U2l6ZTogc2lkZUxhYmVsRm9udCxcbiAgICAgICAgICAgICAgICAgICAgbWFpbkJvZHlQYWRkaW5nOiBtYWluQm9keVBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhRm9udFNpemU6IGRlbHRhRm9udFNpemUsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhU2NhbGU6IGRlbHRhU2NhbGVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubWFpbkJvZHkgPSBuZXcgTWFpbkJvZHlWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uOiB0aGlzLm1vZGVsLmFwcGxpY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMubW9kZWwuY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogdGhpcy5tb2RlbC5yZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGF0aW9uOiB0aGlzLm1vZGVsLnByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY2hpbGRyZW4ubWFpbkJvZHksICdzaW5nbGVEcmlsbGRvd25DbGlja2VkJywgZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlRHJpbGxkb3duQ2xpY2tlZChwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jaGlsZHJlbi5tYWluQm9keSwgJ2FuY2hvclRhZ0NsaWNrZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQW5jaG9yVGFnQ2xpY2tlZChlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubWFpbkJvZHkucmVuZGVyKCkuYXBwZW5kVG8oJHN2Z0NvbnRhaW5lcik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoYW5kbGVTaW5nbGVEcmlsbGRvd25DbGlja2VkOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIocGFyYW1zLnNwZWNpZmljRXZlbnROYW1lcywgcGFyYW1zLmRyaWxsZG93bkluZm8pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGFuZGxlQW5jaG9yVGFnQ2xpY2tlZDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIC8vIHhsaW5rOmhyZWYgZG9lcyBub3Qgd29yayBmb3IgU1ZHIGFuY2hvcnMgaW4gb3VyIGNhc2UsIHNvIHdlIG11c3QgaGFuZGxlIHJlZGlyZWN0IG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgdmFyIGhyZWYgPSAkKGUuY3VycmVudFRhcmdldCkuYXR0cignaHJlZicpO1xuICAgICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlLnJlZGlyZWN0VG8oaHJlZiwgZHJpbGxkb3duVXRpbC5zaG91bGREcmlsbGRvd25Jbk5ld1RhYihlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZHJhd1VuZGVyTGFiZWw6IGZ1bmN0aW9uKCRzdmdDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdW5kZXJMYWJlbENvbG9yID0gdGhpcy5oYXNCYWNrZ3JvdW5kKCkgPyB0aGlzLkJMT0NLX0RFRkFVTFRfRk9OVF9DT0xPUiA6IHRoaXMuVU5ERVJMQUJFTF9DT0xPUixcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJMYWJlbE9wYWNpdHkgPSB0aGlzLmhhc0JhY2tncm91bmQoKSA/IDAuOCA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHVuZGVyTGFiZWxZO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzU3BhcmtsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuZGVyTGFiZWxZID0gNzI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJMYWJlbFkgPSA4NTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi51bmRlckxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4udW5kZXJMYWJlbC5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi51bmRlckxhYmVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5zZXQoe1xuICAgICAgICAgICAgICAgICAgICB1bmRlckxhYmVsWTogdW5kZXJMYWJlbFksXG4gICAgICAgICAgICAgICAgICAgIHVuZGVyTGFiZWxDb2xvcjogdW5kZXJMYWJlbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICB1bmRlckxhYmVsT3BhY2l0eTogdW5kZXJMYWJlbE9wYWNpdHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi51bmRlckxhYmVsID0gbmV3IFVuZGVyTGFiZWxWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLm1vZGVsLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IHRoaXMubW9kZWwucmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRhdGlvbjogdGhpcy5tb2RlbC5wcmVzZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbjogdGhpcy5tb2RlbC5hcHBsaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY2hpbGRyZW4udW5kZXJMYWJlbCwgJ3NpbmdsZURyaWxsZG93bkNsaWNrZWQnLCBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGVEcmlsbGRvd25DbGlja2VkKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNoaWxkcmVuLnVuZGVyTGFiZWwsICdhbmNob3JUYWdDbGlja2VkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFuY2hvclRhZ0NsaWNrZWQoZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnVuZGVyTGFiZWwucmVuZGVyKCkuYXBwZW5kVG8oJHN2Z0NvbnRhaW5lcik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkcmF3Q29tcG9uZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyICRzdmdDb250YWluZXIgPSB0aGlzLmRyYXdTdmdDb250YWluZXIoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaGFzU3BhcmtsaW5lID0gdGhpcy5tb2RlbC5yZXN1bHRzLmdldCgnc3BhcmtsaW5lJykgJiYgc3BsdW5rVXRpbC5ub3JtYWxpemVCb29sZWFuKHRoaXMubW9kZWwuY29uZmlnLmdldCgnZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS5zaG93U3BhcmtsaW5lJykpICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5zZXQoJ2hhc1NwYXJrbGluZScsIHRoaXMuaGFzU3BhcmtsaW5lKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NldmVyaXR5QmFja2dyb3VuZCgkc3ZnQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd01haW5Cb2R5KCRzdmdDb250YWluZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuY29uZmlnLmdldChcImRpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUudW5kZXJMYWJlbFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdVbmRlckxhYmVsKCRzdmdDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NwYXJrbGluZSgkc3ZnQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbmRlck1heFJlc3VsdENvdW50TWVzc2FnZTogZnVuY3Rpb24ocmVzdWx0Q291bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHNwbHVua1V0aWwuc3ByaW50ZihcbiAgICAgICAgICAgICAgICAgICAgXygnVGhlc2UgcmVzdWx0cyBtYXkgYmUgdHJ1bmNhdGVkLiBUaGlzIHZpc3VhbGl6YXRpb24gaXMgY29uZmlndXJlZCB0byBkaXNwbGF5IGEgbWF4aW11bSBvZiAlcyByZXN1bHRzIHBlciBzZXJpZXMsIGFuZCB0aGF0IGxpbWl0IGhhcyBiZWVuIHJlYWNoZWQuJykudCgpLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRDb3VudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5saW5lTWVzc2FnZS5odG1sKF8odGhpcy5pbmxpbmVNZXNzYWdlVGVtcGxhdGUpLnRlbXBsYXRlKHsgbWVzc2FnZTogbWVzc2FnZSwgbGV2ZWw6ICd3YXJuaW5nJyB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5saW5lTWVzc2FnZVRlbXBsYXRlOiAnXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtaW5saW5lIGFsZXJ0LTwlPSBsZXZlbCAlPiBhbGVydC1pbmxpbmVcIj4gXFxcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJpY29uLWFsZXJ0XCI+PC9pPiBcXFxuICAgICAgICAgICAgICAgICAgICA8JS0gbWVzc2FnZSAlPiBcXFxuICAgICAgICAgICAgICAgIDwvZGl2PiBcXFxuICAgICAgICAgICAgJyxcblxuICAgICAgICAgICAgdXBkYXRlVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXN1bHRTdGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3ModGhpcy5fZHluYW1pY0NsYXNzZXMgfHwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDbGFzc2VzID0gW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZy5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUuYWRkaXRpb25hbENsYXNzJyksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RmllbGRWYWx1ZSh0aGlzLm1vZGVsLmNvbmZpZy5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUuY2xhc3NGaWVsZCcpKVxuICAgICAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKHRoaXMuX2R5bmFtaWNDbGFzc2VzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0NvbXBvbmVudHMoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuJGlubGluZU1lc3NhZ2UucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5tb2RlbC5zZWFyY2hEYXRhUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuTUFYX1JFU1VMVF9DT1VOVCA9IHRoaXMubW9kZWwuc2VhcmNoRGF0YVBhcmFtcy5nZXQoJ2NvdW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5tb2RlbC5yZXN1bHRzLmdldCgnc3BhcmtsaW5lJykgJiYgdGhpcy5tb2RlbC5yZXN1bHRzLmdldCgnc3BhcmtsaW5lJykubGVuZ3RoID49IHRoaXMuTUFYX1JFU1VMVF9DT1VOVCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck1heFJlc3VsdENvdW50TWVzc2FnZSh0aGlzLk1BWF9SRVNVTFRfQ09VTlQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRpbmxpbmVNZXNzYWdlLmluc2VydEFmdGVyKHRoaXMuJCgnLnN2Zy1jb250YWluZXInKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBZGRlZFRvRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhlbWVVdGlscy5nZXRDdXJyZW50VGhlbWUoKSA9PT0gJ2RhcmsnID8gVEhFTUVTLmRhcmsgOiBUSEVNRVMuZW50ZXJwcmlzZSkpO1xuICAgIH1cbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvdmlld3Mvc2hhcmVkL3NpbmdsZXZhbHVlL01hc3Rlci5qc1xuLy8gbW9kdWxlIGlkID0gdmlld3Mvc2hhcmVkL3NpbmdsZXZhbHVlL01hc3RlclxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "uri/route":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/jquery\"), __webpack_require__(\"require/underscore\"), __webpack_require__(\"shim/splunk.util\"), __webpack_require__(\"util/splunkd_utils\"), __webpack_require__(\"stubs/splunk.config\"), __webpack_require__(\"util/console\")], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, splunkutil, splunkdUtils, splunkConfig, console)\n{\n    var exports = {};\n    exports.getSplunkVersion = function(){\n        var version = \"@\" + encodeURIComponent(String(splunkConfig.BUILD_NUMBER));\n        if (splunkConfig.BUILD_PUSH_NUMBER) {\n            version += \".\" + encodeURIComponent(String(splunkConfig.BUILD_PUSH_NUMBER));\n        }\n        return version;\n    };\n    exports.encodeRoot = function(path, locale) {\n        if (splunkConfig.INDEPENDENT_MODE) {\n            console.warn('route: Trying to generate URL in independent mode when URL structure is unknown');\n        }\n\n        var parts = _.map((path || '').split('/'), function(part) {\n            return encodeURIComponent(part);\n        });\n        path = parts.join('/');\n        path = path ? '/' + path : path;\n        return path + '/' + encodeURIComponent(locale);\n    };\n    exports.alertActionIconFile = function(root, locale, appName, options) {\n        options = options || {};\n        var version = exports.getSplunkVersion();\n        if (options.file) {\n            if (appName === 'system') {\n                return exports.img(root, locale, version, options.file);\n            }\n            return exports.appStaticFileVersioned(root, locale, version, appName, options.file);\n        } else {\n            return exports.img(root, locale, version, 'mod_alert_icon_default.png');\n        }\n    };\n    exports.vizIconFile = function(root, locale, appBuildNumber, appName, fileName, directory) {\n        var systemDirectory = 'viz_previews';\n        var defaultIcon = 'default.png';\n        fileName = fileName || defaultIcon;\n\n        if (appName === 'system') {\n            var version = exports.getSplunkVersion();\n            directory = systemDirectory;\n            return exports.img(root, locale, version, fileName, directory);\n        }\n        else {\n            return exports.appVizFileVersioned(root, locale, appBuildNumber, appName, fileName, directory);\n        }\n    };\n    exports.appStaticFileAppVersioned = function(root, locale, appBuildNumber, appName, path) {\n        var version = exports.getSplunkVersion();\n        if (appBuildNumber){\n            version += \"-\" + encodeURIComponent(String(appBuildNumber));\n        }\n        return exports.encodeRoot(root, locale) + '/static/'+ version + '/app/' + encodeURIComponent(appName) + '/' + path;\n    };\n    exports.appVizFileVersioned = function(root, locale, appBuildNumber, appName, file, directory) {\n        return exports.appStaticFileAppVersioned(root, locale, appBuildNumber, appName, 'visualizations/' + encodeURIComponent(directory) + '/' + file);\n    };\n    exports.appStaticFileVersioned = function(root, locale, version, appName, file) {\n        return exports.encodeRoot(root, locale) + '/static/'+ version + '/app/' + encodeURIComponent(appName) + '/' + file;\n    };\n    exports.appStaticFile = function(root, locale, appName, file) {\n        return exports.encodeRoot(root, locale) + '/static/app/' + encodeURIComponent(appName) + '/' + file;\n    };\n    exports.staticFile = function(root, locale, version, file) {\n        return exports.encodeRoot(root,  locale)  + '/static/' + version + '/' + encodeURIComponent(file);\n    };\n    exports.img = function(root, locale, version, file, directory) {\n        var url = exports.encodeRoot(root,  locale)  + '/static/';\n        if (!_.isUndefined(version) && !_.isNull(version)) {\n            url += version + '/';\n        }\n        url += 'img/';\n        if (!_.isUndefined(directory)) {\n            url += encodeURIComponent(directory) + '/';\n        }\n        url += encodeURIComponent(file);\n        return url;\n    };\n    /**\n     * Convenience method for static asset URL, mostly used on the login page when window.$C doesn't contain the BUILD_NUMBER.\n     * Consider using splunkutil.make_url or any other method in this file before using this method.\n     * @param root application root.\n     * @param locale application locale.\n     * @param version on the login page, window.$C doesn't contain the BUILD_NUMBER, so we created this convenience method that build the URL\n     * @param assetPath array of string containing deep folder structure and the filename.\n     */\n    exports.staticAssetUrl = function(root, locale, version, assetPath) {\n        return exports.staticFile(root, locale, \"@\" + version, assetPath.join('/'));\n    };\n    /**\n     * This method builds the logo URL of the login page.\n     * If this is a full URL, http(s)://www.splunk.com/logo/png, just returns it.\n     * @param root\n     * @param locale\n     * @param version window.$C['BUILD_NUMBER'] or preferably this.model.serverInfo.entry.content.get('build')\n     * @param assetData the conf value of the loginCustomLogo conf variable: this.model.web.entry.content.get('loginCustomLogo')\n     * @returns {*}\n     */\n    exports.loginPageLogo = function(root, locale, version, assetData) {\n        var url = assetData;\n        var regex = new RegExp(/https?:\\/\\//);\n        // Construct logo URL if it's not a full URL\n        if (url && !regex.test(url)) {\n            url = exports.staticAssetUrl(root, locale, version, exports.assetPath(url));\n        }\n        return url;\n    };\n    /**\n     * This method builds the background image URL of the login page.\n     * @param root\n     * @param locale\n     * @param version window.$C['BUILD_NUMBER'] or preferably this.model.serverInfo.entry.content.get('build')\n     * @param assetData the conf value of the loginCustomBackgroundImage conf variable: this.model.web.entry.content.get('loginCustomBackgroundImage')\n     */\n    exports.loginPageBackground = function(root, locale, version, assetData) {\n        return exports.staticAssetUrl(root, locale, version, exports.assetPath(assetData));\n    };\n    /**\n     * This helper method builds an array of URL fragments of an asset given an asset data (most likely a conf variable)\n     * In order to build the URL of an asset, this methods is looking for a app namespace in the asset data.\n     * If no app namespace provided, default to 'search'.\n     * Then, append the assetPath to the array splitting by slashes.\n     * Example 1:\n     * - assetData = simplexml:directory/file.ext\n     * will return ['app','simplexml','directory','file.ext']\n     * Example 2:\n     * - assetData = directory/file.ext\n     * will return ['app','search','directory','file.ext']\n     * @param assetData\n     * @returns {string[]}\n     */\n    exports.assetPath = function(assetData) {\n        var assetPath = ['app'];\n        assetPath.push(assetData.substring(0,assetData.indexOf(\":\")) || 'search');\n        assetPath = assetPath.concat(assetData.substring(assetData.indexOf(\":\") + 1).split('/'));\n        return assetPath;\n    };\n    exports.page = function(root, locale, app, page, options) {\n        if(typeof page === 'undefined'){\n            page = '';\n        }\n        var url = exports.encodeRoot(root, locale) + '/app/' + encodeURIComponent(app);\n            if (_.isArray(page)) {\n            _.each(page, function(dir) {\n                url += '/' + encodeURIComponent(dir);\n            });\n        } else {\n            url += '/' + encodeURIComponent(page);\n        }\n        if (options) {\n            if (options.data) {\n                url = url + '?' + splunkutil.propToQueryString(options.data);\n            }\n            if (options.absolute) {\n                url = window.location.protocol + \"//\" + window.location.host + url;\n            }\n        }\n        return url;\n    };\n    exports.appIcon = function(root, locale, owner, app, options){\n        options = options || {};\n        var size = '';\n        if((window && window.devicePixelRatio > 1) || options.hiRes) {\n            size = '_2x';\n        }\n        return exports.splunkdNS(root, locale, owner, app, 'static/appIcon'+size+'.png', options);\n    };\n    exports.appIconAlt = function(root, locale, owner, app, options){\n        var size = '';\n        if(window && window.devicePixelRatio > 1){\n            size = '_2x';\n        }\n        return exports.splunkdNS(root, locale, owner, app, 'static/appIconAlt'+size+'.png', options);\n    };\n    exports.appLogo = function(root, locale, owner, app, options){\n        var size = '';\n        if(window && window.devicePixelRatio > 1){\n            size = '_2x';\n        }\n        return exports.splunkdNS(root, locale, owner, app, 'static/appLogo'+size+'.png', options);\n    };\n    exports.fileExplorer = function(root, locale, owner, app, options){\n        return exports.splunkdNS(root, locale, owner, app, 'admin/file-explorer', options);\n    };\n    exports.regExplorer = function(root, locale, owner, app, options){\n        return exports.splunkdNS(root, locale, owner, app, 'admin/win-reg-explorer', options);\n    };\n    exports.adExplorer = function(root, locale, owner, app, options){\n        return exports.splunkdNS(root, locale, owner, app, 'admin/win-ad-explorer', options);\n    };\n    exports.gettingStartedPlaceholderContent = function(root, locale, owner, app, options){\n        return exports.splunkdNS(root, locale, owner, app, 'static/gettingStartedPlaceholder.png', options);\n    };\n    exports.chooseDashboardIcon = function(root, locale, owner, app, options){\n        return exports.splunkdNS(root, locale, owner, app, 'static/chooseDashboardIcon.png', options);\n    };\n    exports.moreAppsIcon = function(root, locale, owner, app, options){\n        return exports.splunkdNS(root, locale, owner, app, 'static/moreAppsIcon.png', options);\n    };\n    exports.splunkd = function(root, locale){\n        return exports.encodeRoot(root, locale) + '/splunkd';\n    };\n    exports.splunkdRaw = function(root, locale){\n        return exports.splunkd(root, locale) + '/__raw';\n    };\n    exports.splunkdNS = function(root, locale, owner, app, path){\n        return exports.splunkdRaw(root, locale) + '/servicesNS/' + encodeURIComponent(owner) + '/' + encodeURIComponent(app) + '/' + path;\n    };\n    exports.indexingPreviewUpload = function(root, locale){\n        return exports.splunkd(root, locale) + '/__upload/indexing/preview';\n    };\n    exports.receiversStream = function(root, locale){\n        return exports.splunkd(root, locale) + '/__upload/receivers/stream';\n    };\n    exports.identicons = function(root, locale, value){\n        return exports.encodeRoot(root, locale) + '/static/app/search/identicons/' + encodeURIComponent(value) + '.png';\n    };\n    exports.pivot = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'pivot', options);\n    };\n    exports.table = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'table', options);\n    };\n    exports.dynamic_data = function(root, locale, app, options) {\n        options = options || {};\n        return exports.page(root, locale, 'dynamic-data-self-storage-app', \"self-storage-locations\", options);\n    };\n    exports.dataset = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'dataset', options);\n    };\n    exports.datasets = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'datasets', options);\n    };\n    exports.data_model_manager = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'data_model_manager', options);\n    };\n    exports.data_model_editor = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'data_model_editor', options);\n    };\n    exports.field_extractor = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'field_extractor', options);\n    };\n    exports.search = function(root, locale, app, options) {\n        if (app === splunkdUtils.SYSTEM) {\n            app = 'search';\n        }\n        return exports.page(root, locale, app, 'search', options);\n    };\n    exports.analysis_workspace = function(root, locale, app, options) {\n        if (app === splunkdUtils.SYSTEM) {\n            app = 'search';\n        }\n        return exports.page(root, locale, app, 'analysis_workspace', options);\n    };\n    exports.report = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'report', options);\n    };\n    exports.reports = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'reports', options);\n    };\n    exports.alert = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'alert', options);\n    };\n    exports.alerts = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'alerts', options);\n    };\n    exports.job_manager = function(root, locale, app, options) {\n        return exports.page(root, locale, app, 'job_manager', options);\n    };\n    exports.managementConsole = function(root, locale, options) {\n        return exports.page(root, locale, 'splunk_monitoring_console', 'monitoringconsole_overview', options);\n    };\n    exports.addData = function(root, locale, app, step, options) {\n        // if app is not provided, default to search\n        var page = step ? [\"adddatamethods\", step] : 'adddata';\n        return exports.manager(root, locale, app || \"search\", page, options);\n    };\n    exports.editDashboard = function(root, locale, app, name, options) {\n        return exports.page(root, locale, app, [name, 'edit'], options);\n    };\n    exports.dashboardFromID = function(root, locale, id, options) {\n        options = options || {};\n        //owner[1]/app[0]/data[2]/ui[3]/views[4]/name[5]\n        var parts = id.split('/').slice(-6);\n        return this.page(root, locale, parts[1], parts[5], options);\n    };\n    exports.logout = function(root, locale) {\n        return exports.encodeRoot(root, locale) + '/account/logout';\n    };\n    exports.proxyLogin = function(root, locale) {\n        return exports.encodeRoot(root, locale) + '/account/login';\n    };\n    exports.returnTo = function(root, locale, url) {\n        if (url.indexOf('/')===0) {\n            return url.replace(/^[\\/\\s\\\\]+/, '/');\n        }\n        return exports.encodeRoot(root, locale);\n    };\n    exports.embed = function(root, locale, embedToken, savedSearchId) {\n        var url,\n        data = {\n            s: savedSearchId,\n            oid: embedToken\n        };\n        if (splunkConfig.EMBED_URI) {\n            url = splunkConfig.EMBED_URI + '/';\n        } else {\n            url = window.location.protocol + \"//\" + window.location.host + '/';\n            if (root) {\n                url += root + '/';\n            }\n        }\n        return url + locale + '/embed?' + splunkutil.propToQueryString(data);\n    };\n    exports.jobInspector = function(root, locale, app, sid) {\n        var options = {\n                data: {\n                    sid: sid\n                }\n            };\n        // SPL-132167 SplunkWebCore needs to support previous versions.\n        // Remove this if statement once SplunkWebCore no longer needs to support 6.4\n        var sixDotMatch = splunkConfig.VERSION_LABEL.match(/^6\\.(\\d)\\./);\n        if (sixDotMatch && (sixDotMatch[1] < 5)) {\n            options.data.namespace = app;\n            return exports.encodeRoot(root, locale) + '/search/inspector' + '?' + splunkutil.propToQueryString(options.data);\n        }\n        return exports.manager(root, locale, app, 'job_inspector', options);\n    };\n    exports.searchJobUrls = function(root, locale, sid, page, options) {\n        var url = exports.encodeRoot(root, locale) + '/api/search/jobs/' + encodeURIComponent(sid) + '/' + encodeURIComponent(page);\n        if (options && options.data) {\n            url = url + '?' + splunkutil.propToQueryString(options.data);\n        }\n        return url;\n    };\n    exports.searchJobTimeline = function(root, locale, sid, options) {\n        return exports.searchJobUrls(root, locale, sid, 'timeline', options);\n    };\n    exports.searchJobSummary = function(root, locale, sid, options) {\n        return exports.searchJobUrls(root, locale, sid, 'summary', options);\n    };\n    exports.manager = function(root, locale, app, page, options) {\n        var url =  exports.encodeRoot(root, locale) + '/manager/' + encodeURIComponent(app);\n        if (_.isArray(page)) {\n            _.each(page, function(dir) {\n                url += '/' + encodeURIComponent(dir);\n            });\n        } else {\n            url += '/' + encodeURIComponent(page);\n        }\n        if (options) {\n            if (options.data) {\n                url = url + '?' + splunkutil.propToQueryString(options.data);\n            }\n        }\n        return url;\n    };\n    exports.appSetupLink = function(root, locale, app, options) {\n        options || (options = {});\n        options.data = _.extend({ action: 'edit' }, options.data);\n        var page = ['apps', 'local', app, 'setup'];\n        return exports.manager(root, locale, app, page, options);\n    };\n\n    exports.archives = function(root, locale, app, options) {\n        options = options || {};\n        return exports.manager(root, locale, app, \"archives\", options);\n    };\n    exports.indexes = function(root, locale, app, options) {\n        options = options || {};\n        return exports.manager(root, locale, app, \"data/indexes\", options);\n    };\n    // HUNK routes\n    exports.providers = function(root, locale, app, options) {\n        options = options || {};\n        _(options).defaults({data:{t:\"providers\"}});\n        return exports.manager(root, locale, \"system\", \"virtual_indexes\", options);\n    };\n    exports.virtualIndexes = function(root, locale, app, options) {\n        options = options || {};\n        _(options).defaults({data:{t:\"indexes\"}});\n        return exports.manager(root, locale, \"system\", \"virtual_indexes\", options);\n    };\n    exports.exploreData = function(root, locale, app, options) {\n        options = options || {};\n        return exports.manager(root, locale, \"system\", \"explore_data\", options);\n    };\n    exports.managerEdit = function(root, locale, app, page, id, options) {\n        options = options || {};\n        options = $.extend(true, {data: {action: 'edit', uri: id}}, options);\n        return exports.manager(root, locale, app, page, options);\n    };\n    exports.managerPermissions = function(root, locale, app, page, id, options) {\n        options || (options = {});\n        var url =  exports.encodeRoot(root, locale) + '/manager/permissions/' + encodeURIComponent(app);\n        url += '/' + _.chain([page]).flatten().map(encodeURIComponent).value().join('/');\n        url += '/' + encodeURIComponent(id);\n        if (options.data) {\n            url = url + '?' + splunkutil.propToQueryString(options.data);\n        }\n        return url;\n    };\n    exports.triggeredAlerts = function(root, locale, app, options) {\n        var url = exports.encodeRoot(root, locale) + '/alerts/' + encodeURIComponent(app);\n        if (options) {\n            if (options.data) {\n                url = url + '?' + splunkutil.propToQueryString(options.data);\n            }\n        }\n        return url;\n    };\n    exports.docSearch = function(locale, version, isFree, isTrial, search) {\n        var base = 'http://docs.splunk.com/Special:SplunkSearch/docs',\n            params = {\n                locale: locale,\n                versionNumber: version,\n                license: isFree ? 'free' : 'pro',\n                installType: isTrial ? 'trial' : 'prod',\n                q: search\n            };\n        return base + '?' + splunkutil.propToQueryString(params);\n    };\n    exports.docHelp = function(root, locale, location) {\n        locale = locale || splunkdUtils.DEFAULT_LOCALE;\n        var url =  exports.encodeRoot(root, locale) + '/help',\n            params = {\n                location: location\n            };\n        return url + '?' + splunkutil.propToQueryString(params);\n    };\n    exports.docHelpInAppContext = function(root, locale, location, appName, appVersion, isCoreApp, appDocSectionOverride) {\n        var url = exports.encodeRoot(root, locale) + '/help',\n            params = {\n                location: location\n            };\n            // add [appName:appVersion] or [appDocsSectionOverride] prefix if the app is NOT a core app\n            if (!isCoreApp) {\n                if (appDocSectionOverride) {\n                    params.location = '[' + appDocSectionOverride + ']' + params.location;\n                } else {\n                    params.location = '[' + appName + ':' + appVersion + ']' + params.location;\n                }\n            }\n        return url + '?' + splunkutil.propToQueryString(params);\n    };\n    exports.exportUrl = function(root, locale, sid, filename, format, count, isReport, options) {\n        options = options || {};\n        var resultType = isReport ? 'results' : 'event';\n        var url = exports.encodeRoot(root, locale) + '/api/search/jobs/' + encodeURIComponent(sid) + '/' + resultType;\n        var params = {\n            isDownload: true,\n            timeFormat: options.timeFormat || '%FT%T.%Q%:z',\n            maxLines: 0,\n            count: count,\n            filename: filename || '',\n            outputMode: format\n        };\n        url += '?' + splunkutil.propToQueryString(params);\n\n        _.each(options.fields, function(field) {\n            url += '&field_list=' + field;\n        }, this);\n\n        return url;\n    };\n    exports.updateChecker = function(baseURL, isFree, versionNumber, checkerLocation, isTrial, guid, masterGuid) {\n        var url,\n            installType = (isTrial) ? 'trial' : 'prod',\n            licenseType = (isFree) ? 'free' : 'pro';\n        if (guid!==masterGuid) {\n            installType += '_slave';\n        }\n        url = baseURL + licenseType + '/' +  encodeURIComponent(versionNumber) + '/' +  encodeURIComponent(checkerLocation) + '/' +  encodeURIComponent(installType) + '/basic';\n        return url;\n    };\n    exports.answers = function() {\n        return 'http://answers.splunk.com';\n    };\n    exports.getContextualPageRouter = function(applicationModel) {\n        var root = applicationModel.get('root'),\n            locale = applicationModel.get('locale'),\n            app = applicationModel.get('app'),\n            nonPageMethods = ['page', 'docSearch', 'docHelp', 'docHelpInAppContext', 'exportUrl', 'exportUrl', 'getContextualPageRouter', 'pageStart', 'encodeRoot', 'redirectTo'],\n            routeNames = _(exports).chain().functions().difference(nonPageMethods),\n            router = {};\n\n        _(routeNames).each(function(route) {\n            var routeFn = exports[route];\n            router[route] = function() {\n                var fullArgs = [root, locale, app].concat(_(arguments).toArray());\n                return routeFn.apply(null, fullArgs);\n            };\n        });\n        return router;\n    };\n    exports.appNavUrl = function(root, locale, app){\n        return exports.encodeRoot(root,  locale)  + '/appnav/' + encodeURIComponent((app || ''));\n    };\n    exports.appsRemote = function(root, locale, app, options){\n       return  exports.manager(root, locale, app, 'appsremote', options);\n    };\n    exports.appsLocal = function(root, locale, app, options){\n        return  exports.manager(root, locale, app, ['apps','local'], options);\n    };\n    exports.splunkbaseApp = function(app) {\n        return 'https://apps.splunk.com/app/' + encodeURIComponent(app);\n    };\n    exports.appInstallRestart = function(root, locale, app){\n        return exports.manager(root, locale, 'system', 'control') + '?return_to=' + encodeURIComponent('/en-US/app/' + app) + '&auto_restart=1';\n    };\n    exports.appSetup = function(root, locale, setuplink){\n        return exports.encodeRoot(root,  locale)  + setuplink;\n    };\n    exports.viewStrings = function(root, locale, app, view){\n        return exports.page(root, locale, app, view) + \"/strings\";\n    };\n    exports.prebuiltAppLink = function(root, locale, app, link) {\n        /* properly sets up a URL for an /app/<app> link\n         *  returns root/locale/app/link\n         *  since link may contain a query string, it is not encoded\n         *  example:\n         *     root = /gadzooks, locale = en-US, app = search, link = search?tour=test\n         *     return /gadzooks/en-US/search/search?tour=test\n         */\n        return exports.encodeRoot(root, locale) + '/app/' + encodeURIComponent(app) + '/' + link;\n    };\n    exports.home = function(root, locale) {\n        /* our routing system routes /root/locale to the user's default app/default page\n         * as we ship, this is launcher/home, but the user can override this\n         * root and locale are accessible from application model\n         */\n        return exports.encodeRoot(root, locale);\n    };\n    /**\n     * Redirects to a new url, optionally in a new tab.\n     *\n     * Intentionally forked from the redirect_to function in util.js, instead providing a redirect method\n     * that is intended to consume a fully-formed URL like the ones generated by the other methods in this file.\n     *\n     * Correctly handles the case where we have an asynchronously generated URL that needs to open in a new tab.\n     * The new tab is created synchronously (to avoid pop-up blockers) and given its location when the promise resolves.\n     *\n     * @param url {String or a promise resolving with a string} the URL to navigate to\n     * @param useNewTab {Boolean}\n     *\n     */\n    exports.redirectTo = function(url, useNewTab) {\n        var target = useNewTab ? window.open() : window;\n        target.focus();\n        $.when(url)\n            .done(function(newLocation) {\n                target.location = newLocation;\n            })\n            .fail(function() {\n                console.error('failed to open new URL: ' + url);\n                console.error.apply(console, arguments);\n                if(useNewTab) {\n                    target.close();\n                }\n            });\n    };\n    exports.sourcetypeList = function(root, locale, app, options) {\n        // if app is not provided, default to search\n        return exports.manager(root, locale, app, 'sourcetypes', options);\n    };\n    exports.sourcetypeEdit = function(root, locale, app, id, options) {\n        // if app is not provided, default to search\n        return exports.sourcetypeList(root, locale, app, options) + '/'+id;\n    };\n    exports.spmetadata = function(root, locale) {\n        return exports.encodeRoot(root, locale) + '/saml/spmetadata';\n    };\n\n    exports.getView = function(view) {\n        switch (view) {\n            case 'analysis_workspace':\n                return {openLabel: _('Open in Metrics Workspace').t(), route: exports.analysis_workspace};\n            case 'pivot':\n                return {openLabel: _('Open in Pivot').t(), route: exports.pivot};\n            default:\n                return {openLabel: _('Open in Search').t(), route: exports.search};\n        }\n    };\n\n    return exports;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3VyaS9yb3V0ZS5qcz8yZTJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQSxpQ0FDQSxzUkFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTSxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU0sYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8seUJBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoidXJpL3JvdXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFxuICAgIFsnanF1ZXJ5JywgJ3VuZGVyc2NvcmUnLCAnc3BsdW5rLnV0aWwnLCAndXRpbC9zcGx1bmtkX3V0aWxzJywgJ3NwbHVuay5jb25maWcnLCAndXRpbC9jb25zb2xlJ10sXG4gICAgZnVuY3Rpb24oJCwgXywgc3BsdW5rdXRpbCwgc3BsdW5rZFV0aWxzLCBzcGx1bmtDb25maWcsIGNvbnNvbGUpXG57XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICBleHBvcnRzLmdldFNwbHVua1ZlcnNpb24gPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdmVyc2lvbiA9IFwiQFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzcGx1bmtDb25maWcuQlVJTERfTlVNQkVSKSk7XG4gICAgICAgIGlmIChzcGx1bmtDb25maWcuQlVJTERfUFVTSF9OVU1CRVIpIHtcbiAgICAgICAgICAgIHZlcnNpb24gKz0gXCIuXCIgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNwbHVua0NvbmZpZy5CVUlMRF9QVVNIX05VTUJFUikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIH07XG4gICAgZXhwb3J0cy5lbmNvZGVSb290ID0gZnVuY3Rpb24ocGF0aCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChzcGx1bmtDb25maWcuSU5ERVBFTkRFTlRfTU9ERSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdyb3V0ZTogVHJ5aW5nIHRvIGdlbmVyYXRlIFVSTCBpbiBpbmRlcGVuZGVudCBtb2RlIHdoZW4gVVJMIHN0cnVjdHVyZSBpcyB1bmtub3duJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFydHMgPSBfLm1hcCgocGF0aCB8fCAnJykuc3BsaXQoJy8nKSwgZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwYXJ0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG4gICAgICAgIHBhdGggPSBwYXRoID8gJy8nICsgcGF0aCA6IHBhdGg7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGxvY2FsZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmFsZXJ0QWN0aW9uSWNvbkZpbGUgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciB2ZXJzaW9uID0gZXhwb3J0cy5nZXRTcGx1bmtWZXJzaW9uKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmZpbGUpIHtcbiAgICAgICAgICAgIGlmIChhcHBOYW1lID09PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmltZyhyb290LCBsb2NhbGUsIHZlcnNpb24sIG9wdGlvbnMuZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5hcHBTdGF0aWNGaWxlVmVyc2lvbmVkKHJvb3QsIGxvY2FsZSwgdmVyc2lvbiwgYXBwTmFtZSwgb3B0aW9ucy5maWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmltZyhyb290LCBsb2NhbGUsIHZlcnNpb24sICdtb2RfYWxlcnRfaWNvbl9kZWZhdWx0LnBuZycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnZpekljb25GaWxlID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHBCdWlsZE51bWJlciwgYXBwTmFtZSwgZmlsZU5hbWUsIGRpcmVjdG9yeSkge1xuICAgICAgICB2YXIgc3lzdGVtRGlyZWN0b3J5ID0gJ3Zpel9wcmV2aWV3cyc7XG4gICAgICAgIHZhciBkZWZhdWx0SWNvbiA9ICdkZWZhdWx0LnBuZyc7XG4gICAgICAgIGZpbGVOYW1lID0gZmlsZU5hbWUgfHwgZGVmYXVsdEljb247XG5cbiAgICAgICAgaWYgKGFwcE5hbWUgPT09ICdzeXN0ZW0nKSB7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IGV4cG9ydHMuZ2V0U3BsdW5rVmVyc2lvbigpO1xuICAgICAgICAgICAgZGlyZWN0b3J5ID0gc3lzdGVtRGlyZWN0b3J5O1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuaW1nKHJvb3QsIGxvY2FsZSwgdmVyc2lvbiwgZmlsZU5hbWUsIGRpcmVjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5hcHBWaXpGaWxlVmVyc2lvbmVkKHJvb3QsIGxvY2FsZSwgYXBwQnVpbGROdW1iZXIsIGFwcE5hbWUsIGZpbGVOYW1lLCBkaXJlY3RvcnkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmFwcFN0YXRpY0ZpbGVBcHBWZXJzaW9uZWQgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcEJ1aWxkTnVtYmVyLCBhcHBOYW1lLCBwYXRoKSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gZXhwb3J0cy5nZXRTcGx1bmtWZXJzaW9uKCk7XG4gICAgICAgIGlmIChhcHBCdWlsZE51bWJlcil7XG4gICAgICAgICAgICB2ZXJzaW9uICs9IFwiLVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhcHBCdWlsZE51bWJlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVJvb3Qocm9vdCwgbG9jYWxlKSArICcvc3RhdGljLycrIHZlcnNpb24gKyAnL2FwcC8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFwcE5hbWUpICsgJy8nICsgcGF0aDtcbiAgICB9O1xuICAgIGV4cG9ydHMuYXBwVml6RmlsZVZlcnNpb25lZCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwQnVpbGROdW1iZXIsIGFwcE5hbWUsIGZpbGUsIGRpcmVjdG9yeSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5hcHBTdGF0aWNGaWxlQXBwVmVyc2lvbmVkKHJvb3QsIGxvY2FsZSwgYXBwQnVpbGROdW1iZXIsIGFwcE5hbWUsICd2aXN1YWxpemF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRpcmVjdG9yeSkgKyAnLycgKyBmaWxlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuYXBwU3RhdGljRmlsZVZlcnNpb25lZCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgdmVyc2lvbiwgYXBwTmFtZSwgZmlsZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVSb290KHJvb3QsIGxvY2FsZSkgKyAnL3N0YXRpYy8nKyB2ZXJzaW9uICsgJy9hcHAvJyArIGVuY29kZVVSSUNvbXBvbmVudChhcHBOYW1lKSArICcvJyArIGZpbGU7XG4gICAgfTtcbiAgICBleHBvcnRzLmFwcFN0YXRpY0ZpbGUgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcE5hbWUsIGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUm9vdChyb290LCBsb2NhbGUpICsgJy9zdGF0aWMvYXBwLycgKyBlbmNvZGVVUklDb21wb25lbnQoYXBwTmFtZSkgKyAnLycgKyBmaWxlO1xuICAgIH07XG4gICAgZXhwb3J0cy5zdGF0aWNGaWxlID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCB2ZXJzaW9uLCBmaWxlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVJvb3Qocm9vdCwgIGxvY2FsZSkgICsgJy9zdGF0aWMvJyArIHZlcnNpb24gKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoZmlsZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmltZyA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgdmVyc2lvbiwgZmlsZSwgZGlyZWN0b3J5KSB7XG4gICAgICAgIHZhciB1cmwgPSBleHBvcnRzLmVuY29kZVJvb3Qocm9vdCwgIGxvY2FsZSkgICsgJy9zdGF0aWMvJztcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHZlcnNpb24pICYmICFfLmlzTnVsbCh2ZXJzaW9uKSkge1xuICAgICAgICAgICAgdXJsICs9IHZlcnNpb24gKyAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgdXJsICs9ICdpbWcvJztcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGRpcmVjdG9yeSkpIHtcbiAgICAgICAgICAgIHVybCArPSBlbmNvZGVVUklDb21wb25lbnQoZGlyZWN0b3J5KSArICcvJztcbiAgICAgICAgfVxuICAgICAgICB1cmwgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGZpbGUpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBzdGF0aWMgYXNzZXQgVVJMLCBtb3N0bHkgdXNlZCBvbiB0aGUgbG9naW4gcGFnZSB3aGVuIHdpbmRvdy4kQyBkb2Vzbid0IGNvbnRhaW4gdGhlIEJVSUxEX05VTUJFUi5cbiAgICAgKiBDb25zaWRlciB1c2luZyBzcGx1bmt1dGlsLm1ha2VfdXJsIG9yIGFueSBvdGhlciBtZXRob2QgaW4gdGhpcyBmaWxlIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gcm9vdCBhcHBsaWNhdGlvbiByb290LlxuICAgICAqIEBwYXJhbSBsb2NhbGUgYXBwbGljYXRpb24gbG9jYWxlLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIG9uIHRoZSBsb2dpbiBwYWdlLCB3aW5kb3cuJEMgZG9lc24ndCBjb250YWluIHRoZSBCVUlMRF9OVU1CRVIsIHNvIHdlIGNyZWF0ZWQgdGhpcyBjb252ZW5pZW5jZSBtZXRob2QgdGhhdCBidWlsZCB0aGUgVVJMXG4gICAgICogQHBhcmFtIGFzc2V0UGF0aCBhcnJheSBvZiBzdHJpbmcgY29udGFpbmluZyBkZWVwIGZvbGRlciBzdHJ1Y3R1cmUgYW5kIHRoZSBmaWxlbmFtZS5cbiAgICAgKi9cbiAgICBleHBvcnRzLnN0YXRpY0Fzc2V0VXJsID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCB2ZXJzaW9uLCBhc3NldFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc3RhdGljRmlsZShyb290LCBsb2NhbGUsIFwiQFwiICsgdmVyc2lvbiwgYXNzZXRQYXRoLmpvaW4oJy8nKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBidWlsZHMgdGhlIGxvZ28gVVJMIG9mIHRoZSBsb2dpbiBwYWdlLlxuICAgICAqIElmIHRoaXMgaXMgYSBmdWxsIFVSTCwgaHR0cChzKTovL3d3dy5zcGx1bmsuY29tL2xvZ28vcG5nLCBqdXN0IHJldHVybnMgaXQuXG4gICAgICogQHBhcmFtIHJvb3RcbiAgICAgKiBAcGFyYW0gbG9jYWxlXG4gICAgICogQHBhcmFtIHZlcnNpb24gd2luZG93LiRDWydCVUlMRF9OVU1CRVInXSBvciBwcmVmZXJhYmx5IHRoaXMubW9kZWwuc2VydmVySW5mby5lbnRyeS5jb250ZW50LmdldCgnYnVpbGQnKVxuICAgICAqIEBwYXJhbSBhc3NldERhdGEgdGhlIGNvbmYgdmFsdWUgb2YgdGhlIGxvZ2luQ3VzdG9tTG9nbyBjb25mIHZhcmlhYmxlOiB0aGlzLm1vZGVsLndlYi5lbnRyeS5jb250ZW50LmdldCgnbG9naW5DdXN0b21Mb2dvJylcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBleHBvcnRzLmxvZ2luUGFnZUxvZ28gPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIHZlcnNpb24sIGFzc2V0RGF0YSkge1xuICAgICAgICB2YXIgdXJsID0gYXNzZXREYXRhO1xuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKC9odHRwcz86XFwvXFwvLyk7XG4gICAgICAgIC8vIENvbnN0cnVjdCBsb2dvIFVSTCBpZiBpdCdzIG5vdCBhIGZ1bGwgVVJMXG4gICAgICAgIGlmICh1cmwgJiYgIXJlZ2V4LnRlc3QodXJsKSkge1xuICAgICAgICAgICAgdXJsID0gZXhwb3J0cy5zdGF0aWNBc3NldFVybChyb290LCBsb2NhbGUsIHZlcnNpb24sIGV4cG9ydHMuYXNzZXRQYXRoKHVybCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBidWlsZHMgdGhlIGJhY2tncm91bmQgaW1hZ2UgVVJMIG9mIHRoZSBsb2dpbiBwYWdlLlxuICAgICAqIEBwYXJhbSByb290XG4gICAgICogQHBhcmFtIGxvY2FsZVxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIHdpbmRvdy4kQ1snQlVJTERfTlVNQkVSJ10gb3IgcHJlZmVyYWJseSB0aGlzLm1vZGVsLnNlcnZlckluZm8uZW50cnkuY29udGVudC5nZXQoJ2J1aWxkJylcbiAgICAgKiBAcGFyYW0gYXNzZXREYXRhIHRoZSBjb25mIHZhbHVlIG9mIHRoZSBsb2dpbkN1c3RvbUJhY2tncm91bmRJbWFnZSBjb25mIHZhcmlhYmxlOiB0aGlzLm1vZGVsLndlYi5lbnRyeS5jb250ZW50LmdldCgnbG9naW5DdXN0b21CYWNrZ3JvdW5kSW1hZ2UnKVxuICAgICAqL1xuICAgIGV4cG9ydHMubG9naW5QYWdlQmFja2dyb3VuZCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgdmVyc2lvbiwgYXNzZXREYXRhKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnN0YXRpY0Fzc2V0VXJsKHJvb3QsIGxvY2FsZSwgdmVyc2lvbiwgZXhwb3J0cy5hc3NldFBhdGgoYXNzZXREYXRhKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGhlbHBlciBtZXRob2QgYnVpbGRzIGFuIGFycmF5IG9mIFVSTCBmcmFnbWVudHMgb2YgYW4gYXNzZXQgZ2l2ZW4gYW4gYXNzZXQgZGF0YSAobW9zdCBsaWtlbHkgYSBjb25mIHZhcmlhYmxlKVxuICAgICAqIEluIG9yZGVyIHRvIGJ1aWxkIHRoZSBVUkwgb2YgYW4gYXNzZXQsIHRoaXMgbWV0aG9kcyBpcyBsb29raW5nIGZvciBhIGFwcCBuYW1lc3BhY2UgaW4gdGhlIGFzc2V0IGRhdGEuXG4gICAgICogSWYgbm8gYXBwIG5hbWVzcGFjZSBwcm92aWRlZCwgZGVmYXVsdCB0byAnc2VhcmNoJy5cbiAgICAgKiBUaGVuLCBhcHBlbmQgdGhlIGFzc2V0UGF0aCB0byB0aGUgYXJyYXkgc3BsaXR0aW5nIGJ5IHNsYXNoZXMuXG4gICAgICogRXhhbXBsZSAxOlxuICAgICAqIC0gYXNzZXREYXRhID0gc2ltcGxleG1sOmRpcmVjdG9yeS9maWxlLmV4dFxuICAgICAqIHdpbGwgcmV0dXJuIFsnYXBwJywnc2ltcGxleG1sJywnZGlyZWN0b3J5JywnZmlsZS5leHQnXVxuICAgICAqIEV4YW1wbGUgMjpcbiAgICAgKiAtIGFzc2V0RGF0YSA9IGRpcmVjdG9yeS9maWxlLmV4dFxuICAgICAqIHdpbGwgcmV0dXJuIFsnYXBwJywnc2VhcmNoJywnZGlyZWN0b3J5JywnZmlsZS5leHQnXVxuICAgICAqIEBwYXJhbSBhc3NldERhdGFcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZXhwb3J0cy5hc3NldFBhdGggPSBmdW5jdGlvbihhc3NldERhdGEpIHtcbiAgICAgICAgdmFyIGFzc2V0UGF0aCA9IFsnYXBwJ107XG4gICAgICAgIGFzc2V0UGF0aC5wdXNoKGFzc2V0RGF0YS5zdWJzdHJpbmcoMCxhc3NldERhdGEuaW5kZXhPZihcIjpcIikpIHx8ICdzZWFyY2gnKTtcbiAgICAgICAgYXNzZXRQYXRoID0gYXNzZXRQYXRoLmNvbmNhdChhc3NldERhdGEuc3Vic3RyaW5nKGFzc2V0RGF0YS5pbmRleE9mKFwiOlwiKSArIDEpLnNwbGl0KCcvJykpO1xuICAgICAgICByZXR1cm4gYXNzZXRQYXRoO1xuICAgIH07XG4gICAgZXhwb3J0cy5wYWdlID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYodHlwZW9mIHBhZ2UgPT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIHBhZ2UgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gZXhwb3J0cy5lbmNvZGVSb290KHJvb3QsIGxvY2FsZSkgKyAnL2FwcC8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFwcCk7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHBhZ2UpKSB7XG4gICAgICAgICAgICBfLmVhY2gocGFnZSwgZnVuY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgdXJsICs9ICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChkaXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsICsgJz8nICsgc3BsdW5rdXRpbC5wcm9wVG9RdWVyeVN0cmluZyhvcHRpb25zLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgZXhwb3J0cy5hcHBJY29uID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBvd25lciwgYXBwLCBvcHRpb25zKXtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBzaXplID0gJyc7XG4gICAgICAgIGlmKCh3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxKSB8fCBvcHRpb25zLmhpUmVzKSB7XG4gICAgICAgICAgICBzaXplID0gJ18yeCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc3BsdW5rZE5TKHJvb3QsIGxvY2FsZSwgb3duZXIsIGFwcCwgJ3N0YXRpYy9hcHBJY29uJytzaXplKycucG5nJywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmFwcEljb25BbHQgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIG93bmVyLCBhcHAsIG9wdGlvbnMpe1xuICAgICAgICB2YXIgc2l6ZSA9ICcnO1xuICAgICAgICBpZih3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxKXtcbiAgICAgICAgICAgIHNpemUgPSAnXzJ4JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5zcGx1bmtkTlMocm9vdCwgbG9jYWxlLCBvd25lciwgYXBwLCAnc3RhdGljL2FwcEljb25BbHQnK3NpemUrJy5wbmcnLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuYXBwTG9nbyA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgb3duZXIsIGFwcCwgb3B0aW9ucyl7XG4gICAgICAgIHZhciBzaXplID0gJyc7XG4gICAgICAgIGlmKHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEpe1xuICAgICAgICAgICAgc2l6ZSA9ICdfMngnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBvcnRzLnNwbHVua2ROUyhyb290LCBsb2NhbGUsIG93bmVyLCBhcHAsICdzdGF0aWMvYXBwTG9nbycrc2l6ZSsnLnBuZycsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5maWxlRXhwbG9yZXIgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIG93bmVyLCBhcHAsIG9wdGlvbnMpe1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zcGx1bmtkTlMocm9vdCwgbG9jYWxlLCBvd25lciwgYXBwLCAnYWRtaW4vZmlsZS1leHBsb3JlcicsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZWdFeHBsb3JlciA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgb3duZXIsIGFwcCwgb3B0aW9ucyl7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnNwbHVua2ROUyhyb290LCBsb2NhbGUsIG93bmVyLCBhcHAsICdhZG1pbi93aW4tcmVnLWV4cGxvcmVyJywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmFkRXhwbG9yZXIgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIG93bmVyLCBhcHAsIG9wdGlvbnMpe1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zcGx1bmtkTlMocm9vdCwgbG9jYWxlLCBvd25lciwgYXBwLCAnYWRtaW4vd2luLWFkLWV4cGxvcmVyJywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmdldHRpbmdTdGFydGVkUGxhY2Vob2xkZXJDb250ZW50ID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBvd25lciwgYXBwLCBvcHRpb25zKXtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc3BsdW5rZE5TKHJvb3QsIGxvY2FsZSwgb3duZXIsIGFwcCwgJ3N0YXRpYy9nZXR0aW5nU3RhcnRlZFBsYWNlaG9sZGVyLnBuZycsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jaG9vc2VEYXNoYm9hcmRJY29uID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBvd25lciwgYXBwLCBvcHRpb25zKXtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc3BsdW5rZE5TKHJvb3QsIGxvY2FsZSwgb3duZXIsIGFwcCwgJ3N0YXRpYy9jaG9vc2VEYXNoYm9hcmRJY29uLnBuZycsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5tb3JlQXBwc0ljb24gPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIG93bmVyLCBhcHAsIG9wdGlvbnMpe1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zcGx1bmtkTlMocm9vdCwgbG9jYWxlLCBvd25lciwgYXBwLCAnc3RhdGljL21vcmVBcHBzSWNvbi5wbmcnLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc3BsdW5rZCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSl7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVJvb3Qocm9vdCwgbG9jYWxlKSArICcvc3BsdW5rZCc7XG4gICAgfTtcbiAgICBleHBvcnRzLnNwbHVua2RSYXcgPSBmdW5jdGlvbihyb290LCBsb2NhbGUpe1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zcGx1bmtkKHJvb3QsIGxvY2FsZSkgKyAnL19fcmF3JztcbiAgICB9O1xuICAgIGV4cG9ydHMuc3BsdW5rZE5TID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBvd25lciwgYXBwLCBwYXRoKXtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc3BsdW5rZFJhdyhyb290LCBsb2NhbGUpICsgJy9zZXJ2aWNlc05TLycgKyBlbmNvZGVVUklDb21wb25lbnQob3duZXIpICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFwcCkgKyAnLycgKyBwYXRoO1xuICAgIH07XG4gICAgZXhwb3J0cy5pbmRleGluZ1ByZXZpZXdVcGxvYWQgPSBmdW5jdGlvbihyb290LCBsb2NhbGUpe1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zcGx1bmtkKHJvb3QsIGxvY2FsZSkgKyAnL19fdXBsb2FkL2luZGV4aW5nL3ByZXZpZXcnO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZWNlaXZlcnNTdHJlYW0gPSBmdW5jdGlvbihyb290LCBsb2NhbGUpe1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zcGx1bmtkKHJvb3QsIGxvY2FsZSkgKyAnL19fdXBsb2FkL3JlY2VpdmVycy9zdHJlYW0nO1xuICAgIH07XG4gICAgZXhwb3J0cy5pZGVudGljb25zID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCB2YWx1ZSl7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVJvb3Qocm9vdCwgbG9jYWxlKSArICcvc3RhdGljL2FwcC9zZWFyY2gvaWRlbnRpY29ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArICcucG5nJztcbiAgICB9O1xuICAgIGV4cG9ydHMucGl2b3QgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5wYWdlKHJvb3QsIGxvY2FsZSwgYXBwLCAncGl2b3QnLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudGFibGUgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5wYWdlKHJvb3QsIGxvY2FsZSwgYXBwLCAndGFibGUnLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZHluYW1pY19kYXRhID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhZ2Uocm9vdCwgbG9jYWxlLCAnZHluYW1pYy1kYXRhLXNlbGYtc3RvcmFnZS1hcHAnLCBcInNlbGYtc3RvcmFnZS1sb2NhdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmRhdGFzZXQgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5wYWdlKHJvb3QsIGxvY2FsZSwgYXBwLCAnZGF0YXNldCcsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5kYXRhc2V0cyA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhZ2Uocm9vdCwgbG9jYWxlLCBhcHAsICdkYXRhc2V0cycsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5kYXRhX21vZGVsX21hbmFnZXIgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5wYWdlKHJvb3QsIGxvY2FsZSwgYXBwLCAnZGF0YV9tb2RlbF9tYW5hZ2VyJywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmRhdGFfbW9kZWxfZWRpdG9yID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucGFnZShyb290LCBsb2NhbGUsIGFwcCwgJ2RhdGFfbW9kZWxfZWRpdG9yJywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmZpZWxkX2V4dHJhY3RvciA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhZ2Uocm9vdCwgbG9jYWxlLCBhcHAsICdmaWVsZF9leHRyYWN0b3InLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFwcCA9PT0gc3BsdW5rZFV0aWxzLlNZU1RFTSkge1xuICAgICAgICAgICAgYXBwID0gJ3NlYXJjaCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucGFnZShyb290LCBsb2NhbGUsIGFwcCwgJ3NlYXJjaCcsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5hbmFseXNpc193b3Jrc3BhY2UgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoYXBwID09PSBzcGx1bmtkVXRpbHMuU1lTVEVNKSB7XG4gICAgICAgICAgICBhcHAgPSAnc2VhcmNoJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5wYWdlKHJvb3QsIGxvY2FsZSwgYXBwLCAnYW5hbHlzaXNfd29ya3NwYWNlJywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlcG9ydCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhZ2Uocm9vdCwgbG9jYWxlLCBhcHAsICdyZXBvcnQnLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucmVwb3J0cyA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhZ2Uocm9vdCwgbG9jYWxlLCBhcHAsICdyZXBvcnRzJywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmFsZXJ0ID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucGFnZShyb290LCBsb2NhbGUsIGFwcCwgJ2FsZXJ0Jywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmFsZXJ0cyA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhZ2Uocm9vdCwgbG9jYWxlLCBhcHAsICdhbGVydHMnLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuam9iX21hbmFnZXIgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5wYWdlKHJvb3QsIGxvY2FsZSwgYXBwLCAnam9iX21hbmFnZXInLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMubWFuYWdlbWVudENvbnNvbGUgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucGFnZShyb290LCBsb2NhbGUsICdzcGx1bmtfbW9uaXRvcmluZ19jb25zb2xlJywgJ21vbml0b3Jpbmdjb25zb2xlX292ZXJ2aWV3Jywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmFkZERhdGEgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcCwgc3RlcCwgb3B0aW9ucykge1xuICAgICAgICAvLyBpZiBhcHAgaXMgbm90IHByb3ZpZGVkLCBkZWZhdWx0IHRvIHNlYXJjaFxuICAgICAgICB2YXIgcGFnZSA9IHN0ZXAgPyBbXCJhZGRkYXRhbWV0aG9kc1wiLCBzdGVwXSA6ICdhZGRkYXRhJztcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWFuYWdlcihyb290LCBsb2NhbGUsIGFwcCB8fCBcInNlYXJjaFwiLCBwYWdlLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZWRpdERhc2hib2FyZCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhZ2Uocm9vdCwgbG9jYWxlLCBhcHAsIFtuYW1lLCAnZWRpdCddLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZGFzaGJvYXJkRnJvbUlEID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBpZCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgLy9vd25lclsxXS9hcHBbMF0vZGF0YVsyXS91aVszXS92aWV3c1s0XS9uYW1lWzVdXG4gICAgICAgIHZhciBwYXJ0cyA9IGlkLnNwbGl0KCcvJykuc2xpY2UoLTYpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlKHJvb3QsIGxvY2FsZSwgcGFydHNbMV0sIHBhcnRzWzVdLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMubG9nb3V0ID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVJvb3Qocm9vdCwgbG9jYWxlKSArICcvYWNjb3VudC9sb2dvdXQnO1xuICAgIH07XG4gICAgZXhwb3J0cy5wcm94eUxvZ2luID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVJvb3Qocm9vdCwgbG9jYWxlKSArICcvYWNjb3VudC9sb2dpbic7XG4gICAgfTtcbiAgICBleHBvcnRzLnJldHVyblRvID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCB1cmwpIHtcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvJyk9PT0wKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoL15bXFwvXFxzXFxcXF0rLywgJy8nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVSb290KHJvb3QsIGxvY2FsZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmVtYmVkID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBlbWJlZFRva2VuLCBzYXZlZFNlYXJjaElkKSB7XG4gICAgICAgIHZhciB1cmwsXG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICBzOiBzYXZlZFNlYXJjaElkLFxuICAgICAgICAgICAgb2lkOiBlbWJlZFRva2VuXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzcGx1bmtDb25maWcuRU1CRURfVVJJKSB7XG4gICAgICAgICAgICB1cmwgPSBzcGx1bmtDb25maWcuRU1CRURfVVJJICsgJy8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyAnLyc7XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICAgIHVybCArPSByb290ICsgJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmwgKyBsb2NhbGUgKyAnL2VtYmVkPycgKyBzcGx1bmt1dGlsLnByb3BUb1F1ZXJ5U3RyaW5nKGRhdGEpO1xuICAgIH07XG4gICAgZXhwb3J0cy5qb2JJbnNwZWN0b3IgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcCwgc2lkKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc2lkOiBzaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAvLyBTUEwtMTMyMTY3IFNwbHVua1dlYkNvcmUgbmVlZHMgdG8gc3VwcG9ydCBwcmV2aW91cyB2ZXJzaW9ucy5cbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgaWYgc3RhdGVtZW50IG9uY2UgU3BsdW5rV2ViQ29yZSBubyBsb25nZXIgbmVlZHMgdG8gc3VwcG9ydCA2LjRcbiAgICAgICAgdmFyIHNpeERvdE1hdGNoID0gc3BsdW5rQ29uZmlnLlZFUlNJT05fTEFCRUwubWF0Y2goL142XFwuKFxcZClcXC4vKTtcbiAgICAgICAgaWYgKHNpeERvdE1hdGNoICYmIChzaXhEb3RNYXRjaFsxXSA8IDUpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEubmFtZXNwYWNlID0gYXBwO1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUm9vdChyb290LCBsb2NhbGUpICsgJy9zZWFyY2gvaW5zcGVjdG9yJyArICc/JyArIHNwbHVua3V0aWwucHJvcFRvUXVlcnlTdHJpbmcob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5tYW5hZ2VyKHJvb3QsIGxvY2FsZSwgYXBwLCAnam9iX2luc3BlY3RvcicsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5zZWFyY2hKb2JVcmxzID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBzaWQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybCA9IGV4cG9ydHMuZW5jb2RlUm9vdChyb290LCBsb2NhbGUpICsgJy9hcGkvc2VhcmNoL2pvYnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChzaWQpICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhZ2UpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgIHVybCA9IHVybCArICc/JyArIHNwbHVua3V0aWwucHJvcFRvUXVlcnlTdHJpbmcob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgZXhwb3J0cy5zZWFyY2hKb2JUaW1lbGluZSA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgc2lkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnNlYXJjaEpvYlVybHMocm9vdCwgbG9jYWxlLCBzaWQsICd0aW1lbGluZScsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5zZWFyY2hKb2JTdW1tYXJ5ID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBzaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc2VhcmNoSm9iVXJscyhyb290LCBsb2NhbGUsIHNpZCwgJ3N1bW1hcnknLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMubWFuYWdlciA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cmwgPSAgZXhwb3J0cy5lbmNvZGVSb290KHJvb3QsIGxvY2FsZSkgKyAnL21hbmFnZXIvJyArIGVuY29kZVVSSUNvbXBvbmVudChhcHApO1xuICAgICAgICBpZiAoXy5pc0FycmF5KHBhZ2UpKSB7XG4gICAgICAgICAgICBfLmVhY2gocGFnZSwgZnVuY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgdXJsICs9ICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChkaXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsICsgJz8nICsgc3BsdW5rdXRpbC5wcm9wVG9RdWVyeVN0cmluZyhvcHRpb25zLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICBleHBvcnRzLmFwcFNldHVwTGluayA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IF8uZXh0ZW5kKHsgYWN0aW9uOiAnZWRpdCcgfSwgb3B0aW9ucy5kYXRhKTtcbiAgICAgICAgdmFyIHBhZ2UgPSBbJ2FwcHMnLCAnbG9jYWwnLCBhcHAsICdzZXR1cCddO1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5tYW5hZ2VyKHJvb3QsIGxvY2FsZSwgYXBwLCBwYWdlLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5hcmNoaXZlcyA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5tYW5hZ2VyKHJvb3QsIGxvY2FsZSwgYXBwLCBcImFyY2hpdmVzXCIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5pbmRleGVzID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHJldHVybiBleHBvcnRzLm1hbmFnZXIocm9vdCwgbG9jYWxlLCBhcHAsIFwiZGF0YS9pbmRleGVzXCIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLy8gSFVOSyByb3V0ZXNcbiAgICBleHBvcnRzLnByb3ZpZGVycyA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBfKG9wdGlvbnMpLmRlZmF1bHRzKHtkYXRhOnt0OlwicHJvdmlkZXJzXCJ9fSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLm1hbmFnZXIocm9vdCwgbG9jYWxlLCBcInN5c3RlbVwiLCBcInZpcnR1YWxfaW5kZXhlc1wiLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudmlydHVhbEluZGV4ZXMgPSBmdW5jdGlvbihyb290LCBsb2NhbGUsIGFwcCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgXyhvcHRpb25zKS5kZWZhdWx0cyh7ZGF0YTp7dDpcImluZGV4ZXNcIn19KTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWFuYWdlcihyb290LCBsb2NhbGUsIFwic3lzdGVtXCIsIFwidmlydHVhbF9pbmRleGVzXCIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5leHBsb3JlRGF0YSA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5tYW5hZ2VyKHJvb3QsIGxvY2FsZSwgXCJzeXN0ZW1cIiwgXCJleHBsb3JlX2RhdGFcIiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLm1hbmFnZXJFZGl0ID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIHBhZ2UsIGlkLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge2RhdGE6IHthY3Rpb246ICdlZGl0JywgdXJpOiBpZH19LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWFuYWdlcihyb290LCBsb2NhbGUsIGFwcCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLm1hbmFnZXJQZXJtaXNzaW9ucyA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBwYWdlLCBpZCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICB2YXIgdXJsID0gIGV4cG9ydHMuZW5jb2RlUm9vdChyb290LCBsb2NhbGUpICsgJy9tYW5hZ2VyL3Blcm1pc3Npb25zLycgKyBlbmNvZGVVUklDb21wb25lbnQoYXBwKTtcbiAgICAgICAgdXJsICs9ICcvJyArIF8uY2hhaW4oW3BhZ2VdKS5mbGF0dGVuKCkubWFwKGVuY29kZVVSSUNvbXBvbmVudCkudmFsdWUoKS5qb2luKCcvJyk7XG4gICAgICAgIHVybCArPSAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoaWQpO1xuICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwgKyAnPycgKyBzcGx1bmt1dGlsLnByb3BUb1F1ZXJ5U3RyaW5nKG9wdGlvbnMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuICAgIGV4cG9ydHMudHJpZ2dlcmVkQWxlcnRzID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybCA9IGV4cG9ydHMuZW5jb2RlUm9vdChyb290LCBsb2NhbGUpICsgJy9hbGVydHMvJyArIGVuY29kZVVSSUNvbXBvbmVudChhcHApO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybCArICc/JyArIHNwbHVua3V0aWwucHJvcFRvUXVlcnlTdHJpbmcob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgZXhwb3J0cy5kb2NTZWFyY2ggPSBmdW5jdGlvbihsb2NhbGUsIHZlcnNpb24sIGlzRnJlZSwgaXNUcmlhbCwgc2VhcmNoKSB7XG4gICAgICAgIHZhciBiYXNlID0gJ2h0dHA6Ly9kb2NzLnNwbHVuay5jb20vU3BlY2lhbDpTcGx1bmtTZWFyY2gvZG9jcycsXG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbk51bWJlcjogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBsaWNlbnNlOiBpc0ZyZWUgPyAnZnJlZScgOiAncHJvJyxcbiAgICAgICAgICAgICAgICBpbnN0YWxsVHlwZTogaXNUcmlhbCA/ICd0cmlhbCcgOiAncHJvZCcsXG4gICAgICAgICAgICAgICAgcTogc2VhcmNoXG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYmFzZSArICc/JyArIHNwbHVua3V0aWwucHJvcFRvUXVlcnlTdHJpbmcocGFyYW1zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZG9jSGVscCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgbG9jYXRpb24pIHtcbiAgICAgICAgbG9jYWxlID0gbG9jYWxlIHx8IHNwbHVua2RVdGlscy5ERUZBVUxUX0xPQ0FMRTtcbiAgICAgICAgdmFyIHVybCA9ICBleHBvcnRzLmVuY29kZVJvb3Qocm9vdCwgbG9jYWxlKSArICcvaGVscCcsXG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdXJsICsgJz8nICsgc3BsdW5rdXRpbC5wcm9wVG9RdWVyeVN0cmluZyhwYXJhbXMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5kb2NIZWxwSW5BcHBDb250ZXh0ID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBsb2NhdGlvbiwgYXBwTmFtZSwgYXBwVmVyc2lvbiwgaXNDb3JlQXBwLCBhcHBEb2NTZWN0aW9uT3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIHVybCA9IGV4cG9ydHMuZW5jb2RlUm9vdChyb290LCBsb2NhbGUpICsgJy9oZWxwJyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBhZGQgW2FwcE5hbWU6YXBwVmVyc2lvbl0gb3IgW2FwcERvY3NTZWN0aW9uT3ZlcnJpZGVdIHByZWZpeCBpZiB0aGUgYXBwIGlzIE5PVCBhIGNvcmUgYXBwXG4gICAgICAgICAgICBpZiAoIWlzQ29yZUFwcCkge1xuICAgICAgICAgICAgICAgIGlmIChhcHBEb2NTZWN0aW9uT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmxvY2F0aW9uID0gJ1snICsgYXBwRG9jU2VjdGlvbk92ZXJyaWRlICsgJ10nICsgcGFyYW1zLmxvY2F0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5sb2NhdGlvbiA9ICdbJyArIGFwcE5hbWUgKyAnOicgKyBhcHBWZXJzaW9uICsgJ10nICsgcGFyYW1zLmxvY2F0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybCArICc/JyArIHNwbHVua3V0aWwucHJvcFRvUXVlcnlTdHJpbmcocGFyYW1zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZXhwb3J0VXJsID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBzaWQsIGZpbGVuYW1lLCBmb3JtYXQsIGNvdW50LCBpc1JlcG9ydCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHJlc3VsdFR5cGUgPSBpc1JlcG9ydCA/ICdyZXN1bHRzJyA6ICdldmVudCc7XG4gICAgICAgIHZhciB1cmwgPSBleHBvcnRzLmVuY29kZVJvb3Qocm9vdCwgbG9jYWxlKSArICcvYXBpL3NlYXJjaC9qb2JzLycgKyBlbmNvZGVVUklDb21wb25lbnQoc2lkKSArICcvJyArIHJlc3VsdFR5cGU7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBpc0Rvd25sb2FkOiB0cnVlLFxuICAgICAgICAgICAgdGltZUZvcm1hdDogb3B0aW9ucy50aW1lRm9ybWF0IHx8ICclRlQlVC4lUSU6eicsXG4gICAgICAgICAgICBtYXhMaW5lczogMCxcbiAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSB8fCAnJyxcbiAgICAgICAgICAgIG91dHB1dE1vZGU6IGZvcm1hdFxuICAgICAgICB9O1xuICAgICAgICB1cmwgKz0gJz8nICsgc3BsdW5rdXRpbC5wcm9wVG9RdWVyeVN0cmluZyhwYXJhbXMpO1xuXG4gICAgICAgIF8uZWFjaChvcHRpb25zLmZpZWxkcywgZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICAgIHVybCArPSAnJmZpZWxkX2xpc3Q9JyArIGZpZWxkO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgZXhwb3J0cy51cGRhdGVDaGVja2VyID0gZnVuY3Rpb24oYmFzZVVSTCwgaXNGcmVlLCB2ZXJzaW9uTnVtYmVyLCBjaGVja2VyTG9jYXRpb24sIGlzVHJpYWwsIGd1aWQsIG1hc3Rlckd1aWQpIHtcbiAgICAgICAgdmFyIHVybCxcbiAgICAgICAgICAgIGluc3RhbGxUeXBlID0gKGlzVHJpYWwpID8gJ3RyaWFsJyA6ICdwcm9kJyxcbiAgICAgICAgICAgIGxpY2Vuc2VUeXBlID0gKGlzRnJlZSkgPyAnZnJlZScgOiAncHJvJztcbiAgICAgICAgaWYgKGd1aWQhPT1tYXN0ZXJHdWlkKSB7XG4gICAgICAgICAgICBpbnN0YWxsVHlwZSArPSAnX3NsYXZlJztcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBiYXNlVVJMICsgbGljZW5zZVR5cGUgKyAnLycgKyAgZW5jb2RlVVJJQ29tcG9uZW50KHZlcnNpb25OdW1iZXIpICsgJy8nICsgIGVuY29kZVVSSUNvbXBvbmVudChjaGVja2VyTG9jYXRpb24pICsgJy8nICsgIGVuY29kZVVSSUNvbXBvbmVudChpbnN0YWxsVHlwZSkgKyAnL2Jhc2ljJztcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuICAgIGV4cG9ydHMuYW5zd2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ2h0dHA6Ly9hbnN3ZXJzLnNwbHVuay5jb20nO1xuICAgIH07XG4gICAgZXhwb3J0cy5nZXRDb250ZXh0dWFsUGFnZVJvdXRlciA9IGZ1bmN0aW9uKGFwcGxpY2F0aW9uTW9kZWwpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBhcHBsaWNhdGlvbk1vZGVsLmdldCgncm9vdCcpLFxuICAgICAgICAgICAgbG9jYWxlID0gYXBwbGljYXRpb25Nb2RlbC5nZXQoJ2xvY2FsZScpLFxuICAgICAgICAgICAgYXBwID0gYXBwbGljYXRpb25Nb2RlbC5nZXQoJ2FwcCcpLFxuICAgICAgICAgICAgbm9uUGFnZU1ldGhvZHMgPSBbJ3BhZ2UnLCAnZG9jU2VhcmNoJywgJ2RvY0hlbHAnLCAnZG9jSGVscEluQXBwQ29udGV4dCcsICdleHBvcnRVcmwnLCAnZXhwb3J0VXJsJywgJ2dldENvbnRleHR1YWxQYWdlUm91dGVyJywgJ3BhZ2VTdGFydCcsICdlbmNvZGVSb290JywgJ3JlZGlyZWN0VG8nXSxcbiAgICAgICAgICAgIHJvdXRlTmFtZXMgPSBfKGV4cG9ydHMpLmNoYWluKCkuZnVuY3Rpb25zKCkuZGlmZmVyZW5jZShub25QYWdlTWV0aG9kcyksXG4gICAgICAgICAgICByb3V0ZXIgPSB7fTtcblxuICAgICAgICBfKHJvdXRlTmFtZXMpLmVhY2goZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgICAgICAgIHZhciByb3V0ZUZuID0gZXhwb3J0c1tyb3V0ZV07XG4gICAgICAgICAgICByb3V0ZXJbcm91dGVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bGxBcmdzID0gW3Jvb3QsIGxvY2FsZSwgYXBwXS5jb25jYXQoXyhhcmd1bWVudHMpLnRvQXJyYXkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlRm4uYXBwbHkobnVsbCwgZnVsbEFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfTtcbiAgICBleHBvcnRzLmFwcE5hdlVybCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwKXtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUm9vdChyb290LCAgbG9jYWxlKSAgKyAnL2FwcG5hdi8nICsgZW5jb2RlVVJJQ29tcG9uZW50KChhcHAgfHwgJycpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuYXBwc1JlbW90ZSA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKXtcbiAgICAgICByZXR1cm4gIGV4cG9ydHMubWFuYWdlcihyb290LCBsb2NhbGUsIGFwcCwgJ2FwcHNyZW1vdGUnLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuYXBwc0xvY2FsID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIG9wdGlvbnMpe1xuICAgICAgICByZXR1cm4gIGV4cG9ydHMubWFuYWdlcihyb290LCBsb2NhbGUsIGFwcCwgWydhcHBzJywnbG9jYWwnXSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnNwbHVua2Jhc2VBcHAgPSBmdW5jdGlvbihhcHApIHtcbiAgICAgICAgcmV0dXJuICdodHRwczovL2FwcHMuc3BsdW5rLmNvbS9hcHAvJyArIGVuY29kZVVSSUNvbXBvbmVudChhcHApO1xuICAgIH07XG4gICAgZXhwb3J0cy5hcHBJbnN0YWxsUmVzdGFydCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgYXBwKXtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWFuYWdlcihyb290LCBsb2NhbGUsICdzeXN0ZW0nLCAnY29udHJvbCcpICsgJz9yZXR1cm5fdG89JyArIGVuY29kZVVSSUNvbXBvbmVudCgnL2VuLVVTL2FwcC8nICsgYXBwKSArICcmYXV0b19yZXN0YXJ0PTEnO1xuICAgIH07XG4gICAgZXhwb3J0cy5hcHBTZXR1cCA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSwgc2V0dXBsaW5rKXtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUm9vdChyb290LCAgbG9jYWxlKSAgKyBzZXR1cGxpbms7XG4gICAgfTtcbiAgICBleHBvcnRzLnZpZXdTdHJpbmdzID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIHZpZXcpe1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5wYWdlKHJvb3QsIGxvY2FsZSwgYXBwLCB2aWV3KSArIFwiL3N0cmluZ3NcIjtcbiAgICB9O1xuICAgIGV4cG9ydHMucHJlYnVpbHRBcHBMaW5rID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIGxpbmspIHtcbiAgICAgICAgLyogcHJvcGVybHkgc2V0cyB1cCBhIFVSTCBmb3IgYW4gL2FwcC88YXBwPiBsaW5rXG4gICAgICAgICAqICByZXR1cm5zIHJvb3QvbG9jYWxlL2FwcC9saW5rXG4gICAgICAgICAqICBzaW5jZSBsaW5rIG1heSBjb250YWluIGEgcXVlcnkgc3RyaW5nLCBpdCBpcyBub3QgZW5jb2RlZFxuICAgICAgICAgKiAgZXhhbXBsZTpcbiAgICAgICAgICogICAgIHJvb3QgPSAvZ2Fkem9va3MsIGxvY2FsZSA9IGVuLVVTLCBhcHAgPSBzZWFyY2gsIGxpbmsgPSBzZWFyY2g/dG91cj10ZXN0XG4gICAgICAgICAqICAgICByZXR1cm4gL2dhZHpvb2tzL2VuLVVTL3NlYXJjaC9zZWFyY2g/dG91cj10ZXN0XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVSb290KHJvb3QsIGxvY2FsZSkgKyAnL2FwcC8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFwcCkgKyAnLycgKyBsaW5rO1xuICAgIH07XG4gICAgZXhwb3J0cy5ob21lID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlKSB7XG4gICAgICAgIC8qIG91ciByb3V0aW5nIHN5c3RlbSByb3V0ZXMgL3Jvb3QvbG9jYWxlIHRvIHRoZSB1c2VyJ3MgZGVmYXVsdCBhcHAvZGVmYXVsdCBwYWdlXG4gICAgICAgICAqIGFzIHdlIHNoaXAsIHRoaXMgaXMgbGF1bmNoZXIvaG9tZSwgYnV0IHRoZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzXG4gICAgICAgICAqIHJvb3QgYW5kIGxvY2FsZSBhcmUgYWNjZXNzaWJsZSBmcm9tIGFwcGxpY2F0aW9uIG1vZGVsXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVSb290KHJvb3QsIGxvY2FsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWRpcmVjdHMgdG8gYSBuZXcgdXJsLCBvcHRpb25hbGx5IGluIGEgbmV3IHRhYi5cbiAgICAgKlxuICAgICAqIEludGVudGlvbmFsbHkgZm9ya2VkIGZyb20gdGhlIHJlZGlyZWN0X3RvIGZ1bmN0aW9uIGluIHV0aWwuanMsIGluc3RlYWQgcHJvdmlkaW5nIGEgcmVkaXJlY3QgbWV0aG9kXG4gICAgICogdGhhdCBpcyBpbnRlbmRlZCB0byBjb25zdW1lIGEgZnVsbHktZm9ybWVkIFVSTCBsaWtlIHRoZSBvbmVzIGdlbmVyYXRlZCBieSB0aGUgb3RoZXIgbWV0aG9kcyBpbiB0aGlzIGZpbGUuXG4gICAgICpcbiAgICAgKiBDb3JyZWN0bHkgaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSB3ZSBoYXZlIGFuIGFzeW5jaHJvbm91c2x5IGdlbmVyYXRlZCBVUkwgdGhhdCBuZWVkcyB0byBvcGVuIGluIGEgbmV3IHRhYi5cbiAgICAgKiBUaGUgbmV3IHRhYiBpcyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgKHRvIGF2b2lkIHBvcC11cCBibG9ja2VycykgYW5kIGdpdmVuIGl0cyBsb2NhdGlvbiB3aGVuIHRoZSBwcm9taXNlIHJlc29sdmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCB7U3RyaW5nIG9yIGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhIHN0cmluZ30gdGhlIFVSTCB0byBuYXZpZ2F0ZSB0b1xuICAgICAqIEBwYXJhbSB1c2VOZXdUYWIge0Jvb2xlYW59XG4gICAgICpcbiAgICAgKi9cbiAgICBleHBvcnRzLnJlZGlyZWN0VG8gPSBmdW5jdGlvbih1cmwsIHVzZU5ld1RhYikge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdXNlTmV3VGFiID8gd2luZG93Lm9wZW4oKSA6IHdpbmRvdztcbiAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICQud2hlbih1cmwpXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbihuZXdMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHRhcmdldC5sb2NhdGlvbiA9IG5ld0xvY2F0aW9uO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBvcGVuIG5ldyBVUkw6ICcgKyB1cmwpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZih1c2VOZXdUYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnNvdXJjZXR5cGVMaXN0ID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gaWYgYXBwIGlzIG5vdCBwcm92aWRlZCwgZGVmYXVsdCB0byBzZWFyY2hcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWFuYWdlcihyb290LCBsb2NhbGUsIGFwcCwgJ3NvdXJjZXR5cGVzJywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnNvdXJjZXR5cGVFZGl0ID0gZnVuY3Rpb24ocm9vdCwgbG9jYWxlLCBhcHAsIGlkLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGlmIGFwcCBpcyBub3QgcHJvdmlkZWQsIGRlZmF1bHQgdG8gc2VhcmNoXG4gICAgICAgIHJldHVybiBleHBvcnRzLnNvdXJjZXR5cGVMaXN0KHJvb3QsIGxvY2FsZSwgYXBwLCBvcHRpb25zKSArICcvJytpZDtcbiAgICB9O1xuICAgIGV4cG9ydHMuc3BtZXRhZGF0YSA9IGZ1bmN0aW9uKHJvb3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVSb290KHJvb3QsIGxvY2FsZSkgKyAnL3NhbWwvc3BtZXRhZGF0YSc7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuZ2V0VmlldyA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgc3dpdGNoICh2aWV3KSB7XG4gICAgICAgICAgICBjYXNlICdhbmFseXNpc193b3Jrc3BhY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7b3BlbkxhYmVsOiBfKCdPcGVuIGluIE1ldHJpY3MgV29ya3NwYWNlJykudCgpLCByb3V0ZTogZXhwb3J0cy5hbmFseXNpc193b3Jrc3BhY2V9O1xuICAgICAgICAgICAgY2FzZSAncGl2b3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7b3BlbkxhYmVsOiBfKCdPcGVuIGluIFBpdm90JykudCgpLCByb3V0ZTogZXhwb3J0cy5waXZvdH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7b3BlbkxhYmVsOiBfKCdPcGVuIGluIFNlYXJjaCcpLnQoKSwgcm91dGU6IGV4cG9ydHMuc2VhcmNofTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZXhwb3J0cztcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3VyaS9yb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gdXJpL3JvdXRlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "util/splunkd_utils":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\"),\n        __webpack_require__(\"shim/splunk.util\"),\n        __webpack_require__(\"stubs/splunk.config\"),\n        __webpack_require__(\"util/general_utils\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, splunkUtils, splunkConfig, generalUtils) {\n        \n        var SYSTEM = \"system\",\n            GLOBAL = \"global\",\n            APP = \"app\",\n            USER = \"user\",\n            NOBODY = \"nobody\",\n            WILDCARD = \"-\",\n            VERBOSE = \"verbose\",\n            FAST = \"fast\",\n            SMART = \"smart\",\n            RISKY_COMMAND = 'risky_command',\n            FATAL = 'fatal',\n            ERROR = 'error',\n            WARNING = 'warn',\n            INFO = 'info',\n            NETWORK_ERROR = 'network_error',\n            NOT_FOUND = '404',\n            DEFAULT_LOCALE = 'en-US';\n        \n        var fullpath = function(path, options) {\n            options = options || {};\n            var isServicesPath = /^\\/services/.test(path),\n                isAbsolute = /^\\/.*/.test(path),\n                isFullPath = /^http[s]?:\\/\\//.test(path);\n\n            //return if it is already a full path\n            if (isFullPath) {\n                return path;\n            }\n\n            //return if not a relative path\n            if (isAbsolute && !isServicesPath){\n                return path;\n            } else if (isAbsolute && isServicesPath) {\n                return splunkConfig.SPLUNKD_PATH + path;\n            }\n\n            // If we don't have an app name (explicitly or implicitly), we default to /services/\n            if (!options.app && !options.owner) {\n                return splunkConfig.SPLUNKD_PATH + \"/services/\" + path;\n            }\n\n            // Get the app and owner, first from the passed in namespace or\n            // default to wild cards\n            var owner = options.owner || WILDCARD;\n            var app   = options.app || WILDCARD;\n\n            options.sharing = (options.sharing || \"\").toLowerCase();\n             \n            // Modify the owner and app appropriately based on the sharing parameter\n            if (options.sharing === APP || options.sharing === GLOBAL) {\n                owner = NOBODY;\n            } else if (options.sharing === SYSTEM) {\n                owner = NOBODY;\n                app = SYSTEM;\n            }\n            return splunkConfig.SPLUNKD_PATH + \"/servicesNS/\" + encodeURIComponent(owner) + \"/\" + encodeURIComponent(app) + \"/\" + path;\n        };\n        \n        var xhrErrorResponseParser = function(response, id) {\n            var responseData = {}, \n                isValidJSON = true,\n                messages = [];\n            id = id || _(\"object from SplunkD\").t();\n                        \n            if(response.hasOwnProperty('responseText') && response.hasOwnProperty('getResponseHeader')) {\n               var contentType = response.getResponseHeader('Content-Type');\n               if (contentType && (contentType.indexOf('application/json') > -1) && response.responseText) {\n                    try {\n                        responseData = JSON.parse(response.responseText);\n                    }\n                    catch(e) {\n                        isValidJSON = false;\n                    }\n                }\n            }\n                        \n            // have to maintain compatibility with older models that have the response wrapped in a \"data\" attribute\n            if(response.hasOwnProperty('data')) {\n                responseData = responseData.data;\n            }\n            \n            if (response.hasOwnProperty('status')) {\n                if (response.status == 404 && $.isEmptyObject(responseData)) {\n                    messages.push(createMessageObject(\n                        NOT_FOUND,\n                        splunkUtils.sprintf(\n                            _('Could not retrieve %s. Make sure that this resource exists and has the correct permissions.').t(),\n                            id\n                        )\n                    ));\n                } else if (response.status == 0 || response.status == 12029) {\n                    messages.push(createMessageObject(NETWORK_ERROR, _('Your network connection may have been lost or Splunk may be down.').t()));\n                }\n            }\n            \n            if (!isValidJSON) {\n                messages.push(createMessageObject(ERROR, splunkUtils.sprintf(_('Invalid JSON from: %s.').t(), id)));\n            } else if (responseData.messages) {\n                messages = messages.concat(parseMessagesObject(responseData.messages));\n            } else if (response.messages) {\n                var responseMessages = parseMessagesObject(response.messages);\n                if (responseMessages.length) {\n                    messages = messages.concat(responseMessages);\n                } else {\n                    messages.push(createMessageObject(ERROR, _('Server error').t()));\n                }\n            } else if (_.isString(response)) {\n                messages.push(createMessageObject(ERROR, response));\n            }\n            \n            if (!messages.length) {\n                messages.push(createMessageObject(ERROR, _('Server error').t()));\n            }\n            \n            return messages;\n        };\n\n        var prepareSyncOptions = function(options, baseUrl) {\n            var appOwner = {},\n                defaults = {data: {output_mode: 'json'}};\n\n            if (options && options.data){\n                appOwner = $.extend(appOwner, { //JQuery purges undefined\n                    app: options.data.app || undefined,\n                    owner: options.data.owner || undefined,\n                    sharing: options.data.sharing || undefined\n                });\n                delete options.data.app;\n                delete options.data.owner;\n                delete options.data.sharing;\n            }\n            defaults.url = fullpath(baseUrl, appOwner);\n            return $.extend(true, defaults, options || {});\n        };\n        \n        var nameFromString = function(str) {\n            str = str || \"\";\n            return str.toLowerCase().replace(/\\s/g, \"_\").replace(/\\W/g, \"\");\n        };\n\n        var quoteSearchFilterValue = function(value) {\n            // Reusing string-quoting semantics of JSON.stringify()\n            // Backslash-escapes quotes and backslashes in the value\n            // 'foo\\bar \"baz\"' -> '\"foo\\\\bar \\\"baz\\\"'\n            return JSON.stringify(String(value));\n        };\n\n        var createSearchFilterString = function(value, keys, options) {\n            var values = (value) ? (value.match(generalUtils.VALUES_REGEX) || []): [];\n            options = options || {};\n            return _(keys).map(function(key) {\n                if (values.length) {\n                    var result = '(' + _.chain(values)\n                            .map(function(value) {\n                                // if value has quote around it remove quotes\n                                if (value.match(generalUtils.QUOTES_REGEX)) {\n                                    var len = value.length;\n                                    value = value.substring(1, len-1);\n                                }\n                                //escape quotes\n                                return [key, '=\"*', value.replace(/'/g,\"\\\\'\").replace(/\"/g,'\\\\\"'), '*\"'].join('');\n                            },this)\n                            .join(' AND ')\n                            .value();\n                    // If we have a conditional filter to add, AND it with the current key\n                    if (options.conditions && options.conditions[key]) {\n                        result += \" AND \" + options.conditions[key];\n                    }\n                    return result  + \")\";\n                } else {\n                    return [key, '=*'].join('');\n                }\n            },this).join(' OR ');\n        };\n\n        var createSearchFilterObj = function(value, keys) {\n            var values = (value) ? (value.match(generalUtils.VALUES_REGEX) || []): [],\n            filterObj = {}; \n\n            if (values.length) {\n                var matches = [];\n                _(values).each(function(value){\n                    if (value.match(generalUtils.QUOTES_REGEX)) {\n                        var len = value.length;\n                        value = value.substring(1, len-1);\n                    }\n                    matches.push(value.replace(/'/g,\"\\\\'\").replace(/\"/g,'\\\"'));\n                },this);   \n\n                _(keys).each(function(key) {\n                    filterObj[key] = matches;\n                }, this);\n            }\n            return filterObj;\n        };\n\n        var parseError = function(error) {\n            var passedErrors = {},\n                parsedError;\n\n            if (error.responseText) {\n                try {\n                    parsedError = JSON.parse(error.responseText);\n                }\n                catch(e) {\n                    parsedError = {};\n                }\n                if (parsedError.messages) {\n                    _.each(parsedError.messages, function(value) {\n                        passedErrors['splunkD:' + value.type] = value.text;\n                    });\n                }\n            } else {\n                passedErrors = error;\n            }\n            return passedErrors;\n        };\n\n        var createMessageObject = function(type, message, help) {\n            type = type.toLowerCase();\n\n            var jsonStart = message.indexOf(\"~!~{\");\n            var jsonEnd = message.lastIndexOf(\"}~!~\");\n            var jsonMsg;\n            var messageText = message;\n\n            if (jsonStart != -1 && jsonEnd != -1) {\n                try\n                {\n                    var jsonBlock = message.slice(jsonStart+3, jsonEnd+1);\n                    jsonMsg = JSON.parse(jsonBlock);\n                    messageText = jsonMsg.errorMessageEnglish;\n                }\n                catch (e) {\n                }\n            }\n            // Handle structured message\n            return ({\n                key: _.uniqueId('splunkd_' + type),\n                type: type,\n                message: messageText,\n                text: messageText,\n                help: help\n            });\n\n        };\n        \n        var parseMessagesObject = function(messages) {\n            if(!messages) {\n                return [];\n            }\n            return _(messages).map(function(message) {\n                return createMessageObject(message.type, message.text, message.help || \"\");\n            });\n        };\n\n        \n        var messagesContainsOneOfTypes = function(messages, types){\n            if (messages) {\n                for(var i = 0; i < messages.length; i++) {\n                    if (_.indexOf(types, messages[i].type) != -1) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        \n        var filterMessagesByTypes = function(messages, types) {\n            var filteredMessages = [];\n            if (messages) {\n                for(var i = 0; i < messages.length; i++) {\n                    if (_.indexOf(types, messages[i].type) != -1) {\n                        filteredMessages.push(messages[i]);\n                    }\n                }\n            }\n            return filteredMessages;\n        };\n        \n        /**\n         * Munge the difference between what splunkd outputs and what the renderer expects for message type.\n         *\n         * Namely splunkd has a 'fatal' type that we re-map to 'error', and splunkd uses 'warn' where the renderer\n         * wants 'warning'.\n         */\n        var normalizeType = function(type) {\n            if(type === FATAL) {\n                return ERROR;\n            }\n            if(type === WARNING) {\n                return 'warning';\n            }\n            return type;\n        };\n        \n        var addAnchorsToWildcardArray = function(wildcardArray) {\n            return _.map(wildcardArray, function(wildcard){\n                if (!/^\\^/.test(wildcard)){\n                    return \"^\" + wildcard;\n                }\n                return wildcard;\n            });\n        };\n        \n        var createSplunkDMessage = function(type, text) {\n            return {\n                messages: [{\n                    type: type,\n                    text: text\n                }]\n            };\n        };\n\n        var getSharingLabel = function(sharing) {\n            switch (sharing) {\n                case USER:\n                    return _(\"Private\").t();\n                case APP:\n                    return _(\"App\").t();\n                case GLOBAL:\n                    return _(\"Global\").t();\n                case SYSTEM:\n                    return _(\"Global\").t();\n            }\n        };\n\n        var getPermissionLabel = function(sharing, owner) {\n            switch (sharing) {\n                case USER:\n                    return splunkUtils.sprintf(_(\"Private. Owned by %s.\").t(), owner);\n                case APP:\n                    return splunkUtils.sprintf(_(\"Shared in App. Owned by %s.\").t(), owner);\n                case GLOBAL:\n                case SYSTEM:\n                    return splunkUtils.sprintf(_(\"Shared Globally. Owned by %s.\").t(), owner);\n            }\n            return \"\";\n        };\n        \n        var normalizeValuesForPOST = function(values) {\n            var valuesCopy = $.extend(true, {}, values);\n            _.each(valuesCopy, function(value, key) {\n                if (typeof(value) === \"boolean\") {\n                    if (value) {\n                        valuesCopy[key] = \"1\";\n                    } else {\n                        valuesCopy[key] = \"0\";\n                    }\n                }              \n            });\n            return valuesCopy;\n        };\n        \n        var normalizeBooleanTo01String = function(value) {\n            var bool = splunkUtils.normalizeBoolean(value);\n            if (bool) {\n                return \"1\";\n            }\n            return \"0\";\n        };\n        \n        var isExistingEntity = function(payload) {\n            if (\n        \t\tpayload && \n        \t\tpayload.entry && \n        \t\t_.isArray(payload.entry) && \n        \t\tpayload.entry[0].links && \n        \t\tpayload.entry[0].links.alternate && \n        \t\t!/.\\/_new$/.test(payload.entry[0].links.alternate)\n            ) {\n                return true;\n            }\n            return false;\n        };\n         \n        var getHeaders = function(headersString) {\n            var headers = {};\n            var headerLines = headersString.split(\"\\n\");\n            for(var i = 0; i < headerLines.length; i++) {\n                if (headerLines[i].trim() !== \"\") {\n                    var headerParts = headerLines[i].split(\": \");\n                    headers[headerParts[0]] = headerParts[1];\n                }\n            }\n            return headers;\n        };\n\n        /**\n         * A utility function for translating a jquery response object (jqXHR) to the format expected\n         * by consumers of the sdk.\n         * @param  {jqXHR} response\n         * @return {Object} formatted response data\n         */\n        var convertToSDKResponse = function(response) {\n            return {\n                status: response.status,\n                // If the response is successful, 'error' will be 'success' to conform with sdk api\n                error: response.statusText,\n                data: response.responseJSON,\n                response: {\n                    statusCode: response.status,\n                    headers: getHeaders(response.getAllResponseHeaders())\n                }\n            };\n        };\n\n        return {\n            // constants for splunkd message types\n            RISKY_COMMAND: RISKY_COMMAND,\n            FATAL: FATAL,\n            ERROR: ERROR,\n            WARNING: WARNING,\n            INFO: INFO,\n            NOT_FOUND: NOT_FOUND,\n            NETWORK_ERROR: NETWORK_ERROR,\n            \n            //constants for ACL\n            SYSTEM: SYSTEM,\n            GLOBAL: GLOBAL,\n            APP: APP,\n            USER: USER,\n            NOBODY: NOBODY,\n            WILDCARD:  WILDCARD,\n            \n            //constants for the adhoc search level\n            VERBOSE: VERBOSE,\n            FAST: FAST,\n            SMART: SMART,\n\n            //constans for filters\n            VALUES_REGEX: generalUtils.VALUES_REGEX,\n            QUOTES_REGEX: generalUtils.QUOTES_REGEX,\n\n            DEFAULT_LOCALE: DEFAULT_LOCALE,\n\n            fullpath: fullpath,\n            prepareSyncOptions: prepareSyncOptions,\n            nameFromString: nameFromString,\n            quoteSearchFilterValue: quoteSearchFilterValue,\n            createSearchFilterString: createSearchFilterString,\n            createSearchFilterObj: createSearchFilterObj,\n            parseError: parseError,\n            parseMessagesObject: parseMessagesObject,\n            createMessageObject: createMessageObject,\n            messagesContainsOneOfTypes: messagesContainsOneOfTypes,\n            addAnchorsToWildcardArray: addAnchorsToWildcardArray,\n            createSplunkDMessage: createSplunkDMessage,\n            getSharingLabel: getSharingLabel,\n            getPermissionLabel: getPermissionLabel,\n            normalizeType: normalizeType,\n            filterMessagesByTypes: filterMessagesByTypes,\n            xhrErrorResponseParser: xhrErrorResponseParser,\n            normalizeValuesForPOST: normalizeValuesForPOST,\n            normalizeBooleanTo01String: normalizeBooleanTo01String,\n            isExistingEntity: isExistingEntity,\n            getHeaders: getHeaders,\n            convertToSDKResponse: convertToSDKResponse\n        };\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvc3BsdW5rZF91dGlscy5qcz84YjkzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQSxpQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0IsNEJBQTRCLE9BQU87O0FBRW5DO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLDJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTzs7QUFFakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUJBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6InV0aWwvc3BsdW5rZF91dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShcbiAgICBbXG4gICAgICAgICdqcXVlcnknLFxuICAgICAgICAndW5kZXJzY29yZScsXG4gICAgICAgICdzcGx1bmsudXRpbCcsXG4gICAgICAgICdzcGx1bmsuY29uZmlnJyxcbiAgICAgICAgJ3V0aWwvZ2VuZXJhbF91dGlscydcbiAgICBdLFxuICAgIGZ1bmN0aW9uKCQsIF8sIHNwbHVua1V0aWxzLCBzcGx1bmtDb25maWcsIGdlbmVyYWxVdGlscykge1xuICAgICAgICBcbiAgICAgICAgdmFyIFNZU1RFTSA9IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBHTE9CQUwgPSBcImdsb2JhbFwiLFxuICAgICAgICAgICAgQVBQID0gXCJhcHBcIixcbiAgICAgICAgICAgIFVTRVIgPSBcInVzZXJcIixcbiAgICAgICAgICAgIE5PQk9EWSA9IFwibm9ib2R5XCIsXG4gICAgICAgICAgICBXSUxEQ0FSRCA9IFwiLVwiLFxuICAgICAgICAgICAgVkVSQk9TRSA9IFwidmVyYm9zZVwiLFxuICAgICAgICAgICAgRkFTVCA9IFwiZmFzdFwiLFxuICAgICAgICAgICAgU01BUlQgPSBcInNtYXJ0XCIsXG4gICAgICAgICAgICBSSVNLWV9DT01NQU5EID0gJ3Jpc2t5X2NvbW1hbmQnLFxuICAgICAgICAgICAgRkFUQUwgPSAnZmF0YWwnLFxuICAgICAgICAgICAgRVJST1IgPSAnZXJyb3InLFxuICAgICAgICAgICAgV0FSTklORyA9ICd3YXJuJyxcbiAgICAgICAgICAgIElORk8gPSAnaW5mbycsXG4gICAgICAgICAgICBORVRXT1JLX0VSUk9SID0gJ25ldHdvcmtfZXJyb3InLFxuICAgICAgICAgICAgTk9UX0ZPVU5EID0gJzQwNCcsXG4gICAgICAgICAgICBERUZBVUxUX0xPQ0FMRSA9ICdlbi1VUyc7XG4gICAgICAgIFxuICAgICAgICB2YXIgZnVsbHBhdGggPSBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBpc1NlcnZpY2VzUGF0aCA9IC9eXFwvc2VydmljZXMvLnRlc3QocGF0aCksXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IC9eXFwvLiovLnRlc3QocGF0aCksXG4gICAgICAgICAgICAgICAgaXNGdWxsUGF0aCA9IC9eaHR0cFtzXT86XFwvXFwvLy50ZXN0KHBhdGgpO1xuXG4gICAgICAgICAgICAvL3JldHVybiBpZiBpdCBpcyBhbHJlYWR5IGEgZnVsbCBwYXRoXG4gICAgICAgICAgICBpZiAoaXNGdWxsUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3JldHVybiBpZiBub3QgYSByZWxhdGl2ZSBwYXRoXG4gICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSAmJiAhaXNTZXJ2aWNlc1BhdGgpe1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Fic29sdXRlICYmIGlzU2VydmljZXNQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwbHVua0NvbmZpZy5TUExVTktEX1BBVEggKyBwYXRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIGFwcCBuYW1lIChleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkpLCB3ZSBkZWZhdWx0IHRvIC9zZXJ2aWNlcy9cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hcHAgJiYgIW9wdGlvbnMub3duZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BsdW5rQ29uZmlnLlNQTFVOS0RfUEFUSCArIFwiL3NlcnZpY2VzL1wiICsgcGF0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBhcHAgYW5kIG93bmVyLCBmaXJzdCBmcm9tIHRoZSBwYXNzZWQgaW4gbmFtZXNwYWNlIG9yXG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIHdpbGQgY2FyZHNcbiAgICAgICAgICAgIHZhciBvd25lciA9IG9wdGlvbnMub3duZXIgfHwgV0lMRENBUkQ7XG4gICAgICAgICAgICB2YXIgYXBwICAgPSBvcHRpb25zLmFwcCB8fCBXSUxEQ0FSRDtcblxuICAgICAgICAgICAgb3B0aW9ucy5zaGFyaW5nID0gKG9wdGlvbnMuc2hhcmluZyB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSBvd25lciBhbmQgYXBwIGFwcHJvcHJpYXRlbHkgYmFzZWQgb24gdGhlIHNoYXJpbmcgcGFyYW1ldGVyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaGFyaW5nID09PSBBUFAgfHwgb3B0aW9ucy5zaGFyaW5nID09PSBHTE9CQUwpIHtcbiAgICAgICAgICAgICAgICBvd25lciA9IE5PQk9EWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zaGFyaW5nID09PSBTWVNURU0pIHtcbiAgICAgICAgICAgICAgICBvd25lciA9IE5PQk9EWTtcbiAgICAgICAgICAgICAgICBhcHAgPSBTWVNURU07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3BsdW5rQ29uZmlnLlNQTFVOS0RfUEFUSCArIFwiL3NlcnZpY2VzTlMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQob3duZXIpICsgXCIvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXBwKSArIFwiL1wiICsgcGF0aDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciB4aHJFcnJvclJlc3BvbnNlUGFyc2VyID0gZnVuY3Rpb24ocmVzcG9uc2UsIGlkKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VEYXRhID0ge30sIFxuICAgICAgICAgICAgICAgIGlzVmFsaWRKU09OID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgaWQgPSBpZCB8fCBfKFwib2JqZWN0IGZyb20gU3BsdW5rRFwiKS50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHJlc3BvbnNlLmhhc093blByb3BlcnR5KCdyZXNwb25zZVRleHQnKSAmJiByZXNwb25zZS5oYXNPd25Qcm9wZXJ0eSgnZ2V0UmVzcG9uc2VIZWFkZXInKSkge1xuICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSkgJiYgcmVzcG9uc2UucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZEpTT04gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gaGF2ZSB0byBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgbW9kZWxzIHRoYXQgaGF2ZSB0aGUgcmVzcG9uc2Ugd3JhcHBlZCBpbiBhIFwiZGF0YVwiIGF0dHJpYnV0ZVxuICAgICAgICAgICAgaWYocmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ2RhdGEnKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlRGF0YS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ3N0YXR1cycpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PSA0MDQgJiYgJC5pc0VtcHR5T2JqZWN0KHJlc3BvbnNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXMucHVzaChjcmVhdGVNZXNzYWdlT2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgTk9UX0ZPVU5ELFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsdW5rVXRpbHMuc3ByaW50ZihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfKCdDb3VsZCBub3QgcmV0cmlldmUgJXMuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcmVzb3VyY2UgZXhpc3RzIGFuZCBoYXMgdGhlIGNvcnJlY3QgcGVybWlzc2lvbnMuJykudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09IDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09IDEyMDI5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goY3JlYXRlTWVzc2FnZU9iamVjdChORVRXT1JLX0VSUk9SLCBfKCdZb3VyIG5ldHdvcmsgY29ubmVjdGlvbiBtYXkgaGF2ZSBiZWVuIGxvc3Qgb3IgU3BsdW5rIG1heSBiZSBkb3duLicpLnQoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSlNPTikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goY3JlYXRlTWVzc2FnZU9iamVjdChFUlJPUiwgc3BsdW5rVXRpbHMuc3ByaW50ZihfKCdJbnZhbGlkIEpTT04gZnJvbTogJXMuJykudCgpLCBpZCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VEYXRhLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5jb25jYXQocGFyc2VNZXNzYWdlc09iamVjdChyZXNwb25zZURhdGEubWVzc2FnZXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VNZXNzYWdlcyA9IHBhcnNlTWVzc2FnZXNPYmplY3QocmVzcG9uc2UubWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcyA9IG1lc3NhZ2VzLmNvbmNhdChyZXNwb25zZU1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGNyZWF0ZU1lc3NhZ2VPYmplY3QoRVJST1IsIF8oJ1NlcnZlciBlcnJvcicpLnQoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGNyZWF0ZU1lc3NhZ2VPYmplY3QoRVJST1IsIHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghbWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXMucHVzaChjcmVhdGVNZXNzYWdlT2JqZWN0KEVSUk9SLCBfKCdTZXJ2ZXIgZXJyb3InKS50KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcmVwYXJlU3luY09wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCBiYXNlVXJsKSB7XG4gICAgICAgICAgICB2YXIgYXBwT3duZXIgPSB7fSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0cyA9IHtkYXRhOiB7b3V0cHV0X21vZGU6ICdqc29uJ319O1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhdGEpe1xuICAgICAgICAgICAgICAgIGFwcE93bmVyID0gJC5leHRlbmQoYXBwT3duZXIsIHsgLy9KUXVlcnkgcHVyZ2VzIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBhcHA6IG9wdGlvbnMuZGF0YS5hcHAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBvd25lcjogb3B0aW9ucy5kYXRhLm93bmVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmluZzogb3B0aW9ucy5kYXRhLnNoYXJpbmcgfHwgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5hcHA7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5vd25lcjtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNoYXJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0cy51cmwgPSBmdWxscGF0aChiYXNlVXJsLCBhcHBPd25lcik7XG4gICAgICAgICAgICByZXR1cm4gJC5leHRlbmQodHJ1ZSwgZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIG5hbWVGcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIgfHwgXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgXCJfXCIpLnJlcGxhY2UoL1xcVy9nLCBcIlwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcXVvdGVTZWFyY2hGaWx0ZXJWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBSZXVzaW5nIHN0cmluZy1xdW90aW5nIHNlbWFudGljcyBvZiBKU09OLnN0cmluZ2lmeSgpXG4gICAgICAgICAgICAvLyBCYWNrc2xhc2gtZXNjYXBlcyBxdW90ZXMgYW5kIGJhY2tzbGFzaGVzIGluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gJ2Zvb1xcYmFyIFwiYmF6XCInIC0+ICdcImZvb1xcXFxiYXIgXFxcImJhelxcXCInXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNyZWF0ZVNlYXJjaEZpbHRlclN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gKHZhbHVlKSA/ICh2YWx1ZS5tYXRjaChnZW5lcmFsVXRpbHMuVkFMVUVTX1JFR0VYKSB8fCBbXSk6IFtdO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICByZXR1cm4gXyhrZXlzKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcoJyArIF8uY2hhaW4odmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdmFsdWUgaGFzIHF1b3RlIGFyb3VuZCBpdCByZW1vdmUgcXVvdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaChnZW5lcmFsVXRpbHMuUVVPVEVTX1JFR0VYKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIGxlbi0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2VzY2FwZSBxdW90ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksICc9XCIqJywgdmFsdWUucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXCIvZywnXFxcXFwiJyksICcqXCInXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyBBTkQgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNvbmRpdGlvbmFsIGZpbHRlciB0byBhZGQsIEFORCBpdCB3aXRoIHRoZSBjdXJyZW50IGtleVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jb25kaXRpb25zICYmIG9wdGlvbnMuY29uZGl0aW9uc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgQU5EIFwiICsgb3B0aW9ucy5jb25kaXRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAgKyBcIilcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgJz0qJ10uam9pbignJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSx0aGlzKS5qb2luKCcgT1IgJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNyZWF0ZVNlYXJjaEZpbHRlck9iaiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXlzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gKHZhbHVlKSA/ICh2YWx1ZS5tYXRjaChnZW5lcmFsVXRpbHMuVkFMVUVTX1JFR0VYKSB8fCBbXSk6IFtdLFxuICAgICAgICAgICAgZmlsdGVyT2JqID0ge307IFxuXG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgXyh2YWx1ZXMpLmVhY2goZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goZ2VuZXJhbFV0aWxzLlFVT1RFU19SRUdFWCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCBsZW4tMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHZhbHVlLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1wiL2csJ1xcXCInKSk7XG4gICAgICAgICAgICAgICAgfSx0aGlzKTsgICBcblxuICAgICAgICAgICAgICAgIF8oa2V5cykuZWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyT2JqW2tleV0gPSBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlck9iajtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFyc2VFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgcGFzc2VkRXJyb3JzID0ge30sXG4gICAgICAgICAgICAgICAgcGFyc2VkRXJyb3I7XG5cbiAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRFcnJvciA9IEpTT04ucGFyc2UoZXJyb3IucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRFcnJvciA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkRXJyb3IubWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHBhcnNlZEVycm9yLm1lc3NhZ2VzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VkRXJyb3JzWydzcGx1bmtEOicgKyB2YWx1ZS50eXBlXSA9IHZhbHVlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFzc2VkRXJyb3JzID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFzc2VkRXJyb3JzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjcmVhdGVNZXNzYWdlT2JqZWN0ID0gZnVuY3Rpb24odHlwZSwgbWVzc2FnZSwgaGVscCkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgdmFyIGpzb25TdGFydCA9IG1lc3NhZ2UuaW5kZXhPZihcIn4hfntcIik7XG4gICAgICAgICAgICB2YXIganNvbkVuZCA9IG1lc3NhZ2UubGFzdEluZGV4T2YoXCJ9fiF+XCIpO1xuICAgICAgICAgICAgdmFyIGpzb25Nc2c7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZVRleHQgPSBtZXNzYWdlO1xuXG4gICAgICAgICAgICBpZiAoanNvblN0YXJ0ICE9IC0xICYmIGpzb25FbmQgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqc29uQmxvY2sgPSBtZXNzYWdlLnNsaWNlKGpzb25TdGFydCszLCBqc29uRW5kKzEpO1xuICAgICAgICAgICAgICAgICAgICBqc29uTXNnID0gSlNPTi5wYXJzZShqc29uQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlVGV4dCA9IGpzb25Nc2cuZXJyb3JNZXNzYWdlRW5nbGlzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgc3RydWN0dXJlZCBtZXNzYWdlXG4gICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBrZXk6IF8udW5pcXVlSWQoJ3NwbHVua2RfJyArIHR5cGUpLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVRleHQsXG4gICAgICAgICAgICAgICAgdGV4dDogbWVzc2FnZVRleHQsXG4gICAgICAgICAgICAgICAgaGVscDogaGVscFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBwYXJzZU1lc3NhZ2VzT2JqZWN0ID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGlmKCFtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfKG1lc3NhZ2VzKS5tYXAoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVNZXNzYWdlT2JqZWN0KG1lc3NhZ2UudHlwZSwgbWVzc2FnZS50ZXh0LCBtZXNzYWdlLmhlbHAgfHwgXCJcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBcbiAgICAgICAgdmFyIG1lc3NhZ2VzQ29udGFpbnNPbmVPZlR5cGVzID0gZnVuY3Rpb24obWVzc2FnZXMsIHR5cGVzKXtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pbmRleE9mKHR5cGVzLCBtZXNzYWdlc1tpXS50eXBlKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgZmlsdGVyTWVzc2FnZXNCeVR5cGVzID0gZnVuY3Rpb24obWVzc2FnZXMsIHR5cGVzKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRNZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmluZGV4T2YodHlwZXMsIG1lc3NhZ2VzW2ldLnR5cGUpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZE1lc3NhZ2VzLnB1c2gobWVzc2FnZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkTWVzc2FnZXM7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogTXVuZ2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB3aGF0IHNwbHVua2Qgb3V0cHV0cyBhbmQgd2hhdCB0aGUgcmVuZGVyZXIgZXhwZWN0cyBmb3IgbWVzc2FnZSB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOYW1lbHkgc3BsdW5rZCBoYXMgYSAnZmF0YWwnIHR5cGUgdGhhdCB3ZSByZS1tYXAgdG8gJ2Vycm9yJywgYW5kIHNwbHVua2QgdXNlcyAnd2Fybicgd2hlcmUgdGhlIHJlbmRlcmVyXG4gICAgICAgICAqIHdhbnRzICd3YXJuaW5nJy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBub3JtYWxpemVUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgaWYodHlwZSA9PT0gRkFUQUwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0eXBlID09PSBXQVJOSU5HKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd3YXJuaW5nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGFkZEFuY2hvcnNUb1dpbGRjYXJkQXJyYXkgPSBmdW5jdGlvbih3aWxkY2FyZEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gXy5tYXAod2lsZGNhcmRBcnJheSwgZnVuY3Rpb24od2lsZGNhcmQpe1xuICAgICAgICAgICAgICAgIGlmICghL15cXF4vLnRlc3Qod2lsZGNhcmQpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXlwiICsgd2lsZGNhcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aWxkY2FyZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGNyZWF0ZVNwbHVua0RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRTaGFyaW5nTGFiZWwgPSBmdW5jdGlvbihzaGFyaW5nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNoYXJpbmcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFVTRVI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfKFwiUHJpdmF0ZVwiKS50KCk7XG4gICAgICAgICAgICAgICAgY2FzZSBBUFA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfKFwiQXBwXCIpLnQoKTtcbiAgICAgICAgICAgICAgICBjYXNlIEdMT0JBTDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8oXCJHbG9iYWxcIikudCgpO1xuICAgICAgICAgICAgICAgIGNhc2UgU1lTVEVNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXyhcIkdsb2JhbFwiKS50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFBlcm1pc3Npb25MYWJlbCA9IGZ1bmN0aW9uKHNoYXJpbmcsIG93bmVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNoYXJpbmcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFVTRVI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGx1bmtVdGlscy5zcHJpbnRmKF8oXCJQcml2YXRlLiBPd25lZCBieSAlcy5cIikudCgpLCBvd25lcik7XG4gICAgICAgICAgICAgICAgY2FzZSBBUFA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGx1bmtVdGlscy5zcHJpbnRmKF8oXCJTaGFyZWQgaW4gQXBwLiBPd25lZCBieSAlcy5cIikudCgpLCBvd25lcik7XG4gICAgICAgICAgICAgICAgY2FzZSBHTE9CQUw6XG4gICAgICAgICAgICAgICAgY2FzZSBTWVNURU06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGx1bmtVdGlscy5zcHJpbnRmKF8oXCJTaGFyZWQgR2xvYmFsbHkuIE93bmVkIGJ5ICVzLlwiKS50KCksIG93bmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIG5vcm1hbGl6ZVZhbHVlc0ZvclBPU1QgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNDb3B5ID0gJC5leHRlbmQodHJ1ZSwge30sIHZhbHVlcyk7XG4gICAgICAgICAgICBfLmVhY2godmFsdWVzQ29weSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc0NvcHlba2V5XSA9IFwiMVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzQ29weVtrZXldID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc0NvcHk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgbm9ybWFsaXplQm9vbGVhblRvMDFTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGJvb2wgPSBzcGx1bmtVdGlscy5ub3JtYWxpemVCb29sZWFuKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGlzRXhpc3RpbmdFbnRpdHkgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgIFx0XHRwYXlsb2FkICYmIFxuICAgICAgICBcdFx0cGF5bG9hZC5lbnRyeSAmJiBcbiAgICAgICAgXHRcdF8uaXNBcnJheShwYXlsb2FkLmVudHJ5KSAmJiBcbiAgICAgICAgXHRcdHBheWxvYWQuZW50cnlbMF0ubGlua3MgJiYgXG4gICAgICAgIFx0XHRwYXlsb2FkLmVudHJ5WzBdLmxpbmtzLmFsdGVybmF0ZSAmJiBcbiAgICAgICAgXHRcdCEvLlxcL19uZXckLy50ZXN0KHBheWxvYWQuZW50cnlbMF0ubGlua3MuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgICBcbiAgICAgICAgdmFyIGdldEhlYWRlcnMgPSBmdW5jdGlvbihoZWFkZXJzU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgdmFyIGhlYWRlckxpbmVzID0gaGVhZGVyc1N0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBoZWFkZXJMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJMaW5lc1tpXS50cmltKCkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlclBhcnRzID0gaGVhZGVyTGluZXNbaV0uc3BsaXQoXCI6IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1toZWFkZXJQYXJ0c1swXV0gPSBoZWFkZXJQYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSB1dGlsaXR5IGZ1bmN0aW9uIGZvciB0cmFuc2xhdGluZyBhIGpxdWVyeSByZXNwb25zZSBvYmplY3QgKGpxWEhSKSB0byB0aGUgZm9ybWF0IGV4cGVjdGVkXG4gICAgICAgICAqIGJ5IGNvbnN1bWVycyBvZiB0aGUgc2RrLlxuICAgICAgICAgKiBAcGFyYW0gIHtqcVhIUn0gcmVzcG9uc2VcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBmb3JtYXR0ZWQgcmVzcG9uc2UgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNvbnZlcnRUb1NES1Jlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWwsICdlcnJvcicgd2lsbCBiZSAnc3VjY2VzcycgdG8gY29uZm9ybSB3aXRoIHNkayBhcGlcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZS5yZXNwb25zZUpTT04sXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzKHJlc3BvbnNlLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIGNvbnN0YW50cyBmb3Igc3BsdW5rZCBtZXNzYWdlIHR5cGVzXG4gICAgICAgICAgICBSSVNLWV9DT01NQU5EOiBSSVNLWV9DT01NQU5ELFxuICAgICAgICAgICAgRkFUQUw6IEZBVEFMLFxuICAgICAgICAgICAgRVJST1I6IEVSUk9SLFxuICAgICAgICAgICAgV0FSTklORzogV0FSTklORyxcbiAgICAgICAgICAgIElORk86IElORk8sXG4gICAgICAgICAgICBOT1RfRk9VTkQ6IE5PVF9GT1VORCxcbiAgICAgICAgICAgIE5FVFdPUktfRVJST1I6IE5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY29uc3RhbnRzIGZvciBBQ0xcbiAgICAgICAgICAgIFNZU1RFTTogU1lTVEVNLFxuICAgICAgICAgICAgR0xPQkFMOiBHTE9CQUwsXG4gICAgICAgICAgICBBUFA6IEFQUCxcbiAgICAgICAgICAgIFVTRVI6IFVTRVIsXG4gICAgICAgICAgICBOT0JPRFk6IE5PQk9EWSxcbiAgICAgICAgICAgIFdJTERDQVJEOiAgV0lMRENBUkQsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY29uc3RhbnRzIGZvciB0aGUgYWRob2Mgc2VhcmNoIGxldmVsXG4gICAgICAgICAgICBWRVJCT1NFOiBWRVJCT1NFLFxuICAgICAgICAgICAgRkFTVDogRkFTVCxcbiAgICAgICAgICAgIFNNQVJUOiBTTUFSVCxcblxuICAgICAgICAgICAgLy9jb25zdGFucyBmb3IgZmlsdGVyc1xuICAgICAgICAgICAgVkFMVUVTX1JFR0VYOiBnZW5lcmFsVXRpbHMuVkFMVUVTX1JFR0VYLFxuICAgICAgICAgICAgUVVPVEVTX1JFR0VYOiBnZW5lcmFsVXRpbHMuUVVPVEVTX1JFR0VYLFxuXG4gICAgICAgICAgICBERUZBVUxUX0xPQ0FMRTogREVGQVVMVF9MT0NBTEUsXG5cbiAgICAgICAgICAgIGZ1bGxwYXRoOiBmdWxscGF0aCxcbiAgICAgICAgICAgIHByZXBhcmVTeW5jT3B0aW9uczogcHJlcGFyZVN5bmNPcHRpb25zLFxuICAgICAgICAgICAgbmFtZUZyb21TdHJpbmc6IG5hbWVGcm9tU3RyaW5nLFxuICAgICAgICAgICAgcXVvdGVTZWFyY2hGaWx0ZXJWYWx1ZTogcXVvdGVTZWFyY2hGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgIGNyZWF0ZVNlYXJjaEZpbHRlclN0cmluZzogY3JlYXRlU2VhcmNoRmlsdGVyU3RyaW5nLFxuICAgICAgICAgICAgY3JlYXRlU2VhcmNoRmlsdGVyT2JqOiBjcmVhdGVTZWFyY2hGaWx0ZXJPYmosXG4gICAgICAgICAgICBwYXJzZUVycm9yOiBwYXJzZUVycm9yLFxuICAgICAgICAgICAgcGFyc2VNZXNzYWdlc09iamVjdDogcGFyc2VNZXNzYWdlc09iamVjdCxcbiAgICAgICAgICAgIGNyZWF0ZU1lc3NhZ2VPYmplY3Q6IGNyZWF0ZU1lc3NhZ2VPYmplY3QsXG4gICAgICAgICAgICBtZXNzYWdlc0NvbnRhaW5zT25lT2ZUeXBlczogbWVzc2FnZXNDb250YWluc09uZU9mVHlwZXMsXG4gICAgICAgICAgICBhZGRBbmNob3JzVG9XaWxkY2FyZEFycmF5OiBhZGRBbmNob3JzVG9XaWxkY2FyZEFycmF5LFxuICAgICAgICAgICAgY3JlYXRlU3BsdW5rRE1lc3NhZ2U6IGNyZWF0ZVNwbHVua0RNZXNzYWdlLFxuICAgICAgICAgICAgZ2V0U2hhcmluZ0xhYmVsOiBnZXRTaGFyaW5nTGFiZWwsXG4gICAgICAgICAgICBnZXRQZXJtaXNzaW9uTGFiZWw6IGdldFBlcm1pc3Npb25MYWJlbCxcbiAgICAgICAgICAgIG5vcm1hbGl6ZVR5cGU6IG5vcm1hbGl6ZVR5cGUsXG4gICAgICAgICAgICBmaWx0ZXJNZXNzYWdlc0J5VHlwZXM6IGZpbHRlck1lc3NhZ2VzQnlUeXBlcyxcbiAgICAgICAgICAgIHhockVycm9yUmVzcG9uc2VQYXJzZXI6IHhockVycm9yUmVzcG9uc2VQYXJzZXIsXG4gICAgICAgICAgICBub3JtYWxpemVWYWx1ZXNGb3JQT1NUOiBub3JtYWxpemVWYWx1ZXNGb3JQT1NULFxuICAgICAgICAgICAgbm9ybWFsaXplQm9vbGVhblRvMDFTdHJpbmc6IG5vcm1hbGl6ZUJvb2xlYW5UbzAxU3RyaW5nLFxuICAgICAgICAgICAgaXNFeGlzdGluZ0VudGl0eTogaXNFeGlzdGluZ0VudGl0eSxcbiAgICAgICAgICAgIGdldEhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgICAgICAgICBjb252ZXJ0VG9TREtSZXNwb25zZTogY29udmVydFRvU0RLUmVzcG9uc2VcbiAgICAgICAgfTtcbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy91dGlsL3NwbHVua2RfdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvc3BsdW5rZF91dGlsc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "util/general_utils":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\"),\n        __webpack_require__(\"shim/splunk.util\"),\n        __webpack_require__(\"util/math_utils\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, SplunkUtils, mathUtils) {\n        //returns an array of key:value pairs from the union of the values found in the\n        //arrays with the key being the passed key\n        var unionWithKey = function(arrayOne, arrayTwo, key) {\n            var union = _.union(arrayOne, arrayTwo);\n            return _.map(union, function(field) {\n                var ret_hash = {};\n                ret_hash[key] = field;\n                return ret_hash;\n            });\n        };\n\n        //returns an array of key:value pairs from the difference of the values found in the\n        //arrays with the key being the passed key\n\n        var differenceWithKey = function(arrayOne, arrayTwo, key) {\n            var difference = _.difference(arrayOne, arrayTwo);\n            return _.map(difference, function(field) {\n                var ret_hash = {};\n                ret_hash[key] = field;\n                return ret_hash;\n            });\n        };\n\n        /**\n         * Filters the given object, omitting any key-value pairs where the key doesn't match at least one of the given\n         * regular expressions\n         *\n         * @param obj {Object} the object to filter\n         * @param regexes {Array<String or RegExp> or String or RegExp} a list of strings or regular expressions, strings will be converted\n         *                                                              to regular expressions internally\n         * @param options {Object} {\n         *     strip {String or RegExp} optional, a pattern to strip from each key before comparing\n         *     allowEmpty {Boolean} defaults to false, whether keys with empty values should be included in the return object\n         *     allowObject {Boolean} defaults to false, whether keys with Object values should be included in the return object\n         * }\n         */\n\n        var filterObjectByRegexes = function(obj, regexes, options) {\n            options = options || {};\n            if(!_(regexes).isArray()) {\n                regexes = [regexes];\n            }\n            regexes = _.map(regexes, function(regex) {\n                return (regex instanceof RegExp ? regex: new RegExp(regex));\n            });\n\n            var attrs = {}, strippedKey,\n                strip = _.isString(options.strip) ? options.strip : '',\n                allowEmpty = !!options.allowEmpty,\n                allowObject = !!options.allowObject;\n\n            // match for the wildcards on each key\n            _.each(obj, function(value, key) {\n                strippedKey = key.replace(strip, '');\n                if (attrs[strippedKey]) {\n                    return;\n                }\n                _.each(regexes, function(regex) {\n                    if (regex.test(key)) {\n                        if (!_.isUndefined(value)){\n                            if ((_.isString(value) && value=='' && !allowEmpty) || (_.isObject(value) && !allowObject)) {\n                                return;\n                            }\n                            attrs[strippedKey] = value;\n                        }\n                    }\n                }, this);\n            }, this);\n            return attrs;\n        };\n\n        var deleteFromObjectByRegexes = function(obj, regexes) {\n            if(!_(regexes).isArray()) {\n                regexes = [regexes];\n            }\n            regexes = _.map(regexes, function(regex) {\n                return (regex instanceof RegExp ? regex: new RegExp(regex));\n            });\n\n            var attrs = $.extend(true, {}, obj);\n\n            // match for the wildcards on each key\n            _.each(attrs, function(value, key) {\n                _.each(regexes, function(regex) {\n                    if (regex.test(key)) {\n                        delete attrs[key];\n                    }\n                }, this);\n            }, this);\n\n            return attrs;\n        };\n\n        /**\n         * Recursively removes all attributes with an undefined value from an object\n         *\n         * @param obj\n         * @returns obj\n         */\n        var stripUndefinedAttrs = function(obj) {\n            _.each(obj, function(value, key) {\n                if (value === undefined) {\n                    delete obj[key];\n                } else if (_.isObject(value)) {\n                    stripUndefinedAttrs(value);\n                }\n            });\n            return obj;\n        };\n\n        // Returns input as an array\n        var asArray = function(obj) {\n            if (obj == null) {\n                return [];\n            }\n            return _.isArray(obj) ? obj : [obj];\n        };\n\n        /**\n         * Converts a string with wildcard asterisks to the appropriate\n         * regular expression object.\n         *\n         * Example Usage:\n         *\n         * var foo = globber('te*st*');\n         * // typeof foo is: RegExp\n         * // foo's value is (without spaces): / ^ t e . * s t . * /\n         *\n         */\n        var globber = function(str) {\n            var rex,\n                chars = str.split('');\n\n            if (_.first(chars) !== '*') {\n                chars.unshift('^');\n            }\n\n            if (_.last(chars) !== '*') {\n                chars.push('$');\n            }\n            str = chars.join('').replace(/\\*/g, '.*');\n\n            try {\n                rex = new RegExp(str);\n            } catch(e) {}\n\n            return rex;\n        };\n\n        //takes two values and compares them returning the comparison inverted or not depending on\n        //the sort direction boolean isAsc\n        var compareWithDirection = function(value1, value2, isAsc) {\n            var returnVal = 0;\n            if (value1 == value2) {\n                return returnVal;\n            }\n            if (value1 < value2){\n                returnVal = -1;\n            } else {\n                returnVal = 1;\n            }\n            return (isAsc) ? returnVal : -returnVal;\n        };\n\n        /**\n         * @author sfishel\n         *\n         * Checks if a list of values can be considered \"numeric\".\n         *\n         * Returns true if half or more of the non-null values can be parsed to a float.\n         *\n         * @param {Array} values\n         * @return {Boolean}\n         */\n\n        var valuesAreNumeric = function(values) {\n            var numericCount = 0,\n                nonNullCount = 0;\n\n            _(values).each(function(value) {\n                // in the case of multivalue fields, use the first value\n                if(_(value).isArray()) {\n                    value = value.length > 0 ? value[0] : null;\n                }\n                if(_(value).isNull()) {\n                    return;\n                }\n                nonNullCount++;\n\n                var isNumber = !!mathUtils.strictParseFloat(value) || mathUtils.isCommaSeparatedNumber(value);\n                if(isNumber) {\n                    numericCount++;\n                }\n            });\n            if(nonNullCount === 0) {\n                return false;\n            }\n            return (numericCount >= (nonNullCount / 2));\n        };\n\n        var valuesAreNumericAndFinite = function(values) {\n            var areNumericAndFinite = true;\n            _(values).each(function(value) {\n                if (isNaN(value) || !isFinite(value)) {\n                    areNumericAndFinite = false;\n                }\n            });\n            return areNumericAndFinite;\n        };\n\n        /**\n         * @author sfishel\n         *\n         * This is an approximation method for obtaining a pair of lower and upper percentile values from a list.\n         *\n         * Ported from //python-site/splunk/appserver/mrsparkle/lib/util.py\n         *\n         * @param {Array} orderedList, must be sorted before calling this method\n         * @param {Number} lowerPercentile\n         * @param {Number} upperPercentile\n         *\n         * @return {Object} an object with properties 'upper' and 'lower' corresponding to the upper and lower values.\n         */\n\n        var getPercentiles = function(orderedList, lowerPercentile, upperPercentile) {\n\n            if(orderedList.length === 0) {\n                return { upper: null, lower: null };\n            }\n\n            var f = function(p, ln) {\n                var n = p * (ln - 1) + 1,\n                    k = Math.floor(n),\n                    d = n - k;\n\n                return [n, k, d];\n            };\n\n            var v = function(percentile, oList) {\n                var fArray = f(percentile, oList.length),\n                    n = fArray[0],\n                    k = fArray[1],\n                    d = fArray[2];\n\n                if(k === 0 || oList.length === 1) {\n                    return oList[0];\n                }\n                else if(k === oList.length - 1) {\n                    return oList[oList.length - 1];\n                }\n                else {\n                    return (oList[k] + d * (oList[k + 1] - oList[k]));\n                }\n            };\n\n            return ({\n                lower: v(lowerPercentile, orderedList),\n                upper: v(upperPercentile, orderedList)\n            });\n\n        };\n\n        //take an object and replace a key with another key\n        var transferKey = function(obj, oldKey, newKey) {\n            if (!_.isUndefined(obj[oldKey])){\n                obj[newKey] = obj[oldKey];\n                delete obj[oldKey];\n            }\n        };\n\n        /**\n         *  @author jszeto\n         *\n         *  Returns a copy of the object where the keys have become the values and the values the keys.\n         *  For this to work, all of your object's values should be unique and string serializable.\n         *\n         * @param obj\n         * @return {Object}\n         */\n        var invert = function (obj) {\n\n            // TODO [JCS] Create a version that resolves key conflicts by creating an array of values.\n            // TODO [JCS] Underscore provides an invert function, but the values must be unique.\n            var new_obj = {};\n\n            for (var prop in obj) {\n                if(obj.hasOwnProperty(prop)) {\n                    new_obj[obj[prop]] = prop;\n                }\n            }\n\n            return new_obj;\n        };\n\n        /**\n         * Converts 13824237 to 13,824,237\n         * @param num\n         * @return {String}\n         */\n        var convertNumToString = function(num) {\n            // adds a comma after each 3 digits\n            if (!num) {\n                return null;\n            }\n            return (num.toString()).replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, \"$1,\");\n        };\n\n        // translates a JSON-style serialized list in to a primitive array\n        // cannot handle nested arrays\n        var stringToArray = function (str) {\n            if (!str) {\n                return false;\n            }\n            str = $.trim(str);\n            var strLen = str.length;\n\n            if (str.charAt(0) !== '[' || str.charAt(strLen - 1) !== ']') {\n                return false;\n            }\n            if (/^\\[\\s*\\]$/.test(str)) {\n                return [];\n            }\n            str = str.substr(1, strLen - 2);\n            return SplunkUtils.stringToFieldList(str);\n        };\n\n        /**\n         * Not an exhaustive check that the search string can be parsed as a pivot search, but some simple checks\n         * that the search starts with \"| pivot\" and doesn't pipe to any other search commands.\n         *\n         * @param searchString\n         */\n        var isValidPivotSearch = function(searchString) {\n            if(!/^\\s*\\|\\s*pivot\\s+/.test(searchString)) {\n                return false;\n            }\n            // now we need to check for a \"|\" to another search command,\n            // but need to make sure we don't match a \"|\" inside a string\n            // start by removing any escaped quotes\n            searchString = searchString.replace(/(\\\\\"|\\\\')/g, '');\n            // then it is safe to remove any quoted contents\n            searchString = searchString.replace(/\"[^\"]*\"/g, '').replace(/'[^']*'/g, '');\n            // now if there is more than one \"|\" left it is a search language pipe\n            return searchString.split('|').length === 2;\n        };\n\n        /**\n         * Returns the text currently selected with mouse or null\n         */\n        var getMouseSelection = function() {\n            if (window.getSelection) {\n                return window.getSelection().toString();\n            } else if (document.selection) {\n                return document.selection.createRange().text;\n            }\n            return null;\n        };\n\n        var isTrueEquivalent = function(value) {\n            value = typeof(value) === 'string' ? value.toLowerCase() : value;\n            return value === true || value === 1 ||\n                value === 'true' || value === '1' || value === 'on' || value === 'yes';\n        };\n\n        var isFalseEquivalent = function(value) {\n            value = typeof(value) === 'string' ? value.toLowerCase() : value;\n            return value === false || value === 0 ||\n                value === 'false' || value === '0' || value === 'off' || value === 'no';\n        };\n\n        /**\n         * Checks if the given value can be normalized to a boolean value\n         * @see normalizeBoolean\n         * @param value {*} the value which\n         * @returns {Boolean} true if the value can be normalized to a boolean value, otherwise false\n         */\n        var isBooleanEquivalent = function(value) {\n            return isTrueEquivalent(value) || isFalseEquivalent(value);\n        };\n\n        /**\n         * Strict normalization of a string to boolean which always returns a boolean value.\n         * The following values are treated as true (see isTrue helper)\n         *      - the strings \"true\", \"on\", \"yes\" or \"1\" (case-insensitive)\n         *      - the integer 1\n         *      - the boolean true\n         * The following values are normalized to false (see isFalse helper)\n         *      - the strings \"false\", \"off\", \"no\" or \"0\" (case-insensitive)\n         *      - the integer 0\n         *      - the boolean false\n         * @param value {Boolean|Number|String} - a value to be normalized as a boolean\n         * @param options {Object} - {\n         *      default {Boolean|Number|String} - fallback value in case the string is not a valid boolean expression\n         *  }\n         * @returns {Boolean} the normalization result in case of a valid boolean expression, the default value if\n         *                    specified and a valid boolean, otherwise the default value is normalized or if not\n         *                    specified false is returned by default\n         */\n        var normalizeBoolean = function(value, options) {\n            options || (options = {});\n            if (isTrueEquivalent(value)) {\n                return true;\n            }\n            if (isFalseEquivalent(value)) {\n                return false;\n            }\n            return options.hasOwnProperty('default') ?\n                (typeof(options['default']) === 'boolean' ? options['default'] : normalizeBoolean(options['default']))\n                : false;\n        };\n\n\n        /**\n         * This method is some nasty backwards compatibility for a GET param that used to be a boolean string, but has been migrated to int\n         */\n        var parseBooleanOrInt = function(val) {\n            if (mathUtils.isInteger(val)) {\n                return parseInt(val, 10);\n            }\n            return normalizeBoolean(val);\n        };\n\n        /**\n        * Equality comparison that will deal with objects and Booleans.\n        * If both params are Boolean or Boolean-equivalent\n        * (see the the doc comment for normalizeBoolean)\n        * convert them to Boolean and use === to compare.\n        * Otherwise use Underscore isEqual to compare them.\n        *\n        * @param value1 {Boolean|Number|String|Object} - value to be compared.\n        * @param value2 {Boolean|Number|String|Object} - value to be compared.\n        * @returns {Boolean} - Returns true if the values are the same, false if they are different.\n        */\n        var checkEquality = function(value1, value2) {\n            if (isBooleanEquivalent(value1) && isBooleanEquivalent(value2)) {\n                return (normalizeBoolean(value1) === normalizeBoolean(value2));\n            } else {\n                return _.isEqual(value1, value2);\n            }\n        };\n\n        /**\n         * Check if an array is a subset of another array, where the\n         * needle array may contain wildcard characaters. An empty array\n         * is always a subset of another array.\n         *\n         * NOTE: String comparison is always used, so [1] will be considered\n         * a subset of ['1'].\n         *\n         * Example Usage:\n         *\n         * var isSubset = isFuzzySubset(['one', 't*e'], ['four', 'three', 'one', 'two']);\n         * // isSubset's value is: true\n         *\n         */\n        var isFuzzySubset = function(subset, superset) {\n            superset.length || (superset = ['*']);  // Force superset to have at least one element\n            var intersection = _(subset).filter(function(subsetElement) {\n                var subsetElementPattern = globber(subsetElement.toString());\n                return _(superset).find(function(supersetElement) {\n                    return supersetElement.toString().match(subsetElementPattern) !== null;\n                });\n            });\n            return intersection.length == subset.length;\n        };\n\n\n        /**\n         * Genereate regular expression from filter string\n         *\n         * Example Usage:\n         *\n         * var foo = generateRegex(\"a bc d\")\n         * // typeof foo is: RegExp\n         * // foo's value is (without spaces): /^(?=.*a)(?=.*bc)(?=.*d)/\n         *\n         */\n        var VALUES_REGEX = /(\\'.*?\\')|(\\\".*?\\\")|([^\\s]+)/g,\n            QUOTES_REGEX = /^(\\\".*\\\")$|^(\\'.*\\')$/;\n        var generateFilterRegex = function(value) {\n            // Escape value to be treated as literal string\n            value = SplunkUtils.escapeRegex(value);\n\n            var values = (value) ? value.match(VALUES_REGEX): [];\n            if (values.length) {\n                var parsed = _.chain(values)\n                    .map(function(value) {\n                        if (value.match(QUOTES_REGEX)) {\n                            var len = value.length;\n                            value = value.substring(1, len-1);\n                        }\n                        return ['(?=.*', value,')'].join('');\n                    })\n                    .join('')\n                    .value();\n                return new RegExp('^' + parsed, 'im'); // Added ignore case and multiline match flags\n            } else {\n                return new RegExp('.*');\n            }\n        };\n\n        /**\n         * Create a random GUID (guid) / UUID (uuid) for an use as a unique id.\n         *\n         * The unique id is of the form xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx,\n         * where each x is replaced with a hexadecimal digit from 0 to f, and y is replaced with a\n         * hexadecimal digit from 8 to b.\n         * \n         * This was taken from the answer provided by \"Briguy37\" in the StackOverflow: \n         * http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n         * \n         */\n        \n        var generateUUID = function() {\n            var d = new Date().getTime(),\n                uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n                    var r = (d + Math.random()*16)%16 | 0;\n                    d = Math.floor(d/16);\n                    return (c=='x' ? r : (r&0x3|0x8)).toString(16);\n                });\n            return uuid;\n        };\n\n        return {\n            VALUES_REGEX: VALUES_REGEX,\n            QUOTES_REGEX: QUOTES_REGEX,\n            compareWithDirection: compareWithDirection,\n            unionWithKey: unionWithKey,\n            differenceWithKey: differenceWithKey,\n            filterObjectByRegexes: filterObjectByRegexes,\n            deleteFromObjectByRegexes: deleteFromObjectByRegexes,\n            stripUndefinedAttrs: stripUndefinedAttrs,\n            globber: globber,\n            valuesAreNumeric: valuesAreNumeric,\n            valuesAreNumericAndFinite: valuesAreNumericAndFinite,\n            getPercentiles: getPercentiles,\n            transferKey: transferKey,\n            convertNumToString: convertNumToString,\n            stringToArray: stringToArray,\n            invert: invert,\n            isValidPivotSearch: isValidPivotSearch,\n            getMouseSelection: getMouseSelection,\n            normalizeBoolean: normalizeBoolean,\n            isBooleanEquivalent: isBooleanEquivalent,\n            checkEquality: checkEquality,\n            isFuzzySubset: isFuzzySubset,\n            asArray: asArray,\n            generateFilterRegex: generateFilterRegex,\n            parseBooleanOrInt: parseBooleanOrInt,\n            generateUUID: generateUUID\n        };\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvZ2VuZXJhbF91dGlscy5qcz9iNmQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQSxpQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUIsMkJBQTJCLDRDQUE0QztBQUN2RTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDLHNCQUFzQixpQkFBaUI7QUFDdkMsMkJBQTJCLFFBQVE7QUFDbkMsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYix5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0IscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DLDJCQUEyQixPQUFPO0FBQ2xDLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RCx5QkFBeUIsNkJBQTZCO0FBQ3RELG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSkFDQSIsImZpbGUiOiJ1dGlsL2dlbmVyYWxfdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoXG4gICAgW1xuICAgICAgICAnanF1ZXJ5JyxcbiAgICAgICAgJ3VuZGVyc2NvcmUnLFxuICAgICAgICAnc3BsdW5rLnV0aWwnLFxuICAgICAgICAndXRpbC9tYXRoX3V0aWxzJ1xuICAgIF0sXG4gICAgZnVuY3Rpb24oJCwgXywgU3BsdW5rVXRpbHMsIG1hdGhVdGlscykge1xuICAgICAgICAvL3JldHVybnMgYW4gYXJyYXkgb2Yga2V5OnZhbHVlIHBhaXJzIGZyb20gdGhlIHVuaW9uIG9mIHRoZSB2YWx1ZXMgZm91bmQgaW4gdGhlXG4gICAgICAgIC8vYXJyYXlzIHdpdGggdGhlIGtleSBiZWluZyB0aGUgcGFzc2VkIGtleVxuICAgICAgICB2YXIgdW5pb25XaXRoS2V5ID0gZnVuY3Rpb24oYXJyYXlPbmUsIGFycmF5VHdvLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciB1bmlvbiA9IF8udW5pb24oYXJyYXlPbmUsIGFycmF5VHdvKTtcbiAgICAgICAgICAgIHJldHVybiBfLm1hcCh1bmlvbiwgZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0X2hhc2ggPSB7fTtcbiAgICAgICAgICAgICAgICByZXRfaGFzaFtrZXldID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldF9oYXNoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9yZXR1cm5zIGFuIGFycmF5IG9mIGtleTp2YWx1ZSBwYWlycyBmcm9tIHRoZSBkaWZmZXJlbmNlIG9mIHRoZSB2YWx1ZXMgZm91bmQgaW4gdGhlXG4gICAgICAgIC8vYXJyYXlzIHdpdGggdGhlIGtleSBiZWluZyB0aGUgcGFzc2VkIGtleVxuXG4gICAgICAgIHZhciBkaWZmZXJlbmNlV2l0aEtleSA9IGZ1bmN0aW9uKGFycmF5T25lLCBhcnJheVR3bywga2V5KSB7XG4gICAgICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IF8uZGlmZmVyZW5jZShhcnJheU9uZSwgYXJyYXlUd28pO1xuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKGRpZmZlcmVuY2UsIGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldF9oYXNoID0ge307XG4gICAgICAgICAgICAgICAgcmV0X2hhc2hba2V5XSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRfaGFzaDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWx0ZXJzIHRoZSBnaXZlbiBvYmplY3QsIG9taXR0aW5nIGFueSBrZXktdmFsdWUgcGFpcnMgd2hlcmUgdGhlIGtleSBkb2Vzbid0IG1hdGNoIGF0IGxlYXN0IG9uZSBvZiB0aGUgZ2l2ZW5cbiAgICAgICAgICogcmVndWxhciBleHByZXNzaW9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb2JqIHtPYmplY3R9IHRoZSBvYmplY3QgdG8gZmlsdGVyXG4gICAgICAgICAqIEBwYXJhbSByZWdleGVzIHtBcnJheTxTdHJpbmcgb3IgUmVnRXhwPiBvciBTdHJpbmcgb3IgUmVnRXhwfSBhIGxpc3Qgb2Ygc3RyaW5ncyBvciByZWd1bGFyIGV4cHJlc3Npb25zLCBzdHJpbmdzIHdpbGwgYmUgY29udmVydGVkXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byByZWd1bGFyIGV4cHJlc3Npb25zIGludGVybmFsbHlcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0ge1xuICAgICAgICAgKiAgICAgc3RyaXAge1N0cmluZyBvciBSZWdFeHB9IG9wdGlvbmFsLCBhIHBhdHRlcm4gdG8gc3RyaXAgZnJvbSBlYWNoIGtleSBiZWZvcmUgY29tcGFyaW5nXG4gICAgICAgICAqICAgICBhbGxvd0VtcHR5IHtCb29sZWFufSBkZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBrZXlzIHdpdGggZW1wdHkgdmFsdWVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuIG9iamVjdFxuICAgICAgICAgKiAgICAgYWxsb3dPYmplY3Qge0Jvb2xlYW59IGRlZmF1bHRzIHRvIGZhbHNlLCB3aGV0aGVyIGtleXMgd2l0aCBPYmplY3QgdmFsdWVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuIG9iamVjdFxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBmaWx0ZXJPYmplY3RCeVJlZ2V4ZXMgPSBmdW5jdGlvbihvYmosIHJlZ2V4ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgaWYoIV8ocmVnZXhlcykuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgcmVnZXhlcyA9IFtyZWdleGVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZ2V4ZXMgPSBfLm1hcChyZWdleGVzLCBmdW5jdGlvbihyZWdleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVnZXggaW5zdGFuY2VvZiBSZWdFeHAgPyByZWdleDogbmV3IFJlZ0V4cChyZWdleCkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBhdHRycyA9IHt9LCBzdHJpcHBlZEtleSxcbiAgICAgICAgICAgICAgICBzdHJpcCA9IF8uaXNTdHJpbmcob3B0aW9ucy5zdHJpcCkgPyBvcHRpb25zLnN0cmlwIDogJycsXG4gICAgICAgICAgICAgICAgYWxsb3dFbXB0eSA9ICEhb3B0aW9ucy5hbGxvd0VtcHR5LFxuICAgICAgICAgICAgICAgIGFsbG93T2JqZWN0ID0gISFvcHRpb25zLmFsbG93T2JqZWN0O1xuXG4gICAgICAgICAgICAvLyBtYXRjaCBmb3IgdGhlIHdpbGRjYXJkcyBvbiBlYWNoIGtleVxuICAgICAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIHN0cmlwcGVkS2V5ID0ga2V5LnJlcGxhY2Uoc3RyaXAsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnNbc3RyaXBwZWRLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy5lYWNoKHJlZ2V4ZXMsIGZ1bmN0aW9uKHJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh2YWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoXy5pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWU9PScnICYmICFhbGxvd0VtcHR5KSB8fCAoXy5pc09iamVjdCh2YWx1ZSkgJiYgIWFsbG93T2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW3N0cmlwcGVkS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGVsZXRlRnJvbU9iamVjdEJ5UmVnZXhlcyA9IGZ1bmN0aW9uKG9iaiwgcmVnZXhlcykge1xuICAgICAgICAgICAgaWYoIV8ocmVnZXhlcykuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgcmVnZXhlcyA9IFtyZWdleGVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZ2V4ZXMgPSBfLm1hcChyZWdleGVzLCBmdW5jdGlvbihyZWdleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVnZXggaW5zdGFuY2VvZiBSZWdFeHAgPyByZWdleDogbmV3IFJlZ0V4cChyZWdleCkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBhdHRycyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBvYmopO1xuXG4gICAgICAgICAgICAvLyBtYXRjaCBmb3IgdGhlIHdpbGRjYXJkcyBvbiBlYWNoIGtleVxuICAgICAgICAgICAgXy5lYWNoKGF0dHJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHJlZ2V4ZXMsIGZ1bmN0aW9uKHJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWN1cnNpdmVseSByZW1vdmVzIGFsbCBhdHRyaWJ1dGVzIHdpdGggYW4gdW5kZWZpbmVkIHZhbHVlIGZyb20gYW4gb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICogQHJldHVybnMgb2JqXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3RyaXBVbmRlZmluZWRBdHRycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmlwVW5kZWZpbmVkQXR0cnModmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIGlucHV0IGFzIGFuIGFycmF5XG4gICAgICAgIHZhciBhc0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmogOiBbb2JqXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSBzdHJpbmcgd2l0aCB3aWxkY2FyZCBhc3Rlcmlza3MgdG8gdGhlIGFwcHJvcHJpYXRlXG4gICAgICAgICAqIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgVXNhZ2U6XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBmb28gPSBnbG9iYmVyKCd0ZSpzdConKTtcbiAgICAgICAgICogLy8gdHlwZW9mIGZvbyBpczogUmVnRXhwXG4gICAgICAgICAqIC8vIGZvbydzIHZhbHVlIGlzICh3aXRob3V0IHNwYWNlcyk6IC8gXiB0IGUgLiAqIHMgdCAuICogL1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGdsb2JiZXIgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciByZXgsXG4gICAgICAgICAgICAgICAgY2hhcnMgPSBzdHIuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICBpZiAoXy5maXJzdChjaGFycykgIT09ICcqJykge1xuICAgICAgICAgICAgICAgIGNoYXJzLnVuc2hpZnQoJ14nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF8ubGFzdChjaGFycykgIT09ICcqJykge1xuICAgICAgICAgICAgICAgIGNoYXJzLnB1c2goJyQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IGNoYXJzLmpvaW4oJycpLnJlcGxhY2UoL1xcKi9nLCAnLionKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXggPSBuZXcgUmVnRXhwKHN0cik7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHt9XG5cbiAgICAgICAgICAgIHJldHVybiByZXg7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy90YWtlcyB0d28gdmFsdWVzIGFuZCBjb21wYXJlcyB0aGVtIHJldHVybmluZyB0aGUgY29tcGFyaXNvbiBpbnZlcnRlZCBvciBub3QgZGVwZW5kaW5nIG9uXG4gICAgICAgIC8vdGhlIHNvcnQgZGlyZWN0aW9uIGJvb2xlYW4gaXNBc2NcbiAgICAgICAgdmFyIGNvbXBhcmVXaXRoRGlyZWN0aW9uID0gZnVuY3Rpb24odmFsdWUxLCB2YWx1ZTIsIGlzQXNjKSB7XG4gICAgICAgICAgICB2YXIgcmV0dXJuVmFsID0gMDtcbiAgICAgICAgICAgIGlmICh2YWx1ZTEgPT0gdmFsdWUyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZTEgPCB2YWx1ZTIpe1xuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChpc0FzYykgPyByZXR1cm5WYWwgOiAtcmV0dXJuVmFsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYXV0aG9yIHNmaXNoZWxcbiAgICAgICAgICpcbiAgICAgICAgICogQ2hlY2tzIGlmIGEgbGlzdCBvZiB2YWx1ZXMgY2FuIGJlIGNvbnNpZGVyZWQgXCJudW1lcmljXCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBoYWxmIG9yIG1vcmUgb2YgdGhlIG5vbi1udWxsIHZhbHVlcyBjYW4gYmUgcGFyc2VkIHRvIGEgZmxvYXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgdmFsdWVzQXJlTnVtZXJpYyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICAgICAgdmFyIG51bWVyaWNDb3VudCA9IDAsXG4gICAgICAgICAgICAgICAgbm9uTnVsbENvdW50ID0gMDtcblxuICAgICAgICAgICAgXyh2YWx1ZXMpLmVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBtdWx0aXZhbHVlIGZpZWxkcywgdXNlIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmKF8odmFsdWUpLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmxlbmd0aCA+IDAgPyB2YWx1ZVswXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKF8odmFsdWUpLmlzTnVsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9uTnVsbENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNOdW1iZXIgPSAhIW1hdGhVdGlscy5zdHJpY3RQYXJzZUZsb2F0KHZhbHVlKSB8fCBtYXRoVXRpbHMuaXNDb21tYVNlcGFyYXRlZE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYoaXNOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtZXJpY0NvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZihub25OdWxsQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKG51bWVyaWNDb3VudCA+PSAobm9uTnVsbENvdW50IC8gMikpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB2YWx1ZXNBcmVOdW1lcmljQW5kRmluaXRlID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgYXJlTnVtZXJpY0FuZEZpbml0ZSA9IHRydWU7XG4gICAgICAgICAgICBfKHZhbHVlcykuZWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmVOdW1lcmljQW5kRmluaXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYXJlTnVtZXJpY0FuZEZpbml0ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGF1dGhvciBzZmlzaGVsXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYW4gYXBwcm94aW1hdGlvbiBtZXRob2QgZm9yIG9idGFpbmluZyBhIHBhaXIgb2YgbG93ZXIgYW5kIHVwcGVyIHBlcmNlbnRpbGUgdmFsdWVzIGZyb20gYSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBQb3J0ZWQgZnJvbSAvL3B5dGhvbi1zaXRlL3NwbHVuay9hcHBzZXJ2ZXIvbXJzcGFya2xlL2xpYi91dGlsLnB5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG9yZGVyZWRMaXN0LCBtdXN0IGJlIHNvcnRlZCBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbG93ZXJQZXJjZW50aWxlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1cHBlclBlcmNlbnRpbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzICd1cHBlcicgYW5kICdsb3dlcicgY29ycmVzcG9uZGluZyB0byB0aGUgdXBwZXIgYW5kIGxvd2VyIHZhbHVlcy5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGdldFBlcmNlbnRpbGVzID0gZnVuY3Rpb24ob3JkZXJlZExpc3QsIGxvd2VyUGVyY2VudGlsZSwgdXBwZXJQZXJjZW50aWxlKSB7XG5cbiAgICAgICAgICAgIGlmKG9yZGVyZWRMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVwcGVyOiBudWxsLCBsb3dlcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKHAsIGxuKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBwICogKGxuIC0gMSkgKyAxLFxuICAgICAgICAgICAgICAgICAgICBrID0gTWF0aC5mbG9vcihuKSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IG4gLSBrO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuLCBrLCBkXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB2ID0gZnVuY3Rpb24ocGVyY2VudGlsZSwgb0xpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZkFycmF5ID0gZihwZXJjZW50aWxlLCBvTGlzdC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBuID0gZkFycmF5WzBdLFxuICAgICAgICAgICAgICAgICAgICBrID0gZkFycmF5WzFdLFxuICAgICAgICAgICAgICAgICAgICBkID0gZkFycmF5WzJdO1xuXG4gICAgICAgICAgICAgICAgaWYoayA9PT0gMCB8fCBvTGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9MaXN0WzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGsgPT09IG9MaXN0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9MaXN0W29MaXN0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChvTGlzdFtrXSArIGQgKiAob0xpc3RbayArIDFdIC0gb0xpc3Rba10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBsb3dlcjogdihsb3dlclBlcmNlbnRpbGUsIG9yZGVyZWRMaXN0KSxcbiAgICAgICAgICAgICAgICB1cHBlcjogdih1cHBlclBlcmNlbnRpbGUsIG9yZGVyZWRMaXN0KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvL3Rha2UgYW4gb2JqZWN0IGFuZCByZXBsYWNlIGEga2V5IHdpdGggYW5vdGhlciBrZXlcbiAgICAgICAgdmFyIHRyYW5zZmVyS2V5ID0gZnVuY3Rpb24ob2JqLCBvbGRLZXksIG5ld0tleSkge1xuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKG9ialtvbGRLZXldKSl7XG4gICAgICAgICAgICAgICAgb2JqW25ld0tleV0gPSBvYmpbb2xkS2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW29sZEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBAYXV0aG9yIGpzemV0b1xuICAgICAgICAgKlxuICAgICAgICAgKiAgUmV0dXJucyBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aGVyZSB0aGUga2V5cyBoYXZlIGJlY29tZSB0aGUgdmFsdWVzIGFuZCB0aGUgdmFsdWVzIHRoZSBrZXlzLlxuICAgICAgICAgKiAgRm9yIHRoaXMgdG8gd29yaywgYWxsIG9mIHlvdXIgb2JqZWN0J3MgdmFsdWVzIHNob3VsZCBiZSB1bmlxdWUgYW5kIHN0cmluZyBzZXJpYWxpemFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGludmVydCA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgICAgICAgICAgLy8gVE9ETyBbSkNTXSBDcmVhdGUgYSB2ZXJzaW9uIHRoYXQgcmVzb2x2ZXMga2V5IGNvbmZsaWN0cyBieSBjcmVhdGluZyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICAgICAgICAvLyBUT0RPIFtKQ1NdIFVuZGVyc2NvcmUgcHJvdmlkZXMgYW4gaW52ZXJ0IGZ1bmN0aW9uLCBidXQgdGhlIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZS5cbiAgICAgICAgICAgIHZhciBuZXdfb2JqID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld19vYmpbb2JqW3Byb3BdXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3X29iajtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgMTM4MjQyMzcgdG8gMTMsODI0LDIzN1xuICAgICAgICAgKiBAcGFyYW0gbnVtXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjb252ZXJ0TnVtVG9TdHJpbmcgPSBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgIC8vIGFkZHMgYSBjb21tYSBhZnRlciBlYWNoIDMgZGlnaXRzXG4gICAgICAgICAgICBpZiAoIW51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChudW0udG9TdHJpbmcoKSkucmVwbGFjZSgvKFxcZCkoPz0oXFxkXFxkXFxkKSsoPyFcXGQpKS9nLCBcIiQxLFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0cmFuc2xhdGVzIGEgSlNPTi1zdHlsZSBzZXJpYWxpemVkIGxpc3QgaW4gdG8gYSBwcmltaXRpdmUgYXJyYXlcbiAgICAgICAgLy8gY2Fubm90IGhhbmRsZSBuZXN0ZWQgYXJyYXlzXG4gICAgICAgIHZhciBzdHJpbmdUb0FycmF5ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSAkLnRyaW0oc3RyKTtcbiAgICAgICAgICAgIHZhciBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJ1snIHx8IHN0ci5jaGFyQXQoc3RyTGVuIC0gMSkgIT09ICddJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvXlxcW1xccypcXF0kLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDEsIHN0ckxlbiAtIDIpO1xuICAgICAgICAgICAgcmV0dXJuIFNwbHVua1V0aWxzLnN0cmluZ1RvRmllbGRMaXN0KHN0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdCBhbiBleGhhdXN0aXZlIGNoZWNrIHRoYXQgdGhlIHNlYXJjaCBzdHJpbmcgY2FuIGJlIHBhcnNlZCBhcyBhIHBpdm90IHNlYXJjaCwgYnV0IHNvbWUgc2ltcGxlIGNoZWNrc1xuICAgICAgICAgKiB0aGF0IHRoZSBzZWFyY2ggc3RhcnRzIHdpdGggXCJ8IHBpdm90XCIgYW5kIGRvZXNuJ3QgcGlwZSB0byBhbnkgb3RoZXIgc2VhcmNoIGNvbW1hbmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2VhcmNoU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaXNWYWxpZFBpdm90U2VhcmNoID0gZnVuY3Rpb24oc2VhcmNoU3RyaW5nKSB7XG4gICAgICAgICAgICBpZighL15cXHMqXFx8XFxzKnBpdm90XFxzKy8udGVzdChzZWFyY2hTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gY2hlY2sgZm9yIGEgXCJ8XCIgdG8gYW5vdGhlciBzZWFyY2ggY29tbWFuZCxcbiAgICAgICAgICAgIC8vIGJ1dCBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBtYXRjaCBhIFwifFwiIGluc2lkZSBhIHN0cmluZ1xuICAgICAgICAgICAgLy8gc3RhcnQgYnkgcmVtb3ZpbmcgYW55IGVzY2FwZWQgcXVvdGVzXG4gICAgICAgICAgICBzZWFyY2hTdHJpbmcgPSBzZWFyY2hTdHJpbmcucmVwbGFjZSgvKFxcXFxcInxcXFxcJykvZywgJycpO1xuICAgICAgICAgICAgLy8gdGhlbiBpdCBpcyBzYWZlIHRvIHJlbW92ZSBhbnkgcXVvdGVkIGNvbnRlbnRzXG4gICAgICAgICAgICBzZWFyY2hTdHJpbmcgPSBzZWFyY2hTdHJpbmcucmVwbGFjZSgvXCJbXlwiXSpcIi9nLCAnJykucmVwbGFjZSgvJ1teJ10qJy9nLCAnJyk7XG4gICAgICAgICAgICAvLyBub3cgaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBcInxcIiBsZWZ0IGl0IGlzIGEgc2VhcmNoIGxhbmd1YWdlIHBpcGVcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hTdHJpbmcuc3BsaXQoJ3wnKS5sZW5ndGggPT09IDI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRleHQgY3VycmVudGx5IHNlbGVjdGVkIHdpdGggbW91c2Ugb3IgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGdldE1vdXNlU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaXNUcnVlRXF1aXZhbGVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHR5cGVvZih2YWx1ZSkgPT09ICdzdHJpbmcnID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSAxIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJzEnIHx8IHZhbHVlID09PSAnb24nIHx8IHZhbHVlID09PSAneWVzJztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaXNGYWxzZUVxdWl2YWxlbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0eXBlb2YodmFsdWUpID09PSAnc3RyaW5nJyA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IDAgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJzAnIHx8IHZhbHVlID09PSAnb2ZmJyB8fCB2YWx1ZSA9PT0gJ25vJztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgbm9ybWFsaXplZCB0byBhIGJvb2xlYW4gdmFsdWVcbiAgICAgICAgICogQHNlZSBub3JtYWxpemVCb29sZWFuXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSB7Kn0gdGhlIHZhbHVlIHdoaWNoXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSB2YWx1ZSBjYW4gYmUgbm9ybWFsaXplZCB0byBhIGJvb2xlYW4gdmFsdWUsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGlzQm9vbGVhbkVxdWl2YWxlbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVHJ1ZUVxdWl2YWxlbnQodmFsdWUpIHx8IGlzRmFsc2VFcXVpdmFsZW50KHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaWN0IG5vcm1hbGl6YXRpb24gb2YgYSBzdHJpbmcgdG8gYm9vbGVhbiB3aGljaCBhbHdheXMgcmV0dXJucyBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgdmFsdWVzIGFyZSB0cmVhdGVkIGFzIHRydWUgKHNlZSBpc1RydWUgaGVscGVyKVxuICAgICAgICAgKiAgICAgIC0gdGhlIHN0cmluZ3MgXCJ0cnVlXCIsIFwib25cIiwgXCJ5ZXNcIiBvciBcIjFcIiAoY2FzZS1pbnNlbnNpdGl2ZSlcbiAgICAgICAgICogICAgICAtIHRoZSBpbnRlZ2VyIDFcbiAgICAgICAgICogICAgICAtIHRoZSBib29sZWFuIHRydWVcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIG5vcm1hbGl6ZWQgdG8gZmFsc2UgKHNlZSBpc0ZhbHNlIGhlbHBlcilcbiAgICAgICAgICogICAgICAtIHRoZSBzdHJpbmdzIFwiZmFsc2VcIiwgXCJvZmZcIiwgXCJub1wiIG9yIFwiMFwiIChjYXNlLWluc2Vuc2l0aXZlKVxuICAgICAgICAgKiAgICAgIC0gdGhlIGludGVnZXIgMFxuICAgICAgICAgKiAgICAgIC0gdGhlIGJvb2xlYW4gZmFsc2VcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIHtCb29sZWFufE51bWJlcnxTdHJpbmd9IC0gYSB2YWx1ZSB0byBiZSBub3JtYWxpemVkIGFzIGEgYm9vbGVhblxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSAtIHtcbiAgICAgICAgICogICAgICBkZWZhdWx0IHtCb29sZWFufE51bWJlcnxTdHJpbmd9IC0gZmFsbGJhY2sgdmFsdWUgaW4gY2FzZSB0aGUgc3RyaW5nIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4gZXhwcmVzc2lvblxuICAgICAgICAgKiAgfVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIG5vcm1hbGl6YXRpb24gcmVzdWx0IGluIGNhc2Ugb2YgYSB2YWxpZCBib29sZWFuIGV4cHJlc3Npb24sIHRoZSBkZWZhdWx0IHZhbHVlIGlmXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZWQgYW5kIGEgdmFsaWQgYm9vbGVhbiwgb3RoZXJ3aXNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIG5vcm1hbGl6ZWQgb3IgaWYgbm90XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZWQgZmFsc2UgaXMgcmV0dXJuZWQgYnkgZGVmYXVsdFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG5vcm1hbGl6ZUJvb2xlYW4gPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgICAgIGlmIChpc1RydWVFcXVpdmFsZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmFsc2VFcXVpdmFsZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgP1xuICAgICAgICAgICAgICAgICh0eXBlb2Yob3B0aW9uc1snZGVmYXVsdCddKSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9uc1snZGVmYXVsdCddIDogbm9ybWFsaXplQm9vbGVhbihvcHRpb25zWydkZWZhdWx0J10pKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgc29tZSBuYXN0eSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgYSBHRVQgcGFyYW0gdGhhdCB1c2VkIHRvIGJlIGEgYm9vbGVhbiBzdHJpbmcsIGJ1dCBoYXMgYmVlbiBtaWdyYXRlZCB0byBpbnRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBwYXJzZUJvb2xlYW5PckludCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgaWYgKG1hdGhVdGlscy5pc0ludGVnZXIodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVCb29sZWFuKHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogRXF1YWxpdHkgY29tcGFyaXNvbiB0aGF0IHdpbGwgZGVhbCB3aXRoIG9iamVjdHMgYW5kIEJvb2xlYW5zLlxuICAgICAgICAqIElmIGJvdGggcGFyYW1zIGFyZSBCb29sZWFuIG9yIEJvb2xlYW4tZXF1aXZhbGVudFxuICAgICAgICAqIChzZWUgdGhlIHRoZSBkb2MgY29tbWVudCBmb3Igbm9ybWFsaXplQm9vbGVhbilcbiAgICAgICAgKiBjb252ZXJ0IHRoZW0gdG8gQm9vbGVhbiBhbmQgdXNlID09PSB0byBjb21wYXJlLlxuICAgICAgICAqIE90aGVyd2lzZSB1c2UgVW5kZXJzY29yZSBpc0VxdWFsIHRvIGNvbXBhcmUgdGhlbS5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSB2YWx1ZTEge0Jvb2xlYW58TnVtYmVyfFN0cmluZ3xPYmplY3R9IC0gdmFsdWUgdG8gYmUgY29tcGFyZWQuXG4gICAgICAgICogQHBhcmFtIHZhbHVlMiB7Qm9vbGVhbnxOdW1iZXJ8U3RyaW5nfE9iamVjdH0gLSB2YWx1ZSB0byBiZSBjb21wYXJlZC5cbiAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlcyBhcmUgdGhlIHNhbWUsIGZhbHNlIGlmIHRoZXkgYXJlIGRpZmZlcmVudC5cbiAgICAgICAgKi9cbiAgICAgICAgdmFyIGNoZWNrRXF1YWxpdHkgPSBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgICAgICAgaWYgKGlzQm9vbGVhbkVxdWl2YWxlbnQodmFsdWUxKSAmJiBpc0Jvb2xlYW5FcXVpdmFsZW50KHZhbHVlMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5vcm1hbGl6ZUJvb2xlYW4odmFsdWUxKSA9PT0gbm9ybWFsaXplQm9vbGVhbih2YWx1ZTIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNFcXVhbCh2YWx1ZTEsIHZhbHVlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGFuIGFycmF5IGlzIGEgc3Vic2V0IG9mIGFub3RoZXIgYXJyYXksIHdoZXJlIHRoZVxuICAgICAgICAgKiBuZWVkbGUgYXJyYXkgbWF5IGNvbnRhaW4gd2lsZGNhcmQgY2hhcmFjYXRlcnMuIEFuIGVtcHR5IGFycmF5XG4gICAgICAgICAqIGlzIGFsd2F5cyBhIHN1YnNldCBvZiBhbm90aGVyIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBOT1RFOiBTdHJpbmcgY29tcGFyaXNvbiBpcyBhbHdheXMgdXNlZCwgc28gWzFdIHdpbGwgYmUgY29uc2lkZXJlZFxuICAgICAgICAgKiBhIHN1YnNldCBvZiBbJzEnXS5cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSBVc2FnZTpcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGlzU3Vic2V0ID0gaXNGdXp6eVN1YnNldChbJ29uZScsICd0KmUnXSwgWydmb3VyJywgJ3RocmVlJywgJ29uZScsICd0d28nXSk7XG4gICAgICAgICAqIC8vIGlzU3Vic2V0J3MgdmFsdWUgaXM6IHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHZhciBpc0Z1enp5U3Vic2V0ID0gZnVuY3Rpb24oc3Vic2V0LCBzdXBlcnNldCkge1xuICAgICAgICAgICAgc3VwZXJzZXQubGVuZ3RoIHx8IChzdXBlcnNldCA9IFsnKiddKTsgIC8vIEZvcmNlIHN1cGVyc2V0IHRvIGhhdmUgYXQgbGVhc3Qgb25lIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBfKHN1YnNldCkuZmlsdGVyKGZ1bmN0aW9uKHN1YnNldEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2V0RWxlbWVudFBhdHRlcm4gPSBnbG9iYmVyKHN1YnNldEVsZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8oc3VwZXJzZXQpLmZpbmQoZnVuY3Rpb24oc3VwZXJzZXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlcnNldEVsZW1lbnQudG9TdHJpbmcoKS5tYXRjaChzdWJzZXRFbGVtZW50UGF0dGVybikgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24ubGVuZ3RoID09IHN1YnNldC5sZW5ndGg7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJlYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIGZpbHRlciBzdHJpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSBVc2FnZTpcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGZvbyA9IGdlbmVyYXRlUmVnZXgoXCJhIGJjIGRcIilcbiAgICAgICAgICogLy8gdHlwZW9mIGZvbyBpczogUmVnRXhwXG4gICAgICAgICAqIC8vIGZvbydzIHZhbHVlIGlzICh3aXRob3V0IHNwYWNlcyk6IC9eKD89LiphKSg/PS4qYmMpKD89LipkKS9cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHZhciBWQUxVRVNfUkVHRVggPSAvKFxcJy4qP1xcJyl8KFxcXCIuKj9cXFwiKXwoW15cXHNdKykvZyxcbiAgICAgICAgICAgIFFVT1RFU19SRUdFWCA9IC9eKFxcXCIuKlxcXCIpJHxeKFxcJy4qXFwnKSQvO1xuICAgICAgICB2YXIgZ2VuZXJhdGVGaWx0ZXJSZWdleCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBFc2NhcGUgdmFsdWUgdG8gYmUgdHJlYXRlZCBhcyBsaXRlcmFsIHN0cmluZ1xuICAgICAgICAgICAgdmFsdWUgPSBTcGx1bmtVdGlscy5lc2NhcGVSZWdleCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSAodmFsdWUpID8gdmFsdWUubWF0Y2goVkFMVUVTX1JFR0VYKTogW107XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBfLmNoYWluKHZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKFFVT1RFU19SRUdFWCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIGxlbi0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbJyg/PS4qJywgdmFsdWUsJyknXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJycpXG4gICAgICAgICAgICAgICAgICAgIC52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHBhcnNlZCwgJ2ltJyk7IC8vIEFkZGVkIGlnbm9yZSBjYXNlIGFuZCBtdWx0aWxpbmUgbWF0Y2ggZmxhZ3NcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJy4qJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHJhbmRvbSBHVUlEIChndWlkKSAvIFVVSUQgKHV1aWQpIGZvciBhbiB1c2UgYXMgYSB1bmlxdWUgaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB1bmlxdWUgaWQgaXMgb2YgdGhlIGZvcm0geHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4LFxuICAgICAgICAgKiB3aGVyZSBlYWNoIHggaXMgcmVwbGFjZWQgd2l0aCBhIGhleGFkZWNpbWFsIGRpZ2l0IGZyb20gMCB0byBmLCBhbmQgeSBpcyByZXBsYWNlZCB3aXRoIGFcbiAgICAgICAgICogaGV4YWRlY2ltYWwgZGlnaXQgZnJvbSA4IHRvIGIuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGlzIHdhcyB0YWtlbiBmcm9tIHRoZSBhbnN3ZXIgcHJvdmlkZWQgYnkgXCJCcmlndXkzN1wiIGluIHRoZSBTdGFja092ZXJmbG93OiBcbiAgICAgICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvY3JlYXRlLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAqIFxuICAgICAgICAgKi9cbiAgICAgICAgXG4gICAgICAgIHZhciBnZW5lcmF0ZVVVSUQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgdXVpZCA9ICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IChkICsgTWF0aC5yYW5kb20oKSoxNiklMTYgfCAwO1xuICAgICAgICAgICAgICAgICAgICBkID0gTWF0aC5mbG9vcihkLzE2KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjPT0neCcgPyByIDogKHImMHgzfDB4OCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB1dWlkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBWQUxVRVNfUkVHRVg6IFZBTFVFU19SRUdFWCxcbiAgICAgICAgICAgIFFVT1RFU19SRUdFWDogUVVPVEVTX1JFR0VYLFxuICAgICAgICAgICAgY29tcGFyZVdpdGhEaXJlY3Rpb246IGNvbXBhcmVXaXRoRGlyZWN0aW9uLFxuICAgICAgICAgICAgdW5pb25XaXRoS2V5OiB1bmlvbldpdGhLZXksXG4gICAgICAgICAgICBkaWZmZXJlbmNlV2l0aEtleTogZGlmZmVyZW5jZVdpdGhLZXksXG4gICAgICAgICAgICBmaWx0ZXJPYmplY3RCeVJlZ2V4ZXM6IGZpbHRlck9iamVjdEJ5UmVnZXhlcyxcbiAgICAgICAgICAgIGRlbGV0ZUZyb21PYmplY3RCeVJlZ2V4ZXM6IGRlbGV0ZUZyb21PYmplY3RCeVJlZ2V4ZXMsXG4gICAgICAgICAgICBzdHJpcFVuZGVmaW5lZEF0dHJzOiBzdHJpcFVuZGVmaW5lZEF0dHJzLFxuICAgICAgICAgICAgZ2xvYmJlcjogZ2xvYmJlcixcbiAgICAgICAgICAgIHZhbHVlc0FyZU51bWVyaWM6IHZhbHVlc0FyZU51bWVyaWMsXG4gICAgICAgICAgICB2YWx1ZXNBcmVOdW1lcmljQW5kRmluaXRlOiB2YWx1ZXNBcmVOdW1lcmljQW5kRmluaXRlLFxuICAgICAgICAgICAgZ2V0UGVyY2VudGlsZXM6IGdldFBlcmNlbnRpbGVzLFxuICAgICAgICAgICAgdHJhbnNmZXJLZXk6IHRyYW5zZmVyS2V5LFxuICAgICAgICAgICAgY29udmVydE51bVRvU3RyaW5nOiBjb252ZXJ0TnVtVG9TdHJpbmcsXG4gICAgICAgICAgICBzdHJpbmdUb0FycmF5OiBzdHJpbmdUb0FycmF5LFxuICAgICAgICAgICAgaW52ZXJ0OiBpbnZlcnQsXG4gICAgICAgICAgICBpc1ZhbGlkUGl2b3RTZWFyY2g6IGlzVmFsaWRQaXZvdFNlYXJjaCxcbiAgICAgICAgICAgIGdldE1vdXNlU2VsZWN0aW9uOiBnZXRNb3VzZVNlbGVjdGlvbixcbiAgICAgICAgICAgIG5vcm1hbGl6ZUJvb2xlYW46IG5vcm1hbGl6ZUJvb2xlYW4sXG4gICAgICAgICAgICBpc0Jvb2xlYW5FcXVpdmFsZW50OiBpc0Jvb2xlYW5FcXVpdmFsZW50LFxuICAgICAgICAgICAgY2hlY2tFcXVhbGl0eTogY2hlY2tFcXVhbGl0eSxcbiAgICAgICAgICAgIGlzRnV6enlTdWJzZXQ6IGlzRnV6enlTdWJzZXQsXG4gICAgICAgICAgICBhc0FycmF5OiBhc0FycmF5LFxuICAgICAgICAgICAgZ2VuZXJhdGVGaWx0ZXJSZWdleDogZ2VuZXJhdGVGaWx0ZXJSZWdleCxcbiAgICAgICAgICAgIHBhcnNlQm9vbGVhbk9ySW50OiBwYXJzZUJvb2xlYW5PckludCxcbiAgICAgICAgICAgIGdlbmVyYXRlVVVJRDogZ2VuZXJhdGVVVUlEXG4gICAgICAgIH07XG4gICAgfVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy91dGlsL2dlbmVyYWxfdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvZ2VuZXJhbF91dGlsc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "util/math_utils":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n       __webpack_require__(\"require/underscore\")\n   ], __WEBPACK_AMD_DEFINE_RESULT__ = function(_) {\n\n    var DECIMAL_OR_SCIENTIFIC_REGEX = /(^[-+]?[0-9]*[.]?[0-9]*$)|(^[-+]?[0-9][.]?[0-9]*e[-+]?[0-9][0-9]*$)/i;\n    var COMMA_SEPARATED_NUMBER_REGEX = /(^[-+]?([0]|([1-9][0-9]{0,2})|(([1-9][0-9]{0,2}[,])([0-9]{3}[,])*[0-9]{3}))(([.][0-9]+)?)$)/;\n    var MIN_SAFE_INTEGER = -9007199254740991; // Hard code Number.MIN_SAFE_INTEGER since it is not supported in IE, opera and safari\n    var MAX_SAFE_INTEGER =  9007199254740991; // Hard code Number.MAX_SAFE_INTEGER since it is not supported in IE, opera and safari\n\n    /**\n     * @author sfishel\n     *\n     * A strict version of parseFloat that requires the entire input string to be valid decimal or scientific format\n     *\n     * @param {String} str - string to be parsed into a number\n     * @return {Number or NaN}\n     */\n\n    var strictParseFloat = function(str) {\n        // if the number is not in decimal or scientific format, return NaN explicitly\n        // instead of letting JavaScript do its loose parsing\n        if(!DECIMAL_OR_SCIENTIFIC_REGEX.test(str)) {\n            return NaN;\n        }\n        return parseFloat(str);\n    };\n\n    /**\n    * @author rtran\n    *\n    * Checks if the value passed in is some comma separated number\n    * (e.g. \"1,234\", \"300,000,000\", and \"12,345.67\"). This function provides \n    * a simple way to determine when a comma seperated value string should be \n    * considered a number.\n    *\n    * @param {String} str - string to be checked\n    * @returns {Boolean} - return true if (str) is a valid number grouped by either commas or decimals, false otherwise\n    */\n    var isCommaSeparatedNumber = function(str) {\n        // if str is not a number grouped with either commas or decimals\n        if(!COMMA_SEPARATED_NUMBER_REGEX.test(str)) {\n            return false;\n        }\n        return true;\n    };\n\n    /**\n     * \n     * Rounds a number to a specifice exp base 10\n     *\n     * @param {Number} value - number to round\n     * @param {Number} exp - exp of base 10 of the decimal palce to round to \n                            eg: exp=-1 rounds to the tenths place\n                                exp=-2 rounds to the hundredth place\n                                exp=0 rounds to the ones place\n                                exp=1 rounds to the tens place\n     * @return {Number or NaN}\n     *\n     * reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n     */\n    var roundToDecimal = function(value, exp) {\n        // If the exp is undefined or zero...\n        if (typeof exp === 'undefined' || +exp === 0) {\n            return Math.round(value);\n        }\n        value = +value;\n        exp = +exp;\n        // If the value is not a number or the exp is not an integer...\n        if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {\n            return NaN;\n        }\n        // Shift\n        value = value.toString().split('e');\n        value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));\n        // Shift back\n        value = value.toString().split('e');\n        return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));\n    };\n\n    /**\n     *\n     * Returns if an input is an integer\n     *\n     * @param {String} value\n     * @return {Boolean}\n     */\n     var isInteger = function(value) {\n        var parsedValue = strictParseFloat(value);\n        return !isNaN(parsedValue) && parsedValue % 1 === 0;\n     };\n     \n     var nearestMatchAndIndexInArray = function(valueToMatch, values) {         \n         var closestValue, closestIndex;\n         _.each(values, function(value, index){\n             if (closestValue == null || (Math.abs(valueToMatch - value) < Math.abs(closestValue - valueToMatch))) {\n                 closestValue = value;\n                 closestIndex = index;\n             }\n         });\n         return {value: closestValue, index: closestIndex};\n     };\n\n     /*\n      * Returns the nearest whole power of ten to the given number, without exceeding that number\n      * e.g.\n      *\n      * 10 -> 10\n      * 11 -> 10\n      * 99 -> 10\n      * 100 -> 100\n      * ...\n      */\n     var nearestPowerOfTen = function(number) {\n         return Math.pow(10, Math.floor(Math.log(number) / Math.LN10));\n     };\n\n     var isLessThanMinSafeInt = function(number) {\n        if(typeof number != 'number') return false;\n        if(number <= MIN_SAFE_INTEGER) {\n            return true;\n        }\n        return false;\n     };\n\n     var isGreaterThanMaxSafeInt = function(number) {\n        if(typeof number != 'number') return false;\n        if(number >= MAX_SAFE_INTEGER) {\n            return true;\n        }\n        return false;\n     };\n\n     var stripFloatingPointErrors = function(number) {\n         return (parseFloat(number.toPrecision(12)));\n     };\n\n     var convertToTwoDecimalPercentage = function(value, totalCount) {\n         // Convert to percentage and always round to 2 d.p.\n         return (parseFloat(value) / totalCount * 100).toFixed(2);\n     };\n\n    return ({\n        strictParseFloat: strictParseFloat,\n        isCommaSeparatedNumber: isCommaSeparatedNumber,\n        roundToDecimal: roundToDecimal,\n        isInteger: isInteger,\n        nearestMatchAndIndexInArray: nearestMatchAndIndexInArray,\n        nearestPowerOfTen: nearestPowerOfTen,\n        isLessThanMinSafeInt: isLessThanMinSafeInt,\n        isGreaterThanMaxSafeInt: isGreaterThanMaxSafeInt,\n        stripFloatingPointErrors: stripFloatingPointErrors,\n        convertToTwoDecimalPercentage: convertToTwoDecimalPercentage\n    });\n\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvbWF0aF91dGlscy5qcz8xM2FlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0Esc0NBQ0E7O0FBRUE7QUFDQSxnRUFBZ0UsSUFBSSxlQUFlLElBQUksV0FBVyxFQUFFLFdBQVcsRUFBRTtBQUNqSCw2Q0FBNkM7QUFDN0MsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsQ0FBQyIsImZpbGUiOiJ1dGlsL21hdGhfdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1xuICAgICAgICd1bmRlcnNjb3JlJ1xuICAgXSxcbiAgIGZ1bmN0aW9uKF8pIHtcblxuICAgIHZhciBERUNJTUFMX09SX1NDSUVOVElGSUNfUkVHRVggPSAvKF5bLStdP1swLTldKlsuXT9bMC05XSokKXwoXlstK10/WzAtOV1bLl0/WzAtOV0qZVstK10/WzAtOV1bMC05XSokKS9pO1xuICAgIHZhciBDT01NQV9TRVBBUkFURURfTlVNQkVSX1JFR0VYID0gLyheWy0rXT8oWzBdfChbMS05XVswLTldezAsMn0pfCgoWzEtOV1bMC05XXswLDJ9WyxdKShbMC05XXszfVssXSkqWzAtOV17M30pKSgoWy5dWzAtOV0rKT8pJCkvO1xuICAgIHZhciBNSU5fU0FGRV9JTlRFR0VSID0gLTkwMDcxOTkyNTQ3NDA5OTE7IC8vIEhhcmQgY29kZSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiBzaW5jZSBpdCBpcyBub3Qgc3VwcG9ydGVkIGluIElFLCBvcGVyYSBhbmQgc2FmYXJpXG4gICAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAgOTAwNzE5OTI1NDc0MDk5MTsgLy8gSGFyZCBjb2RlIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHNpbmNlIGl0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUsIG9wZXJhIGFuZCBzYWZhcmlcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igc2Zpc2hlbFxuICAgICAqXG4gICAgICogQSBzdHJpY3QgdmVyc2lvbiBvZiBwYXJzZUZsb2F0IHRoYXQgcmVxdWlyZXMgdGhlIGVudGlyZSBpbnB1dCBzdHJpbmcgdG8gYmUgdmFsaWQgZGVjaW1hbCBvciBzY2llbnRpZmljIGZvcm1hdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byBiZSBwYXJzZWQgaW50byBhIG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlciBvciBOYU59XG4gICAgICovXG5cbiAgICB2YXIgc3RyaWN0UGFyc2VGbG9hdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIG5vdCBpbiBkZWNpbWFsIG9yIHNjaWVudGlmaWMgZm9ybWF0LCByZXR1cm4gTmFOIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBsZXR0aW5nIEphdmFTY3JpcHQgZG8gaXRzIGxvb3NlIHBhcnNpbmdcbiAgICAgICAgaWYoIURFQ0lNQUxfT1JfU0NJRU5USUZJQ19SRUdFWC50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBAYXV0aG9yIHJ0cmFuXG4gICAgKlxuICAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaW4gaXMgc29tZSBjb21tYSBzZXBhcmF0ZWQgbnVtYmVyXG4gICAgKiAoZS5nLiBcIjEsMjM0XCIsIFwiMzAwLDAwMCwwMDBcIiwgYW5kIFwiMTIsMzQ1LjY3XCIpLiBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIFxuICAgICogYSBzaW1wbGUgd2F5IHRvIGRldGVybWluZSB3aGVuIGEgY29tbWEgc2VwZXJhdGVkIHZhbHVlIHN0cmluZyBzaG91bGQgYmUgXG4gICAgKiBjb25zaWRlcmVkIGEgbnVtYmVyLlxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gYmUgY2hlY2tlZFxuICAgICogQHJldHVybnMge0Jvb2xlYW59IC0gcmV0dXJuIHRydWUgaWYgKHN0cikgaXMgYSB2YWxpZCBudW1iZXIgZ3JvdXBlZCBieSBlaXRoZXIgY29tbWFzIG9yIGRlY2ltYWxzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAqL1xuICAgIHZhciBpc0NvbW1hU2VwYXJhdGVkTnVtYmVyID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIC8vIGlmIHN0ciBpcyBub3QgYSBudW1iZXIgZ3JvdXBlZCB3aXRoIGVpdGhlciBjb21tYXMgb3IgZGVjaW1hbHNcbiAgICAgICAgaWYoIUNPTU1BX1NFUEFSQVRFRF9OVU1CRVJfUkVHRVgudGVzdChzdHIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIFJvdW5kcyBhIG51bWJlciB0byBhIHNwZWNpZmljZSBleHAgYmFzZSAxMFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gbnVtYmVyIHRvIHJvdW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cCAtIGV4cCBvZiBiYXNlIDEwIG9mIHRoZSBkZWNpbWFsIHBhbGNlIHRvIHJvdW5kIHRvIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVnOiBleHA9LTEgcm91bmRzIHRvIHRoZSB0ZW50aHMgcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwPS0yIHJvdW5kcyB0byB0aGUgaHVuZHJlZHRoIHBsYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cD0wIHJvdW5kcyB0byB0aGUgb25lcyBwbGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHA9MSByb3VuZHMgdG8gdGhlIHRlbnMgcGxhY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXIgb3IgTmFOfVxuICAgICAqXG4gICAgICogcmVmZXJlbmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3JvdW5kXG4gICAgICovXG4gICAgdmFyIHJvdW5kVG9EZWNpbWFsID0gZnVuY3Rpb24odmFsdWUsIGV4cCkge1xuICAgICAgICAvLyBJZiB0aGUgZXhwIGlzIHVuZGVmaW5lZCBvciB6ZXJvLi4uXG4gICAgICAgIGlmICh0eXBlb2YgZXhwID09PSAndW5kZWZpbmVkJyB8fCArZXhwID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICAgIGV4cCA9ICtleHA7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXIgb3IgdGhlIGV4cCBpcyBub3QgYW4gaW50ZWdlci4uLlxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICEodHlwZW9mIGV4cCA9PT0gJ251bWJlcicgJiYgZXhwICUgMSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hpZnRcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCdlJyk7XG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCgrKHZhbHVlWzBdICsgJ2UnICsgKHZhbHVlWzFdID8gKCt2YWx1ZVsxXSAtIGV4cCkgOiAtZXhwKSkpO1xuICAgICAgICAvLyBTaGlmdCBiYWNrXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnZScpO1xuICAgICAgICByZXR1cm4gKyh2YWx1ZVswXSArICdlJyArICh2YWx1ZVsxXSA/ICgrdmFsdWVbMV0gKyBleHApIDogZXhwKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0dXJucyBpZiBhbiBpbnB1dCBpcyBhbiBpbnRlZ2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgICB2YXIgaXNJbnRlZ2VyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnNlZFZhbHVlID0gc3RyaWN0UGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VkVmFsdWUpICYmIHBhcnNlZFZhbHVlICUgMSA9PT0gMDtcbiAgICAgfTtcbiAgICAgXG4gICAgIHZhciBuZWFyZXN0TWF0Y2hBbmRJbmRleEluQXJyYXkgPSBmdW5jdGlvbih2YWx1ZVRvTWF0Y2gsIHZhbHVlcykgeyAgICAgICAgIFxuICAgICAgICAgdmFyIGNsb3Nlc3RWYWx1ZSwgY2xvc2VzdEluZGV4O1xuICAgICAgICAgXy5lYWNoKHZhbHVlcywgZnVuY3Rpb24odmFsdWUsIGluZGV4KXtcbiAgICAgICAgICAgICBpZiAoY2xvc2VzdFZhbHVlID09IG51bGwgfHwgKE1hdGguYWJzKHZhbHVlVG9NYXRjaCAtIHZhbHVlKSA8IE1hdGguYWJzKGNsb3Nlc3RWYWx1ZSAtIHZhbHVlVG9NYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgIGNsb3Nlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICB9XG4gICAgICAgICB9KTtcbiAgICAgICAgIHJldHVybiB7dmFsdWU6IGNsb3Nlc3RWYWx1ZSwgaW5kZXg6IGNsb3Nlc3RJbmRleH07XG4gICAgIH07XG5cbiAgICAgLypcbiAgICAgICogUmV0dXJucyB0aGUgbmVhcmVzdCB3aG9sZSBwb3dlciBvZiB0ZW4gdG8gdGhlIGdpdmVuIG51bWJlciwgd2l0aG91dCBleGNlZWRpbmcgdGhhdCBudW1iZXJcbiAgICAgICogZS5nLlxuICAgICAgKlxuICAgICAgKiAxMCAtPiAxMFxuICAgICAgKiAxMSAtPiAxMFxuICAgICAgKiA5OSAtPiAxMFxuICAgICAgKiAxMDAgLT4gMTAwXG4gICAgICAqIC4uLlxuICAgICAgKi9cbiAgICAgdmFyIG5lYXJlc3RQb3dlck9mVGVuID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2cobnVtYmVyKSAvIE1hdGguTE4xMCkpO1xuICAgICB9O1xuXG4gICAgIHZhciBpc0xlc3NUaGFuTWluU2FmZUludCA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICBpZih0eXBlb2YgbnVtYmVyICE9ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKG51bWJlciA8PSBNSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgIH07XG5cbiAgICAgdmFyIGlzR3JlYXRlclRoYW5NYXhTYWZlSW50ID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgIGlmKHR5cGVvZiBudW1iZXIgIT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYobnVtYmVyID49IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgfTtcblxuICAgICB2YXIgc3RyaXBGbG9hdGluZ1BvaW50RXJyb3JzID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQobnVtYmVyLnRvUHJlY2lzaW9uKDEyKSkpO1xuICAgICB9O1xuXG4gICAgIHZhciBjb252ZXJ0VG9Ud29EZWNpbWFsUGVyY2VudGFnZSA9IGZ1bmN0aW9uKHZhbHVlLCB0b3RhbENvdW50KSB7XG4gICAgICAgICAvLyBDb252ZXJ0IHRvIHBlcmNlbnRhZ2UgYW5kIGFsd2F5cyByb3VuZCB0byAyIGQucC5cbiAgICAgICAgIHJldHVybiAocGFyc2VGbG9hdCh2YWx1ZSkgLyB0b3RhbENvdW50ICogMTAwKS50b0ZpeGVkKDIpO1xuICAgICB9O1xuXG4gICAgcmV0dXJuICh7XG4gICAgICAgIHN0cmljdFBhcnNlRmxvYXQ6IHN0cmljdFBhcnNlRmxvYXQsXG4gICAgICAgIGlzQ29tbWFTZXBhcmF0ZWROdW1iZXI6IGlzQ29tbWFTZXBhcmF0ZWROdW1iZXIsXG4gICAgICAgIHJvdW5kVG9EZWNpbWFsOiByb3VuZFRvRGVjaW1hbCxcbiAgICAgICAgaXNJbnRlZ2VyOiBpc0ludGVnZXIsXG4gICAgICAgIG5lYXJlc3RNYXRjaEFuZEluZGV4SW5BcnJheTogbmVhcmVzdE1hdGNoQW5kSW5kZXhJbkFycmF5LFxuICAgICAgICBuZWFyZXN0UG93ZXJPZlRlbjogbmVhcmVzdFBvd2VyT2ZUZW4sXG4gICAgICAgIGlzTGVzc1RoYW5NaW5TYWZlSW50OiBpc0xlc3NUaGFuTWluU2FmZUludCxcbiAgICAgICAgaXNHcmVhdGVyVGhhbk1heFNhZmVJbnQ6IGlzR3JlYXRlclRoYW5NYXhTYWZlSW50LFxuICAgICAgICBzdHJpcEZsb2F0aW5nUG9pbnRFcnJvcnM6IHN0cmlwRmxvYXRpbmdQb2ludEVycm9ycyxcbiAgICAgICAgY29udmVydFRvVHdvRGVjaW1hbFBlcmNlbnRhZ2U6IGNvbnZlcnRUb1R3b0RlY2ltYWxQZXJjZW50YWdlXG4gICAgfSk7XG5cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy91dGlsL21hdGhfdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvbWF0aF91dGlsc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "views/shared/viz/Base":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * A common base class for a Backbone View that wraps a visualization.  The visualization can be a\n * mod viz defined in an app or a built-in visualization.\n *\n * This base class uses managed asynchronous passes to batch rendering and processing operations.\n * To integrate these passes with the surrounding system, this class changes the behavior of\n * the activate/deactivate/invalidateReflow methods to make them \"pass aware\".  More details\n * in inline comments below.\n *\n * The goal of this class is to provide a tiered API.  A simple subclass can only implement\n * the updateView method and do all data processing and rendering there.  Or a more advanced\n * subclass can break these out into distinct data process and rendering passes, and override\n * the change handlers to control when those passes are invalidated.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(\"require/underscore\"),\n            __webpack_require__(\"contrib/jg_lib/async/MPassTarget\"),\n            __webpack_require__(\"contrib/jg_lib/async/Pass\"),\n            __webpack_require__(\"contrib/jg_lib/Class\"),\n            __webpack_require__(\"contrib/jg_lib/utils/Set\"),\n            __webpack_require__(\"views/Base\"),\n            __webpack_require__(\"util/console\"),\n            __webpack_require__(\"helpers/Printer\"),\n            __webpack_require__(\"mixins/DataSourceMixin\"),\n            __webpack_require__(\"shim/jquery.resize\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n            _,\n            MPassTarget,\n            Pass,\n            Class,\n            Set,\n            BaseView,\n            console,\n            Printer,\n            DataSourceMixin,\n            undefined\n        ) {\n\n    // Define a custom subclass of the built-in asynchronous pass object that\n    // integrates with the activate/deactivate lifecycle.\n    var DeactivatingPass = Class(Pass, function(DeactivatingPass, base) {\n\n        // Check whether or not its target is active when the pass is invalidated.\n        // If the target is not active, the pass does not go into the processing queue\n        // and instead broadcasts itself to the target view to be dealt with\n        // if/when the view is activated later.\n        this.invalidate = function(target) {\n            if (target instanceof SplunkVisualizationBase && !target.active) {\n                target.enqueueInvalidPass(this);\n                return;\n            }\n            base.invalidate.apply(this, arguments);\n        };\n\n        // If a pass comes out of the processing queue while the view is deactivated\n        // (i.e. it was invalidated right before the view was deactivated) it marks\n        // itself valid without running its method and broadcasts itself to be\n        // dealt with if/when the view is activated later.\n        this.validate = function(target) {\n            if (target instanceof SplunkVisualizationBase && !target.active) {\n                this.markValid(target);\n                target.enqueueInvalidPass(this);\n                return;\n            }\n            base.validate.apply(this, arguments);\n        };\n\n    });\n\n    var FORMAT_DATA_PASS_ORDER = 0.1,\n        UPDATE_VIEW_PASS_ORDER = FORMAT_DATA_PASS_ORDER + 0.1,\n        REFLOW_PASS_ORDER = UPDATE_VIEW_PASS_ORDER + 0.1;\n\n    var SplunkVisualizationBase = BaseView.extend(_.extend({}, MPassTarget, DataSourceMixin, {\n\n        formatDataPass: new DeactivatingPass('_formatData', FORMAT_DATA_PASS_ORDER),\n        updateViewPass: new DeactivatingPass('_updateView', UPDATE_VIEW_PASS_ORDER),\n        reflowPass: new DeactivatingPass('reflow', REFLOW_PASS_ORDER),\n\n        initialize: function() {\n            BaseView.prototype.initialize.apply(this, arguments);\n            this.listenTo(this.model.config, 'change', function(configModel) {\n                this.onConfigChange(\n                    configModel.changedAttributes(),\n                    configModel.previousAttributes()\n                );\n            });\n            this.$el.on('elementResize', this.onContainerSizeChange.bind(this));\n            this.listenTo(Printer, Printer.PRINT_START, this.onPrintStart.bind(this));\n            this.listenTo(Printer, Printer.PRINT_END, this.onPrintEnd.bind(this));\n            this._pendingPasses = new Set();\n            this._formattedData = null;\n            this._setupView = _.once(function() { this.setupView(); });\n\n            // No scale by default\n            this._scaleDictionary = {};\n\n            this.dataSources = this.options.dataSources || [];\n            this.setupDataSources();\n            this.activate();\n        },\n\n        setupDataSources: function() {\n            _(this.getRequiredDataSources()).each(function(name) {\n                if (this.getDataSource(name) == null) {\n                    throw new Error('DataSource ' + name + ' is required');\n                }\n            }, this);\n            // setup search result change listener for each data source.\n            _(this.getAllDataSources()).each(function(ds) {\n                this.listenTo(ds, 'searchResultsChange', this.onDataChange);\n            }, this);\n        },\n\n        getRequiredDataSources: function() {\n            return ['primary'];\n        },\n\n        setScaleDictionary: function(scaleDictionary) {\n            if (!scaleDictionary){\n                return;\n            }\n            _.each(this._scaleDictionary, function(scale){\n                scale.unregister(this);\n                scale.off('change', this._scaleChange, this);\n            }, this);\n            this._scaleDictionary = scaleDictionary;\n            _.each(this._scaleDictionary, function(scale){\n                scale.register(this);\n                scale.on('change', this._scaleChange, this);\n            }, this);\n        },\n\n        _scaleChange: function(e){\n            this.invalidate('updateViewPass');\n        },\n\n        // Nothing by default\n        // Subclasses should override to add scale values\n        provideScaleValues: function(){\n            return {};\n        },\n\n        remove: function() {\n            _.each(this._scaleDictionary, function(scale){\n                scale.off('change', this._scaleChange, this);\n                scale.unregister(this);\n            }, this);\n            this.markValid();\n            this.$el.off('elementResize');\n            return BaseView.prototype.remove.apply(this, arguments);\n        },\n\n        getDataFromAllSources: function() {\n            var data = {};\n            _.each(this.getAllDataSources(), function(ds) {\n                data[ds.name] = ds.getSearchResults();\n            });\n            return data;\n        },\n\n        onDataChange: function() {\n            this.invalidate('formatDataPass');\n        },\n\n        // By default, any config change invalidates the formatDataPass.\n        // Subclasses can override this method for more fine-grained control, making use of the\n        // given changed and previous attributes to determine the most efficient way to handle the change.\n        //\n        // For example, it's common for certain config attributes to have no effect on the formatDataPass,\n        // so a subclass could avoid needless work by invalidating the updateViewPass instead.\n        onConfigChange: function(changedAttributes, previousAttributes) {\n            this.invalidate('formatDataPass');\n        },\n\n        onContainerSizeChange: function() {\n            this.invalidate('reflowPass');\n        },\n\n        onPrintStart: function() {\n            this.invalidate('reflowPass');\n            this.validate();\n        },\n\n        onPrintEnd: function() {\n            this.invalidate('reflowPass');\n            this.validate();\n        },\n\n        // Override to configure subclass properties based on display mode\n        setDisplayMode: function() {},\n\n        // The formatDataPass will call the subclass-specific combineData and formatData routine and store\n        // the formatted data as an instance variable to be used later by the updateViewPass.\n        // It then invalidates the updateViewPass so that the visualization is updated with the new data.\n        //\n        // In certain cases, a subclass might want to avoid invalidating the updateViewPass.\n        // This can be accomplished by overriding the _shouldUpdateViewOnDataChange method.\n        _formatData: function() {\n            var dataFromAllSources = this.getDataFromAllSources();\n            var combinedData = this.combineData(dataFromAllSources, this.model.config.toJSON());\n            var previousData = this._formattedData;\n            this._formattedData = this.formatData(combinedData, this.model.config.toJSON());\n            if(!_.isEmpty(this._scaleDictionary)){\n                var scaleValues = this.provideScaleValues(this._formattedData, this.model.config.toJSON());\n                _.each(this._scaleDictionary, function (scale, scaleName) {\n                    if (_.contains(_.keys(scaleValues), scaleName)) {\n                        scale.setValues(this, scaleValues[scaleName]);\n                    }\n                    else {\n                        scale.setValues(this, null);\n                    }\n                }, this);\n            }\n            if (this._shouldUpdateViewOnDataChange(this._formattedData, previousData)) {\n                this.invalidate('updateViewPass');\n            }\n        },\n\n        _shouldUpdateViewOnDataChange: function(data, previousData) {\n            return true;\n        },\n\n        // Override to implement as custom data combining routine\n        combineData: function(dataFromAllSources, config) {\n            if (this.getAllDataSources().length > 1) {\n                throw new Error('Implement combineData to support multiple data sources');\n            }\n            return dataFromAllSources.primary || {}; // return primary data by default.\n        },\n\n        // Override to implement as custom data processing routine\n        formatData: function(data, config) {\n            return data;\n        },\n\n        // The updateViewPass takes care of calling the one-time setupView routine,\n        // followed by the updateView routine.\n        //\n        // By default, the updateView routine is assumed to execute synchronously, so upstream consumers\n        // will be notified of the update immediately after it runs.  If a subclass has an\n        // asynchronous updateView routine, it must call the `async` function, which will\n        // return a callback to invoke when the update completes, e.g.:\n        //\n        // updateView: function(data, config, async) {\n        //     var done = async();\n        //     // render some stuff hidden, ready to animate into view\n        //     $renderedStuff.slideDown(500, function() {\n        //         // the rendered stuff has finished animating\n        //         done();\n        //     });\n        // }\n        _updateView: function() {\n            this._setupView();\n            var syncRender = true;\n            var updateError = false;\n\n            var async = function() {\n                syncRender = false;\n                return function() {\n                    if (!updateError) {\n                        this._onViewUpdated();\n                    }\n                    this.stopListening(this, 'error', errorListener);\n                }.bind(this);\n            }.bind(this);\n\n            var errorListener = function() {\n                updateError = true;\n            };\n\n            this.listenTo(this, 'error', errorListener);\n\n            this.updateView(\n                this._formattedData,\n                this.model.config.toJSON(),\n                async\n            );\n            if (syncRender) {\n                if (!updateError) {\n                    this._onViewUpdated();\n                }\n                this.stopListening(this, 'error', errorListener);\n            }\n        },\n\n        getScale: function(name){\n            return this._scaleDictionary[name];\n        },\n\n        getScales: function() {\n            return this._scaleDictionary;\n        },\n\n        _onViewUpdated: function() {\n            this.trigger('rendered');\n        },\n\n        // Override for one-time view setup code\n        setupView: function() {},\n\n        // Override to render something\n        updateView: function(data, config, async) {\n            console.log('Modular component does not override updateView');\n        },\n\n        // Support the existing pattern of creating a view with pre-populated models\n        // and then calling render when it's ready to go into the DOM.\n        render: function() {\n            this.invalidate('formatDataPass');\n            this.invalidate('updateViewPass');\n            return this;\n        },\n\n        // Override to reflow\n        reflow: function() {},\n\n        enqueueInvalidPass: function(pass) {\n            this._pendingPasses.add(pass);\n        },\n\n        getValidateDepth: BaseView.prototype.getReflowDepth,\n\n        // Modify the behavior of activate and deactivate to work with the passes.\n        // The activate method should run any passes that were invalidated while the\n        // view was deactivated.  And the deactivate method should not unbind event\n        // listeners.\n        activate: function() {\n            if (this.active) {\n                return BaseView.prototype.activate.apply(this, arguments);\n            }\n            BaseView.prototype.activate.apply(this, arguments);\n            _(this._pendingPasses.entries()).each(this.invalidate, this);\n            this._pendingPasses.clear();\n            return this;\n        },\n\n        deactivate: function(options) {\n            options = _.extend({}, options, { stopListening: false });\n            return BaseView.prototype.deactivate.call(this, options);\n        },\n\n        wake: function() {\n            return this.activate();\n        },\n\n        sleep: function() {\n            return this.deactivate();\n        },\n\n        // Intercept calls to invalidateReflow and re-map them to invalidation\n        // of the reflow pass.\n        invalidateReflow: function() {\n            this.invalidate('reflowPass');\n        }\n\n    }));\n\n    return SplunkVisualizationBase;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC92aXovQmFzZS5qcz84ZjI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0IsRUFBRTs7QUFFckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLGlDQUFpQyxZQUFZLHVCQUF1QjtBQUNwRTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQyIsImZpbGUiOiJ2aWV3cy9zaGFyZWQvdml6L0Jhc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgY29tbW9uIGJhc2UgY2xhc3MgZm9yIGEgQmFja2JvbmUgVmlldyB0aGF0IHdyYXBzIGEgdmlzdWFsaXphdGlvbi4gIFRoZSB2aXN1YWxpemF0aW9uIGNhbiBiZSBhXG4gKiBtb2Qgdml6IGRlZmluZWQgaW4gYW4gYXBwIG9yIGEgYnVpbHQtaW4gdmlzdWFsaXphdGlvbi5cbiAqXG4gKiBUaGlzIGJhc2UgY2xhc3MgdXNlcyBtYW5hZ2VkIGFzeW5jaHJvbm91cyBwYXNzZXMgdG8gYmF0Y2ggcmVuZGVyaW5nIGFuZCBwcm9jZXNzaW5nIG9wZXJhdGlvbnMuXG4gKiBUbyBpbnRlZ3JhdGUgdGhlc2UgcGFzc2VzIHdpdGggdGhlIHN1cnJvdW5kaW5nIHN5c3RlbSwgdGhpcyBjbGFzcyBjaGFuZ2VzIHRoZSBiZWhhdmlvciBvZlxuICogdGhlIGFjdGl2YXRlL2RlYWN0aXZhdGUvaW52YWxpZGF0ZVJlZmxvdyBtZXRob2RzIHRvIG1ha2UgdGhlbSBcInBhc3MgYXdhcmVcIi4gIE1vcmUgZGV0YWlsc1xuICogaW4gaW5saW5lIGNvbW1lbnRzIGJlbG93LlxuICpcbiAqIFRoZSBnb2FsIG9mIHRoaXMgY2xhc3MgaXMgdG8gcHJvdmlkZSBhIHRpZXJlZCBBUEkuICBBIHNpbXBsZSBzdWJjbGFzcyBjYW4gb25seSBpbXBsZW1lbnRcbiAqIHRoZSB1cGRhdGVWaWV3IG1ldGhvZCBhbmQgZG8gYWxsIGRhdGEgcHJvY2Vzc2luZyBhbmQgcmVuZGVyaW5nIHRoZXJlLiAgT3IgYSBtb3JlIGFkdmFuY2VkXG4gKiBzdWJjbGFzcyBjYW4gYnJlYWsgdGhlc2Ugb3V0IGludG8gZGlzdGluY3QgZGF0YSBwcm9jZXNzIGFuZCByZW5kZXJpbmcgcGFzc2VzLCBhbmQgb3ZlcnJpZGVcbiAqIHRoZSBjaGFuZ2UgaGFuZGxlcnMgdG8gY29udHJvbCB3aGVuIHRob3NlIHBhc3NlcyBhcmUgaW52YWxpZGF0ZWQuXG4gKi9cblxuZGVmaW5lKFtcbiAgICAgICAgICAgICd1bmRlcnNjb3JlJyxcbiAgICAgICAgICAgICdqZy9hc3luYy9NUGFzc1RhcmdldCcsXG4gICAgICAgICAgICAnamcvYXN5bmMvUGFzcycsXG4gICAgICAgICAgICAnamcvQ2xhc3MnLFxuICAgICAgICAgICAgJ2pnL3V0aWxzL1NldCcsXG4gICAgICAgICAgICAndmlld3MvQmFzZScsXG4gICAgICAgICAgICAndXRpbC9jb25zb2xlJyxcbiAgICAgICAgICAgICdoZWxwZXJzL1ByaW50ZXInLFxuICAgICAgICAgICAgJ21peGlucy9EYXRhU291cmNlTWl4aW4nLFxuICAgICAgICAgICAgJ2pxdWVyeS5yZXNpemUnXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uKFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIE1QYXNzVGFyZ2V0LFxuICAgICAgICAgICAgUGFzcyxcbiAgICAgICAgICAgIENsYXNzLFxuICAgICAgICAgICAgU2V0LFxuICAgICAgICAgICAgQmFzZVZpZXcsXG4gICAgICAgICAgICBjb25zb2xlLFxuICAgICAgICAgICAgUHJpbnRlcixcbiAgICAgICAgICAgIERhdGFTb3VyY2VNaXhpbixcbiAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICApIHtcblxuICAgIC8vIERlZmluZSBhIGN1c3RvbSBzdWJjbGFzcyBvZiB0aGUgYnVpbHQtaW4gYXN5bmNocm9ub3VzIHBhc3Mgb2JqZWN0IHRoYXRcbiAgICAvLyBpbnRlZ3JhdGVzIHdpdGggdGhlIGFjdGl2YXRlL2RlYWN0aXZhdGUgbGlmZWN5Y2xlLlxuICAgIHZhciBEZWFjdGl2YXRpbmdQYXNzID0gQ2xhc3MoUGFzcywgZnVuY3Rpb24oRGVhY3RpdmF0aW5nUGFzcywgYmFzZSkge1xuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgb3Igbm90IGl0cyB0YXJnZXQgaXMgYWN0aXZlIHdoZW4gdGhlIHBhc3MgaXMgaW52YWxpZGF0ZWQuXG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgbm90IGFjdGl2ZSwgdGhlIHBhc3MgZG9lcyBub3QgZ28gaW50byB0aGUgcHJvY2Vzc2luZyBxdWV1ZVxuICAgICAgICAvLyBhbmQgaW5zdGVhZCBicm9hZGNhc3RzIGl0c2VsZiB0byB0aGUgdGFyZ2V0IHZpZXcgdG8gYmUgZGVhbHQgd2l0aFxuICAgICAgICAvLyBpZi93aGVuIHRoZSB2aWV3IGlzIGFjdGl2YXRlZCBsYXRlci5cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU3BsdW5rVmlzdWFsaXphdGlvbkJhc2UgJiYgIXRhcmdldC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZW5xdWV1ZUludmFsaWRQYXNzKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2UuaW52YWxpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIElmIGEgcGFzcyBjb21lcyBvdXQgb2YgdGhlIHByb2Nlc3NpbmcgcXVldWUgd2hpbGUgdGhlIHZpZXcgaXMgZGVhY3RpdmF0ZWRcbiAgICAgICAgLy8gKGkuZS4gaXQgd2FzIGludmFsaWRhdGVkIHJpZ2h0IGJlZm9yZSB0aGUgdmlldyB3YXMgZGVhY3RpdmF0ZWQpIGl0IG1hcmtzXG4gICAgICAgIC8vIGl0c2VsZiB2YWxpZCB3aXRob3V0IHJ1bm5pbmcgaXRzIG1ldGhvZCBhbmQgYnJvYWRjYXN0cyBpdHNlbGYgdG8gYmVcbiAgICAgICAgLy8gZGVhbHQgd2l0aCBpZi93aGVuIHRoZSB2aWV3IGlzIGFjdGl2YXRlZCBsYXRlci5cbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNwbHVua1Zpc3VhbGl6YXRpb25CYXNlICYmICF0YXJnZXQuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrVmFsaWQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZW5xdWV1ZUludmFsaWRQYXNzKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2UudmFsaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgIH0pO1xuXG4gICAgdmFyIEZPUk1BVF9EQVRBX1BBU1NfT1JERVIgPSAwLjEsXG4gICAgICAgIFVQREFURV9WSUVXX1BBU1NfT1JERVIgPSBGT1JNQVRfREFUQV9QQVNTX09SREVSICsgMC4xLFxuICAgICAgICBSRUZMT1dfUEFTU19PUkRFUiA9IFVQREFURV9WSUVXX1BBU1NfT1JERVIgKyAwLjE7XG5cbiAgICB2YXIgU3BsdW5rVmlzdWFsaXphdGlvbkJhc2UgPSBCYXNlVmlldy5leHRlbmQoXy5leHRlbmQoe30sIE1QYXNzVGFyZ2V0LCBEYXRhU291cmNlTWl4aW4sIHtcblxuICAgICAgICBmb3JtYXREYXRhUGFzczogbmV3IERlYWN0aXZhdGluZ1Bhc3MoJ19mb3JtYXREYXRhJywgRk9STUFUX0RBVEFfUEFTU19PUkRFUiksXG4gICAgICAgIHVwZGF0ZVZpZXdQYXNzOiBuZXcgRGVhY3RpdmF0aW5nUGFzcygnX3VwZGF0ZVZpZXcnLCBVUERBVEVfVklFV19QQVNTX09SREVSKSxcbiAgICAgICAgcmVmbG93UGFzczogbmV3IERlYWN0aXZhdGluZ1Bhc3MoJ3JlZmxvdycsIFJFRkxPV19QQVNTX09SREVSKSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEJhc2VWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwuY29uZmlnLCAnY2hhbmdlJywgZnVuY3Rpb24oY29uZmlnTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29uZmlnQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICBjb25maWdNb2RlbC5jaGFuZ2VkQXR0cmlidXRlcygpLFxuICAgICAgICAgICAgICAgICAgICBjb25maWdNb2RlbC5wcmV2aW91c0F0dHJpYnV0ZXMoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuJGVsLm9uKCdlbGVtZW50UmVzaXplJywgdGhpcy5vbkNvbnRhaW5lclNpemVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKFByaW50ZXIsIFByaW50ZXIuUFJJTlRfU1RBUlQsIHRoaXMub25QcmludFN0YXJ0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhQcmludGVyLCBQcmludGVyLlBSSU5UX0VORCwgdGhpcy5vblByaW50RW5kLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Bhc3NlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlZERhdGEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBWaWV3ID0gXy5vbmNlKGZ1bmN0aW9uKCkgeyB0aGlzLnNldHVwVmlldygpOyB9KTtcblxuICAgICAgICAgICAgLy8gTm8gc2NhbGUgYnkgZGVmYXVsdFxuICAgICAgICAgICAgdGhpcy5fc2NhbGVEaWN0aW9uYXJ5ID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZXMgPSB0aGlzLm9wdGlvbnMuZGF0YVNvdXJjZXMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnNldHVwRGF0YVNvdXJjZXMoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXR1cERhdGFTb3VyY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF8odGhpcy5nZXRSZXF1aXJlZERhdGFTb3VyY2VzKCkpLmVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldERhdGFTb3VyY2UobmFtZSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTb3VyY2UgJyArIG5hbWUgKyAnIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAvLyBzZXR1cCBzZWFyY2ggcmVzdWx0IGNoYW5nZSBsaXN0ZW5lciBmb3IgZWFjaCBkYXRhIHNvdXJjZS5cbiAgICAgICAgICAgIF8odGhpcy5nZXRBbGxEYXRhU291cmNlcygpKS5lYWNoKGZ1bmN0aW9uKGRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhkcywgJ3NlYXJjaFJlc3VsdHNDaGFuZ2UnLCB0aGlzLm9uRGF0YUNoYW5nZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRSZXF1aXJlZERhdGFTb3VyY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3ByaW1hcnknXTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRTY2FsZURpY3Rpb25hcnk6IGZ1bmN0aW9uKHNjYWxlRGljdGlvbmFyeSkge1xuICAgICAgICAgICAgaWYgKCFzY2FsZURpY3Rpb25hcnkpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLl9zY2FsZURpY3Rpb25hcnksIGZ1bmN0aW9uKHNjYWxlKXtcbiAgICAgICAgICAgICAgICBzY2FsZS51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIHNjYWxlLm9mZignY2hhbmdlJywgdGhpcy5fc2NhbGVDaGFuZ2UsIHRoaXMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZURpY3Rpb25hcnkgPSBzY2FsZURpY3Rpb25hcnk7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5fc2NhbGVEaWN0aW9uYXJ5LCBmdW5jdGlvbihzY2FsZSl7XG4gICAgICAgICAgICAgICAgc2NhbGUucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgc2NhbGUub24oJ2NoYW5nZScsIHRoaXMuX3NjYWxlQ2hhbmdlLCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zY2FsZUNoYW5nZTogZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGUoJ3VwZGF0ZVZpZXdQYXNzJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTm90aGluZyBieSBkZWZhdWx0XG4gICAgICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRvIGFkZCBzY2FsZSB2YWx1ZXNcbiAgICAgICAgcHJvdmlkZVNjYWxlVmFsdWVzOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5fc2NhbGVEaWN0aW9uYXJ5LCBmdW5jdGlvbihzY2FsZSl7XG4gICAgICAgICAgICAgICAgc2NhbGUub2ZmKCdjaGFuZ2UnLCB0aGlzLl9zY2FsZUNoYW5nZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgc2NhbGUudW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5tYXJrVmFsaWQoKTtcbiAgICAgICAgICAgIHRoaXMuJGVsLm9mZignZWxlbWVudFJlc2l6ZScpO1xuICAgICAgICAgICAgcmV0dXJuIEJhc2VWaWV3LnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREYXRhRnJvbUFsbFNvdXJjZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmdldEFsbERhdGFTb3VyY2VzKCksIGZ1bmN0aW9uKGRzKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtkcy5uYW1lXSA9IGRzLmdldFNlYXJjaFJlc3VsdHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EYXRhQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgnZm9ybWF0RGF0YVBhc3MnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBCeSBkZWZhdWx0LCBhbnkgY29uZmlnIGNoYW5nZSBpbnZhbGlkYXRlcyB0aGUgZm9ybWF0RGF0YVBhc3MuXG4gICAgICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBtb3JlIGZpbmUtZ3JhaW5lZCBjb250cm9sLCBtYWtpbmcgdXNlIG9mIHRoZVxuICAgICAgICAvLyBnaXZlbiBjaGFuZ2VkIGFuZCBwcmV2aW91cyBhdHRyaWJ1dGVzIHRvIGRldGVybWluZSB0aGUgbW9zdCBlZmZpY2llbnQgd2F5IHRvIGhhbmRsZSB0aGUgY2hhbmdlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBGb3IgZXhhbXBsZSwgaXQncyBjb21tb24gZm9yIGNlcnRhaW4gY29uZmlnIGF0dHJpYnV0ZXMgdG8gaGF2ZSBubyBlZmZlY3Qgb24gdGhlIGZvcm1hdERhdGFQYXNzLFxuICAgICAgICAvLyBzbyBhIHN1YmNsYXNzIGNvdWxkIGF2b2lkIG5lZWRsZXNzIHdvcmsgYnkgaW52YWxpZGF0aW5nIHRoZSB1cGRhdGVWaWV3UGFzcyBpbnN0ZWFkLlxuICAgICAgICBvbkNvbmZpZ0NoYW5nZTogZnVuY3Rpb24oY2hhbmdlZEF0dHJpYnV0ZXMsIHByZXZpb3VzQXR0cmlidXRlcykge1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCdmb3JtYXREYXRhUGFzcycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ29udGFpbmVyU2l6ZUNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGUoJ3JlZmxvd1Bhc3MnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblByaW50U3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCdyZWZsb3dQYXNzJyk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25QcmludEVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGUoJ3JlZmxvd1Bhc3MnKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVycmlkZSB0byBjb25maWd1cmUgc3ViY2xhc3MgcHJvcGVydGllcyBiYXNlZCBvbiBkaXNwbGF5IG1vZGVcbiAgICAgICAgc2V0RGlzcGxheU1vZGU6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAgICAgLy8gVGhlIGZvcm1hdERhdGFQYXNzIHdpbGwgY2FsbCB0aGUgc3ViY2xhc3Mtc3BlY2lmaWMgY29tYmluZURhdGEgYW5kIGZvcm1hdERhdGEgcm91dGluZSBhbmQgc3RvcmVcbiAgICAgICAgLy8gdGhlIGZvcm1hdHRlZCBkYXRhIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIHRvIGJlIHVzZWQgbGF0ZXIgYnkgdGhlIHVwZGF0ZVZpZXdQYXNzLlxuICAgICAgICAvLyBJdCB0aGVuIGludmFsaWRhdGVzIHRoZSB1cGRhdGVWaWV3UGFzcyBzbyB0aGF0IHRoZSB2aXN1YWxpemF0aW9uIGlzIHVwZGF0ZWQgd2l0aCB0aGUgbmV3IGRhdGEuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIGNlcnRhaW4gY2FzZXMsIGEgc3ViY2xhc3MgbWlnaHQgd2FudCB0byBhdm9pZCBpbnZhbGlkYXRpbmcgdGhlIHVwZGF0ZVZpZXdQYXNzLlxuICAgICAgICAvLyBUaGlzIGNhbiBiZSBhY2NvbXBsaXNoZWQgYnkgb3ZlcnJpZGluZyB0aGUgX3Nob3VsZFVwZGF0ZVZpZXdPbkRhdGFDaGFuZ2UgbWV0aG9kLlxuICAgICAgICBfZm9ybWF0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUZyb21BbGxTb3VyY2VzID0gdGhpcy5nZXREYXRhRnJvbUFsbFNvdXJjZXMoKTtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZERhdGEgPSB0aGlzLmNvbWJpbmVEYXRhKGRhdGFGcm9tQWxsU291cmNlcywgdGhpcy5tb2RlbC5jb25maWcudG9KU09OKCkpO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzRGF0YSA9IHRoaXMuX2Zvcm1hdHRlZERhdGE7XG4gICAgICAgICAgICB0aGlzLl9mb3JtYXR0ZWREYXRhID0gdGhpcy5mb3JtYXREYXRhKGNvbWJpbmVkRGF0YSwgdGhpcy5tb2RlbC5jb25maWcudG9KU09OKCkpO1xuICAgICAgICAgICAgaWYoIV8uaXNFbXB0eSh0aGlzLl9zY2FsZURpY3Rpb25hcnkpKXtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVWYWx1ZXMgPSB0aGlzLnByb3ZpZGVTY2FsZVZhbHVlcyh0aGlzLl9mb3JtYXR0ZWREYXRhLCB0aGlzLm1vZGVsLmNvbmZpZy50b0pTT04oKSk7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHRoaXMuX3NjYWxlRGljdGlvbmFyeSwgZnVuY3Rpb24gKHNjYWxlLCBzY2FsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uY29udGFpbnMoXy5rZXlzKHNjYWxlVmFsdWVzKSwgc2NhbGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUuc2V0VmFsdWVzKHRoaXMsIHNjYWxlVmFsdWVzW3NjYWxlTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUuc2V0VmFsdWVzKHRoaXMsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkVXBkYXRlVmlld09uRGF0YUNoYW5nZSh0aGlzLl9mb3JtYXR0ZWREYXRhLCBwcmV2aW91c0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCd1cGRhdGVWaWV3UGFzcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG91bGRVcGRhdGVWaWV3T25EYXRhQ2hhbmdlOiBmdW5jdGlvbihkYXRhLCBwcmV2aW91c0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJyaWRlIHRvIGltcGxlbWVudCBhcyBjdXN0b20gZGF0YSBjb21iaW5pbmcgcm91dGluZVxuICAgICAgICBjb21iaW5lRGF0YTogZnVuY3Rpb24oZGF0YUZyb21BbGxTb3VyY2VzLCBjb25maWcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEFsbERhdGFTb3VyY2VzKCkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1wbGVtZW50IGNvbWJpbmVEYXRhIHRvIHN1cHBvcnQgbXVsdGlwbGUgZGF0YSBzb3VyY2VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YUZyb21BbGxTb3VyY2VzLnByaW1hcnkgfHwge307IC8vIHJldHVybiBwcmltYXJ5IGRhdGEgYnkgZGVmYXVsdC5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVycmlkZSB0byBpbXBsZW1lbnQgYXMgY3VzdG9tIGRhdGEgcHJvY2Vzc2luZyByb3V0aW5lXG4gICAgICAgIGZvcm1hdERhdGE6IGZ1bmN0aW9uKGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZVZpZXdQYXNzIHRha2VzIGNhcmUgb2YgY2FsbGluZyB0aGUgb25lLXRpbWUgc2V0dXBWaWV3IHJvdXRpbmUsXG4gICAgICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSB1cGRhdGVWaWV3IHJvdXRpbmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSB1cGRhdGVWaWV3IHJvdXRpbmUgaXMgYXNzdW1lZCB0byBleGVjdXRlIHN5bmNocm9ub3VzbHksIHNvIHVwc3RyZWFtIGNvbnN1bWVyc1xuICAgICAgICAvLyB3aWxsIGJlIG5vdGlmaWVkIG9mIHRoZSB1cGRhdGUgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgcnVucy4gIElmIGEgc3ViY2xhc3MgaGFzIGFuXG4gICAgICAgIC8vIGFzeW5jaHJvbm91cyB1cGRhdGVWaWV3IHJvdXRpbmUsIGl0IG11c3QgY2FsbCB0aGUgYGFzeW5jYCBmdW5jdGlvbiwgd2hpY2ggd2lsbFxuICAgICAgICAvLyByZXR1cm4gYSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGUgdXBkYXRlIGNvbXBsZXRlcywgZS5nLjpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdXBkYXRlVmlldzogZnVuY3Rpb24oZGF0YSwgY29uZmlnLCBhc3luYykge1xuICAgICAgICAvLyAgICAgdmFyIGRvbmUgPSBhc3luYygpO1xuICAgICAgICAvLyAgICAgLy8gcmVuZGVyIHNvbWUgc3R1ZmYgaGlkZGVuLCByZWFkeSB0byBhbmltYXRlIGludG8gdmlld1xuICAgICAgICAvLyAgICAgJHJlbmRlcmVkU3R1ZmYuc2xpZGVEb3duKDUwMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICAgICAgLy8gdGhlIHJlbmRlcmVkIHN0dWZmIGhhcyBmaW5pc2hlZCBhbmltYXRpbmdcbiAgICAgICAgLy8gICAgICAgICBkb25lKCk7XG4gICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgLy8gfVxuICAgICAgICBfdXBkYXRlVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cFZpZXcoKTtcbiAgICAgICAgICAgIHZhciBzeW5jUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVFcnJvciA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgYXN5bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzeW5jUmVuZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblZpZXdVcGRhdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKHRoaXMsICdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMsICdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9ybWF0dGVkRGF0YSxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZy50b0pTT04oKSxcbiAgICAgICAgICAgICAgICBhc3luY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChzeW5jUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblZpZXdVcGRhdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcExpc3RlbmluZyh0aGlzLCAnZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTY2FsZTogZnVuY3Rpb24obmFtZSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVEaWN0aW9uYXJ5W25hbWVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNjYWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVEaWN0aW9uYXJ5O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vblZpZXdVcGRhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncmVuZGVyZWQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVycmlkZSBmb3Igb25lLXRpbWUgdmlldyBzZXR1cCBjb2RlXG4gICAgICAgIHNldHVwVmlldzogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAvLyBPdmVycmlkZSB0byByZW5kZXIgc29tZXRoaW5nXG4gICAgICAgIHVwZGF0ZVZpZXc6IGZ1bmN0aW9uKGRhdGEsIGNvbmZpZywgYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNb2R1bGFyIGNvbXBvbmVudCBkb2VzIG5vdCBvdmVycmlkZSB1cGRhdGVWaWV3Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU3VwcG9ydCB0aGUgZXhpc3RpbmcgcGF0dGVybiBvZiBjcmVhdGluZyBhIHZpZXcgd2l0aCBwcmUtcG9wdWxhdGVkIG1vZGVsc1xuICAgICAgICAvLyBhbmQgdGhlbiBjYWxsaW5nIHJlbmRlciB3aGVuIGl0J3MgcmVhZHkgdG8gZ28gaW50byB0aGUgRE9NLlxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCdmb3JtYXREYXRhUGFzcycpO1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCd1cGRhdGVWaWV3UGFzcycpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgdG8gcmVmbG93XG4gICAgICAgIHJlZmxvdzogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICBlbnF1ZXVlSW52YWxpZFBhc3M6IGZ1bmN0aW9uKHBhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdQYXNzZXMuYWRkKHBhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFZhbGlkYXRlRGVwdGg6IEJhc2VWaWV3LnByb3RvdHlwZS5nZXRSZWZsb3dEZXB0aCxcblxuICAgICAgICAvLyBNb2RpZnkgdGhlIGJlaGF2aW9yIG9mIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIHRvIHdvcmsgd2l0aCB0aGUgcGFzc2VzLlxuICAgICAgICAvLyBUaGUgYWN0aXZhdGUgbWV0aG9kIHNob3VsZCBydW4gYW55IHBhc3NlcyB0aGF0IHdlcmUgaW52YWxpZGF0ZWQgd2hpbGUgdGhlXG4gICAgICAgIC8vIHZpZXcgd2FzIGRlYWN0aXZhdGVkLiAgQW5kIHRoZSBkZWFjdGl2YXRlIG1ldGhvZCBzaG91bGQgbm90IHVuYmluZCBldmVudFxuICAgICAgICAvLyBsaXN0ZW5lcnMuXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCYXNlVmlldy5wcm90b3R5cGUuYWN0aXZhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEJhc2VWaWV3LnByb3RvdHlwZS5hY3RpdmF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgXyh0aGlzLl9wZW5kaW5nUGFzc2VzLmVudHJpZXMoKSkuZWFjaCh0aGlzLmludmFsaWRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Bhc3Nlcy5jbGVhcigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVhY3RpdmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7IHN0b3BMaXN0ZW5pbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEJhc2VWaWV3LnByb3RvdHlwZS5kZWFjdGl2YXRlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2FrZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNsZWVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJbnRlcmNlcHQgY2FsbHMgdG8gaW52YWxpZGF0ZVJlZmxvdyBhbmQgcmUtbWFwIHRoZW0gdG8gaW52YWxpZGF0aW9uXG4gICAgICAgIC8vIG9mIHRoZSByZWZsb3cgcGFzcy5cbiAgICAgICAgaW52YWxpZGF0ZVJlZmxvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGUoJ3JlZmxvd1Bhc3MnKTtcbiAgICAgICAgfVxuXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIFNwbHVua1Zpc3VhbGl6YXRpb25CYXNlO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvdmlld3Mvc2hhcmVkL3Zpei9CYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSB2aWV3cy9zaGFyZWQvdml6L0Jhc2Vcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "views/Base":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(\"shim/jquery\"),\n    __webpack_require__(\"require/backbone\"),\n    __webpack_require__(\"require/underscore\"),\n    __webpack_require__(\"mixins/viewlogging\"),\n    __webpack_require__(\"util/console\"),\n    __webpack_require__(\"global/GlobalReflowQueue\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n    $,\n    Backbone,\n    _,\n    viewloggingmixin,\n    console,\n    GlobalReflowQueue\n){\n    /**\n     * @namespace views\n     */\n    /**\n     * @constructor\n     * @memberOf views\n     * @name Base\n     * @description A collection of Backbone.View utilities and conventions to assist with template\n     * compilation and cacheing, noop nested views and className naming conventions. The general\n     * rule of thumb is to not override native Backbone.View methods but to complement the core API\n     * with simple and useful patterns.\n     * @extends {Backbone.View}\n     * @mixes viewlogging\n     *\n     * @param {Object} options\n     * @param {String} [options.moduleId] An id (commonly the requirejs module.id) that is formatted\n     * and appended as a className to the root view el. Added as an instance member if passed in via\n     * the constructor.\n     *\n     * @param {String} [options.template] An _.template that is passed through the compileTemplate\n     * method. Added as an instance member if passed including an additional compiledTemplate\n     * instance member (see compileTemplate for specification).\n     */\n    var BaseView = Backbone.View.extend(/** @lends views.Base.prototype */{\n        awake: true,\n        touch: false,\n        active: false,\n        isReflowValid: true,\n\n        constructor: function(options) {\n            this.options = options || {};\n            this.children = {};\n\n            if (this.options.moduleId) {\n                this.moduleId = this.options.moduleId;\n            }\n            if (this.options.template) {\n                this.template = this.options.template;\n            }\n            if (this.template) {\n                this.compiledTemplate = this.compileTemplate(this.template);\n            }\n\n            if (this.css && Object.keys(this.css) && !this.className) {\n                this.options.dontAddModuleIdAsClass = true;\n            }\n            // Clone css to allow local overrides.\n            if (this.css) {\n                this.css = _.clone(this.css);\n            }\n\n            Backbone.View.apply(this, arguments);\n        },\n        initialize: function() {\n            var render = this.render;\n            this.render = _.bind(function() {\n                var start = (new Date()).getTime(),\n                    end;\n                if (this.awake) {\n                    render.apply(this, arguments);\n                } else {\n                    this.touch = true;\n                }\n                end = (new Date()).getTime();\n                if(this.options.instrument !== false) {\n                    this.$el.attr('data-render-time', (end - start)/1000);\n                }\n                return this;\n            }, this);\n\n            this.$el.attr('data-cid', this.cid);\n            if (this.moduleId) {\n                var className = this.cssNamespace();\n\n                if (!this.options.dontAddModuleIdAsClass) {\n                    this.$el.addClass(className);\n                }\n                this.$el.attr('data-view', this.moduleId);\n            }\n\n            // Add view class automatically\n            if (this.css && this.css.view) {\n                this.$el.addClass(this.css.view);\n            }\n        },\n\n        /**\n         * Calls the method named by methodName on each child of the view.\n         * @param {Function} method\n         * @param {...Any} [args] Any extra arguments will be passed to method on invocation\n         */\n        invokeOnChildren: function(method) {\n            if (!_.isString(method)) {\n                throw new Error('Your method must be a string');\n            }\n            var argsForMethod = Array.prototype.slice.call(arguments, 1);\n\n            _.each(this.children, function(child) {\n                if (_.isArray(child)) {\n                    _.each(child, function(view) {\n                        if (_.isFunction(view[method])) {\n                            view[method].apply(view, argsForMethod);\n                        }\n                    });\n                } else {\n                    if (child && _.isFunction(child[method])) {\n                        child[method].apply(child, argsForMethod);\n                    }\n                }\n            });\n        },\n\n        /**\n         * Iterates over the children of this view, yielding each in turn to an iterator function.\n         * @param {Function} iterator Each invocation of iterator is called with one argument:\n         * (child).\n         * @param {Any} [context] The iterator is bound to the context object, if one is passed.\n         */\n        eachChild: function(iterator, context) {\n            if (!_.isFunction(iterator)) {\n                throw new Error('Your iterator must be a function');\n            }\n\n            _.each(this.children, function(child){\n                if (_.isArray(child)) {\n                    _.each(child, function(view){\n                        if (!_.isNull(view)) {\n                            iterator.call(context, view);\n                        }\n                    });\n                } else if (!_.isNull(child)) {\n                    iterator.call(context, child);\n                }\n            });\n        },\n\n        /**\n         * Replaces render noop proxy to original render routine. Additionally traverses\n         * a special children attribute that consists of an object collection of views and\n         * calls wake if that method exists.\n         *\n         * @param {Object} options\n         *      @param {Boolean} [options.syncRender] Call the standard (sync) render method over\n         *      async (debouncedRender) variant.\n         *\n         */\n        wake: function(options) {\n            options || (options = {});\n            this.awake = true;\n            if (this.touch) {\n                this.touch = false;\n                if (options.syncRender) {\n                    this.render();\n                } else {\n                    this.debouncedRender();\n                }\n            }\n            this.invokeOnChildren('wake', options);\n            return this;\n        },\n        /**\n         * Stops any subsequent calls to render and proxies them to a noop routine. Additionally\n         * traverses a special children attribute that consists of an object collection of views and\n         * calls sleep if that method exists.\n         */\n        sleep: function() {\n            this.awake = false;\n            this.invokeOnChildren('sleep');\n            return this;\n        },\n\n        /**\n         * Postpone the execution of render until after the input has stopped arriving. Useful for\n         * assigning to model/collection change event listeners that should only happen after the\n         * input has stopped arriving.\n         */\n        debouncedRender: function() {\n            if (!this._debouncedRender) {\n                this._debouncedRender = _.debounce(this.render, 0);\n            }\n            this._debouncedRender.apply(this, arguments);\n        },\n\n        /**\n         * Compiles and memoizes an [_.template]{@link http://underscorejs.org/#template} string\n         * into a function that can be evaulated for rendering.\n         *\n         * @param {String} templateStr An _.template string for compilation into a function.\n         * @return {Function} A function that can be evaluated for rendering, pass in a data object\n         * that that has properties corresponding to the template's free variables.\n         * @function\n         */\n        compileTemplate: _.memoize(function(templateStr) {\n            return _.template(templateStr);\n        }),\n        /**\n         * Tailored for the requirejs module.id format converting into a safe and legal css\n         * class attribute. For example the following module id '/views/shared/SkidRow'\n         * would be converted to 'views-shared-skdrow'.\n         */\n        cssNamespace: function() {\n            return (this.moduleId || '').toLowerCase()\n                .replace(/\\//g, '-')\n                .replace(/\\_/g, '')\n                .replace(/^views-/, '')\n                .replace(/-master$/, '');\n        },\n        /**\n         * Generates a unique namespace that can be humanly cross-referenced to the view.\n         */\n        uniqueNS: function() {\n            return (this.moduleId || 'unidentified').toLowerCase().replace(/\\//g, '-') + '-' + this.cid;\n        },\n\n        /**\n         * Subscribe listeners.\n         * implement as necessary\n         */\n        startListening: function() {\n        },\n\n        stopListening: function() {\n            if(arguments.length === 0) {\n                this.modelsOff(this.model);\n                this.collectionsOff(this.collection);\n            }\n            Backbone.View.prototype.stopListening.apply(this, arguments);\n        },\n\n        remove: function() {\n            this.removeChildren();\n            if (this._isAddedToDocument) {\n                this.onRemovedFromDocument();\n                this._isAddedToDocument = false;\n            }\n            this.stopListening();\n            this.$el.remove();\n            GlobalReflowQueue.remove(this);\n            return this;\n        },\n\n        debouncedRemove: function(options) {\n            options || (options = {});\n            var defaults = {\n                detach: false\n            };\n            _.defaults(options, defaults);\n            if (options.detach) {\n                this.$el.detach();\n            }\n            if (!this._debouncedRemove) {\n                this._debouncedRemove = _.debounce(this.remove, 0);\n            }\n            this._debouncedRemove.apply(this, arguments);\n            return this;\n        },\n\n        removeChildren: function() {\n            this.invokeOnChildren('remove');\n        },\n\n        ensureDeactivated: function(options) {\n            if (this.active) {\n                this.deactivate(options);\n            }\n        },\n\n        activate: function(options) {\n            options || (options = {});\n            // the options for startListening and trigger are always shallow\n            var clonedOptions = _.extend({startListening: true, trigger: true}, options);\n            delete options.startListening;\n            delete options.trigger;\n            if (!this.active && clonedOptions.startListening) {\n                this.startListening();\n            }\n            if (this.active) {\n                console.debug(\"Calling activate again on view:\" + this.moduleId, this.cid);\n            } else {\n                this.active = true;\n                if (clonedOptions.trigger) {\n                    this.trigger(\"activated\");\n                }\n            }\n            //children get activated after the parent\n            if (options.deep) {\n                this.invokeOnChildren('activate', options);\n            }\n            return this;\n        },\n\n        deactivate: function(options) {\n            options || (options = {});\n            // the options for stopListening and trigger are always shallow\n            var clonedOptions = _.extend({stopListening: true, trigger: true}, options);\n            delete options.stopListening;\n            delete options.trigger;\n            //children get deactivated before the parent\n            if (options.deep) {\n                this.invokeOnChildren('deactivate', options);\n            }\n            if (this.active && clonedOptions.stopListening) {\n                this.stopListening();\n            }\n            if (!this.active) {\n                console.debug(\"Calling deactivate again on view:\" + this.moduleId, this.cid);\n            } else {\n                this.active = false;\n                if (clonedOptions.trigger) {\n                    this.trigger(\"deactivated\");\n                }\n            }\n            return this;\n        },\n\n        /**\n         *  Helper function for deepDestroy, recursively calls off() on its model(s)\n         */\n        modelsOff: function (model) {\n            if (model instanceof Backbone.Model) {\n                _.isFunction(model.associatedOff) && model.associatedOff(null, null, this);\n                model.off(null, null, this);\n            } else if (_.isArray(model) || $.isPlainObject(model)) { // SPL-90156\n                _(model).each(function(mod) {\n                    this.modelsOff(mod);\n                }, this);\n            } else if (model instanceof Backbone.Collection) { // TODO: revisit this logic after Dash release\n                console.warn(\"Warning: trying to call modelsOff() on a Backbone.Collection object, please move it to this.collection instead.\");\n                this.collectionsOff(model);\n            } else if (model != null) {\n                console.warn('Warning: trying to call modelsOff() on non-Backbone.Model object! Maybe move it to this.options?');\n            }\n            return this;\n        },\n        /**\n         *  Helper function for deepDestroy, recursively calls off() on its collections(s)\n         */\n         collectionsOff: function(collection) {\n            if (collection instanceof Backbone.Collection) {\n                collection.off(null, null, this);\n            } else if (_.isArray(collection) || $.isPlainObject(collection)) {\n                _(collection).each(function(coll) {\n                    this.collectionsOff(coll);\n                }, this);\n            } else if (collection instanceof Backbone.Model) { // TODO: revisit this logic after Dash release\n                console.warn(\"Warning: trying to call collectionsOff() on a Backbone.Model object, pleaes move it to this.model instead.\");\n                this.modelsOff(collection);\n            } else if (collection != null) {\n                console.warn('Warning: trying to call collectionsOff() on non-Backbone.Collection object! Maybe move it to this.options?');\n            }\n            return this;\n        },\n\n        /**\n         * Helper function for removing the view from the DOM while a render occurs. If you call this on subviews in\n         * a render function, jQuery will remove all of the subview's event listeners\n         */\n        detach: function() {\n            if (this._isAddedToDocument) {\n                this.onRemovedFromDocument();\n                this._isAddedToDocument = false;\n            }\n            this.$el.detach();\n        },\n\n        // add instance methods for all commonly used jQuery attachment methods\n        //replaceContentsOf is the analog of $.html($container)\n        replaceContentsOf: function($container) {\n            if(_.isString($container)) {\n                throw new Error('replaceContentsOf does not support selectors or HTML strings');\n            }\n\n            // ensure the given $container parameter is a jQuery object\n            $container = $($container);\n            $container.empty();\n            return this.attachToDocument($container, 'appendTo');\n        },\n        appendTo: function($container) { return this.attachToDocument($container, 'appendTo'); },\n        prependTo: function($container) { return this.attachToDocument($container, 'prependTo'); },\n        replaceAll: function($container) { return this.attachToDocument($container, 'replaceAll'); },\n        insertAfter: function($container) { return this.attachToDocument($container, 'insertAfter'); },\n        insertBefore: function($container) { return this.attachToDocument($container, 'insertBefore'); },\n\n        /**\n         * Attach the view to the given DOM element using the given method.\n         * If afterward the view is attached to the document element, the onAddedToDocument method will be called.\n         * If the view was already attached to the document element, and the given DOM element is different than\n         * the view's current parent element, the onRemovedFromDocument method will be called first.\n         *\n         * Not meant to be called directly, only as a helper for the more specific attachment methods above.\n         *\n         * @param {DOM|jQuery} $container The target element\n         * @param {String} attachmentMethod a valid jQuery DOM attachment method name\n         */\n        attachToDocument: function($container, attachmentMethod) {\n            if(_.isString($container)) {\n                throw new Error(attachmentMethod + ' does not support selectors or HTML strings');\n            }\n\n            // ensure the given $container parameter is a jQuery object\n            $container = $($container);\n\n            // if no container, abort\n            if ($container.length === 0) {\n                return this;\n            }\n\n            // get the raw DOM container\n            var container = $container[0];\n\n            // call onRemovedFromDocument if needed\n            var oldParent = this.el.parentNode;\n            if (oldParent && (oldParent !== container)) {\n                if (this._isAddedToDocument) {\n                    this.onRemovedFromDocument();\n                    this._isAddedToDocument = false;\n                }\n            }\n\n            // do the attachment\n            this.$el[attachmentMethod]($container);\n\n            // call onAddedToDocument if needed\n            if (oldParent !== container) {\n                if ($.contains(document.documentElement, this.el)) {\n                    this._isAddedToDocument = true;\n                    this.onAddedToDocument();\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Called when this view is added to the document. Recursively calls\n         * onAddedToDocument on all child views. Override this method with custom code\n         * that should be run when this view is added to the document. Make sure to call\n         * the base implementation when overriding.\n         *\n         * This method is automatically called and should not be called directly.\n         */\n        onAddedToDocument: function() {\n            this.invalidateReflow();\n            this.eachChild(function(child) {\n                if (_.isFunction(child.onAddedToDocument) && this.isAncestorOf(child) && !child._isAddedToDocument) {\n                    child._isAddedToDocument = true;\n                    child.onAddedToDocument();\n                }\n            }, this);\n            this.trigger('addedToDocument');\n        },\n\n        /**\n         * Called when this view is removed from the document. Recursively calls\n         * onRemovedFromDocument on all child views. Override this method with custom\n         * code that should be run when this view is removed from the document. Make\n         * sure to call the base implementation when overriding.\n         *\n         * This method is automatically called and should not be called directly.\n         */\n        onRemovedFromDocument: function() {\n            this.isReflowValid = true;\n            GlobalReflowQueue.remove(this);\n            this.eachChild(function(child) {\n                if (_.isFunction(child.onRemovedFromDocument) && this.isAncestorOf(child) && child._isAddedToDocument) {\n                    child.onRemovedFromDocument();\n                    child._isAddedToDocument = false;\n                }\n            }, this);\n            this.trigger('removedFromDocument');\n        },\n\n        /**\n         * Returns a boolean indicating whether the view is currently attached to the document element\n         */\n        isAddedToDocument: function() {\n            return this._isAddedToDocument;\n        },\n\n        /**\n         * Returns true if this view is an ancestor of the given view; false otherwise;\n         *\n         * @param {Backbone.View} descendant A Backbone.View instance to test against.\n         */\n        isAncestorOf: function(descendant) {\n            return descendant.el ? $.contains(this.el, descendant.el) : false;\n        },\n\n        /**\n         * Returns true if this view is a descendant of the given view; false otherwise;\n         *\n         * @param {Backbone.View} ancestor A Backbone.View instance to test against.\n         */\n        isDescendantOf: function(ancestor) {\n            return ancestor.el ? $.contains(ancestor.el, this.el) : false;\n        },\n\n        /**\n         * Instruct the view to re-flow itself in its current container.\n         *\n         * Override this method to do any work that is required when the view needs to adjust to its container size.\n         */\n        reflow: function() {\n        },\n\n        /**\n         * Helper function that returns the paths of ancestor Backbone views. The algorithm\n         * traverses the DOM up the parent chain and the data-view attribute of each DOM element\n         * with a data-view attribute. The data-view attribute is added to the DOM tree root of\n         * each views/Base.\n         *\n         * The array is sorted starting with the top-most DOM element's data-view string\n         *\n         * This function will only return the full ancestor list once it has been added to a DOM\n         *\n         * @param depth {Number} specifies the maximum number of ancestors to return\n         * @return {Array}\n         */\n        getAncestors: function(depth) {\n            var results = [];\n            var parent = this.$el;\n\n            while (true) {\n                parent = parent.parent();\n\n                if (parent.length > 0) {\n                    var dataView = parent.attr(\"data-view\");\n                    if (!_(dataView).isUndefined() && !_(dataView).isEmpty())\n                        results.unshift(dataView);\n                } else {\n                    break;\n                }\n\n                if (!_(depth).isUndefined() && depth == results.length)\n                    break;\n            }\n\n            return results;\n        },\n\n        invalidateReflow: function() {\n            if (this.isReflowValid) {\n                this.isReflowValid = false;\n                GlobalReflowQueue.add(this);\n            }\n        },\n\n        validateReflow: function(force) {\n            if (!this.isReflowValid || force) {\n                this.reflow();\n                this.isReflowValid = true;\n                GlobalReflowQueue.remove(this);\n            }\n            this.invokeOnChildren('validateReflow');\n        },\n\n        getReflowDepth: function() {\n            var depth = 0;\n            for (var parentNode = this.el.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                depth++;\n            }\n            return depth;\n        }\n    });\n\n    _.extend(BaseView.prototype, viewloggingmixin);\n\n    return BaseView;\n\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL0Jhc2UuanM/MGZkMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsaURBQWlELHdDQUF3QztBQUN6RjtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsMENBQTBDLG9DQUFvQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSwwQ0FBMEMsbUNBQW1DO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdURBQXVEO0FBQ3BFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxpREFBaUQ7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxpREFBaUQ7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDLHNEQUFzRCxFQUFFO0FBQ2hHLHlDQUF5Qyx1REFBdUQsRUFBRTtBQUNsRywwQ0FBMEMsd0RBQXdELEVBQUU7QUFDcEcsMkNBQTJDLHlEQUF5RCxFQUFFO0FBQ3RHLDRDQUE0QywwREFBMEQsRUFBRTs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoidmlld3MvQmFzZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXG4gICAgJ2pxdWVyeScsXG4gICAgJ2JhY2tib25lJyxcbiAgICAndW5kZXJzY29yZScsXG4gICAgJ21peGlucy92aWV3bG9nZ2luZycsXG4gICAgJ3V0aWwvY29uc29sZScsXG4gICAgJ2dsb2JhbC9HbG9iYWxSZWZsb3dRdWV1ZSdcbl0sXG5mdW5jdGlvbihcbiAgICAkLFxuICAgIEJhY2tib25lLFxuICAgIF8sXG4gICAgdmlld2xvZ2dpbmdtaXhpbixcbiAgICBjb25zb2xlLFxuICAgIEdsb2JhbFJlZmxvd1F1ZXVlXG4pe1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2Ugdmlld3NcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2Ygdmlld3NcbiAgICAgKiBAbmFtZSBCYXNlXG4gICAgICogQGRlc2NyaXB0aW9uIEEgY29sbGVjdGlvbiBvZiBCYWNrYm9uZS5WaWV3IHV0aWxpdGllcyBhbmQgY29udmVudGlvbnMgdG8gYXNzaXN0IHdpdGggdGVtcGxhdGVcbiAgICAgKiBjb21waWxhdGlvbiBhbmQgY2FjaGVpbmcsIG5vb3AgbmVzdGVkIHZpZXdzIGFuZCBjbGFzc05hbWUgbmFtaW5nIGNvbnZlbnRpb25zLiBUaGUgZ2VuZXJhbFxuICAgICAqIHJ1bGUgb2YgdGh1bWIgaXMgdG8gbm90IG92ZXJyaWRlIG5hdGl2ZSBCYWNrYm9uZS5WaWV3IG1ldGhvZHMgYnV0IHRvIGNvbXBsZW1lbnQgdGhlIGNvcmUgQVBJXG4gICAgICogd2l0aCBzaW1wbGUgYW5kIHVzZWZ1bCBwYXR0ZXJucy5cbiAgICAgKiBAZXh0ZW5kcyB7QmFja2JvbmUuVmlld31cbiAgICAgKiBAbWl4ZXMgdmlld2xvZ2dpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZHVsZUlkXSBBbiBpZCAoY29tbW9ubHkgdGhlIHJlcXVpcmVqcyBtb2R1bGUuaWQpIHRoYXQgaXMgZm9ybWF0dGVkXG4gICAgICogYW5kIGFwcGVuZGVkIGFzIGEgY2xhc3NOYW1lIHRvIHRoZSByb290IHZpZXcgZWwuIEFkZGVkIGFzIGFuIGluc3RhbmNlIG1lbWJlciBpZiBwYXNzZWQgaW4gdmlhXG4gICAgICogdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRlbXBsYXRlXSBBbiBfLnRlbXBsYXRlIHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNvbXBpbGVUZW1wbGF0ZVxuICAgICAqIG1ldGhvZC4gQWRkZWQgYXMgYW4gaW5zdGFuY2UgbWVtYmVyIGlmIHBhc3NlZCBpbmNsdWRpbmcgYW4gYWRkaXRpb25hbCBjb21waWxlZFRlbXBsYXRlXG4gICAgICogaW5zdGFuY2UgbWVtYmVyIChzZWUgY29tcGlsZVRlbXBsYXRlIGZvciBzcGVjaWZpY2F0aW9uKS5cbiAgICAgKi9cbiAgICB2YXIgQmFzZVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCgvKiogQGxlbmRzIHZpZXdzLkJhc2UucHJvdG90eXBlICove1xuICAgICAgICBhd2FrZTogdHJ1ZSxcbiAgICAgICAgdG91Y2g6IGZhbHNlLFxuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBpc1JlZmxvd1ZhbGlkOiB0cnVlLFxuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHt9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vZHVsZUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2R1bGVJZCA9IHRoaXMub3B0aW9ucy5tb2R1bGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLmNvbXBpbGVUZW1wbGF0ZSh0aGlzLnRlbXBsYXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY3NzICYmIE9iamVjdC5rZXlzKHRoaXMuY3NzKSAmJiAhdGhpcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZG9udEFkZE1vZHVsZUlkQXNDbGFzcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbG9uZSBjc3MgdG8gYWxsb3cgbG9jYWwgb3ZlcnJpZGVzLlxuICAgICAgICAgICAgaWYgKHRoaXMuY3NzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jc3MgPSBfLmNsb25lKHRoaXMuY3NzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQmFja2JvbmUuVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXIgPSB0aGlzLnJlbmRlcjtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hd2FrZSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdWNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5kID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuaW5zdHJ1bWVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYXR0cignZGF0YS1yZW5kZXItdGltZScsIChlbmQgLSBzdGFydCkvMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuJGVsLmF0dHIoJ2RhdGEtY2lkJywgdGhpcy5jaWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kdWxlSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jc3NOYW1lc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRvbnRBZGRNb2R1bGVJZEFzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuYXR0cignZGF0YS12aWV3JywgdGhpcy5tb2R1bGVJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB2aWV3IGNsYXNzIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgIGlmICh0aGlzLmNzcyAmJiB0aGlzLmNzcy52aWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3ModGhpcy5jc3Mudmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxzIHRoZSBtZXRob2QgbmFtZWQgYnkgbWV0aG9kTmFtZSBvbiBlYWNoIGNoaWxkIG9mIHRoZSB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHsuLi5Bbnl9IFthcmdzXSBBbnkgZXh0cmEgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIHRvIG1ldGhvZCBvbiBpbnZvY2F0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpbnZva2VPbkNoaWxkcmVuOiBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgIGlmICghXy5pc1N0cmluZyhtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJnc0Zvck1ldGhvZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChjaGlsZCwgZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih2aWV3W21ldGhvZF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1ttZXRob2RdLmFwcGx5KHZpZXcsIGFyZ3NGb3JNZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgJiYgXy5pc0Z1bmN0aW9uKGNoaWxkW21ldGhvZF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFttZXRob2RdLmFwcGx5KGNoaWxkLCBhcmdzRm9yTWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBjaGlsZHJlbiBvZiB0aGlzIHZpZXcsIHlpZWxkaW5nIGVhY2ggaW4gdHVybiB0byBhbiBpdGVyYXRvciBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3IgRWFjaCBpbnZvY2F0aW9uIG9mIGl0ZXJhdG9yIGlzIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgICAgICogKGNoaWxkKS5cbiAgICAgICAgICogQHBhcmFtIHtBbnl9IFtjb250ZXh0XSBUaGUgaXRlcmF0b3IgaXMgYm91bmQgdG8gdGhlIGNvbnRleHQgb2JqZWN0LCBpZiBvbmUgaXMgcGFzc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaENoaWxkOiBmdW5jdGlvbihpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oaXRlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGl0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLmVhY2godGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpe1xuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChjaGlsZCwgZnVuY3Rpb24odmlldyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNOdWxsKHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghXy5pc051bGwoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlcyByZW5kZXIgbm9vcCBwcm94eSB0byBvcmlnaW5hbCByZW5kZXIgcm91dGluZS4gQWRkaXRpb25hbGx5IHRyYXZlcnNlc1xuICAgICAgICAgKiBhIHNwZWNpYWwgY2hpbGRyZW4gYXR0cmlidXRlIHRoYXQgY29uc2lzdHMgb2YgYW4gb2JqZWN0IGNvbGxlY3Rpb24gb2Ygdmlld3MgYW5kXG4gICAgICAgICAqIGNhbGxzIHdha2UgaWYgdGhhdCBtZXRob2QgZXhpc3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3luY1JlbmRlcl0gQ2FsbCB0aGUgc3RhbmRhcmQgKHN5bmMpIHJlbmRlciBtZXRob2Qgb3ZlclxuICAgICAgICAgKiAgICAgIGFzeW5jIChkZWJvdW5jZWRSZW5kZXIpIHZhcmlhbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB3YWtlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICAgICAgdGhpcy5hd2FrZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy50b3VjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zeW5jUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJvdW5jZWRSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludm9rZU9uQ2hpbGRyZW4oJ3dha2UnLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgYW55IHN1YnNlcXVlbnQgY2FsbHMgdG8gcmVuZGVyIGFuZCBwcm94aWVzIHRoZW0gdG8gYSBub29wIHJvdXRpbmUuIEFkZGl0aW9uYWxseVxuICAgICAgICAgKiB0cmF2ZXJzZXMgYSBzcGVjaWFsIGNoaWxkcmVuIGF0dHJpYnV0ZSB0aGF0IGNvbnNpc3RzIG9mIGFuIG9iamVjdCBjb2xsZWN0aW9uIG9mIHZpZXdzIGFuZFxuICAgICAgICAgKiBjYWxscyBzbGVlcCBpZiB0aGF0IG1ldGhvZCBleGlzdHMuXG4gICAgICAgICAqL1xuICAgICAgICBzbGVlcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmF3YWtlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmludm9rZU9uQ2hpbGRyZW4oJ3NsZWVwJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zdHBvbmUgdGhlIGV4ZWN1dGlvbiBvZiByZW5kZXIgdW50aWwgYWZ0ZXIgdGhlIGlucHV0IGhhcyBzdG9wcGVkIGFycml2aW5nLiBVc2VmdWwgZm9yXG4gICAgICAgICAqIGFzc2lnbmluZyB0byBtb2RlbC9jb2xsZWN0aW9uIGNoYW5nZSBldmVudCBsaXN0ZW5lcnMgdGhhdCBzaG91bGQgb25seSBoYXBwZW4gYWZ0ZXIgdGhlXG4gICAgICAgICAqIGlucHV0IGhhcyBzdG9wcGVkIGFycml2aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZGVib3VuY2VkUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGVib3VuY2VkUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVib3VuY2VkUmVuZGVyID0gXy5kZWJvdW5jZSh0aGlzLnJlbmRlciwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWJvdW5jZWRSZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGlsZXMgYW5kIG1lbW9pemVzIGFuIFtfLnRlbXBsYXRlXXtAbGluayBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jdGVtcGxhdGV9IHN0cmluZ1xuICAgICAgICAgKiBpbnRvIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgZXZhdWxhdGVkIGZvciByZW5kZXJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVN0ciBBbiBfLnRlbXBsYXRlIHN0cmluZyBmb3IgY29tcGlsYXRpb24gaW50byBhIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBldmFsdWF0ZWQgZm9yIHJlbmRlcmluZywgcGFzcyBpbiBhIGRhdGEgb2JqZWN0XG4gICAgICAgICAqIHRoYXQgdGhhdCBoYXMgcHJvcGVydGllcyBjb3JyZXNwb25kaW5nIHRvIHRoZSB0ZW1wbGF0ZSdzIGZyZWUgdmFyaWFibGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGNvbXBpbGVUZW1wbGF0ZTogXy5tZW1vaXplKGZ1bmN0aW9uKHRlbXBsYXRlU3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZSh0ZW1wbGF0ZVN0cik7XG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGFpbG9yZWQgZm9yIHRoZSByZXF1aXJlanMgbW9kdWxlLmlkIGZvcm1hdCBjb252ZXJ0aW5nIGludG8gYSBzYWZlIGFuZCBsZWdhbCBjc3NcbiAgICAgICAgICogY2xhc3MgYXR0cmlidXRlLiBGb3IgZXhhbXBsZSB0aGUgZm9sbG93aW5nIG1vZHVsZSBpZCAnL3ZpZXdzL3NoYXJlZC9Ta2lkUm93J1xuICAgICAgICAgKiB3b3VsZCBiZSBjb252ZXJ0ZWQgdG8gJ3ZpZXdzLXNoYXJlZC1za2Ryb3cnLlxuICAgICAgICAgKi9cbiAgICAgICAgY3NzTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5tb2R1bGVJZCB8fCAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJy0nKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXF8vZywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL152aWV3cy0vLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvLW1hc3RlciQvLCAnJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgbmFtZXNwYWNlIHRoYXQgY2FuIGJlIGh1bWFubHkgY3Jvc3MtcmVmZXJlbmNlZCB0byB0aGUgdmlldy5cbiAgICAgICAgICovXG4gICAgICAgIHVuaXF1ZU5TOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5tb2R1bGVJZCB8fCAndW5pZGVudGlmaWVkJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC8vZywgJy0nKSArICctJyArIHRoaXMuY2lkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJzY3JpYmUgbGlzdGVuZXJzLlxuICAgICAgICAgKiBpbXBsZW1lbnQgYXMgbmVjZXNzYXJ5XG4gICAgICAgICAqL1xuICAgICAgICBzdGFydExpc3RlbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RvcExpc3RlbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbHNPZmYodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uc09mZih0aGlzLmNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUuc3RvcExpc3RlbmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNBZGRlZFRvRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVtb3ZlZEZyb21Eb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzQWRkZWRUb0RvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgR2xvYmFsUmVmbG93UXVldWUucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVib3VuY2VkUmVtb3ZlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgIGRldGFjaDogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRzKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRldGFjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmRldGFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kZWJvdW5jZWRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJvdW5jZWRSZW1vdmUgPSBfLmRlYm91bmNlKHRoaXMucmVtb3ZlLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlYm91bmNlZFJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5pbnZva2VPbkNoaWxkcmVuKCdyZW1vdmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVEZWFjdGl2YXRlZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICAgICAgLy8gdGhlIG9wdGlvbnMgZm9yIHN0YXJ0TGlzdGVuaW5nIGFuZCB0cmlnZ2VyIGFyZSBhbHdheXMgc2hhbGxvd1xuICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBfLmV4dGVuZCh7c3RhcnRMaXN0ZW5pbmc6IHRydWUsIHRyaWdnZXI6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnN0YXJ0TGlzdGVuaW5nO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMudHJpZ2dlcjtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUgJiYgY2xvbmVkT3B0aW9ucy5zdGFydExpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJDYWxsaW5nIGFjdGl2YXRlIGFnYWluIG9uIHZpZXc6XCIgKyB0aGlzLm1vZHVsZUlkLCB0aGlzLmNpZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvbmVkT3B0aW9ucy50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImFjdGl2YXRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NoaWxkcmVuIGdldCBhY3RpdmF0ZWQgYWZ0ZXIgdGhlIHBhcmVudFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVlcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlT25DaGlsZHJlbignYWN0aXZhdGUnLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlYWN0aXZhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgICAgICAvLyB0aGUgb3B0aW9ucyBmb3Igc3RvcExpc3RlbmluZyBhbmQgdHJpZ2dlciBhcmUgYWx3YXlzIHNoYWxsb3dcbiAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gXy5leHRlbmQoe3N0b3BMaXN0ZW5pbmc6IHRydWUsIHRyaWdnZXI6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnN0b3BMaXN0ZW5pbmc7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy50cmlnZ2VyO1xuICAgICAgICAgICAgLy9jaGlsZHJlbiBnZXQgZGVhY3RpdmF0ZWQgYmVmb3JlIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludm9rZU9uQ2hpbGRyZW4oJ2RlYWN0aXZhdGUnLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSAmJiBjbG9uZWRPcHRpb25zLnN0b3BMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiQ2FsbGluZyBkZWFjdGl2YXRlIGFnYWluIG9uIHZpZXc6XCIgKyB0aGlzLm1vZHVsZUlkLCB0aGlzLmNpZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGNsb25lZE9wdGlvbnMudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJkZWFjdGl2YXRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogIEhlbHBlciBmdW5jdGlvbiBmb3IgZGVlcERlc3Ryb3ksIHJlY3Vyc2l2ZWx5IGNhbGxzIG9mZigpIG9uIGl0cyBtb2RlbChzKVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWxzT2ZmOiBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKG1vZGVsLmFzc29jaWF0ZWRPZmYpICYmIG1vZGVsLmFzc29jaWF0ZWRPZmYobnVsbCwgbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgbW9kZWwub2ZmKG51bGwsIG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkobW9kZWwpIHx8ICQuaXNQbGFpbk9iamVjdChtb2RlbCkpIHsgLy8gU1BMLTkwMTU2XG4gICAgICAgICAgICAgICAgXyhtb2RlbCkuZWFjaChmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbHNPZmYobW9kKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS5Db2xsZWN0aW9uKSB7IC8vIFRPRE86IHJldmlzaXQgdGhpcyBsb2dpYyBhZnRlciBEYXNoIHJlbGVhc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiB0cnlpbmcgdG8gY2FsbCBtb2RlbHNPZmYoKSBvbiBhIEJhY2tib25lLkNvbGxlY3Rpb24gb2JqZWN0LCBwbGVhc2UgbW92ZSBpdCB0byB0aGlzLmNvbGxlY3Rpb24gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uc09mZihtb2RlbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IHRyeWluZyB0byBjYWxsIG1vZGVsc09mZigpIG9uIG5vbi1CYWNrYm9uZS5Nb2RlbCBvYmplY3QhIE1heWJlIG1vdmUgaXQgdG8gdGhpcy5vcHRpb25zPycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgSGVscGVyIGZ1bmN0aW9uIGZvciBkZWVwRGVzdHJveSwgcmVjdXJzaXZlbHkgY2FsbHMgb2ZmKCkgb24gaXRzIGNvbGxlY3Rpb25zKHMpXG4gICAgICAgICAqL1xuICAgICAgICAgY29sbGVjdGlvbnNPZmY6IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ub2ZmKG51bGwsIG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoY29sbGVjdGlvbikgfHwgJC5pc1BsYWluT2JqZWN0KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgXyhjb2xsZWN0aW9uKS5lYWNoKGZ1bmN0aW9uKGNvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uc09mZihjb2xsKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIEJhY2tib25lLk1vZGVsKSB7IC8vIFRPRE86IHJldmlzaXQgdGhpcyBsb2dpYyBhZnRlciBEYXNoIHJlbGVhc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiB0cnlpbmcgdG8gY2FsbCBjb2xsZWN0aW9uc09mZigpIG9uIGEgQmFja2JvbmUuTW9kZWwgb2JqZWN0LCBwbGVhZXMgbW92ZSBpdCB0byB0aGlzLm1vZGVsIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxzT2ZmKGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IHRyeWluZyB0byBjYWxsIGNvbGxlY3Rpb25zT2ZmKCkgb24gbm9uLUJhY2tib25lLkNvbGxlY3Rpb24gb2JqZWN0ISBNYXliZSBtb3ZlIGl0IHRvIHRoaXMub3B0aW9ucz8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHJlbW92aW5nIHRoZSB2aWV3IGZyb20gdGhlIERPTSB3aGlsZSBhIHJlbmRlciBvY2N1cnMuIElmIHlvdSBjYWxsIHRoaXMgb24gc3Vidmlld3MgaW5cbiAgICAgICAgICogYSByZW5kZXIgZnVuY3Rpb24sIGpRdWVyeSB3aWxsIHJlbW92ZSBhbGwgb2YgdGhlIHN1YnZpZXcncyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICovXG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNBZGRlZFRvRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVtb3ZlZEZyb21Eb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzQWRkZWRUb0RvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRlbC5kZXRhY2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhZGQgaW5zdGFuY2UgbWV0aG9kcyBmb3IgYWxsIGNvbW1vbmx5IHVzZWQgalF1ZXJ5IGF0dGFjaG1lbnQgbWV0aG9kc1xuICAgICAgICAvL3JlcGxhY2VDb250ZW50c09mIGlzIHRoZSBhbmFsb2cgb2YgJC5odG1sKCRjb250YWluZXIpXG4gICAgICAgIHJlcGxhY2VDb250ZW50c09mOiBmdW5jdGlvbigkY29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZihfLmlzU3RyaW5nKCRjb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXBsYWNlQ29udGVudHNPZiBkb2VzIG5vdCBzdXBwb3J0IHNlbGVjdG9ycyBvciBIVE1MIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBnaXZlbiAkY29udGFpbmVyIHBhcmFtZXRlciBpcyBhIGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICRjb250YWluZXIgPSAkKCRjb250YWluZXIpO1xuICAgICAgICAgICAgJGNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoVG9Eb2N1bWVudCgkY29udGFpbmVyLCAnYXBwZW5kVG8nKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kVG86IGZ1bmN0aW9uKCRjb250YWluZXIpIHsgcmV0dXJuIHRoaXMuYXR0YWNoVG9Eb2N1bWVudCgkY29udGFpbmVyLCAnYXBwZW5kVG8nKTsgfSxcbiAgICAgICAgcHJlcGVuZFRvOiBmdW5jdGlvbigkY29udGFpbmVyKSB7IHJldHVybiB0aGlzLmF0dGFjaFRvRG9jdW1lbnQoJGNvbnRhaW5lciwgJ3ByZXBlbmRUbycpOyB9LFxuICAgICAgICByZXBsYWNlQWxsOiBmdW5jdGlvbigkY29udGFpbmVyKSB7IHJldHVybiB0aGlzLmF0dGFjaFRvRG9jdW1lbnQoJGNvbnRhaW5lciwgJ3JlcGxhY2VBbGwnKTsgfSxcbiAgICAgICAgaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uKCRjb250YWluZXIpIHsgcmV0dXJuIHRoaXMuYXR0YWNoVG9Eb2N1bWVudCgkY29udGFpbmVyLCAnaW5zZXJ0QWZ0ZXInKTsgfSxcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbigkY29udGFpbmVyKSB7IHJldHVybiB0aGlzLmF0dGFjaFRvRG9jdW1lbnQoJGNvbnRhaW5lciwgJ2luc2VydEJlZm9yZScpOyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggdGhlIHZpZXcgdG8gdGhlIGdpdmVuIERPTSBlbGVtZW50IHVzaW5nIHRoZSBnaXZlbiBtZXRob2QuXG4gICAgICAgICAqIElmIGFmdGVyd2FyZCB0aGUgdmlldyBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQgZWxlbWVudCwgdGhlIG9uQWRkZWRUb0RvY3VtZW50IG1ldGhvZCB3aWxsIGJlIGNhbGxlZC5cbiAgICAgICAgICogSWYgdGhlIHZpZXcgd2FzIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50IGVsZW1lbnQsIGFuZCB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgaXMgZGlmZmVyZW50IHRoYW5cbiAgICAgICAgICogdGhlIHZpZXcncyBjdXJyZW50IHBhcmVudCBlbGVtZW50LCB0aGUgb25SZW1vdmVkRnJvbURvY3VtZW50IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBmaXJzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90IG1lYW50IHRvIGJlIGNhbGxlZCBkaXJlY3RseSwgb25seSBhcyBhIGhlbHBlciBmb3IgdGhlIG1vcmUgc3BlY2lmaWMgYXR0YWNobWVudCBtZXRob2RzIGFib3ZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0RPTXxqUXVlcnl9ICRjb250YWluZXIgVGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRhY2htZW50TWV0aG9kIGEgdmFsaWQgalF1ZXJ5IERPTSBhdHRhY2htZW50IG1ldGhvZCBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICBhdHRhY2hUb0RvY3VtZW50OiBmdW5jdGlvbigkY29udGFpbmVyLCBhdHRhY2htZW50TWV0aG9kKSB7XG4gICAgICAgICAgICBpZihfLmlzU3RyaW5nKCRjb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGF0dGFjaG1lbnRNZXRob2QgKyAnIGRvZXMgbm90IHN1cHBvcnQgc2VsZWN0b3JzIG9yIEhUTUwgc3RyaW5ncycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIGdpdmVuICRjb250YWluZXIgcGFyYW1ldGVyIGlzIGEgalF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgJGNvbnRhaW5lciA9ICQoJGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIGlmIG5vIGNvbnRhaW5lciwgYWJvcnRcbiAgICAgICAgICAgIGlmICgkY29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIHJhdyBET00gY29udGFpbmVyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gJGNvbnRhaW5lclswXTtcblxuICAgICAgICAgICAgLy8gY2FsbCBvblJlbW92ZWRGcm9tRG9jdW1lbnQgaWYgbmVlZGVkXG4gICAgICAgICAgICB2YXIgb2xkUGFyZW50ID0gdGhpcy5lbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKG9sZFBhcmVudCAmJiAob2xkUGFyZW50ICE9PSBjb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQWRkZWRUb0RvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25SZW1vdmVkRnJvbURvY3VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzQWRkZWRUb0RvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkbyB0aGUgYXR0YWNobWVudFxuICAgICAgICAgICAgdGhpcy4kZWxbYXR0YWNobWVudE1ldGhvZF0oJGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIGNhbGwgb25BZGRlZFRvRG9jdW1lbnQgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAob2xkUGFyZW50ICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoJC5jb250YWlucyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzQWRkZWRUb0RvY3VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkFkZGVkVG9Eb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHRoaXMgdmlldyBpcyBhZGRlZCB0byB0aGUgZG9jdW1lbnQuIFJlY3Vyc2l2ZWx5IGNhbGxzXG4gICAgICAgICAqIG9uQWRkZWRUb0RvY3VtZW50IG9uIGFsbCBjaGlsZCB2aWV3cy4gT3ZlcnJpZGUgdGhpcyBtZXRob2Qgd2l0aCBjdXN0b20gY29kZVxuICAgICAgICAgKiB0aGF0IHNob3VsZCBiZSBydW4gd2hlbiB0aGlzIHZpZXcgaXMgYWRkZWQgdG8gdGhlIGRvY3VtZW50LiBNYWtlIHN1cmUgdG8gY2FsbFxuICAgICAgICAgKiB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbiB3aGVuIG92ZXJyaWRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGFuZCBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseS5cbiAgICAgICAgICovXG4gICAgICAgIG9uQWRkZWRUb0RvY3VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZVJlZmxvdygpO1xuICAgICAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNoaWxkLm9uQWRkZWRUb0RvY3VtZW50KSAmJiB0aGlzLmlzQW5jZXN0b3JPZihjaGlsZCkgJiYgIWNoaWxkLl9pc0FkZGVkVG9Eb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5faXNBZGRlZFRvRG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5vbkFkZGVkVG9Eb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdhZGRlZFRvRG9jdW1lbnQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gdGhpcyB2aWV3IGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQuIFJlY3Vyc2l2ZWx5IGNhbGxzXG4gICAgICAgICAqIG9uUmVtb3ZlZEZyb21Eb2N1bWVudCBvbiBhbGwgY2hpbGQgdmlld3MuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHdpdGggY3VzdG9tXG4gICAgICAgICAqIGNvZGUgdGhhdCBzaG91bGQgYmUgcnVuIHdoZW4gdGhpcyB2aWV3IGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQuIE1ha2VcbiAgICAgICAgICogc3VyZSB0byBjYWxsIHRoZSBiYXNlIGltcGxlbWVudGF0aW9uIHdoZW4gb3ZlcnJpZGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYW5kIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgb25SZW1vdmVkRnJvbURvY3VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZWZsb3dWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICBHbG9iYWxSZWZsb3dRdWV1ZS5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY2hpbGQub25SZW1vdmVkRnJvbURvY3VtZW50KSAmJiB0aGlzLmlzQW5jZXN0b3JPZihjaGlsZCkgJiYgY2hpbGQuX2lzQWRkZWRUb0RvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLm9uUmVtb3ZlZEZyb21Eb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5faXNBZGRlZFRvRG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncmVtb3ZlZEZyb21Eb2N1bWVudCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHZpZXcgaXMgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBpc0FkZGVkVG9Eb2N1bWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNBZGRlZFRvRG9jdW1lbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZpZXcgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIHZpZXc7IGZhbHNlIG90aGVyd2lzZTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtCYWNrYm9uZS5WaWV3fSBkZXNjZW5kYW50IEEgQmFja2JvbmUuVmlldyBpbnN0YW5jZSB0byB0ZXN0IGFnYWluc3QuXG4gICAgICAgICAqL1xuICAgICAgICBpc0FuY2VzdG9yT2Y6IGZ1bmN0aW9uKGRlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjZW5kYW50LmVsID8gJC5jb250YWlucyh0aGlzLmVsLCBkZXNjZW5kYW50LmVsKSA6IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2aWV3IGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgZ2l2ZW4gdmlldzsgZmFsc2Ugb3RoZXJ3aXNlO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0JhY2tib25lLlZpZXd9IGFuY2VzdG9yIEEgQmFja2JvbmUuVmlldyBpbnN0YW5jZSB0byB0ZXN0IGFnYWluc3QuXG4gICAgICAgICAqL1xuICAgICAgICBpc0Rlc2NlbmRhbnRPZjogZnVuY3Rpb24oYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBhbmNlc3Rvci5lbCA/ICQuY29udGFpbnMoYW5jZXN0b3IuZWwsIHRoaXMuZWwpIDogZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RydWN0IHRoZSB2aWV3IHRvIHJlLWZsb3cgaXRzZWxmIGluIGl0cyBjdXJyZW50IGNvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZG8gYW55IHdvcmsgdGhhdCBpcyByZXF1aXJlZCB3aGVuIHRoZSB2aWV3IG5lZWRzIHRvIGFkanVzdCB0byBpdHMgY29udGFpbmVyIHNpemUuXG4gICAgICAgICAqL1xuICAgICAgICByZWZsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBwYXRocyBvZiBhbmNlc3RvciBCYWNrYm9uZSB2aWV3cy4gVGhlIGFsZ29yaXRobVxuICAgICAgICAgKiB0cmF2ZXJzZXMgdGhlIERPTSB1cCB0aGUgcGFyZW50IGNoYWluIGFuZCB0aGUgZGF0YS12aWV3IGF0dHJpYnV0ZSBvZiBlYWNoIERPTSBlbGVtZW50XG4gICAgICAgICAqIHdpdGggYSBkYXRhLXZpZXcgYXR0cmlidXRlLiBUaGUgZGF0YS12aWV3IGF0dHJpYnV0ZSBpcyBhZGRlZCB0byB0aGUgRE9NIHRyZWUgcm9vdCBvZlxuICAgICAgICAgKiBlYWNoIHZpZXdzL0Jhc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBhcnJheSBpcyBzb3J0ZWQgc3RhcnRpbmcgd2l0aCB0aGUgdG9wLW1vc3QgRE9NIGVsZW1lbnQncyBkYXRhLXZpZXcgc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IHJldHVybiB0aGUgZnVsbCBhbmNlc3RvciBsaXN0IG9uY2UgaXQgaGFzIGJlZW4gYWRkZWQgdG8gYSBET01cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRlcHRoIHtOdW1iZXJ9IHNwZWNpZmllcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgYW5jZXN0b3JzIHRvIHJldHVyblxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFuY2VzdG9yczogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy4kZWw7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVmlldyA9IHBhcmVudC5hdHRyKFwiZGF0YS12aWV3XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV8oZGF0YVZpZXcpLmlzVW5kZWZpbmVkKCkgJiYgIV8oZGF0YVZpZXcpLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMudW5zaGlmdChkYXRhVmlldyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFfKGRlcHRoKS5pc1VuZGVmaW5lZCgpICYmIGRlcHRoID09IHJlc3VsdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW52YWxpZGF0ZVJlZmxvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1JlZmxvd1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlZmxvd1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgR2xvYmFsUmVmbG93UXVldWUuYWRkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbGlkYXRlUmVmbG93OiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVmbG93VmFsaWQgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZWZsb3dWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgR2xvYmFsUmVmbG93UXVldWUucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnZva2VPbkNoaWxkcmVuKCd2YWxpZGF0ZVJlZmxvdycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFJlZmxvd0RlcHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBwYXJlbnROb2RlID0gdGhpcy5lbC5wYXJlbnROb2RlOyBwYXJlbnROb2RlOyBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgXy5leHRlbmQoQmFzZVZpZXcucHJvdG90eXBlLCB2aWV3bG9nZ2luZ21peGluKTtcblxuICAgIHJldHVybiBCYXNlVmlldztcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvdmlld3MvQmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gdmlld3MvQmFzZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "require/backbone":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/jquery\"), __webpack_require__(\"require/underscore\"), __webpack_require__(\"contrib/backbone\")], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone) {\n    // inject a reference to jquery in case we ever run it in no conflict mode\n    Backbone.$ = $;\n    return Backbone.noConflict();\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3JlcXVpcmUvYmFja2JvbmUuanM/OTU4NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InJlcXVpcmUvYmFja2JvbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydqcXVlcnknLCAndW5kZXJzY29yZScsICdjb250cmliL2JhY2tib25lJ10sIGZ1bmN0aW9uKCQsIF8sIEJhY2tib25lKSB7XG4gICAgLy8gaW5qZWN0IGEgcmVmZXJlbmNlIHRvIGpxdWVyeSBpbiBjYXNlIHdlIGV2ZXIgcnVuIGl0IGluIG5vIGNvbmZsaWN0IG1vZGVcbiAgICBCYWNrYm9uZS4kID0gJDtcbiAgICByZXR1cm4gQmFja2JvbmUubm9Db25mbGljdCgpO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3JlcXVpcmUvYmFja2JvbmUuanNcbi8vIG1vZHVsZSBpZCA9IHJlcXVpcmUvYmFja2JvbmVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/backbone":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Backbone.js 1.1.2\n\n//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function(root, factory) {\n\n  // Set up Backbone appropriately for the environment. Start with AMD.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"require/underscore\"), __webpack_require__(\"shim/jquery\"), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      root.Backbone = factory(root, exports, _, $);\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    factory(root, exports, _);\n\n  // Finally, as a browser global.\n  } else {\n    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n\n}(this, function(root, Backbone, _, $) {\n\n  // Initial Setup\n  // -------------\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create local references to array methods we'll want to use later.\n  var array = [];\n  var push = array.push;\n  var slice = array.slice;\n  var splice = array.splice;\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '1.1.2';\n\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n  // the `$` variable.\n  Backbone.$ = $;\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback\n  // functions to an event; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {\n\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function(name, callback, context) {\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n      this._events || (this._events = {});\n      var events = this._events[name] || (this._events[name] = []);\n      events.push({callback: callback, context: context, ctx: context || this});\n      return this;\n    },\n\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function(name, callback, context) {\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n      var self = this;\n      var once = _.once(function() {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n      return this.on(name, once, context);\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function(name, callback, context) {\n      var retain, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n      if (!name && !callback && !context) {\n        this._events = void 0;\n        return this;\n      }\n      names = name ? [name] : _.keys(this._events);\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n        if (events = this._events[name]) {\n          this._events[name] = retain = [];\n          if (callback || context) {\n            for (j = 0, k = events.length; j < k; j++) {\n              ev = events[j];\n              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                  (context && context !== ev.context)) {\n                retain.push(ev);\n              }\n            }\n          }\n          if (!retain.length) delete this._events[name];\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(name) {\n      if (!this._events) return this;\n      var args = slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) return this;\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, arguments);\n      return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function(obj, name, callback) {\n      var listeningTo = this._listeningTo;\n      if (!listeningTo) return this;\n      var remove = !name && !callback;\n      if (!callback && typeof name === 'object') callback = this;\n      if (obj) (listeningTo = {})[obj._listenId] = obj;\n      for (var id in listeningTo) {\n        obj = listeningTo[id];\n        obj.off(name, callback, this);\n        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];\n      }\n      return this;\n    }\n\n  };\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n  var eventsApi = function(obj, action, name, rest) {\n    if (!name) return true;\n\n    // Handle event maps.\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n      return false;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return false;\n    }\n\n    return true;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n  };\n\n  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n  _.each(listenMethods, function(implementation, method) {\n    Events[method] = function(obj, name, callback) {\n      var listeningTo = this._listeningTo || (this._listeningTo = {});\n      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n      listeningTo[id] = obj;\n      if (!callback && typeof name === 'object') callback = this;\n      obj[implementation](name, callback, this);\n      return this;\n    };\n  });\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Backbone.Model\n  // --------------\n\n  // Backbone **Models** are the basic data object in the framework --\n  // frequently representing a row in a table in a database on your server.\n  // A discrete chunk of data and a bunch of useful, related methods for\n  // performing computations and transformations on that data.\n\n  // Create a new model with the specified attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.cid = _.uniqueId('c');\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  };\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Proxy `Backbone.sync` by default -- but override this if you need\n    // custom syncing semantics for *this* particular model.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      return _.escape(this.get(attr));\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n      var attr, attrs, unset, changes, silent, changing, prev, current;\n      if (key == null) return this;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options || (options = {});\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Extract attributes and options.\n      unset           = options.unset;\n      silent          = options.silent;\n      changes         = [];\n      changing        = this._changing;\n      this._changing  = true;\n\n      if (!changing) {\n        this._previousAttributes = _.clone(this.attributes);\n        this.changed = {};\n      }\n      current = this.attributes, prev = this._previousAttributes;\n\n      // Check for changes of `id`.\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n      // For each `set` attribute, update or delete the current value.\n      for (attr in attrs) {\n        val = attrs[attr];\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\n        if (!_.isEqual(prev[attr], val)) {\n          this.changed[attr] = val;\n        } else {\n          delete this.changed[attr];\n        }\n        unset ? delete current[attr] : current[attr] = val;\n      }\n\n      // Trigger all relevant attribute changes.\n      if (!silent) {\n        if (changes.length) this._pending = options;\n        for (var i = 0, l = changes.length; i < l; i++) {\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\n        }\n      }\n\n      // You might be wondering why there's a `while` loop here. Changes can\n      // be recursively nested within `\"change\"` events.\n      if (changing) return this;\n      if (!silent) {\n        while (this._pending) {\n          options = this._pending;\n          this._pending = false;\n          this.trigger('change', this, options);\n        }\n      }\n      this._pending = false;\n      this._changing = false;\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n      var attrs = {};\n      for (var key in this.attributes) attrs[key] = void 0;\n      return this.set(attrs, _.extend({}, options, {unset: true}));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (attr == null) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var val, changed = false;\n      var old = this._changing ? this._previousAttributes : this.attributes;\n      for (var attr in diff) {\n        if (_.isEqual(old[attr], (val = diff[attr]))) continue;\n        (changed || (changed = {}))[attr] = val;\n      }\n      return changed;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (attr == null || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Fetch the model from the server. If the server's representation of the\n    // model differs from its current attributes, they will be overridden,\n    // triggering a `\"change\"` event.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        if (!model.set(model.parse(resp, options), options)) return false;\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, val, options) {\n      var attrs, method, xhr, attributes = this.attributes;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (key == null || typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options = _.extend({validate: true}, options);\n\n      // If we're not waiting and attributes exist, save acts as\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\n      // the model will be valid when the attributes, if any, are set.\n      if (attrs && !options.wait) {\n        if (!this.set(attrs, options)) return false;\n      } else {\n        if (!this._validate(attrs, options)) return false;\n      }\n\n      // Set temporary attributes if `{wait: true}`.\n      if (attrs && options.wait) {\n        this.attributes = _.extend({}, attributes, attrs);\n      }\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        // Ensure attributes are restored during synchronous saves.\n        model.attributes = attributes;\n        var serverAttrs = model.parse(resp, options);\n        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);\n        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {\n          return false;\n        }\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n\n      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n      if (method === 'patch') options.attrs = attrs;\n      xhr = this.sync(method, this, options);\n\n      // Restore attributes.\n      if (attrs && options.wait) this.attributes = attributes;\n\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n\n      var destroy = function() {\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      options.success = function(resp) {\n        if (options.wait || model.isNew()) destroy();\n        if (success) success(model, resp, options);\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\n      };\n\n      if (this.isNew()) {\n        options.success();\n        return false;\n      }\n      wrapError(this, options);\n\n      var xhr = this.sync('delete', this, options);\n      if (!options.wait) destroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base =\n        _.result(this, 'urlRoot') ||\n        _.result(this.collection, 'url') ||\n        urlError();\n      if (this.isNew()) return base;\n      return base.replace(/([^\\/])$/, '$1/') + encodeURIComponent(this.id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return !this.has(this.idAttribute);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n      return this._validate({}, _.extend(options || {}, { validate: true }));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n      if (!options.validate || !this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validationError = this.validate(attrs, options) || null;\n      if (!error) return true;\n      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n      return false;\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Model.\n  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];\n\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\n  _.each(modelMethods, function(method) {\n    Model.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.attributes);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Backbone.Collection\n  // -------------------\n\n  // If models tend to represent a single row of data, a Backbone Collection is\n  // more analagous to a table full of data ... or a small slice or page of that\n  // table, or a collection of rows that belong together for a particular reason\n  // -- all of the messages in this particular folder, all of the documents\n  // belonging to this particular author, and so on. Collections maintain\n  // indexes of their models, both in order, and for lookup by `id`.\n\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\n  // If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, _.extend({silent: true}, options));\n  };\n\n  // Default options for `Collection#set`.\n  var setOptions = {add: true, remove: true, merge: true};\n  var addOptions = {add: true, remove: false};\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model){ return model.toJSON(options); });\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Add a model, or list of models to the set.\n    add: function(models, options) {\n      return this.set(models, _.extend({merge: false}, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n      var singular = !_.isArray(models);\n      models = singular ? [models] : _.clone(models);\n      options || (options = {});\n      var i, l, index, model;\n      for (i = 0, l = models.length; i < l; i++) {\n        model = models[i] = this.get(models[i]);\n        if (!model) continue;\n        delete this._byId[model.id];\n        delete this._byId[model.cid];\n        index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n        this._removeReference(model, options);\n      }\n      return singular ? models[0] : models;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n      options = _.defaults({}, options, setOptions);\n      if (options.parse) models = this.parse(models, options);\n      var singular = !_.isArray(models);\n      models = singular ? (models ? [models] : []) : _.clone(models);\n      var i, l, id, model, attrs, existing, sort;\n      var at = options.at;\n      var targetModel = this.model;\n      var sortable = this.comparator && (at == null) && options.sort !== false;\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n      var toAdd = [], toRemove = [], modelMap = {};\n      var add = options.add, merge = options.merge, remove = options.remove;\n      var order = !sortable && add && remove ? [] : false;\n\n      // Turn bare objects into model references, and prevent invalid models\n      // from being added.\n      for (i = 0, l = models.length; i < l; i++) {\n        attrs = models[i] || {};\n        if (attrs instanceof Model) {\n          id = model = attrs;\n        } else {\n          id = attrs[targetModel.prototype.idAttribute || 'id'];\n        }\n\n        // If a duplicate is found, prevent it from being added and\n        // optionally merge it into the existing model.\n        if (existing = this.get(id)) {\n          if (remove) modelMap[existing.cid] = true;\n          if (merge) {\n            attrs = attrs === model ? model.attributes : attrs;\n            if (options.parse) attrs = existing.parse(attrs, options);\n            existing.set(attrs, options);\n            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n          }\n          models[i] = existing;\n\n        // If this is a new, valid model, push it to the `toAdd` list.\n        } else if (add) {\n          model = models[i] = this._prepareModel(attrs, options);\n          if (!model) continue;\n          toAdd.push(model);\n          this._addReference(model, options);\n        }\n\n        // Do not add multiple models with the same `id`.\n        model = existing || model;\n        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);\n        modelMap[model.id] = true;\n      }\n\n      // Remove nonexistent models if appropriate.\n      if (remove) {\n        for (i = 0, l = this.length; i < l; ++i) {\n          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);\n        }\n        if (toRemove.length) this.remove(toRemove, options);\n      }\n\n      // See if sorting is needed, update `length` and splice in new models.\n      if (toAdd.length || (order && order.length)) {\n        if (sortable) sort = true;\n        this.length += toAdd.length;\n        if (at != null) {\n          for (i = 0, l = toAdd.length; i < l; i++) {\n            this.models.splice(at + i, 0, toAdd[i]);\n          }\n        } else {\n          if (order) this.models.length = 0;\n          var orderedModels = order || toAdd;\n          for (i = 0, l = orderedModels.length; i < l; i++) {\n            this.models.push(orderedModels[i]);\n          }\n        }\n      }\n\n      // Silently sort the collection if appropriate.\n      if (sort) this.sort({silent: true});\n\n      // Unless silenced, it's time to fire all appropriate add/sort events.\n      if (!options.silent) {\n        for (i = 0, l = toAdd.length; i < l; i++) {\n          (model = toAdd[i]).trigger('add', model, this, options);\n        }\n        if (sort || (order && order.length)) this.trigger('sort', this, options);\n      }\n\n      // Return the added (or merged) model (or models).\n      return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n      options || (options = {});\n      for (var i = 0, l = this.models.length; i < l; i++) {\n        this._removeReference(this.models[i], options);\n      }\n      options.previousModels = this.models;\n      this._reset();\n      models = this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      return this.add(model, _.extend({at: this.length}, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      return this.add(model, _.extend({at: 0}, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n      return slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id.\n    get: function(obj) {\n      if (obj == null) return void 0;\n      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of\n    // `filter`.\n    where: function(attrs, first) {\n      if (_.isEmpty(attrs)) return first ? void 0 : [];\n      return this[first ? 'find' : 'filter'](function(model) {\n        for (var key in attrs) {\n          if (attrs[key] !== model.get(key)) return false;\n        }\n        return true;\n      });\n    },\n\n    // Return the first model with matching attributes. Useful for simple cases\n    // of `find`.\n    findWhere: function(attrs) {\n      return this.where(attrs, true);\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n      options || (options = {});\n\n      // Run sort based on type of `comparator`.\n      if (_.isString(this.comparator) || this.comparator.length === 1) {\n        this.models = this.sortBy(this.comparator, this);\n      } else {\n        this.models.sort(_.bind(this.comparator, this));\n      }\n\n      if (!options.silent) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return _.invoke(this.models, 'get', attr);\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `reset: true` is passed, the response\n    // data will be passed through the `reset` method instead of `set`.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var success = options.success;\n      var collection = this;\n      options.success = function(resp) {\n        var method = options.reset ? 'reset' : 'set';\n        collection[method](resp, options);\n        if (success) success(collection, resp, options);\n        collection.trigger('sync', collection, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      options = options ? _.clone(options) : {};\n      if (!(model = this._prepareModel(model, options))) return false;\n      if (!options.wait) this.add(model, options);\n      var collection = this;\n      var success = options.success;\n      options.success = function(model, resp) {\n        if (options.wait) collection.add(model, options);\n        if (success) success(model, resp, options);\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n      return new this.constructor(this.models);\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n      if (attrs instanceof Model) return attrs;\n      options = options ? _.clone(options) : {};\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model.validationError) return model;\n      this.trigger('invalid', this, model.validationError, options);\n      return false;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n      this._byId[model.cid] = model;\n      if (model.id != null) this._byId[model.id] = model;\n      if (!model.collection) model.collection = this;\n      model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n      if (this === model.collection) delete model.collection;\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if ((event === 'add' || event === 'remove') && collection !== this) return;\n      if (event === 'destroy') this.remove(model, options);\n      if (model && event === 'change:' + model.idAttribute) {\n        delete this._byId[model.previous(model.idAttribute)];\n        if (model.id != null) this._byId[model.id] = model;\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  // 90% of the core usefulness of Backbone Collections is actually implemented\n  // right here:\n  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\n    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',\n    'lastIndexOf', 'isEmpty', 'chain', 'sample'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  _.each(methods, function(method) {\n    Collection.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.models);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Underscore methods that take a property name as an argument.\n  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];\n\n  // Use attributes instead of properties.\n  _.each(attributeMethods, function(method) {\n    Collection.prototype[method] = function(value, context) {\n      var iterator = _.isFunction(value) ? value : function(model) {\n        return model.get(value);\n      };\n      return _[method](this.models, iterator, context);\n    };\n  });\n\n  // Backbone.View\n  // -------------\n\n  // Backbone Views are almost more convention than they are actual code. A View\n  // is simply a JavaScript object that represents a logical chunk of UI in the\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\n  // UI as a **View** allows you to define your DOM events declaratively, without\n  // having to worry about render order ... and makes it easy for the view to\n  // react to specific changes in the state of your models.\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    options || (options = {});\n    _.extend(this, _.pick(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n    this.delegateEvents();\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be merged as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function() {\n      this.$el.remove();\n      this.stopListening();\n      return this;\n    },\n\n    // Change the view's element (`this.el` property), including event\n    // re-delegation.\n    setElement: function(element, delegate) {\n      if (this.$el) this.undelegateEvents();\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\n      this.el = this.$el[0];\n      if (delegate !== false) this.delegateEvents();\n      return this;\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    // This only works for delegate-able events: not `focus`, `blur`, and\n    // not `change`, `submit`, and `reset` in Internet Explorer.\n    delegateEvents: function(events) {\n      if (!(events || (events = _.result(this, 'events')))) return this;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[events[key]];\n        if (!method) continue;\n\n        var match = key.match(delegateEventSplitter);\n        var eventName = match[1], selector = match[2];\n        method = _.bind(method, this);\n        eventName += '.delegateEvents' + this.cid;\n        if (selector === '') {\n          this.$el.on(eventName, method);\n        } else {\n          this.$el.on(eventName, selector, method);\n        }\n      }\n      return this;\n    },\n\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      this.$el.off('.delegateEvents' + this.cid);\n      return this;\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = _.extend({}, _.result(this, 'attributes'));\n        if (this.id) attrs.id = _.result(this, 'id');\n        if (this.className) attrs['class'] = _.result(this, 'className');\n        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);\n        this.setElement($el, false);\n      } else {\n        this.setElement(_.result(this, 'el'), false);\n      }\n    }\n\n  });\n\n  // Backbone.sync\n  // -------------\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    _.defaults(options || (options = {}), {\n      emulateHTTP: Backbone.emulateHTTP,\n      emulateJSON: Backbone.emulateJSON\n    });\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = _.result(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (options.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n      params.type = 'POST';\n      if (options.emulateJSON) params.data._method = type;\n      var beforeSend = options.beforeSend;\n      options.beforeSend = function(xhr) {\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        if (beforeSend) return beforeSend.apply(this, arguments);\n      };\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !options.emulateJSON) {\n      params.processData = false;\n    }\n\n    // If we're sending a `PATCH` request, and we're in an old Internet Explorer\n    // that still has ActiveX enabled by default, override jQuery to use that\n    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.\n    if (params.type === 'PATCH' && noXhrPatch) {\n      params.xhr = function() {\n        return new ActiveXObject(\"Microsoft.XMLHTTP\");\n      };\n    }\n\n    // Make the request, allowing the user to override any Ajax options.\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n    model.trigger('request', model, xhr, options);\n    return xhr;\n  };\n\n  var noXhrPatch =\n    typeof window !== 'undefined' && !!window.ActiveXObject &&\n      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'patch':  'PATCH',\n    'delete': 'DELETE',\n    'read':   'GET'\n  };\n\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n  // Override this if you'd like to use a different library.\n  Backbone.ajax = function() {\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\n  };\n\n  // Backbone.Router\n  // ---------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var optionalParam = /\\((.*?)\\)/g;\n  var namedParam    = /(\\(\\?)?:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (_.isFunction(name)) {\n        callback = name;\n        name = '';\n      }\n      if (!callback) callback = this[name];\n      var router = this;\n      Backbone.history.route(route, function(fragment) {\n        var args = router._extractParameters(route, fragment);\n        router.execute(callback, args);\n        router.trigger.apply(router, ['route:' + name].concat(args));\n        router.trigger('route', name, args);\n        Backbone.history.trigger('route', router, name, args);\n      });\n      return this;\n    },\n\n    // Execute a route handler with the provided parameters.  This is an\n    // excellent place to do pre-route setup or post-route cleanup.\n    execute: function(callback, args) {\n      if (callback) callback.apply(this, args);\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n      return this;\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      this.routes = _.result(this, 'routes');\n      var route, routes = _.keys(this.routes);\n      while ((route = routes.pop()) != null) {\n        this.route(route, this.routes[route]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(optionalParam, '(?:$1)?')\n                   .replace(namedParam, function(match, optional) {\n                     return optional ? match : '([^/?]+)';\n                   })\n                   .replace(splatParam, '([^?]*?)');\n      return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted decoded parameters. Empty or unmatched parameters will be\n    // treated as `null` to normalize cross-browser behavior.\n    _extractParameters: function(route, fragment) {\n      var params = route.exec(fragment).slice(1);\n      return _.map(params, function(param, i) {\n        // Don't decode the search params.\n        if (i === params.length - 1) return param || null;\n        return param ? decodeURIComponent(param) : null;\n      });\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on either\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n  // and URL fragments. If the browser supports neither (old IE, natch),\n  // falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    _.bindAll(this, 'checkUrl');\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Cached regex for removing a trailing slash.\n  var trailingSlash = /\\/$/;\n\n  // Cached regex for stripping urls of hash.\n  var pathStripper = /#.*$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Are we at the app root?\n    atRoot: function() {\n      return this.location.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n    },\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (fragment == null) {\n        if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n          fragment = decodeURI(this.location.pathname + this.location.search);\n          var root = this.root.replace(trailingSlash, '');\n          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error(\"Backbone.history has already been started\");\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({root: '/'}, this.options, options);\n      this.root             = this.options.root;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);\n      var fragment          = this.getFragment();\n      var docMode           = document.documentMode;\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      if (oldIE && this._wantsHashChange) {\n        var frame = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\">');\n        this.iframe = frame.hide().appendTo('body')[0].contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        Backbone.$(window).on('popstate', this.checkUrl);\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n        Backbone.$(window).on('hashchange', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = this.location;\n\n      // Transition from hashChange to pushState or vice versa if both are\n      // requested.\n      if (this._wantsHashChange && this._wantsPushState) {\n\n        // If we've started off with a route from a `pushState`-enabled\n        // browser, but we're currently in a browser that doesn't support it...\n        if (!this._hasPushState && !this.atRoot()) {\n          this.fragment = this.getFragment(null, true);\n          this.location.replace(this.root + '#' + this.fragment);\n          // Return immediately as browser will do redirect to new url\n          return true;\n\n        // Or if we've started out with a hash-based route, but we're currently\n        // in a browser where it could be `pushState`-based instead...\n        } else if (this._hasPushState && this.atRoot() && loc.hash) {\n          this.fragment = this.getHash().replace(routeStripper, '');\n          this.history.replaceState({}, document.title, this.root + this.fragment);\n        }\n\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n      if (current === this.fragment && this.iframe) {\n        current = this.getFragment(this.getHash(this.iframe));\n      }\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl();\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragment) {\n      fragment = this.fragment = this.getFragment(fragment);\n      return _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: !!options};\n\n      var url = this.root + (fragment = this.getFragment(fragment || ''));\n\n      // Strip the hash for matching.\n      fragment = fragment.replace(pathStripper, '');\n\n      if (this.fragment === fragment) return;\n      this.fragment = fragment;\n\n      // Don't include a trailing slash on the root.\n      if (fragment === '' && url !== '/') url = url.slice(0, -1);\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if(!options.replace) this.iframe.document.open().close();\n          this._updateHash(this.iframe.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) return this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n  // Create the default Backbone.history.\n  Backbone.history = new History;\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && _.has(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    var Surrogate = function(){ this.constructor = child; };\n    Surrogate.prototype = parent.prototype;\n    child.prototype = new Surrogate;\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) _.extend(child.prototype, protoProps);\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, router, view and history.\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  var wrapError = function(model, options) {\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error(model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n  };\n\n  return Backbone;\n\n}));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvYmFja2JvbmUuanM/ZTc3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsb0NBQW9DO0FBQ3BDOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CLEVBQUU7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsbUJBQW1CLDJEQUEyRDtBQUM5RTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxlQUFlO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRSx5RUFBeUU7QUFDekUsNkVBQTZFO0FBQzdFLGlGQUFpRjtBQUNqRiw2RUFBNkU7QUFDN0U7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQkFBbUI7QUFDbkI7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVksWUFBWTtBQUN2RSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVksWUFBWTtBQUNoRSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQkFBbUI7QUFDbkI7O0FBRUEsMEJBQTBCLGVBQWU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QixHQUFHLGlCQUFpQjtBQUMxRSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw4REFBOEQsdUJBQXVCO0FBQ3JGO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhCQUE4QixFQUFFO0FBQ3RFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixhQUFhOztBQUV4QztBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUNBQWlDO0FBQzlELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsc0NBQXNDO0FBQy9EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoiY29udHJpYi9iYWNrYm9uZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vICAgICBCYWNrYm9uZS5qcyAxLjEuMlxuXG4vLyAgICAgKGMpIDIwMTAtMjAxNCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIEJhY2tib25lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vYmFja2JvbmVqcy5vcmdcblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblxuICAvLyBTZXQgdXAgQmFja2JvbmUgYXBwcm9wcmlhdGVseSBmb3IgdGhlIGVudmlyb25tZW50LiBTdGFydCB3aXRoIEFNRC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3VuZGVyc2NvcmUnLCAnanF1ZXJ5JywgJ2V4cG9ydHMnXSwgZnVuY3Rpb24oXywgJCwgZXhwb3J0cykge1xuICAgICAgLy8gRXhwb3J0IGdsb2JhbCBldmVuIGluIEFNRCBjYXNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIHdpdGhcbiAgICAgIC8vIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgQmFja2JvbmUuXG4gICAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcbiAgICB9KTtcblxuICAvLyBOZXh0IGZvciBOb2RlLmpzIG9yIENvbW1vbkpTLiBqUXVlcnkgbWF5IG5vdCBiZSBuZWVkZWQgYXMgYSBtb2R1bGUuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgZmFjdG9yeShyb290LCBleHBvcnRzLCBfKTtcblxuICAvLyBGaW5hbGx5LCBhcyBhIGJyb3dzZXIgZ2xvYmFsLlxuICB9IGVsc2Uge1xuICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIHt9LCByb290Ll8sIChyb290LmpRdWVyeSB8fCByb290LlplcHRvIHx8IHJvb3QuZW5kZXIgfHwgcm9vdC4kKSk7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXywgJCkge1xuXG4gIC8vIEluaXRpYWwgU2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgbG9jYWwgcmVmZXJlbmNlcyB0byBhcnJheSBtZXRob2RzIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgYXJyYXkgPSBbXTtcbiAgdmFyIHB1c2ggPSBhcnJheS5wdXNoO1xuICB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiAgdmFyIHNwbGljZSA9IGFycmF5LnNwbGljZTtcblxuICAvLyBDdXJyZW50IHZlcnNpb24gb2YgdGhlIGxpYnJhcnkuIEtlZXAgaW4gc3luYyB3aXRoIGBwYWNrYWdlLmpzb25gLlxuICBCYWNrYm9uZS5WRVJTSU9OID0gJzEuMS4yJztcblxuICAvLyBGb3IgQmFja2JvbmUncyBwdXJwb3NlcywgalF1ZXJ5LCBaZXB0bywgRW5kZXIsIG9yIE15IExpYnJhcnkgKGtpZGRpbmcpIG93bnNcbiAgLy8gdGhlIGAkYCB2YXJpYWJsZS5cbiAgQmFja2JvbmUuJCA9ICQ7XG5cbiAgLy8gUnVucyBCYWNrYm9uZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlXG4gIC8vIHRvIGl0cyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIEJhY2tib25lIG9iamVjdC5cbiAgQmFja2JvbmUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuQmFja2JvbmUgPSBwcmV2aW91c0JhY2tib25lO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVIVFRQYCB0byBzdXBwb3J0IGxlZ2FjeSBIVFRQIHNlcnZlcnMuIFNldHRpbmcgdGhpcyBvcHRpb25cbiAgLy8gd2lsbCBmYWtlIGBcIlBBVENIXCJgLCBgXCJQVVRcImAgYW5kIGBcIkRFTEVURVwiYCByZXF1ZXN0cyB2aWEgdGhlIGBfbWV0aG9kYCBwYXJhbWV0ZXIgYW5kXG4gIC8vIHNldCBhIGBYLUh0dHAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gIEJhY2tib25lLmVtdWxhdGVIVFRQID0gZmFsc2U7XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUpTT05gIHRvIHN1cHBvcnQgbGVnYWN5IHNlcnZlcnMgdGhhdCBjYW4ndCBkZWFsIHdpdGggZGlyZWN0XG4gIC8vIGBhcHBsaWNhdGlvbi9qc29uYCByZXF1ZXN0cyAuLi4gd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gIC8vIGZvcm0gcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBhbiBldmVudDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHtcblxuICAgIC8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbiAgICAvLyB0aGUgY2FsbGJhY2sgdG8gYWxsIGV2ZW50cyBmaXJlZC5cbiAgICBvbjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbicsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pIHx8ICFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwgKHRoaXMuX2V2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgIGV2ZW50cy5wdXNoKHtjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCB0aGlzfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBvbmx5IGJlIHRyaWdnZXJlZCBhIHNpbmdsZSB0aW1lLiBBZnRlciB0aGUgZmlyc3QgdGltZVxuICAgIC8vIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkLCBpdCB3aWxsIGJlIHJlbW92ZWQuXG4gICAgb25jZTogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbmNlJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBvbmNlID0gXy5vbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLm9mZihuYW1lLCBvbmNlKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIG9uY2UsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgb25lIG9yIG1hbnkgY2FsbGJhY2tzLiBJZiBgY29udGV4dGAgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3Mgd2l0aCB0aGF0IGZ1bmN0aW9uLiBJZiBgY2FsbGJhY2tgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gICAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAgIC8vIGNhbGxiYWNrcyBmb3IgYWxsIGV2ZW50cy5cbiAgICBvZmY6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmV0YWluLCBldiwgZXZlbnRzLCBuYW1lcywgaSwgbCwgaiwgaztcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICFldmVudHNBcGkodGhpcywgJ29mZicsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcbiAgICAgIGlmICghbGlzdGVuaW5nVG8pIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHJlbW92ZSA9ICFuYW1lICYmICFjYWxsYmFjaztcbiAgICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBpZiAob2JqKSAobGlzdGVuaW5nVG8gPSB7fSlbb2JqLl9saXN0ZW5JZF0gPSBvYmo7XG4gICAgICBmb3IgKHZhciBpZCBpbiBsaXN0ZW5pbmdUbykge1xuICAgICAgICBvYmogPSBsaXN0ZW5pbmdUb1tpZF07XG4gICAgICAgIG9iai5vZmYobmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgICBpZiAocmVtb3ZlIHx8IF8uaXNFbXB0eShvYmouX2V2ZW50cykpIGRlbGV0ZSB0aGlzLl9saXN0ZW5pbmdUb1tpZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgfTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuICAvLyBJbXBsZW1lbnQgZmFuY3kgZmVhdHVyZXMgb2YgdGhlIEV2ZW50cyBBUEkgc3VjaCBhcyBtdWx0aXBsZSBldmVudFxuICAvLyBuYW1lcyBgXCJjaGFuZ2UgYmx1clwiYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50IG1hcHMgYHtjaGFuZ2U6IGFjdGlvbn1gXG4gIC8vIGluIHRlcm1zIG9mIHRoZSBleGlzdGluZyBBUEkuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihvYmosIGFjdGlvbiwgbmFtZSwgcmVzdCkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtrZXksIG5hbWVba2V5XV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3BhY2Ugc2VwYXJhdGVkIGV2ZW50IG5hbWVzLlxuICAgIGlmIChldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtuYW1lc1tpXV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBBIGRpZmZpY3VsdC10by1iZWxpZXZlLCBidXQgb3B0aW1pemVkIGludGVybmFsIGRpc3BhdGNoIGZ1bmN0aW9uIGZvclxuICAvLyB0cmlnZ2VyaW5nIGV2ZW50cy4gVHJpZXMgdG8ga2VlcCB0aGUgdXN1YWwgY2FzZXMgc3BlZWR5IChtb3N0IGludGVybmFsXG4gIC8vIEJhY2tib25lIGV2ZW50cyBoYXZlIDMgYXJndW1lbnRzKS5cbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihldmVudHMsIGFyZ3MpIHtcbiAgICB2YXIgZXYsIGkgPSAtMSwgbCA9IGV2ZW50cy5sZW5ndGgsIGExID0gYXJnc1swXSwgYTIgPSBhcmdzWzFdLCBhMyA9IGFyZ3NbMl07XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCk7IHJldHVybjtcbiAgICAgIGNhc2UgMTogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExKTsgcmV0dXJuO1xuICAgICAgY2FzZSAyOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyKTsgcmV0dXJuO1xuICAgICAgY2FzZSAzOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyLCBhMyk7IHJldHVybjtcbiAgICAgIGRlZmF1bHQ6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmFwcGx5KGV2LmN0eCwgYXJncyk7IHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgbGlzdGVuaW5nVG9baWRdID0gb2JqO1xuICAgICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIGNhbGxiYWNrID0gdGhpcztcbiAgICAgIG9ialtpbXBsZW1lbnRhdGlvbl0obmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIEV2ZW50cy5iaW5kICAgPSBFdmVudHMub247XG4gIEV2ZW50cy51bmJpbmQgPSBFdmVudHMub2ZmO1xuXG4gIC8vIEFsbG93IHRoZSBgQmFja2JvbmVgIG9iamVjdCB0byBzZXJ2ZSBhcyBhIGdsb2JhbCBldmVudCBidXMsIGZvciBmb2xrcyB3aG9cbiAgLy8gd2FudCBnbG9iYWwgXCJwdWJzdWJcIiBpbiBhIGNvbnZlbmllbnQgcGxhY2UuXG4gIF8uZXh0ZW5kKEJhY2tib25lLCBFdmVudHMpO1xuXG4gIC8vIEJhY2tib25lLk1vZGVsXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgKipNb2RlbHMqKiBhcmUgdGhlIGJhc2ljIGRhdGEgb2JqZWN0IGluIHRoZSBmcmFtZXdvcmsgLS1cbiAgLy8gZnJlcXVlbnRseSByZXByZXNlbnRpbmcgYSByb3cgaW4gYSB0YWJsZSBpbiBhIGRhdGFiYXNlIG9uIHlvdXIgc2VydmVyLlxuICAvLyBBIGRpc2NyZXRlIGNodW5rIG9mIGRhdGEgYW5kIGEgYnVuY2ggb2YgdXNlZnVsLCByZWxhdGVkIG1ldGhvZHMgZm9yXG4gIC8vIHBlcmZvcm1pbmcgY29tcHV0YXRpb25zIGFuZCB0cmFuc2Zvcm1hdGlvbnMgb24gdGhhdCBkYXRhLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcy4gQSBjbGllbnQgaWQgKGBjaWRgKVxuICAvLyBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBhbmQgYXNzaWduZWQgZm9yIHlvdS5cbiAgdmFyIE1vZGVsID0gQmFja2JvbmUuTW9kZWwgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgnYycpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSk7XG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICBfLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgbW9kZWwncyBgYXR0cmlidXRlc2Agb2JqZWN0LlxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQgLS0gYnV0IG92ZXJyaWRlIHRoaXMgaWYgeW91IG5lZWRcbiAgICAvLyBjdXN0b20gc3luY2luZyBzZW1hbnRpY3MgZm9yICp0aGlzKiBwYXJ0aWN1bGFyIG1vZGVsLlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZ2V0OiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIEhUTUwtZXNjYXBlZCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZXNjYXBlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gXy5lc2NhcGUodGhpcy5nZXQoYXR0cikpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgbnVsbFxuICAgIC8vIG9yIHVuZGVmaW5lZC5cbiAgICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChhdHRyKSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gVGhpcyBpc1xuICAgIC8vIHRoZSBjb3JlIHByaW1pdGl2ZSBvcGVyYXRpb24gb2YgYSBtb2RlbCwgdXBkYXRpbmcgdGhlIGRhdGEgYW5kIG5vdGlmeWluZ1xuICAgIC8vIGFueW9uZSB3aG8gbmVlZHMgdG8ga25vdyBhYm91dCB0aGUgY2hhbmdlIGluIHN0YXRlLiBUaGUgaGVhcnQgb2YgdGhlIGJlYXN0LlxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRyLCBhdHRycywgdW5zZXQsIGNoYW5nZXMsIHNpbGVudCwgY2hhbmdpbmcsIHByZXYsIGN1cnJlbnQ7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgdW5zZXQgICAgICAgICAgID0gb3B0aW9ucy51bnNldDtcbiAgICAgIHNpbGVudCAgICAgICAgICA9IG9wdGlvbnMuc2lsZW50O1xuICAgICAgY2hhbmdlcyAgICAgICAgID0gW107XG4gICAgICBjaGFuZ2luZyAgICAgICAgPSB0aGlzLl9jaGFuZ2luZztcbiAgICAgIHRoaXMuX2NoYW5naW5nICA9IHRydWU7XG5cbiAgICAgIGlmICghY2hhbmdpbmcpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzID0gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSB0aGlzLmF0dHJpYnV0ZXMsIHByZXYgPSB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXM7XG5cbiAgICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIG9mIGBpZGAuXG4gICAgICBpZiAodGhpcy5pZEF0dHJpYnV0ZSBpbiBhdHRycykgdGhpcy5pZCA9IGF0dHJzW3RoaXMuaWRBdHRyaWJ1dGVdO1xuXG4gICAgICAvLyBGb3IgZWFjaCBgc2V0YCBhdHRyaWJ1dGUsIHVwZGF0ZSBvciBkZWxldGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgdmFsID0gYXR0cnNbYXR0cl07XG4gICAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jaGFuZ2VkW2F0dHJdO1xuICAgICAgICB9XG4gICAgICAgIHVuc2V0ID8gZGVsZXRlIGN1cnJlbnRbYXR0cl0gOiBjdXJyZW50W2F0dHJdID0gdmFsO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gWW91IG1pZ2h0IGJlIHdvbmRlcmluZyB3aHkgdGhlcmUncyBhIGB3aGlsZWAgbG9vcCBoZXJlLiBDaGFuZ2VzIGNhblxuICAgICAgLy8gYmUgcmVjdXJzaXZlbHkgbmVzdGVkIHdpdGhpbiBgXCJjaGFuZ2VcImAgZXZlbnRzLlxuICAgICAgaWYgKGNoYW5naW5nKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BlbmRpbmc7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gYHVuc2V0YCBpcyBhIG5vb3BcbiAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3QuXG4gICAgdW5zZXQ6IGZ1bmN0aW9uKGF0dHIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRyLCB2b2lkIDAsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIENsZWFyIGFsbCBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC5cbiAgICBjbGVhcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSBhdHRyc1trZXldID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJzLCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3Vuc2V0OiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAvLyBJZiB5b3Ugc3BlY2lmeSBhbiBhdHRyaWJ1dGUgbmFtZSwgZGV0ZXJtaW5lIGlmIHRoYXQgYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxuICAgIGhhc0NoYW5nZWQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwpIHJldHVybiAhXy5pc0VtcHR5KHRoaXMuY2hhbmdlZCk7XG4gICAgICByZXR1cm4gXy5oYXModGhpcy5jaGFuZ2VkLCBhdHRyKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZCwgb3JcbiAgICAvLyBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlZCBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXRcbiAgICAvLyBwYXJ0cyBvZiBhIHZpZXcgbmVlZCB0byBiZSB1cGRhdGVkIGFuZC9vciB3aGF0IGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgIC8vIHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLiBVbnNldCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0byBkaWZmIGFnYWluc3QgdGhlIG1vZGVsLFxuICAgIC8vIGRldGVybWluaW5nIGlmIHRoZXJlICp3b3VsZCBiZSogYSBjaGFuZ2UuXG4gICAgY2hhbmdlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZikgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZCgpID8gXy5jbG9uZSh0aGlzLmNoYW5nZWQpIDogZmFsc2U7XG4gICAgICB2YXIgdmFsLCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgb2xkID0gdGhpcy5fY2hhbmdpbmcgPyB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgOiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgaWYgKF8uaXNFcXVhbChvbGRbYXR0cl0sICh2YWwgPSBkaWZmW2F0dHJdKSkpIGNvbnRpbnVlO1xuICAgICAgICAoY2hhbmdlZCB8fCAoY2hhbmdlZCA9IHt9KSlbYXR0cl0gPSB2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUsIHJlY29yZGVkIGF0IHRoZSB0aW1lIHRoZSBsYXN0XG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50IHdhcyBmaXJlZC5cbiAgICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCB8fCAhdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudC5cbiAgICBwcmV2aW91c0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlci4gSWYgdGhlIHNlcnZlcidzIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgIC8vIG1vZGVsIGRpZmZlcnMgZnJvbSBpdHMgY3VycmVudCBhdHRyaWJ1dGVzLCB0aGV5IHdpbGwgYmUgb3ZlcnJpZGRlbixcbiAgICAvLyB0cmlnZ2VyaW5nIGEgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAoIW1vZGVsLnNldChtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSwgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzLCBhbmQgc3luYyB0aGUgbW9kZWwgdG8gdGhlIHNlcnZlci5cbiAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybnMgYW4gYXR0cmlidXRlcyBoYXNoIHRoYXQgZGlmZmVycywgdGhlIG1vZGVsJ3NcbiAgICAvLyBzdGF0ZSB3aWxsIGJlIGBzZXRgIGFnYWluLlxuICAgIHNhdmU6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMsIG1ldGhvZCwgeGhyLCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7dmFsaWRhdGU6IHRydWV9LCBvcHRpb25zKTtcblxuICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgYW5kIGF0dHJpYnV0ZXMgZXhpc3QsIHNhdmUgYWN0cyBhc1xuICAgICAgLy8gYHNldChhdHRyKS5zYXZlKG51bGwsIG9wdHMpYCB3aXRoIHZhbGlkYXRpb24uIE90aGVyd2lzZSwgY2hlY2sgaWZcbiAgICAgIC8vIHRoZSBtb2RlbCB3aWxsIGJlIHZhbGlkIHdoZW4gdGhlIGF0dHJpYnV0ZXMsIGlmIGFueSwgYXJlIHNldC5cbiAgICAgIGlmIChhdHRycyAmJiAhb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIGlmICghdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGVtcG9yYXJ5IGF0dHJpYnV0ZXMgaWYgYHt3YWl0OiB0cnVlfWAuXG4gICAgICBpZiAoYXR0cnMgJiYgb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IF8uZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzZXJ2ZXItc2lkZSBzYXZlLCB0aGUgY2xpZW50IGlzIChvcHRpb25hbGx5KVxuICAgICAgLy8gdXBkYXRlZCB3aXRoIHRoZSBzZXJ2ZXItc2lkZSBzdGF0ZS5cbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQpIHNlcnZlckF0dHJzID0gXy5leHRlbmQoYXR0cnMgfHwge30sIHNlcnZlckF0dHJzKTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3Qoc2VydmVyQXR0cnMpICYmICFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgeGhyID0gdGhpcy5zeW5jKG1ldGhvZCwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cbiAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyIGlmIGl0IHdhcyBhbHJlYWR5IHBlcnNpc3RlZC5cbiAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmVzIHRoZSBtb2RlbCBmcm9tIGl0cyBjb2xsZWN0aW9uLCBpZiBpdCBoYXMgb25lLlxuICAgIC8vIElmIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIHdhaXRzIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgYmVmb3JlIHJlbW92YWwuXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Rlc3Ryb3knLCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQgfHwgbW9kZWwuaXNOZXcoKSkgZGVzdHJveSgpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghbW9kZWwuaXNOZXcoKSkgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgdmFyIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMud2FpdCkgZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBVUkwgZm9yIHRoZSBtb2RlbCdzIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzZXJ2ZXIgLS0gaWYgeW91J3JlXG4gICAgLy8gdXNpbmcgQmFja2JvbmUncyByZXN0ZnVsIG1ldGhvZHMsIG92ZXJyaWRlIHRoaXMgdG8gY2hhbmdlIHRoZSBlbmRwb2ludFxuICAgIC8vIHRoYXQgd2lsbCBiZSBjYWxsZWQuXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlID1cbiAgICAgICAgXy5yZXN1bHQodGhpcywgJ3VybFJvb3QnKSB8fFxuICAgICAgICBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fFxuICAgICAgICB1cmxFcnJvcigpO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkgcmV0dXJuIGJhc2U7XG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC8oW15cXC9dKSQvLCAnJDEvJykgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pZCk7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gdGhlIGhhc2ggb2YgYXR0cmlidXRlcyB0byBiZSBgc2V0YCBvblxuICAgIC8vIHRoZSBtb2RlbC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIHRoZSByZXNwb25zZSBhbG9uZy5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBBIG1vZGVsIGlzIG5ldyBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzYXZlZCB0byB0aGUgc2VydmVyLCBhbmQgbGFja3MgYW4gaWQuXG4gICAgaXNOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhcyh0aGlzLmlkQXR0cmlidXRlKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG1vZGVsIGlzIGN1cnJlbnRseSBpbiBhIHZhbGlkIHN0YXRlLlxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh7fSwgXy5leHRlbmQob3B0aW9ucyB8fCB7fSwgeyB2YWxpZGF0ZTogdHJ1ZSB9KSk7XG4gICAgfSxcblxuICAgIC8vIFJ1biB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIG5leHQgY29tcGxldGUgc2V0IG9mIG1vZGVsIGF0dHJpYnV0ZXMsXG4gICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXG4gICAgX3ZhbGlkYXRlOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLnZhbGlkYXRlIHx8ICF0aGlzLnZhbGlkYXRlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGF0dHJzID0gXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xuICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSB8fCBudWxsO1xuICAgICAgaWYgKCFlcnJvcikgcmV0dXJuIHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBlcnJvciwgXy5leHRlbmQob3B0aW9ucywge3ZhbGlkYXRpb25FcnJvcjogZXJyb3J9KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBNb2RlbC5cbiAgdmFyIG1vZGVsTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAncGFpcnMnLCAnaW52ZXJ0JywgJ3BpY2snLCAnb21pdCddO1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICBfLmVhY2gobW9kZWxNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBNb2RlbC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuQ29sbGVjdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSWYgbW9kZWxzIHRlbmQgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHJvdyBvZiBkYXRhLCBhIEJhY2tib25lIENvbGxlY3Rpb24gaXNcbiAgLy8gbW9yZSBhbmFsYWdvdXMgdG8gYSB0YWJsZSBmdWxsIG9mIGRhdGEgLi4uIG9yIGEgc21hbGwgc2xpY2Ugb3IgcGFnZSBvZiB0aGF0XG4gIC8vIHRhYmxlLCBvciBhIGNvbGxlY3Rpb24gb2Ygcm93cyB0aGF0IGJlbG9uZyB0b2dldGhlciBmb3IgYSBwYXJ0aWN1bGFyIHJlYXNvblxuICAvLyAtLSBhbGwgb2YgdGhlIG1lc3NhZ2VzIGluIHRoaXMgcGFydGljdWxhciBmb2xkZXIsIGFsbCBvZiB0aGUgZG9jdW1lbnRzXG4gIC8vIGJlbG9uZ2luZyB0byB0aGlzIHBhcnRpY3VsYXIgYXV0aG9yLCBhbmQgc28gb24uIENvbGxlY3Rpb25zIG1haW50YWluXG4gIC8vIGluZGV4ZXMgb2YgdGhlaXIgbW9kZWxzLCBib3RoIGluIG9yZGVyLCBhbmQgZm9yIGxvb2t1cCBieSBgaWRgLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyAqKkNvbGxlY3Rpb24qKiwgcGVyaGFwcyB0byBjb250YWluIGEgc3BlY2lmaWMgdHlwZSBvZiBgbW9kZWxgLlxuICAvLyBJZiBhIGBjb21wYXJhdG9yYCBpcyBzcGVjaWZpZWQsIHRoZSBDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cbiAgLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxuICB2YXIgQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24gPSBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLm1vZGVsKSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yICE9PSB2b2lkIDApIHRoaXMuY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvcjtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChtb2RlbHMpIHRoaXMucmVzZXQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIC8vIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbGxlY3Rpb24jc2V0YC5cbiAgdmFyIHNldE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IHRydWUsIG1lcmdlOiB0cnVlfTtcbiAgdmFyIGFkZE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IGZhbHNlfTtcblxuICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSAqKkJhY2tib25lLk1vZGVsKiouXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgIG1vZGVsOiBNb2RlbCxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC5cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5leHRlbmQoe21lcmdlOiBmYWxzZX0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwsIG9yIGEgbGlzdCBvZiBtb2RlbHMgZnJvbSB0aGUgc2V0LlxuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogXy5jbG9uZShtb2RlbHMpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIHZhciBpLCBsLCBpbmRleCwgbW9kZWw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXSA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleE9mKG1vZGVsKTtcbiAgICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGEgY29sbGVjdGlvbiBieSBgc2V0YC1pbmcgYSBuZXcgbGlzdCBvZiBtb2RlbHMsIGFkZGluZyBuZXcgb25lcyxcbiAgICAvLyByZW1vdmluZyBtb2RlbHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQsIGFuZCBtZXJnaW5nIG1vZGVscyB0aGF0XG4gICAgLy8gYWxyZWFkeSBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgYXMgbmVjZXNzYXJ5LiBTaW1pbGFyIHRvICoqTW9kZWwjc2V0KiosXG4gICAgLy8gdGhlIGNvcmUgb3BlcmF0aW9uIGZvciB1cGRhdGluZyB0aGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IChtb2RlbHMgPyBbbW9kZWxzXSA6IFtdKSA6IF8uY2xvbmUobW9kZWxzKTtcbiAgICAgIHZhciBpLCBsLCBpZCwgbW9kZWwsIGF0dHJzLCBleGlzdGluZywgc29ydDtcbiAgICAgIHZhciBhdCA9IG9wdGlvbnMuYXQ7XG4gICAgICB2YXIgdGFyZ2V0TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIHNvcnRhYmxlID0gdGhpcy5jb21wYXJhdG9yICYmIChhdCA9PSBudWxsKSAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlO1xuICAgICAgdmFyIHNvcnRBdHRyID0gXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpID8gdGhpcy5jb21wYXJhdG9yIDogbnVsbDtcbiAgICAgIHZhciB0b0FkZCA9IFtdLCB0b1JlbW92ZSA9IFtdLCBtb2RlbE1hcCA9IHt9O1xuICAgICAgdmFyIGFkZCA9IG9wdGlvbnMuYWRkLCBtZXJnZSA9IG9wdGlvbnMubWVyZ2UsIHJlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuICAgICAgdmFyIG9yZGVyID0gIXNvcnRhYmxlICYmIGFkZCAmJiByZW1vdmUgPyBbXSA6IGZhbHNlO1xuXG4gICAgICAvLyBUdXJuIGJhcmUgb2JqZWN0cyBpbnRvIG1vZGVsIHJlZmVyZW5jZXMsIGFuZCBwcmV2ZW50IGludmFsaWQgbW9kZWxzXG4gICAgICAvLyBmcm9tIGJlaW5nIGFkZGVkLlxuICAgICAgZm9yIChpID0gMCwgbCA9IG1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYXR0cnMgPSBtb2RlbHNbaV0gfHwge307XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgaWQgPSBtb2RlbCA9IGF0dHJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkID0gYXR0cnNbdGFyZ2V0TW9kZWwucHJvdG90eXBlLmlkQXR0cmlidXRlIHx8ICdpZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBkdXBsaWNhdGUgaXMgZm91bmQsIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBhbmRcbiAgICAgICAgLy8gb3B0aW9uYWxseSBtZXJnZSBpdCBpbnRvIHRoZSBleGlzdGluZyBtb2RlbC5cbiAgICAgICAgaWYgKGV4aXN0aW5nID0gdGhpcy5nZXQoaWQpKSB7XG4gICAgICAgICAgaWYgKHJlbW92ZSkgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICBhdHRycyA9IGF0dHJzID09PSBtb2RlbCA/IG1vZGVsLmF0dHJpYnV0ZXMgOiBhdHRycztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IGV4aXN0aW5nLnBhcnNlKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGV4aXN0aW5nLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc29ydGFibGUgJiYgIXNvcnQgJiYgZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cikpIHNvcnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3LCB2YWxpZCBtb2RlbCwgcHVzaCBpdCB0byB0aGUgYHRvQWRkYCBsaXN0LlxuICAgICAgICB9IGVsc2UgaWYgKGFkZCkge1xuICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcbiAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IGFkZCBtdWx0aXBsZSBtb2RlbHMgd2l0aCB0aGUgc2FtZSBgaWRgLlxuICAgICAgICBtb2RlbCA9IGV4aXN0aW5nIHx8IG1vZGVsO1xuICAgICAgICBpZiAob3JkZXIgJiYgKG1vZGVsLmlzTmV3KCkgfHwgIW1vZGVsTWFwW21vZGVsLmlkXSkpIG9yZGVyLnB1c2gobW9kZWwpO1xuICAgICAgICBtb2RlbE1hcFttb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgbm9uZXhpc3RlbnQgbW9kZWxzIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBpZiAoIW1vZGVsTWFwWyhtb2RlbCA9IHRoaXMubW9kZWxzW2ldKS5jaWRdKSB0b1JlbW92ZS5wdXNoKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLnJlbW92ZSh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKHNvcnRhYmxlKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gdG9BZGQubGVuZ3RoO1xuICAgICAgICBpZiAoYXQgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b0FkZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShhdCArIGksIDAsIHRvQWRkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9yZGVyKSB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xuICAgICAgICAgIHZhciBvcmRlcmVkTW9kZWxzID0gb3JkZXIgfHwgdG9BZGQ7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9yZGVyZWRNb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5wdXNoKG9yZGVyZWRNb2RlbHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTaWxlbnRseSBzb3J0IHRoZSBjb2xsZWN0aW9uIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHNvcnQpIHRoaXMuc29ydCh7c2lsZW50OiB0cnVlfSk7XG5cbiAgICAgIC8vIFVubGVzcyBzaWxlbmNlZCwgaXQncyB0aW1lIHRvIGZpcmUgYWxsIGFwcHJvcHJpYXRlIGFkZC9zb3J0IGV2ZW50cy5cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRvQWRkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIChtb2RlbCA9IHRvQWRkW2ldKS50cmlnZ2VyKCdhZGQnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnQgfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgLy8gYW55IGdyYW51bGFyIGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIG1vZGVscyA9IHRoaXMuYWRkKG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcHVzaDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiB0aGlzLmxlbmd0aH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogMH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHNoaWZ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KDApO1xuICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHJldHVybiB0aGlzLl9ieUlkW29ial0gfHwgdGhpcy5fYnlJZFtvYmouaWRdIHx8IHRoaXMuX2J5SWRbb2JqLmNpZF07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWxzW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIG1vZGVscyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzIG9mXG4gICAgLy8gYGZpbHRlcmAuXG4gICAgd2hlcmU6IGZ1bmN0aW9uKGF0dHJzLCBmaXJzdCkge1xuICAgICAgaWYgKF8uaXNFbXB0eShhdHRycykpIHJldHVybiBmaXJzdCA/IHZvaWQgMCA6IFtdO1xuICAgICAgcmV0dXJuIHRoaXNbZmlyc3QgPyAnZmluZCcgOiAnZmlsdGVyJ10oZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG1vZGVsLmdldChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RlbCB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzXG4gICAgLy8gb2YgYGZpbmRgLlxuICAgIGZpbmRXaGVyZTogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKGF0dHJzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gRm9yY2UgdGhlIGNvbGxlY3Rpb24gdG8gcmUtc29ydCBpdHNlbGYuIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyB1bmRlclxuICAgIC8vIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBhcyB0aGUgc2V0IHdpbGwgbWFpbnRhaW4gc29ydCBvcmRlciBhcyBlYWNoIGl0ZW1cbiAgICAvLyBpcyBhZGRlZC5cbiAgICBzb3J0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcGFyYXRvcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc29ydCBhIHNldCB3aXRob3V0IGEgY29tcGFyYXRvcicpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgICBpZiAoXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpIHx8IHRoaXMuY29tcGFyYXRvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLnNvcnRCeSh0aGlzLmNvbXBhcmF0b3IsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2RlbHMuc29ydChfLmJpbmQodGhpcy5jb21wYXJhdG9yLCB0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFBsdWNrIGFuIGF0dHJpYnV0ZSBmcm9tIGVhY2ggbW9kZWwgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmludm9rZSh0aGlzLm1vZGVscywgJ2dldCcsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgZGVmYXVsdCBzZXQgb2YgbW9kZWxzIGZvciB0aGlzIGNvbGxlY3Rpb24sIHJlc2V0dGluZyB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIHdoZW4gdGhleSBhcnJpdmUuIElmIGByZXNldDogdHJ1ZWAgaXMgcGFzc2VkLCB0aGUgcmVzcG9uc2VcbiAgICAvLyBkYXRhIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdGhlIGByZXNldGAgbWV0aG9kIGluc3RlYWQgb2YgYHNldGAuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMucmVzZXQgPyAncmVzZXQnIDogJ3NldCc7XG4gICAgICAgIGNvbGxlY3Rpb25bbWV0aG9kXShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MoY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcignc3luYycsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgbW9kZWwgaW4gdGhpcyBjb2xsZWN0aW9uLiBBZGQgdGhlIG1vZGVsIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gaW1tZWRpYXRlbHksIHVubGVzcyBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgLy8gd2FpdCBmb3IgdGhlIHNlcnZlciB0byBhZ3JlZS5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGlmICghKG1vZGVsID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucy53YWl0KSB0aGlzLmFkZChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKG1vZGVsLCByZXNwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQpIGNvbGxlY3Rpb24uYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1vZGVscyk7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgfSxcblxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgLy8gY29sbGVjdGlvbi5cbiAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKGF0dHJzIGluc3RhbmNlb2YgTW9kZWwpIHJldHVybiBhdHRycztcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKSByZXR1cm4gbW9kZWw7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBtb2RlbC52YWxpZGF0aW9uRXJyb3IsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICBpZiAobW9kZWwuaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcbiAgICAgIGlmICghbW9kZWwuY29sbGVjdGlvbikgbW9kZWwuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBtb2RlbC5vbignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldmVyIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfcmVtb3ZlUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgICAgbW9kZWwub2ZmKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2RlbCBpbiB0aGUgc2V0IGZpcmVzIGFuIGV2ZW50LlxuICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcbiAgICAvLyBldmVudHMgc2ltcGx5IHByb3h5IHRocm91Z2guIFwiYWRkXCIgYW5kIFwicmVtb3ZlXCIgZXZlbnRzIHRoYXQgb3JpZ2luYXRlXG4gICAgLy8gaW4gb3RoZXIgY29sbGVjdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ3JlbW92ZScpICYmIGNvbGxlY3Rpb24gIT09IHRoaXMpIHJldHVybjtcbiAgICAgIGlmIChldmVudCA9PT0gJ2Rlc3Ryb3knKSB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAobW9kZWwgJiYgZXZlbnQgPT09ICdjaGFuZ2U6JyArIG1vZGVsLmlkQXR0cmlidXRlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLnByZXZpb3VzKG1vZGVsLmlkQXR0cmlidXRlKV07XG4gICAgICAgIGlmIChtb2RlbC5pZCAhPSBudWxsKSB0aGlzLl9ieUlkW21vZGVsLmlkXSA9IG1vZGVsO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBDb2xsZWN0aW9uLlxuICAvLyA5MCUgb2YgdGhlIGNvcmUgdXNlZnVsbmVzcyBvZiBCYWNrYm9uZSBDb2xsZWN0aW9ucyBpcyBhY3R1YWxseSBpbXBsZW1lbnRlZFxuICAvLyByaWdodCBoZXJlOlxuICB2YXIgbWV0aG9kcyA9IFsnZm9yRWFjaCcsICdlYWNoJywgJ21hcCcsICdjb2xsZWN0JywgJ3JlZHVjZScsICdmb2xkbCcsXG4gICAgJ2luamVjdCcsICdyZWR1Y2VSaWdodCcsICdmb2xkcicsICdmaW5kJywgJ2RldGVjdCcsICdmaWx0ZXInLCAnc2VsZWN0JyxcbiAgICAncmVqZWN0JywgJ2V2ZXJ5JywgJ2FsbCcsICdzb21lJywgJ2FueScsICdpbmNsdWRlJywgJ2NvbnRhaW5zJywgJ2ludm9rZScsXG4gICAgJ21heCcsICdtaW4nLCAndG9BcnJheScsICdzaXplJywgJ2ZpcnN0JywgJ2hlYWQnLCAndGFrZScsICdpbml0aWFsJywgJ3Jlc3QnLFxuICAgICd0YWlsJywgJ2Ryb3AnLCAnbGFzdCcsICd3aXRob3V0JywgJ2RpZmZlcmVuY2UnLCAnaW5kZXhPZicsICdzaHVmZmxlJyxcbiAgICAnbGFzdEluZGV4T2YnLCAnaXNFbXB0eScsICdjaGFpbicsICdzYW1wbGUnXTtcblxuICAvLyBNaXggaW4gZWFjaCBVbmRlcnNjb3JlIG1ldGhvZCBhcyBhIHByb3h5IHRvIGBDb2xsZWN0aW9uI21vZGVsc2AuXG4gIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLm1vZGVscyk7XG4gICAgICByZXR1cm4gX1ttZXRob2RdLmFwcGx5KF8sIGFyZ3MpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHRha2UgYSBwcm9wZXJ0eSBuYW1lIGFzIGFuIGFyZ3VtZW50LlxuICB2YXIgYXR0cmlidXRlTWV0aG9kcyA9IFsnZ3JvdXBCeScsICdjb3VudEJ5JywgJ3NvcnRCeScsICdpbmRleEJ5J107XG5cbiAgLy8gVXNlIGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzLlxuICBfLmVhY2goYXR0cmlidXRlTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWwuZ2V0KHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXMubW9kZWxzLCBpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuVmlld1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgVmlld3MgYXJlIGFsbW9zdCBtb3JlIGNvbnZlbnRpb24gdGhhbiB0aGV5IGFyZSBhY3R1YWwgY29kZS4gQSBWaWV3XG4gIC8vIGlzIHNpbXBseSBhIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGxvZ2ljYWwgY2h1bmsgb2YgVUkgaW4gdGhlXG4gIC8vIERPTS4gVGhpcyBtaWdodCBiZSBhIHNpbmdsZSBpdGVtLCBhbiBlbnRpcmUgbGlzdCwgYSBzaWRlYmFyIG9yIHBhbmVsLCBvclxuICAvLyBldmVuIHRoZSBzdXJyb3VuZGluZyBmcmFtZSB3aGljaCB3cmFwcyB5b3VyIHdob2xlIGFwcC4gRGVmaW5pbmcgYSBjaHVuayBvZlxuICAvLyBVSSBhcyBhICoqVmlldyoqIGFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgRE9NIGV2ZW50cyBkZWNsYXJhdGl2ZWx5LCB3aXRob3V0XG4gIC8vIGhhdmluZyB0byB3b3JyeSBhYm91dCByZW5kZXIgb3JkZXIgLi4uIGFuZCBtYWtlcyBpdCBlYXN5IGZvciB0aGUgdmlldyB0b1xuICAvLyByZWFjdCB0byBzcGVjaWZpYyBjaGFuZ2VzIGluIHRoZSBzdGF0ZSBvZiB5b3VyIG1vZGVscy5cblxuICAvLyBDcmVhdGluZyBhIEJhY2tib25lLlZpZXcgY3JlYXRlcyBpdHMgaW5pdGlhbCBlbGVtZW50IG91dHNpZGUgb2YgdGhlIERPTSxcbiAgLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbiAgdmFyIFZpZXcgPSBCYWNrYm9uZS5WaWV3ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgndmlldycpO1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggdG8gc3BsaXQga2V5cyBmb3IgYGRlbGVnYXRlYC5cbiAgdmFyIGRlbGVnYXRlRXZlbnRTcGxpdHRlciA9IC9eKFxcUyspXFxzKiguKikkLztcblxuICAvLyBMaXN0IG9mIHZpZXcgb3B0aW9ucyB0byBiZSBtZXJnZWQgYXMgcHJvcGVydGllcy5cbiAgdmFyIHZpZXdPcHRpb25zID0gWydtb2RlbCcsICdjb2xsZWN0aW9uJywgJ2VsJywgJ2lkJywgJ2F0dHJpYnV0ZXMnLCAnY2xhc3NOYW1lJywgJ3RhZ05hbWUnLCAnZXZlbnRzJ107XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlZpZXcqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChWaWV3LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBgdGFnTmFtZWAgb2YgYSBWaWV3J3MgZWxlbWVudCBpcyBgXCJkaXZcImAuXG4gICAgdGFnTmFtZTogJ2RpdicsXG5cbiAgICAvLyBqUXVlcnkgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcbiAgICAvLyBjdXJyZW50IHZpZXcuIFRoaXMgc2hvdWxkIGJlIHByZWZlcnJlZCB0byBnbG9iYWwgbG9va3VwcyB3aGVyZSBwb3NzaWJsZS5cbiAgICAkOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyAqKnJlbmRlcioqIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHRoYXQgeW91ciB2aWV3IHNob3VsZCBvdmVycmlkZSwgaW4gb3JkZXJcbiAgICAvLyB0byBwb3B1bGF0ZSBpdHMgZWxlbWVudCAoYHRoaXMuZWxgKSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSFRNTC4gVGhlXG4gICAgLy8gY29udmVudGlvbiBpcyBmb3IgKipyZW5kZXIqKiB0byBhbHdheXMgcmV0dXJuIGB0aGlzYC5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcgYnkgdGFraW5nIHRoZSBlbGVtZW50IG91dCBvZiB0aGUgRE9NLCBhbmQgcmVtb3ZpbmcgYW55XG4gICAgLy8gYXBwbGljYWJsZSBCYWNrYm9uZS5FdmVudHMgbGlzdGVuZXJzLlxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENoYW5nZSB0aGUgdmlldydzIGVsZW1lbnQgKGB0aGlzLmVsYCBwcm9wZXJ0eSksIGluY2x1ZGluZyBldmVudFxuICAgIC8vIHJlLWRlbGVnYXRpb24uXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLiRlbCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWxlbWVudCA6IEJhY2tib25lLiQoZWxlbWVudCk7XG4gICAgICB0aGlzLmVsID0gdGhpcy4kZWxbMF07XG4gICAgICBpZiAoZGVsZWdhdGUgIT09IGZhbHNlKSB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIC8vIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLCBgYmx1cmAsIGFuZFxuICAgIC8vIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGlmICghKGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKSkpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBldmVudHNba2V5XTtcbiAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obWV0aG9kKSkgbWV0aG9kID0gdGhpc1tldmVudHNba2V5XV07XG4gICAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoWzFdLCBzZWxlY3RvciA9IG1hdGNoWzJdO1xuICAgICAgICBtZXRob2QgPSBfLmJpbmQobWV0aG9kLCB0aGlzKTtcbiAgICAgICAgZXZlbnROYW1lICs9ICcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQ7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gJycpIHtcbiAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIG1ldGhvZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kZWwub24oZXZlbnROYW1lLCBzZWxlY3RvciwgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgd2l0aCBgZGVsZWdhdGVFdmVudHNgLlxuICAgIC8vIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBtYXkgd2lzaCB0byBpZiB5b3UgaGF2ZSBtdWx0aXBsZVxuICAgIC8vIEJhY2tib25lIHZpZXdzIGF0dGFjaGVkIHRvIHRoZSBzYW1lIERPTSBlbGVtZW50LlxuICAgIHVuZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcbiAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgICBpZiAodGhpcy5pZCkgYXR0cnMuaWQgPSBfLnJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSBhdHRyc1snY2xhc3MnXSA9IF8ucmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcbiAgICAgICAgdmFyICRlbCA9IEJhY2tib25lLiQoJzwnICsgXy5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKSArICc+JykuYXR0cihhdHRycyk7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCgkZWwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChfLnJlc3VsdCh0aGlzLCAnZWwnKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5zeW5jXG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBPdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGNoYW5nZSB0aGUgbWFubmVyIGluIHdoaWNoIEJhY2tib25lIHBlcnNpc3RzXG4gIC8vIG1vZGVscyB0byB0aGUgc2VydmVyLiBZb3Ugd2lsbCBiZSBwYXNzZWQgdGhlIHR5cGUgb2YgcmVxdWVzdCwgYW5kIHRoZVxuICAvLyBtb2RlbCBpbiBxdWVzdGlvbi4gQnkgZGVmYXVsdCwgbWFrZXMgYSBSRVNUZnVsIEFqYXggcmVxdWVzdFxuICAvLyB0byB0aGUgbW9kZWwncyBgdXJsKClgLiBTb21lIHBvc3NpYmxlIGN1c3RvbWl6YXRpb25zIGNvdWxkIGJlOlxuICAvL1xuICAvLyAqIFVzZSBgc2V0VGltZW91dGAgdG8gYmF0Y2ggcmFwaWQtZmlyZSB1cGRhdGVzIGludG8gYSBzaW5nbGUgcmVxdWVzdC5cbiAgLy8gKiBTZW5kIHVwIHRoZSBtb2RlbHMgYXMgWE1MIGluc3RlYWQgb2YgSlNPTi5cbiAgLy8gKiBQZXJzaXN0IG1vZGVscyB2aWEgV2ViU29ja2V0cyBpbnN0ZWFkIG9mIEFqYXguXG4gIC8vXG4gIC8vIFR1cm4gb24gYEJhY2tib25lLmVtdWxhdGVIVFRQYCBpbiBvcmRlciB0byBzZW5kIGBQVVRgIGFuZCBgREVMRVRFYCByZXF1ZXN0c1xuICAvLyBhcyBgUE9TVGAsIHdpdGggYSBgX21ldGhvZGAgcGFyYW1ldGVyIGNvbnRhaW5pbmcgdGhlIHRydWUgSFRUUCBtZXRob2QsXG4gIC8vIGFzIHdlbGwgYXMgYWxsIHJlcXVlc3RzIHdpdGggdGhlIGJvZHkgYXMgYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGBcbiAgLy8gaW5zdGVhZCBvZiBgYXBwbGljYXRpb24vanNvbmAgd2l0aCB0aGUgbW9kZWwgaW4gYSBwYXJhbSBuYW1lZCBgbW9kZWxgLlxuICAvLyBVc2VmdWwgd2hlbiBpbnRlcmZhY2luZyB3aXRoIHNlcnZlci1zaWRlIGxhbmd1YWdlcyBsaWtlICoqUEhQKiogdGhhdCBtYWtlXG4gIC8vIGl0IGRpZmZpY3VsdCB0byByZWFkIHRoZSBib2R5IG9mIGBQVVRgIHJlcXVlc3RzLlxuICBCYWNrYm9uZS5zeW5jID0gZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gbWV0aG9kTWFwW21ldGhvZF07XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnMsIHVubGVzcyBzcGVjaWZpZWQuXG4gICAgXy5kZWZhdWx0cyhvcHRpb25zIHx8IChvcHRpb25zID0ge30pLCB7XG4gICAgICBlbXVsYXRlSFRUUDogQmFja2JvbmUuZW11bGF0ZUhUVFAsXG4gICAgICBlbXVsYXRlSlNPTjogQmFja2JvbmUuZW11bGF0ZUpTT05cbiAgICB9KTtcblxuICAgIC8vIERlZmF1bHQgSlNPTi1yZXF1ZXN0IG9wdGlvbnMuXG4gICAgdmFyIHBhcmFtcyA9IHt0eXBlOiB0eXBlLCBkYXRhVHlwZTogJ2pzb24nfTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgYSBVUkwuXG4gICAgaWYgKCFvcHRpb25zLnVybCkge1xuICAgICAgcGFyYW1zLnVybCA9IF8ucmVzdWx0KG1vZGVsLCAndXJsJykgfHwgdXJsRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBhcHByb3ByaWF0ZSByZXF1ZXN0IGRhdGEuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSA9PSBudWxsICYmIG1vZGVsICYmIChtZXRob2QgPT09ICdjcmVhdGUnIHx8IG1ldGhvZCA9PT0gJ3VwZGF0ZScgfHwgbWV0aG9kID09PSAncGF0Y2gnKSkge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgcGFyYW1zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmF0dHJzIHx8IG1vZGVsLnRvSlNPTihvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSlNPTiBieSBlbmNvZGluZyB0aGUgcmVxdWVzdCBpbnRvIGFuIEhUTUwtZm9ybS5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICBwYXJhbXMuZGF0YSA9IHBhcmFtcy5kYXRhID8ge21vZGVsOiBwYXJhbXMuZGF0YX0gOiB7fTtcbiAgICB9XG5cbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBIVFRQIGJ5IG1pbWlja2luZyB0aGUgSFRUUCBtZXRob2Qgd2l0aCBgX21ldGhvZGBcbiAgICAvLyBBbmQgYW4gYFgtSFRUUC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSFRUUCAmJiAodHlwZSA9PT0gJ1BVVCcgfHwgdHlwZSA9PT0gJ0RFTEVURScgfHwgdHlwZSA9PT0gJ1BBVENIJykpIHtcbiAgICAgIHBhcmFtcy50eXBlID0gJ1BPU1QnO1xuICAgICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHBhcmFtcy5kYXRhLl9tZXRob2QgPSB0eXBlO1xuICAgICAgdmFyIGJlZm9yZVNlbmQgPSBvcHRpb25zLmJlZm9yZVNlbmQ7XG4gICAgICBvcHRpb25zLmJlZm9yZVNlbmQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnLCB0eXBlKTtcbiAgICAgICAgaWYgKGJlZm9yZVNlbmQpIHJldHVybiBiZWZvcmVTZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIERvbid0IHByb2Nlc3MgZGF0YSBvbiBhIG5vbi1HRVQgcmVxdWVzdC5cbiAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdHRVQnICYmICFvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICBwYXJhbXMucHJvY2Vzc0RhdGEgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBzZW5kaW5nIGEgYFBBVENIYCByZXF1ZXN0LCBhbmQgd2UncmUgaW4gYW4gb2xkIEludGVybmV0IEV4cGxvcmVyXG4gICAgLy8gdGhhdCBzdGlsbCBoYXMgQWN0aXZlWCBlbmFibGVkIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGpRdWVyeSB0byB1c2UgdGhhdFxuICAgIC8vIGZvciBYSFIgaW5zdGVhZC4gUmVtb3ZlIHRoaXMgbGluZSB3aGVuIGpRdWVyeSBzdXBwb3J0cyBgUEFUQ0hgIG9uIElFOC5cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdQQVRDSCcgJiYgbm9YaHJQYXRjaCkge1xuICAgICAgcGFyYW1zLnhociA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgcmVxdWVzdCwgYWxsb3dpbmcgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgYW55IEFqYXggb3B0aW9ucy5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgPSBCYWNrYm9uZS5hamF4KF8uZXh0ZW5kKHBhcmFtcywgb3B0aW9ucykpO1xuICAgIG1vZGVsLnRyaWdnZXIoJ3JlcXVlc3QnLCBtb2RlbCwgeGhyLCBvcHRpb25zKTtcbiAgICByZXR1cm4geGhyO1xuICB9O1xuXG4gIHZhciBub1hoclBhdGNoID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmXG4gICAgICAhKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAobmV3IFhNTEh0dHBSZXF1ZXN0KS5kaXNwYXRjaEV2ZW50KTtcblxuICAvLyBNYXAgZnJvbSBDUlVEIHRvIEhUVFAgZm9yIG91ciBkZWZhdWx0IGBCYWNrYm9uZS5zeW5jYCBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIG1ldGhvZE1hcCA9IHtcbiAgICAnY3JlYXRlJzogJ1BPU1QnLFxuICAgICd1cGRhdGUnOiAnUFVUJyxcbiAgICAncGF0Y2gnOiAgJ1BBVENIJyxcbiAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgJ3JlYWQnOiAgICdHRVQnXG4gIH07XG5cbiAgLy8gU2V0IHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBCYWNrYm9uZS5hamF4YCB0byBwcm94eSB0aHJvdWdoIHRvIGAkYC5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBpZiB5b3UnZCBsaWtlIHRvIHVzZSBhIGRpZmZlcmVudCBsaWJyYXJ5LlxuICBCYWNrYm9uZS5hamF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJhY2tib25lLiQuYWpheC5hcHBseShCYWNrYm9uZS4kLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEJhY2tib25lLlJvdXRlclxuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSb3V0ZXJzIG1hcCBmYXV4LVVSTHMgdG8gYWN0aW9ucywgYW5kIGZpcmUgZXZlbnRzIHdoZW4gcm91dGVzIGFyZVxuICAvLyBtYXRjaGVkLiBDcmVhdGluZyBhIG5ldyBvbmUgc2V0cyBpdHMgYHJvdXRlc2AgaGFzaCwgaWYgbm90IHNldCBzdGF0aWNhbGx5LlxuICB2YXIgUm91dGVyID0gQmFja2JvbmUuUm91dGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgaWYgKG9wdGlvbnMucm91dGVzKSB0aGlzLnJvdXRlcyA9IG9wdGlvbnMucm91dGVzO1xuICAgIHRoaXMuX2JpbmRSb3V0ZXMoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3IgbWF0Y2hpbmcgbmFtZWQgcGFyYW0gcGFydHMgYW5kIHNwbGF0dGVkXG4gIC8vIHBhcnRzIG9mIHJvdXRlIHN0cmluZ3MuXG4gIHZhciBvcHRpb25hbFBhcmFtID0gL1xcKCguKj8pXFwpL2c7XG4gIHZhciBuYW1lZFBhcmFtICAgID0gLyhcXChcXD8pPzpcXHcrL2c7XG4gIHZhciBzcGxhdFBhcmFtICAgID0gL1xcKlxcdysvZztcbiAgdmFyIGVzY2FwZVJlZ0V4cCAgPSAvW1xcLXt9XFxbXFxdKz8uLFxcXFxcXF4kfCNcXHNdL2c7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlJvdXRlcioqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFJvdXRlci5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gTWFudWFsbHkgYmluZCBhIHNpbmdsZSBuYW1lZCByb3V0ZSB0byBhIGNhbGxiYWNrLiBGb3IgZXhhbXBsZTpcbiAgICAvL1xuICAgIC8vICAgICB0aGlzLnJvdXRlKCdzZWFyY2gvOnF1ZXJ5L3A6bnVtJywgJ3NlYXJjaCcsIGZ1bmN0aW9uKHF1ZXJ5LCBudW0pIHtcbiAgICAvLyAgICAgICAuLi5cbiAgICAvLyAgICAgfSk7XG4gICAgLy9cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIV8uaXNSZWdFeHAocm91dGUpKSByb3V0ZSA9IHRoaXMuX3JvdXRlVG9SZWdFeHAocm91dGUpO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IG5hbWU7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gdGhpc1tuYW1lXTtcbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzO1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5yb3V0ZShyb3V0ZSwgZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSByb3V0ZXIuX2V4dHJhY3RQYXJhbWV0ZXJzKHJvdXRlLCBmcmFnbWVudCk7XG4gICAgICAgIHJvdXRlci5leGVjdXRlKGNhbGxiYWNrLCBhcmdzKTtcbiAgICAgICAgcm91dGVyLnRyaWdnZXIuYXBwbHkocm91dGVyLCBbJ3JvdXRlOicgKyBuYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHJvdXRlciwgbmFtZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeGVjdXRlIGEgcm91dGUgaGFuZGxlciB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzLiAgVGhpcyBpcyBhblxuICAgIC8vIGV4Y2VsbGVudCBwbGFjZSB0byBkbyBwcmUtcm91dGUgc2V0dXAgb3IgcG9zdC1yb3V0ZSBjbGVhbnVwLlxuICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvLyBTaW1wbGUgcHJveHkgdG8gYEJhY2tib25lLmhpc3RvcnlgIHRvIHNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShmcmFnbWVudCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbGwgZGVmaW5lZCByb3V0ZXMgdG8gYEJhY2tib25lLmhpc3RvcnlgLiBXZSBoYXZlIHRvIHJldmVyc2UgdGhlXG4gICAgLy8gb3JkZXIgb2YgdGhlIHJvdXRlcyBoZXJlIHRvIHN1cHBvcnQgYmVoYXZpb3Igd2hlcmUgdGhlIG1vc3QgZ2VuZXJhbFxuICAgIC8vIHJvdXRlcyBjYW4gYmUgZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoZSByb3V0ZSBtYXAuXG4gICAgX2JpbmRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnJvdXRlcykgcmV0dXJuO1xuICAgICAgdGhpcy5yb3V0ZXMgPSBfLnJlc3VsdCh0aGlzLCAncm91dGVzJyk7XG4gICAgICB2YXIgcm91dGUsIHJvdXRlcyA9IF8ua2V5cyh0aGlzLnJvdXRlcyk7XG4gICAgICB3aGlsZSAoKHJvdXRlID0gcm91dGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucm91dGUocm91dGUsIHRoaXMucm91dGVzW3JvdXRlXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSByb3V0ZSBzdHJpbmcgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgc3VpdGFibGUgZm9yIG1hdGNoaW5nXG4gICAgLy8gYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbiBoYXNoLlxuICAgIF9yb3V0ZVRvUmVnRXhwOiBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgJ1xcXFwkJicpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5hbWVkUGFyYW0sIGZ1bmN0aW9uKG1hdGNoLCBvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gbWF0Y2ggOiAnKFteLz9dKyknO1xuICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uoc3BsYXRQYXJhbSwgJyhbXj9dKj8pJyk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyByb3V0ZSArICcoPzpcXFxcPyhbXFxcXHNcXFxcU10qKSk/JCcpO1xuICAgIH0sXG5cbiAgICAvLyBHaXZlbiBhIHJvdXRlLCBhbmQgYSBVUkwgZnJhZ21lbnQgdGhhdCBpdCBtYXRjaGVzLCByZXR1cm4gdGhlIGFycmF5IG9mXG4gICAgLy8gZXh0cmFjdGVkIGRlY29kZWQgcGFyYW1ldGVycy4gRW1wdHkgb3IgdW5tYXRjaGVkIHBhcmFtZXRlcnMgd2lsbCBiZVxuICAgIC8vIHRyZWF0ZWQgYXMgYG51bGxgIHRvIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICAgIF9leHRyYWN0UGFyYW1ldGVyczogZnVuY3Rpb24ocm91dGUsIGZyYWdtZW50KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcm91dGUuZXhlYyhmcmFnbWVudCkuc2xpY2UoMSk7XG4gICAgICByZXR1cm4gXy5tYXAocGFyYW1zLCBmdW5jdGlvbihwYXJhbSwgaSkge1xuICAgICAgICAvLyBEb24ndCBkZWNvZGUgdGhlIHNlYXJjaCBwYXJhbXMuXG4gICAgICAgIGlmIChpID09PSBwYXJhbXMubGVuZ3RoIC0gMSkgcmV0dXJuIHBhcmFtIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBwYXJhbSA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSkgOiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLkhpc3RvcnlcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEhhbmRsZXMgY3Jvc3MtYnJvd3NlciBoaXN0b3J5IG1hbmFnZW1lbnQsIGJhc2VkIG9uIGVpdGhlclxuICAvLyBbcHVzaFN0YXRlXShodHRwOi8vZGl2ZWludG9odG1sNS5pbmZvL2hpc3RvcnkuaHRtbCkgYW5kIHJlYWwgVVJMcywgb3JcbiAgLy8gW29uaGFzaGNoYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vd2luZG93Lm9uaGFzaGNoYW5nZSlcbiAgLy8gYW5kIFVSTCBmcmFnbWVudHMuIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIG5laXRoZXIgKG9sZCBJRSwgbmF0Y2gpLFxuICAvLyBmYWxscyBiYWNrIHRvIHBvbGxpbmcuXG4gIHZhciBIaXN0b3J5ID0gQmFja2JvbmUuSGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICBfLmJpbmRBbGwodGhpcywgJ2NoZWNrVXJsJyk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBgSGlzdG9yeWAgY2FuIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMubG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICB0aGlzLmhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgYSBsZWFkaW5nIGhhc2gvc2xhc2ggYW5kIHRyYWlsaW5nIHNwYWNlLlxuICB2YXIgcm91dGVTdHJpcHBlciA9IC9eWyNcXC9dfFxccyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcy5cbiAgdmFyIHJvb3RTdHJpcHBlciA9IC9eXFwvK3xcXC8rJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3IgZGV0ZWN0aW5nIE1TSUUuXG4gIHZhciBpc0V4cGxvcmVyID0gL21zaWUgW1xcdy5dKy87XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciByZW1vdmluZyBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgdHJhaWxpbmdTbGFzaCA9IC9cXC8kLztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyB1cmxzIG9mIGhhc2guXG4gIHZhciBwYXRoU3RyaXBwZXIgPSAvIy4qJC87XG5cbiAgLy8gSGFzIHRoZSBoaXN0b3J5IGhhbmRsaW5nIGFscmVhZHkgYmVlbiBzdGFydGVkP1xuICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEhpc3RvcnkucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGludGVydmFsIHRvIHBvbGwgZm9yIGhhc2ggY2hhbmdlcywgaWYgbmVjZXNzYXJ5LCBpc1xuICAgIC8vIHR3ZW50eSB0aW1lcyBhIHNlY29uZC5cbiAgICBpbnRlcnZhbDogNTAsXG5cbiAgICAvLyBBcmUgd2UgYXQgdGhlIGFwcCByb290P1xuICAgIGF0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpID09PSB0aGlzLnJvb3Q7XG4gICAgfSxcblxuICAgIC8vIEdldHMgdGhlIHRydWUgaGFzaCB2YWx1ZS4gQ2Fubm90IHVzZSBsb2NhdGlvbi5oYXNoIGRpcmVjdGx5IGR1ZSB0byBidWdcbiAgICAvLyBpbiBGaXJlZm94IHdoZXJlIGxvY2F0aW9uLmhhc2ggd2lsbCBhbHdheXMgYmUgZGVjb2RlZC5cbiAgICBnZXRIYXNoOiBmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAgIHZhciBtYXRjaCA9ICh3aW5kb3cgfHwgdGhpcykubG9jYXRpb24uaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQsIGVpdGhlciBmcm9tIHRoZSBVUkwsXG4gICAgLy8gdGhlIGhhc2gsIG9yIHRoZSBvdmVycmlkZS5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQsIGZvcmNlUHVzaFN0YXRlKSB7XG4gICAgICBpZiAoZnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlIHx8ICF0aGlzLl93YW50c0hhc2hDaGFuZ2UgfHwgZm9yY2VQdXNoU3RhdGUpIHtcbiAgICAgICAgICBmcmFnbWVudCA9IGRlY29kZVVSSSh0aGlzLmxvY2F0aW9uLnBhdGhuYW1lICsgdGhpcy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290LnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgJycpO1xuICAgICAgICAgIGlmICghZnJhZ21lbnQuaW5kZXhPZihyb290KSkgZnJhZ21lbnQgPSBmcmFnbWVudC5zbGljZShyb290Lmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgIH0sXG5cbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrYm9uZS5oaXN0b3J5IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZFwiKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbi4gRG8gd2UgbmVlZCBhbiBpZnJhbWU/XG4gICAgICAvLyBJcyBwdXNoU3RhdGUgZGVzaXJlZCAuLi4gaXMgaXQgYXZhaWxhYmxlP1xuICAgICAgdGhpcy5vcHRpb25zICAgICAgICAgID0gXy5leHRlbmQoe3Jvb3Q6ICcvJ30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnJvb3QgICAgICAgICAgICAgPSB0aGlzLm9wdGlvbnMucm9vdDtcbiAgICAgIHRoaXMuX3dhbnRzSGFzaENoYW5nZSA9IHRoaXMub3B0aW9ucy5oYXNoQ2hhbmdlICE9PSBmYWxzZTtcbiAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlICA9ICEhdGhpcy5vcHRpb25zLnB1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAgICA9ICEhKHRoaXMub3B0aW9ucy5wdXNoU3RhdGUgJiYgdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUpO1xuICAgICAgdmFyIGZyYWdtZW50ICAgICAgICAgID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuICAgICAgdmFyIGRvY01vZGUgICAgICAgICAgID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgICAgdmFyIG9sZElFICAgICAgICAgICAgID0gKGlzRXhwbG9yZXIuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpICYmICghZG9jTW9kZSB8fCBkb2NNb2RlIDw9IDcpKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHJvb3QgdG8gYWx3YXlzIGluY2x1ZGUgYSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xuXG4gICAgICBpZiAob2xkSUUgJiYgdGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IEJhY2tib25lLiQoJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgdGFiaW5kZXg9XCItMVwiPicpO1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGZyYW1lLmhpZGUoKS5hcHBlbmRUbygnYm9keScpWzBdLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoZnJhZ21lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgIEJhY2tib25lLiQod2luZG93KS5vbigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmICgnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cpICYmICFvbGRJRSkge1xuICAgICAgICBCYWNrYm9uZS4kKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBiYXNlIHVybCwgZm9yIGEgcHVzaFN0YXRlIGxpbmtcbiAgICAgIC8vIG9wZW5lZCBieSBhIG5vbi1wdXNoU3RhdGUgYnJvd3Nlci5cbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmxvY2F0aW9uO1xuXG4gICAgICAvLyBUcmFuc2l0aW9uIGZyb20gaGFzaENoYW5nZSB0byBwdXNoU3RhdGUgb3IgdmljZSB2ZXJzYSBpZiBib3RoIGFyZVxuICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZFxuICAgICAgICAvLyBicm93c2VyLCBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KG51bGwsIHRydWUpO1xuICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZSh0aGlzLnJvb3QgKyAnIycgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgYXMgYnJvd3NlciB3aWxsIGRvIHJlZGlyZWN0IHRvIG5ldyB1cmxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiB0aGlzLmF0Um9vdCgpICYmIGxvYy5oYXNoKSB7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpLnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgICAgICAgIHRoaXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB0aGlzLnJvb3QgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNpbGVudCkgcmV0dXJuIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBEaXNhYmxlIEJhY2tib25lLmhpc3RvcnksIHBlcmhhcHMgdGVtcG9yYXJpbHkuIE5vdCB1c2VmdWwgaW4gYSByZWFsIGFwcCxcbiAgICAvLyBidXQgcG9zc2libHkgdXNlZnVsIGZvciB1bml0IHRlc3RpbmcgUm91dGVycy5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIEJhY2tib25lLiQod2luZG93KS5vZmYoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCkub2ZmKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICBpZiAodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja1VybEludGVydmFsKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSByb3V0ZSB0byBiZSB0ZXN0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgY2hhbmdlcy4gUm91dGVzIGFkZGVkIGxhdGVyXG4gICAgLy8gbWF5IG92ZXJyaWRlIHByZXZpb3VzIHJvdXRlcy5cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzLnVuc2hpZnQoe3JvdXRlOiByb3V0ZSwgY2FsbGJhY2s6IGNhbGxiYWNrfSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB0aGUgY3VycmVudCBVUkwgdG8gc2VlIGlmIGl0IGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLFxuICAgIC8vIGNhbGxzIGBsb2FkVXJsYCwgbm9ybWFsaXppbmcgYWNyb3NzIHRoZSBoaWRkZW4gaWZyYW1lLlxuICAgIGNoZWNrVXJsOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50ICYmIHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlmcmFtZSkgdGhpcy5uYXZpZ2F0ZShjdXJyZW50KTtcbiAgICAgIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBBdHRlbXB0IHRvIGxvYWQgdGhlIGN1cnJlbnQgVVJMIGZyYWdtZW50LiBJZiBhIHJvdXRlIHN1Y2NlZWRzIHdpdGggYVxuICAgIC8vIG1hdGNoLCByZXR1cm5zIGB0cnVlYC4gSWYgbm8gZGVmaW5lZCByb3V0ZXMgbWF0Y2hlcyB0aGUgZnJhZ21lbnQsXG4gICAgLy8gcmV0dXJucyBgZmFsc2VgLlxuICAgIGxvYWRVcmw6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIHJldHVybiBfLmFueSh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLnJvdXRlLnRlc3QoZnJhZ21lbnQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhmcmFnbWVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBTYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGFzaCBoaXN0b3J5LCBvciByZXBsYWNlIHRoZSBVUkwgc3RhdGUgaWYgdGhlXG4gICAgLy8gJ3JlcGxhY2UnIG9wdGlvbiBpcyBwYXNzZWQuIFlvdSBhcmUgcmVzcG9uc2libGUgZm9yIHByb3Blcmx5IFVSTC1lbmNvZGluZ1xuICAgIC8vIHRoZSBmcmFnbWVudCBpbiBhZHZhbmNlLlxuICAgIC8vXG4gICAgLy8gVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBjb250YWluIGB0cmlnZ2VyOiB0cnVlYCBpZiB5b3Ugd2lzaCB0byBoYXZlIHRoZVxuICAgIC8vIHJvdXRlIGNhbGxiYWNrIGJlIGZpcmVkIChub3QgdXN1YWxseSBkZXNpcmFibGUpLCBvciBgcmVwbGFjZTogdHJ1ZWAsIGlmXG4gICAgLy8geW91IHdpc2ggdG8gbW9kaWZ5IHRoZSBjdXJyZW50IFVSTCB3aXRob3V0IGFkZGluZyBhbiBlbnRyeSB0byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghSGlzdG9yeS5zdGFydGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucyA9PT0gdHJ1ZSkgb3B0aW9ucyA9IHt0cmlnZ2VyOiAhIW9wdGlvbnN9O1xuXG4gICAgICB2YXIgdXJsID0gdGhpcy5yb290ICsgKGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCB8fCAnJykpO1xuXG4gICAgICAvLyBTdHJpcCB0aGUgaGFzaCBmb3IgbWF0Y2hpbmcuXG4gICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJyk7XG5cbiAgICAgIGlmICh0aGlzLmZyYWdtZW50ID09PSBmcmFnbWVudCkgcmV0dXJuO1xuICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXG4gICAgICBpZiAoZnJhZ21lbnQgPT09ICcnICYmIHVybCAhPT0gJy8nKSB1cmwgPSB1cmwuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAvLyBJZiBwdXNoU3RhdGUgaXMgYXZhaWxhYmxlLCB3ZSB1c2UgaXQgdG8gc2V0IHRoZSBmcmFnbWVudCBhcyBhIHJlYWwgVVJMLlxuICAgICAgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmhpc3Rvcnlbb3B0aW9ucy5yZXBsYWNlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJ10oe30sIGRvY3VtZW50LnRpdGxlLCB1cmwpO1xuXG4gICAgICAvLyBJZiBoYXNoIGNoYW5nZXMgaGF2ZW4ndCBiZWVuIGV4cGxpY2l0bHkgZGlzYWJsZWQsIHVwZGF0ZSB0aGUgaGFzaFxuICAgICAgLy8gZnJhZ21lbnQgdG8gc3RvcmUgaGlzdG9yeS5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUhhc2godGhpcy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIGlmICh0aGlzLmlmcmFtZSAmJiAoZnJhZ21lbnQgIT09IHRoaXMuZ2V0RnJhZ21lbnQodGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lKSkpKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXG4gICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgaWYoIW9wdGlvbnMucmVwbGFjZSkgdGhpcy5pZnJhbWUuZG9jdW1lbnQub3BlbigpLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmlmcmFtZS5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgeW91J3ZlIHRvbGQgdXMgdGhhdCB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IGZhbGxiYWNrIGhhc2hjaGFuZ2UtXG4gICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH07XG4gICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZTtcblxuICAgIC8vIEFkZCBwcm90b3R5cGUgcHJvcGVydGllcyAoaW5zdGFuY2UgcHJvcGVydGllcykgdG8gdGhlIHN1YmNsYXNzLFxuICAgIC8vIGlmIHN1cHBsaWVkLlxuICAgIGlmIChwcm90b1Byb3BzKSBfLmV4dGVuZChjaGlsZC5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuXG4gICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH07XG5cbiAgLy8gU2V0IHVwIGluaGVyaXRhbmNlIGZvciB0aGUgbW9kZWwsIGNvbGxlY3Rpb24sIHJvdXRlciwgdmlldyBhbmQgaGlzdG9yeS5cbiAgTW9kZWwuZXh0ZW5kID0gQ29sbGVjdGlvbi5leHRlbmQgPSBSb3V0ZXIuZXh0ZW5kID0gVmlldy5leHRlbmQgPSBIaXN0b3J5LmV4dGVuZCA9IGV4dGVuZDtcblxuICAvLyBUaHJvdyBhbiBlcnJvciB3aGVuIGEgVVJMIGlzIG5lZWRlZCwgYW5kIG5vbmUgaXMgc3VwcGxpZWQuXG4gIHZhciB1cmxFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBcInVybFwiIHByb3BlcnR5IG9yIGZ1bmN0aW9uIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gIH07XG5cbiAgLy8gV3JhcCBhbiBvcHRpb25hbCBlcnJvciBjYWxsYmFjayB3aXRoIGEgZmFsbGJhY2sgZXJyb3IgZXZlbnQuXG4gIHZhciB3cmFwRXJyb3IgPSBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgb3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgbW9kZWwudHJpZ2dlcignZXJyb3InLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gQmFja2JvbmU7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL2JhY2tib25lLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL2JhY2tib25lXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "mixins/viewlogging":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(\"require/underscore\"),\n            __webpack_require__(\"require/backbone\"),\n            __webpack_require__(\"shim/splunk.logger\"),\n            __webpack_require__(\"shim/splunk.util\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n            _,\n            Backbone,\n            SplunkLogger,\n            splunkUtils\n        ) {\n\n    var logMode = splunkUtils.getConfigValue(\"JS_LOGGER_MODE\", \"None\"),\n        logLevel = splunkUtils.getConfigValue(\"JS_LOGGER_LEVEL\", \"INFO\"),\n        shouldAttachLogging = (logMode !== 'None' && logLevel === 'DEBUG'),\n        // don't attach loggers to events that will be very chatty\n        domEventBlacklist = ['mousemove', 'scroll'],\n        logger = null;\n\n    /**\n     * \n     * Mixin to add logging to a Backbone View\n     *\n     * This mixin will add logging statements to each DOM event handler in the view's \"events\" hash,\n     * but only if logging is enabled and the log level is DEBUG.\n     *\n     * In the case where logging should not be added this code is designed to do as little work as possible.  Attaching\n     * logging should not cause any changes in behavior.\n     *\n     * Usage:\n     *\n     *     var MyView = Backbone.View.extend({\n     *         // view code here\n     *     });\n     *     _.extend(MyView.prototype, viewloggingmixin);\n     * \n     * @mixin viewlogging\n     */\n    var viewlogging = {\n\n        /**\n         * An override of delegateEvents, which will wrap each event handler in a new function that \n         * will log a useful message and then invoke the original handler\n         * @param  {Object} events\n         *\n         * @memberOf viewlogging\n         */\n        delegateEvents: function(events) {\n            // if logging should not be attached, this should be an effective no-op\n            if(!shouldAttachLogging) {\n                return Backbone.View.prototype.delegateEvents.call(this, events);\n            }\n            events = events || _.result(this, 'events');\n            // if there are no events declared, again fall through to the Backbone implementation\n            if(!events) {\n                return Backbone.View.prototype.delegateEvents.call(this, events);\n            }\n            var wrappedEvents = {};\n            // loop over each eventName-handler pair, making sure to normalize the fact that the handler could be a\n            // function or the string name of an instance member, replace the handler with a wrapper function\n            // and call the Backbone implementation with the wrapped version of the handlers\n            _(events).each(function(handler, eventName) {\n                var normalizedHandler = _.isFunction(handler) ? handler : this[handler];\n                if(_.isFunction(normalizedHandler) && _(domEventBlacklist).indexOf(eventName) === -1) {\n                    var viewId = this.moduleId + '/' + this.cid;\n                    wrappedEvents[eventName] = function() {\n                        if(!logger) {\n                            logger = SplunkLogger.getLogger('viewlogging.js');\n                        }\n                        logger.debug('view ' + viewId + ' is handling event ' + eventName.replace(/\\s+/g, ' '));\n                        // \"this\" here will be the context that Backbone uses to invoke the handler\n                        normalizedHandler.apply(this, arguments);\n                    };\n                }\n                // in the case where normalizedHandler is for some reason not a function, it is not safe to create the\n                // wrapper, but make sure to be non-destructive\n                else {\n                    wrappedEvents[eventName] = handler;\n                }\n            }, this);\n            return Backbone.View.prototype.delegateEvents.call(this, wrappedEvents);\n        }\n\n    };\n\n    return viewlogging;\n\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL21peGlucy92aWV3bG9nZ2luZy5qcz83ODM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoibWl4aW5zL3ZpZXdsb2dnaW5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5kZWZpbmUoW1xuICAgICAgICAgICAgJ3VuZGVyc2NvcmUnLFxuICAgICAgICAgICAgJ2JhY2tib25lJyxcbiAgICAgICAgICAgICdzcGx1bmsubG9nZ2VyJyxcbiAgICAgICAgICAgICdzcGx1bmsudXRpbCdcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24oXG4gICAgICAgICAgICBfLFxuICAgICAgICAgICAgQmFja2JvbmUsXG4gICAgICAgICAgICBTcGx1bmtMb2dnZXIsXG4gICAgICAgICAgICBzcGx1bmtVdGlsc1xuICAgICAgICApIHtcblxuICAgIHZhciBsb2dNb2RlID0gc3BsdW5rVXRpbHMuZ2V0Q29uZmlnVmFsdWUoXCJKU19MT0dHRVJfTU9ERVwiLCBcIk5vbmVcIiksXG4gICAgICAgIGxvZ0xldmVsID0gc3BsdW5rVXRpbHMuZ2V0Q29uZmlnVmFsdWUoXCJKU19MT0dHRVJfTEVWRUxcIiwgXCJJTkZPXCIpLFxuICAgICAgICBzaG91bGRBdHRhY2hMb2dnaW5nID0gKGxvZ01vZGUgIT09ICdOb25lJyAmJiBsb2dMZXZlbCA9PT0gJ0RFQlVHJyksXG4gICAgICAgIC8vIGRvbid0IGF0dGFjaCBsb2dnZXJzIHRvIGV2ZW50cyB0aGF0IHdpbGwgYmUgdmVyeSBjaGF0dHlcbiAgICAgICAgZG9tRXZlbnRCbGFja2xpc3QgPSBbJ21vdXNlbW92ZScsICdzY3JvbGwnXSxcbiAgICAgICAgbG9nZ2VyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIE1peGluIHRvIGFkZCBsb2dnaW5nIHRvIGEgQmFja2JvbmUgVmlld1xuICAgICAqXG4gICAgICogVGhpcyBtaXhpbiB3aWxsIGFkZCBsb2dnaW5nIHN0YXRlbWVudHMgdG8gZWFjaCBET00gZXZlbnQgaGFuZGxlciBpbiB0aGUgdmlldydzIFwiZXZlbnRzXCIgaGFzaCxcbiAgICAgKiBidXQgb25seSBpZiBsb2dnaW5nIGlzIGVuYWJsZWQgYW5kIHRoZSBsb2cgbGV2ZWwgaXMgREVCVUcuXG4gICAgICpcbiAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSBsb2dnaW5nIHNob3VsZCBub3QgYmUgYWRkZWQgdGhpcyBjb2RlIGlzIGRlc2lnbmVkIHRvIGRvIGFzIGxpdHRsZSB3b3JrIGFzIHBvc3NpYmxlLiAgQXR0YWNoaW5nXG4gICAgICogbG9nZ2luZyBzaG91bGQgbm90IGNhdXNlIGFueSBjaGFuZ2VzIGluIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogVXNhZ2U6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIE15VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICAgKiAgICAgICAgIC8vIHZpZXcgY29kZSBoZXJlXG4gICAgICogICAgIH0pO1xuICAgICAqICAgICBfLmV4dGVuZChNeVZpZXcucHJvdG90eXBlLCB2aWV3bG9nZ2luZ21peGluKTtcbiAgICAgKiBcbiAgICAgKiBAbWl4aW4gdmlld2xvZ2dpbmdcbiAgICAgKi9cbiAgICB2YXIgdmlld2xvZ2dpbmcgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG92ZXJyaWRlIG9mIGRlbGVnYXRlRXZlbnRzLCB3aGljaCB3aWxsIHdyYXAgZWFjaCBldmVudCBoYW5kbGVyIGluIGEgbmV3IGZ1bmN0aW9uIHRoYXQgXG4gICAgICAgICAqIHdpbGwgbG9nIGEgdXNlZnVsIG1lc3NhZ2UgYW5kIHRoZW4gaW52b2tlIHRoZSBvcmlnaW5hbCBoYW5kbGVyXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiB2aWV3bG9nZ2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgICAgICAgICAgLy8gaWYgbG9nZ2luZyBzaG91bGQgbm90IGJlIGF0dGFjaGVkLCB0aGlzIHNob3VsZCBiZSBhbiBlZmZlY3RpdmUgbm8tb3BcbiAgICAgICAgICAgIGlmKCFzaG91bGRBdHRhY2hMb2dnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJhY2tib25lLlZpZXcucHJvdG90eXBlLmRlbGVnYXRlRXZlbnRzLmNhbGwodGhpcywgZXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cyB8fCBfLnJlc3VsdCh0aGlzLCAnZXZlbnRzJyk7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gZXZlbnRzIGRlY2xhcmVkLCBhZ2FpbiBmYWxsIHRocm91Z2ggdG8gdGhlIEJhY2tib25lIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICBpZighZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJhY2tib25lLlZpZXcucHJvdG90eXBlLmRlbGVnYXRlRXZlbnRzLmNhbGwodGhpcywgZXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3cmFwcGVkRXZlbnRzID0ge307XG4gICAgICAgICAgICAvLyBsb29wIG92ZXIgZWFjaCBldmVudE5hbWUtaGFuZGxlciBwYWlyLCBtYWtpbmcgc3VyZSB0byBub3JtYWxpemUgdGhlIGZhY3QgdGhhdCB0aGUgaGFuZGxlciBjb3VsZCBiZSBhXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBvciB0aGUgc3RyaW5nIG5hbWUgb2YgYW4gaW5zdGFuY2UgbWVtYmVyLCByZXBsYWNlIHRoZSBoYW5kbGVyIHdpdGggYSB3cmFwcGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBhbmQgY2FsbCB0aGUgQmFja2JvbmUgaW1wbGVtZW50YXRpb24gd2l0aCB0aGUgd3JhcHBlZCB2ZXJzaW9uIG9mIHRoZSBoYW5kbGVyc1xuICAgICAgICAgICAgXyhldmVudHMpLmVhY2goZnVuY3Rpb24oaGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRIYW5kbGVyID0gXy5pc0Z1bmN0aW9uKGhhbmRsZXIpID8gaGFuZGxlciA6IHRoaXNbaGFuZGxlcl07XG4gICAgICAgICAgICAgICAgaWYoXy5pc0Z1bmN0aW9uKG5vcm1hbGl6ZWRIYW5kbGVyKSAmJiBfKGRvbUV2ZW50QmxhY2tsaXN0KS5pbmRleE9mKGV2ZW50TmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3SWQgPSB0aGlzLm1vZHVsZUlkICsgJy8nICsgdGhpcy5jaWQ7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRFdmVudHNbZXZlbnROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWxvZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciA9IFNwbHVua0xvZ2dlci5nZXRMb2dnZXIoJ3ZpZXdsb2dnaW5nLmpzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3ZpZXcgJyArIHZpZXdJZCArICcgaXMgaGFuZGxpbmcgZXZlbnQgJyArIGV2ZW50TmFtZS5yZXBsYWNlKC9cXHMrL2csICcgJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJ0aGlzXCIgaGVyZSB3aWxsIGJlIHRoZSBjb250ZXh0IHRoYXQgQmFja2JvbmUgdXNlcyB0byBpbnZva2UgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRIYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIHdoZXJlIG5vcm1hbGl6ZWRIYW5kbGVyIGlzIGZvciBzb21lIHJlYXNvbiBub3QgYSBmdW5jdGlvbiwgaXQgaXMgbm90IHNhZmUgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHdyYXBwZXIsIGJ1dCBtYWtlIHN1cmUgdG8gYmUgbm9uLWRlc3RydWN0aXZlXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRFdmVudHNbZXZlbnROYW1lXSA9IGhhbmRsZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gQmFja2JvbmUuVmlldy5wcm90b3R5cGUuZGVsZWdhdGVFdmVudHMuY2FsbCh0aGlzLCB3cmFwcGVkRXZlbnRzKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHJldHVybiB2aWV3bG9nZ2luZztcblxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL21peGlucy92aWV3bG9nZ2luZy5qc1xuLy8gbW9kdWxlIGlkID0gbWl4aW5zL3ZpZXdsb2dnaW5nXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "global/GlobalReflowQueue":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module){\n\tvar _  = __webpack_require__(\"require/underscore\"),\n\t\tviewsToReflow = [],\n\t\tviewAddInterval,\n\t\ttickInterval = 50;\n\n\n\tvar GlobalReflowQueue = {\n\t\tadd: function(view) {\n\t\t\tviewsToReflow.push(view);\n\t\t\t//If there is at least one view to reflow, set an interval and validate the views\n\t\t\t//We set an interval in case a view is added while we are validating our existing views\n\t\t\t//This view will need to be processed after we have validated the current views to be reflowed.\n\t\t\tif (viewsToReflow.length === 1) {\n\t\t\t\tviewAddInterval = window.setInterval(GlobalReflowQueue.validateViews, tickInterval);\t\n\t\t\t}\n\t\t},\n\n\t\tvalidateViews: function (){\n\t\t\tvar internalViewsToReflow = _.sortBy(viewsToReflow, function(view) {\n\t\t\t\treturn view.getReflowDepth();\n\t\t\t});\n\t\t\tfor (var i = 0; i < internalViewsToReflow.length; i++) {\n\t\t\t\tinternalViewsToReflow[i].validateReflow();\n\t\t\t}\n\t\t\t//If we have no more views to reflow, then clear the interval - we don't need to call the function again\n\t\t\tif (viewsToReflow.length === 0) {\n\t\t\t\tclearInterval(viewAddInterval);\n\t\t\t}\n\t\t},\n\t\tremove: function(view) {\n\t\t\tvar indexToRemove = viewsToReflow.indexOf(view);\n\t\t\tif (indexToRemove > -1) {\n\t\t\t\tviewsToReflow.splice(indexToRemove, 1);\n\t\t\t}\n\t\t\t//If we have removed all of the views that we need to reflow, we don't need to validate views again.\n\t\t\tif (viewsToReflow.length === 0) {\n\t\t\t\tclearInterval(viewAddInterval);\n\t\t\t}\n\t\t},\n\n\n\t\t//For testing, not exposed in real API.\n\t\tgetTickInterval: function() {\n\t\t\treturn tickInterval;\n\t\t},\n\n\t\tclear: function() {\n\t\t\tviewsToReflow = [];\n\t\t}\n\t};\n\treturn GlobalReflowQueue;\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2dsb2JhbC9HbG9iYWxSZWZsb3dRdWV1ZS5qcz84ZjRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJrQ0FBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Imdsb2JhbC9HbG9iYWxSZWZsb3dRdWV1ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1xuXHR2YXIgXyAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksXG5cdFx0dmlld3NUb1JlZmxvdyA9IFtdLFxuXHRcdHZpZXdBZGRJbnRlcnZhbCxcblx0XHR0aWNrSW50ZXJ2YWwgPSA1MDtcblxuXG5cdHZhciBHbG9iYWxSZWZsb3dRdWV1ZSA9IHtcblx0XHRhZGQ6IGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdHZpZXdzVG9SZWZsb3cucHVzaCh2aWV3KTtcblx0XHRcdC8vSWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHZpZXcgdG8gcmVmbG93LCBzZXQgYW4gaW50ZXJ2YWwgYW5kIHZhbGlkYXRlIHRoZSB2aWV3c1xuXHRcdFx0Ly9XZSBzZXQgYW4gaW50ZXJ2YWwgaW4gY2FzZSBhIHZpZXcgaXMgYWRkZWQgd2hpbGUgd2UgYXJlIHZhbGlkYXRpbmcgb3VyIGV4aXN0aW5nIHZpZXdzXG5cdFx0XHQvL1RoaXMgdmlldyB3aWxsIG5lZWQgdG8gYmUgcHJvY2Vzc2VkIGFmdGVyIHdlIGhhdmUgdmFsaWRhdGVkIHRoZSBjdXJyZW50IHZpZXdzIHRvIGJlIHJlZmxvd2VkLlxuXHRcdFx0aWYgKHZpZXdzVG9SZWZsb3cubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHZpZXdBZGRJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChHbG9iYWxSZWZsb3dRdWV1ZS52YWxpZGF0ZVZpZXdzLCB0aWNrSW50ZXJ2YWwpO1x0XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHZhbGlkYXRlVmlld3M6IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGludGVybmFsVmlld3NUb1JlZmxvdyA9IF8uc29ydEJ5KHZpZXdzVG9SZWZsb3csIGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdFx0cmV0dXJuIHZpZXcuZ2V0UmVmbG93RGVwdGgoKTtcblx0XHRcdH0pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnRlcm5hbFZpZXdzVG9SZWZsb3cubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aW50ZXJuYWxWaWV3c1RvUmVmbG93W2ldLnZhbGlkYXRlUmVmbG93KCk7XG5cdFx0XHR9XG5cdFx0XHQvL0lmIHdlIGhhdmUgbm8gbW9yZSB2aWV3cyB0byByZWZsb3csIHRoZW4gY2xlYXIgdGhlIGludGVydmFsIC0gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoZSBmdW5jdGlvbiBhZ2FpblxuXHRcdFx0aWYgKHZpZXdzVG9SZWZsb3cubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGNsZWFySW50ZXJ2YWwodmlld0FkZEludGVydmFsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbW92ZTogZnVuY3Rpb24odmlldykge1xuXHRcdFx0dmFyIGluZGV4VG9SZW1vdmUgPSB2aWV3c1RvUmVmbG93LmluZGV4T2Yodmlldyk7XG5cdFx0XHRpZiAoaW5kZXhUb1JlbW92ZSA+IC0xKSB7XG5cdFx0XHRcdHZpZXdzVG9SZWZsb3cuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xuXHRcdFx0fVxuXHRcdFx0Ly9JZiB3ZSBoYXZlIHJlbW92ZWQgYWxsIG9mIHRoZSB2aWV3cyB0aGF0IHdlIG5lZWQgdG8gcmVmbG93LCB3ZSBkb24ndCBuZWVkIHRvIHZhbGlkYXRlIHZpZXdzIGFnYWluLlxuXHRcdFx0aWYgKHZpZXdzVG9SZWZsb3cubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGNsZWFySW50ZXJ2YWwodmlld0FkZEludGVydmFsKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cblx0XHQvL0ZvciB0ZXN0aW5nLCBub3QgZXhwb3NlZCBpbiByZWFsIEFQSS5cblx0XHRnZXRUaWNrSW50ZXJ2YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRpY2tJbnRlcnZhbDtcblx0XHR9LFxuXG5cdFx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmlld3NUb1JlZmxvdyA9IFtdO1xuXHRcdH1cblx0fTtcblx0cmV0dXJuIEdsb2JhbFJlZmxvd1F1ZXVlO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2dsb2JhbC9HbG9iYWxSZWZsb3dRdWV1ZS5qc1xuLy8gbW9kdWxlIGlkID0gZ2xvYmFsL0dsb2JhbFJlZmxvd1F1ZXVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "contrib/jg_lib/async/Pass":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar FrameClock = __webpack_require__(\"contrib/jg_lib/async/FrameClock\");\n\tvar PassEventData = __webpack_require__(\"contrib/jg_lib/async/PassEventData\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\tvar ChainedEvent = __webpack_require__(\"contrib/jg_lib/events/ChainedEvent\");\n\tvar Event = __webpack_require__(\"contrib/jg_lib/events/Event\");\n\tvar ArrayUtil = __webpack_require__(\"contrib/jg_lib/utils/ArrayUtil\");\n\tvar ErrorUtil = __webpack_require__(\"contrib/jg_lib/utils/ErrorUtil\");\n\tvar Global = __webpack_require__(\"contrib/jg_lib/utils/Global\");\n\tvar Map = __webpack_require__(\"contrib/jg_lib/utils/Map\");\n\tvar ObjectUtil = __webpack_require__(\"contrib/jg_lib/utils/ObjectUtil\");\n\tvar Set = __webpack_require__(\"contrib/jg_lib/utils/Set\");\n\n\treturn Class(module.id, Object, function(Pass, base)\n\t{\n\n\t\t// Public Static Constants\n\n\t\tPass.FRAME_PRIORITY = -1000000;\n\n\t\t// Public Static Events\n\n\t\tPass.invalidated = new Event(\"invalidated\", PassEventData);\n\t\tPass.validated = new Event(\"validated\", PassEventData);\n\n\t\t// Public Static Properties\n\n\t\tPass.debug = false;\n\n\t\t// Private Static Properties\n\n\t\tvar _validateClock = FrameClock.getInstance();\n\t\tvar _validateList = [];\n\t\tvar _validateSet = new Set();\n\t\tvar _validateIndex = -1;\n\t\tvar _validatePass = null;\n\t\tvar _validateEndPass = null;\n\t\tvar _validateCount = 0;\n\t\tvar _isValidating = false;\n\t\tvar _isAsync = false;\n\t\tvar _debugStats = null;\n\n\t\t// Public Static Methods\n\n\t\tPass.resolve = function(target, pass, strict)\n\t\t{\n\t\t\tif (target == null)\n\t\t\t\tthrow new Error(\"Parameter target must be non-null.\");\n\t\t\tif (pass == null)\n\t\t\t\tthrow new Error(\"Parameter pass must be non-null.\");\n\n\t\t\tif (pass instanceof Pass)\n\t\t\t\treturn pass;\n\n\t\t\tif (!Class.isString(pass))\n\t\t\t\tthrow new Error(\"Parameter pass must be of type String or \" + Class.getName(Pass) + \".\");\n\n\t\t\tvar passName = pass;\n\t\t\tif (passName.indexOf(\".\") < 0)\n\t\t\t{\n\t\t\t\tpass = target[passName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar passPath = passName.split(\".\");\n\t\t\t\tpass = target;\n\t\t\t\tfor (var i = 0, l = passPath.length; i < l; i++)\n\t\t\t\t{\n\t\t\t\t\tpass = pass[passPath[i]];\n\t\t\t\t\tif (pass == null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pass != null) && (pass instanceof Pass))\n\t\t\t\treturn pass;\n\n\t\t\tif (strict !== false)\n\t\t\t\tthrow new Error(\"Unknown pass \\\"\" + passName + \"\\\".\");\n\n\t\t\treturn null;\n\t\t};\n\n\t\tPass.validateAll = function(endPass)\n\t\t{\n\t\t\tvar isAsync = _isAsync;\n\t\t\t_isAsync = false;\n\n\t\t\tif ((endPass != null) && !(endPass instanceof Pass))\n\t\t\t\tthrow new Error(\"Parameter endPass must be of type \" + Class.getName(Pass) + \".\");\n\n\t\t\tif (_isValidating || (_validateList.length === 0))\n\t\t\t\treturn;\n\n\t\t\tvar statsList = Pass.debug ? [] : null;\n\t\t\tvar statsSummary = statsList ? DebugStats.begin() : null;\n\t\t\tvar stats;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_isValidating = true;\n\t\t\t\t_validateEndPass = endPass;\n\t\t\t\t_validateCount++;\n\n\t\t\t\tfor (_validateIndex = 0; _validateIndex < _validateList.length; _validateIndex++)\n\t\t\t\t{\n\t\t\t\t\t_validatePass = _validateList[_validateIndex];\n\t\t\t\t\tif (_validateEndPass && (_validateEndPass._order < _validatePass._order))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (statsList)\n\t\t\t\t\t\tstats = _debugStats = DebugStats.begin(_validatePass);\n\n\t\t\t\t\t_validatePass.validateAll();\n\n\t\t\t\t\tif (statsList)\n\t\t\t\t\t\tstatsList.push(DebugStats.end(stats));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\t_validateIndex = -1;\n\t\t\t\t_validatePass = null;\n\t\t\t\t_validateEndPass = null;\n\t\t\t\t_isValidating = false;\n\t\t\t\t_debugStats = null;\n\n\t\t\t\t_dequeueValidPasses();\n\t\t\t}\n\n\t\t\tif (statsList)\n\t\t\t{\n\t\t\t\tstatsList.push(DebugStats.end(statsSummary));\n\t\t\t\tDebugStats.render(statsList, _validateCount, isAsync);\n\t\t\t\tif (_validateList.length > 0)\n\t\t\t\t\tDebugStats.renderWarning(_validateList, endPass);\n\t\t\t}\n\t\t};\n\n\t\tPass.markValid = function(target)\n\t\t{\n\t\t\tvar validateList = _validateList.concat();\n\t\t\tfor (var i = 0, l = validateList.length; i < l; i++)\n\t\t\t\tvalidateList[i].markValid(target);\n\t\t};\n\n\t\tPass.isValid = function(target)\n\t\t{\n\t\t\tvar validateList = _validateList.concat();\n\t\t\tfor (var i = 0, l = validateList.length; i < l; i++)\n\t\t\t{\n\t\t\t\tif (!validateList[i].isValid(target))\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t\tPass.isValidating = function()\n\t\t{\n\t\t\treturn _isValidating;\n\t\t};\n\n\t\t// Private Static Methods\n\n\t\tvar _enqueuePass = function(pass)\n\t\t{\n\t\t\tif (_validateSet.has(pass))\n\t\t\t\treturn;\n\n\t\t\tvar index = -ArrayUtil.binarySearch(_validateList, pass, _passComparator) - 1;\n\t\t\tif (index < _validateList.length)\n\t\t\t\t_validateList.splice(index, 0, pass);\n\t\t\telse\n\t\t\t\t_validateList.push(pass);\n\n\t\t\t_validateSet.add(pass);\n\n\t\t\tif (index <= _validateIndex)\n\t\t\t\t_validateIndex++;\n\n\t\t\tif (_validateList.length === 1)\n\t\t\t\t_validateClock.on(_validateClock.frameTick, _validateClockTick, null, Pass.FRAME_PRIORITY);\n\t\t};\n\n\t\tvar _dequeueValidPasses = function()\n\t\t{\n\t\t\tvar pass;\n\t\t\tfor (var i = _validateList.length - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tpass = _validateList[i];\n\t\t\t\tif (pass._targetMap.size() === 0)\n\t\t\t\t{\n\t\t\t\t\t_validateList.splice(i, 1);\n\t\t\t\t\t_validateSet.del(pass);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_validateList.length === 0)\n\t\t\t\t_validateClock.off(_validateClock.frameTick, _validateClockTick);\n\t\t};\n\n\t\tvar _validateClockTick = function(e)\n\t\t{\n\t\t\t_isAsync = true;\n\t\t\tPass.validateAll();\n\t\t};\n\n\t\tvar _passComparator = function(pass1, pass2)\n\t\t{\n\t\t\tif (pass1._order <= pass2._order)\n\t\t\t\treturn -1;\n\t\t\treturn 1;\n\t\t};\n\n\t\tvar _topDownComparator = function(targetInfo1, targetInfo2)\n\t\t{\n\t\t\tif (targetInfo1.depth < targetInfo2.depth)\n\t\t\t\treturn -1;\n\t\t\tif (targetInfo1.depth > targetInfo2.depth)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t};\n\n\t\tvar _bottomUpComparator = function(targetInfo1, targetInfo2)\n\t\t{\n\t\t\tif (targetInfo1.depth > targetInfo2.depth)\n\t\t\t\treturn -1;\n\t\t\tif (targetInfo1.depth < targetInfo2.depth)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t};\n\n\t\tvar _wrapComparator = function(comparator, direction)\n\t\t{\n\t\t\treturn function(targetInfo1, targetInfo2)\n\t\t\t{\n\t\t\t\treturn (comparator(targetInfo1.target, targetInfo2.target) * direction);\n\t\t\t};\n\t\t};\n\n\t\t// Public Events\n\n\t\tthis.invalidated = null;\n\t\tthis.validated = null;\n\n\t\t// Private Properties\n\n\t\tthis._name = null;\n\t\tthis._order = 0;\n\t\tthis._direction = \"none\";\n\t\tthis._comparator = null;\n\t\tthis._targetMap = null;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(name, order, direction)\n\t\t{\n\t\t\tif (name == null)\n\t\t\t\tthrow new Error(\"Parameter name must be non-null.\");\n\t\t\tif (!Class.isString(name))\n\t\t\t\tthrow new Error(\"Parameter name must be of type String.\");\n\t\t\tif ((order != null) && !Class.isNumber(order))\n\t\t\t\tthrow new Error(\"Parameter order must be of type Number.\");\n\t\t\tif ((direction != null) && !Class.isString(direction))\n\t\t\t\tthrow new Error(\"Parameter direction must be of type String.\");\n\n\t\t\tthis._name = name;\n\t\t\tthis._order = ((order != null) && !isNaN(order)) ? order : 0;\n\t\t\tthis._direction = ((direction === \"topDown\") || (direction === \"bottomUp\")) ? direction : \"none\";\n\n\t\t\tthis._targetMap = new Map();\n\n\t\t\tthis.invalidated = new ChainedEvent(name + \".invalidated\", Pass.invalidated);\n\t\t\tthis.validated = new ChainedEvent(name + \".validated\", Pass.validated);\n\t\t};\n\n\t\t// Public Accessor Methods\n\n\t\tthis.name = function()\n\t\t{\n\t\t\treturn this._name;\n\t\t};\n\n\t\tthis.order = function()\n\t\t{\n\t\t\treturn this._order;\n\t\t};\n\n\t\tthis.direction = function()\n\t\t{\n\t\t\treturn this._direction;\n\t\t};\n\n\t\tthis.comparator = function(value)\n\t\t{\n\t\t\tif (!arguments.length)\n\t\t\t\treturn this._comparator;\n\n\t\t\tif ((value != null) && !Class.isFunction(value))\n\t\t\t\tthrow new Error(\"Parameter comparator must be of type Function.\");\n\n\t\t\tthis._comparator = value || null;\n\n\t\t\treturn this;\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.invalidate = function(target)\n\t\t{\n\t\t\tvar targetMap = this._targetMap;\n\t\t\tif (targetMap.has(target))\n\t\t\t\treturn;\n\n\t\t\tvar method = target[this._name];\n\t\t\tif ((method == null) || !Class.isFunction(method))\n\t\t\t\treturn;\n\n\t\t\ttargetMap.set(target, { target: target, method: method, depth: 0 });\n\t\t\tif (targetMap.size() === 1)\n\t\t\t\t_enqueuePass(this);\n\n\t\t\tif (target.isEventTarget)\n\t\t\t\ttarget.fire(this.invalidated, new PassEventData(this));\n\t\t};\n\n\t\tthis.validate = function(target)\n\t\t{\n\t\t\tvar targetInfo = this._targetMap.get(target);\n\t\t\tif (!targetInfo)\n\t\t\t\treturn;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttargetInfo.method.call(target);\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\tErrorUtil.nonBlockingThrow(e);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (targetInfo.target)\n\t\t\t\t\tthis.markValid(target);\n\t\t\t}\n\t\t};\n\n\t\tthis.validateAll = function()\n\t\t{\n\t\t\tvar direction = this._direction;\n\t\t\tvar comparator = this._comparator;\n\t\t\tvar targetInfoList = this._targetMap.values();\n\t\t\tvar targetInfoCount = targetInfoList.length;\n\t\t\tvar targetInfo;\n\t\t\tvar target;\n\t\t\tvar depth;\n\t\t\tvar i;\n\n\t\t\tif (targetInfoCount === 0)\n\t\t\t\treturn;\n\n\t\t\tif (comparator)\n\t\t\t{\n\t\t\t\tcomparator = _wrapComparator(comparator, (direction === \"bottomUp\") ? -1 : 1);\n\t\t\t\ttargetInfoList.sort(comparator);\n\t\t\t}\n\t\t\telse if (direction !== \"none\")\n\t\t\t{\n\t\t\t\tfor (i = 0; i < targetInfoCount; i++)\n\t\t\t\t{\n\t\t\t\t\ttargetInfo = targetInfoList[i];\n\t\t\t\t\tdepth = +targetInfo.target.getValidateDepth();\n\t\t\t\t\ttargetInfo.depth = !isNaN(depth) ? depth : 0;\n\t\t\t\t}\n\n\t\t\t\tif (direction === \"bottomUp\")\n\t\t\t\t\ttargetInfoList.sort(_bottomUpComparator);\n\t\t\t\telse\n\t\t\t\t\ttargetInfoList.sort(_topDownComparator);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targetInfoCount; i++)\n\t\t\t{\n\t\t\t\ttarget = targetInfoList[i].target;\n\t\t\t\tif (target)\n\t\t\t\t\tthis.validate(target);\n\t\t\t}\n\t\t};\n\n\t\tthis.markValid = function(target)\n\t\t{\n\t\t\tvar targetMap = this._targetMap;\n\t\t\tvar targetInfo = targetMap.get(target);\n\t\t\tif (!targetInfo)\n\t\t\t\treturn;\n\n\t\t\ttargetMap.del(target);\n\t\t\ttargetInfo.target = null;\n\t\t\ttargetInfo.method = null;\n\n\t\t\tif (_debugStats && (_debugStats.pass === this))\n\t\t\t\t_debugStats.targets++;\n\n\t\t\tif (target.isEventTarget)\n\t\t\t\ttarget.fire(this.validated, new PassEventData(this));\n\t\t};\n\n\t\tthis.isValid = function(target)\n\t\t{\n\t\t\treturn !this._targetMap.has(target);\n\t\t};\n\n\t\tthis.isValidating = function()\n\t\t{\n\t\t\treturn (_isValidating && ((_validateEndPass == null) || (_validateEndPass._order >= this._order)));\n\t\t};\n\n\t\t// Private Nested Classes\n\n\t\tvar DebugStats = Class(function(DebugStats)\n\t\t{\n\n\t\t\t// Private Static Constants\n\n\t\t\tvar _R_DECIMAL = /^[^\\.e]*([^$]*)$/;\n\t\t\tvar _R_INFINITY = /^\\-?Infinity$/;\n\n\t\t\t// Public Static Methods\n\n\t\t\tDebugStats.begin = function(pass)\n\t\t\t{\n\t\t\t\tvar stats = {};\n\t\t\t\tstats.pass = pass || null;\n\t\t\t\tstats.time = new Date().getTime();\n\t\t\t\tif (pass)\n\t\t\t\t{\n\t\t\t\t\tstats.name = pass._name;\n\t\t\t\t\tstats.order = pass._order;\n\t\t\t\t\tstats.targets = 0;\n\t\t\t\t}\n\t\t\t\treturn stats;\n\t\t\t};\n\n\t\t\tDebugStats.end = function(stats)\n\t\t\t{\n\t\t\t\tstats.time = new Date().getTime() - stats.time;\n\t\t\t\treturn stats;\n\t\t\t};\n\n\t\t\tDebugStats.render = function(statsList, iterationCount, isAsync)\n\t\t\t{\n\t\t\t\tif (!Global.console || !Global.console.log)\n\t\t\t\t\treturn;\n\n\t\t\t\t_formatData(statsList);\n\n\t\t\t\tvar title = \"ASYNC PASS VALIDATION - iteration \" + iterationCount + (!isAsync ? \" (FORCED SYNC)\" : \"\");\n\n\t\t\t\tvar columns = [];\n\t\t\t\tcolumns.push({ heading: \"name\", field: \"name\", align: \"left\" });\n\t\t\t\tcolumns.push({ heading: \"order\", field: \"order\", align: \"right\" });\n\t\t\t\tcolumns.push({ heading: \"targets\", field: \"targets\", align: \"right\" });\n\t\t\t\tcolumns.push({ heading: \"time\", field: \"time\", align: \"right\" });\n\n\t\t\t\tvar str = \"\\n\" + _renderTable(title, columns, statsList, true) + \"\\n\";\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tGlobal.console.log(str);\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\t// ignore errors\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tDebugStats.renderWarning = function(passList, endPass)\n\t\t\t{\n\t\t\t\tif (!Global.console || !Global.console.warn)\n\t\t\t\t\treturn;\n\n\t\t\t\tvar dataList = [];\n\t\t\t\tvar pass;\n\n\t\t\t\t// populate dataList\n\t\t\t\tfor (var i = 0, l = passList.length; i < l; i++)\n\t\t\t\t{\n\t\t\t\t\tpass = passList[i];\n\t\t\t\t\tif (endPass && (endPass._order < pass._order))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdataList.push({ name: pass._name, order: pass._order, targets: pass._targetMap.size() });\n\t\t\t\t}\n\n\t\t\t\t// bail if no passes occur before endPass\n\t\t\t\tif (dataList.length === 0)\n\t\t\t\t\treturn;\n\n\t\t\t\t_formatData(dataList);\n\n\t\t\t\tvar message = \"WARNING: Validation cycle detected.\";\n\n\t\t\t\tvar title = \"Passes queued for next iteration...\";\n\n\t\t\t\tvar columns = [];\n\t\t\t\tcolumns.push({ heading: \"name\", field: \"name\", align: \"left\" });\n\t\t\t\tcolumns.push({ heading: \"order\", field: \"order\", align: \"right\" });\n\t\t\t\tcolumns.push({ heading: \"targets\", field: \"targets\", align: \"right\" });\n\n\t\t\t\tvar str = message + \"\\n\\n\" + _renderTable(title, columns, dataList) + \"\\n\";\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tGlobal.console.warn(str);\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\t// ignore errors\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Private Static Methods\n\n\t\t\tvar _formatData = function(dataList)\n\t\t\t{\n\t\t\t\tvar dataCount = dataList.length;\n\t\t\t\tvar data;\n\t\t\t\tvar decimalWidth = 0;\n\t\t\t\tvar i;\n\n\t\t\t\t// measure decimal width of \"order\" fields\n\t\t\t\tfor (i = 0; i < dataCount; i++)\n\t\t\t\t{\n\t\t\t\t\tdata = dataList[i];\n\t\t\t\t\tif (ObjectUtil.has(data, \"order\"))\n\t\t\t\t\t\tdecimalWidth = Math.max(decimalWidth, _measureDecimal(data.order));\n\t\t\t\t}\n\n\t\t\t\t// format \"order\" and \"time\" fields\n\t\t\t\tfor (i = 0; i < dataCount; i++)\n\t\t\t\t{\n\t\t\t\t\tdata = dataList[i];\n\t\t\t\t\tif (ObjectUtil.has(data, \"order\"))\n\t\t\t\t\t\tdata.order = _formatDecimal(data.order, decimalWidth);\n\t\t\t\t\tif (ObjectUtil.has(data, \"time\"))\n\t\t\t\t\t\tdata.time = _formatTime(data.time);\n\t\t\t\t}\n\n\t\t\t\treturn dataList;\n\t\t\t};\n\n\t\t\tvar _renderTable = function(title, columnList, dataList, hasFooter)\n\t\t\t{\n\t\t\t\tvar columnCount = columnList.length;\n\t\t\t\tvar column;\n\t\t\t\tvar dataCount = dataList.length;\n\t\t\t\tvar data;\n\t\t\t\tvar i;\n\t\t\t\tvar j;\n\n\t\t\t\tvar width = (columnCount - 1) * 2;\n\t\t\t\tvar columnWidths = [];\n\t\t\t\tvar columnWidth;\n\n\t\t\t\t// measure columns\n\t\t\t\tfor (i = 0; i < columnCount; i++)\n\t\t\t\t{\n\t\t\t\t\tcolumn = columnList[i];\n\t\t\t\t\tcolumnWidth = _measureValue(column.heading);\n\n\t\t\t\t\tfor (j = 0; j < dataCount; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = dataList[j];\n\t\t\t\t\t\tcolumnWidth = Math.max(columnWidth, _measureValue(ObjectUtil.get(data, column.field)));\n\t\t\t\t\t}\n\n\t\t\t\t\twidth += columnWidth;\n\t\t\t\t\tcolumnWidths.push(columnWidth);\n\t\t\t\t}\n\n\t\t\t\t// measure title and adjust column widths if needed\n\t\t\t\tif (title)\n\t\t\t\t{\n\t\t\t\t\tvar titleWidth = _measureValue(title);\n\t\t\t\t\tif (titleWidth > width)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar diff = (titleWidth - width);\n\t\t\t\t\t\twidth = titleWidth;\n\t\t\t\t\t\tfor (i = 0; i < diff; i++)\n\t\t\t\t\t\t\tcolumnWidths[i % columnCount]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar str = \"\";\n\t\t\t\tvar divider = _renderValue(\"\", width, \"left\", \"-\");\n\n\t\t\t\t// render title\n\t\t\t\tif (title)\n\t\t\t\t\tstr += _renderValue(title, width) + \"\\n\\n\";\n\n\t\t\t\t// render headings\n\t\t\t\tfor (i = 0; i < columnCount; i++)\n\t\t\t\t{\n\t\t\t\t\tcolumn = columnList[i];\n\t\t\t\t\tstr += _renderValue(column.heading, columnWidths[i], column.align);\n\t\t\t\t\tstr += (i < (columnCount - 1)) ? \"  \" : \"\\n\";\n\t\t\t\t}\n\t\t\t\tstr += divider + \"\\n\";\n\n\t\t\t\t// render rows\n\t\t\t\tfor (i = 0; i < dataCount; i++)\n\t\t\t\t{\n\t\t\t\t\tdata = dataList[i];\n\n\t\t\t\t\tif (hasFooter && (i === (dataCount - 1)))\n\t\t\t\t\t\tstr += divider + \"\\n\";\n\n\t\t\t\t\tfor (j = 0; j < columnCount; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcolumn = columnList[j];\n\t\t\t\t\t\tstr += _renderValue(ObjectUtil.get(data, column.field), columnWidths[j], column.align);\n\t\t\t\t\t\tstr += (j < (columnCount - 1)) ? \"  \" : \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn str;\n\t\t\t};\n\n\t\t\tvar _measureValue = function(value)\n\t\t\t{\n\t\t\t\tif (value == null)\n\t\t\t\t\treturn 0;\n\n\t\t\t\treturn (\"\" + value).length;\n\t\t\t};\n\n\t\t\tvar _renderValue = function(value, width, align, padChar)\n\t\t\t{\n\t\t\t\tif (!padChar)\n\t\t\t\t\tpadChar = \" \";\n\n\t\t\t\tvar str = (value != null) ? (\"\" + value) : \"\";\n\t\t\t\tvar i;\n\n\t\t\t\tif (align === \"right\")\n\t\t\t\t{\n\t\t\t\t\tfor (i = str.length; i < width; i++)\n\t\t\t\t\t\tstr = padChar + str;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (i = str.length; i < width; i++)\n\t\t\t\t\t\tstr += padChar;\n\t\t\t\t}\n\n\t\t\t\treturn str;\n\t\t\t};\n\n\t\t\tvar _measureDecimal = function(value)\n\t\t\t{\n\t\t\t\tif (value == null)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tvar match = (\"\" + value).match(_R_DECIMAL);\n\t\t\t\tif (match)\n\t\t\t\t\treturn match[1].length;\n\n\t\t\t\treturn 0;\n\t\t\t};\n\n\t\t\tvar _formatDecimal = function(value, decimalWidth)\n\t\t\t{\n\t\t\t\tif (value == null)\n\t\t\t\t\treturn \"\";\n\n\t\t\t\tvar str = \"\" + value;\n\t\t\t\tif (_R_INFINITY.test(str))\n\t\t\t\t\treturn str;\n\n\t\t\t\tvar match = str.match(_R_DECIMAL);\n\t\t\t\tif (match)\n\t\t\t\t\tdecimalWidth -= match[1].length;\n\n\t\t\t\tfor (var i = 0; i < decimalWidth; i++)\n\t\t\t\t\tstr += \" \";\n\n\t\t\t\treturn str;\n\t\t\t};\n\n\t\t\tvar _formatTime = function(value)\n\t\t\t{\n\t\t\t\tif (value == null)\n\t\t\t\t\treturn \"\";\n\n\t\t\t\treturn (value + \" ms\");\n\t\t\t};\n\n\t\t});\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2FzeW5jL1Bhc3MuanM/MWVmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsMkNBQTJDO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLGdEQUFnRDtBQUNsRSxrQkFBa0IsbURBQW1EO0FBQ3JFLGtCQUFrQix1REFBdUQ7QUFDekUsa0JBQWtCLGlEQUFpRDs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isd0VBQXdFO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixnREFBZ0Q7QUFDbEUsa0JBQWtCLG1EQUFtRDtBQUNyRSxrQkFBa0IsdURBQXVEOztBQUV6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSCxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvYXN5bmMvUGFzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIEZyYW1lQ2xvY2sgPSByZXF1aXJlKFwiLi9GcmFtZUNsb2NrXCIpO1xuXHR2YXIgUGFzc0V2ZW50RGF0YSA9IHJlcXVpcmUoXCIuL1Bhc3NFdmVudERhdGFcIik7XG5cdHZhciBDbGFzcyA9IHJlcXVpcmUoXCIuLi9DbGFzc1wiKTtcblx0dmFyIENoYWluZWRFdmVudCA9IHJlcXVpcmUoXCIuLi9ldmVudHMvQ2hhaW5lZEV2ZW50XCIpO1xuXHR2YXIgRXZlbnQgPSByZXF1aXJlKFwiLi4vZXZlbnRzL0V2ZW50XCIpO1xuXHR2YXIgQXJyYXlVdGlsID0gcmVxdWlyZShcIi4uL3V0aWxzL0FycmF5VXRpbFwiKTtcblx0dmFyIEVycm9yVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlscy9FcnJvclV0aWxcIik7XG5cdHZhciBHbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbHMvR2xvYmFsXCIpO1xuXHR2YXIgTWFwID0gcmVxdWlyZShcIi4uL3V0aWxzL01hcFwiKTtcblx0dmFyIE9iamVjdFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbHMvT2JqZWN0VXRpbFwiKTtcblx0dmFyIFNldCA9IHJlcXVpcmUoXCIuLi91dGlscy9TZXRcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgT2JqZWN0LCBmdW5jdGlvbihQYXNzLCBiYXNlKVxuXHR7XG5cblx0XHQvLyBQdWJsaWMgU3RhdGljIENvbnN0YW50c1xuXG5cdFx0UGFzcy5GUkFNRV9QUklPUklUWSA9IC0xMDAwMDAwO1xuXG5cdFx0Ly8gUHVibGljIFN0YXRpYyBFdmVudHNcblxuXHRcdFBhc3MuaW52YWxpZGF0ZWQgPSBuZXcgRXZlbnQoXCJpbnZhbGlkYXRlZFwiLCBQYXNzRXZlbnREYXRhKTtcblx0XHRQYXNzLnZhbGlkYXRlZCA9IG5ldyBFdmVudChcInZhbGlkYXRlZFwiLCBQYXNzRXZlbnREYXRhKTtcblxuXHRcdC8vIFB1YmxpYyBTdGF0aWMgUHJvcGVydGllc1xuXG5cdFx0UGFzcy5kZWJ1ZyA9IGZhbHNlO1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgUHJvcGVydGllc1xuXG5cdFx0dmFyIF92YWxpZGF0ZUNsb2NrID0gRnJhbWVDbG9jay5nZXRJbnN0YW5jZSgpO1xuXHRcdHZhciBfdmFsaWRhdGVMaXN0ID0gW107XG5cdFx0dmFyIF92YWxpZGF0ZVNldCA9IG5ldyBTZXQoKTtcblx0XHR2YXIgX3ZhbGlkYXRlSW5kZXggPSAtMTtcblx0XHR2YXIgX3ZhbGlkYXRlUGFzcyA9IG51bGw7XG5cdFx0dmFyIF92YWxpZGF0ZUVuZFBhc3MgPSBudWxsO1xuXHRcdHZhciBfdmFsaWRhdGVDb3VudCA9IDA7XG5cdFx0dmFyIF9pc1ZhbGlkYXRpbmcgPSBmYWxzZTtcblx0XHR2YXIgX2lzQXN5bmMgPSBmYWxzZTtcblx0XHR2YXIgX2RlYnVnU3RhdHMgPSBudWxsO1xuXG5cdFx0Ly8gUHVibGljIFN0YXRpYyBNZXRob2RzXG5cblx0XHRQYXNzLnJlc29sdmUgPSBmdW5jdGlvbih0YXJnZXQsIHBhc3MsIHN0cmljdClcblx0XHR7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciB0YXJnZXQgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cdFx0XHRpZiAocGFzcyA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgcGFzcyBtdXN0IGJlIG5vbi1udWxsLlwiKTtcblxuXHRcdFx0aWYgKHBhc3MgaW5zdGFuY2VvZiBQYXNzKVxuXHRcdFx0XHRyZXR1cm4gcGFzcztcblxuXHRcdFx0aWYgKCFDbGFzcy5pc1N0cmluZyhwYXNzKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIHBhc3MgbXVzdCBiZSBvZiB0eXBlIFN0cmluZyBvciBcIiArIENsYXNzLmdldE5hbWUoUGFzcykgKyBcIi5cIik7XG5cblx0XHRcdHZhciBwYXNzTmFtZSA9IHBhc3M7XG5cdFx0XHRpZiAocGFzc05hbWUuaW5kZXhPZihcIi5cIikgPCAwKVxuXHRcdFx0e1xuXHRcdFx0XHRwYXNzID0gdGFyZ2V0W3Bhc3NOYW1lXTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dmFyIHBhc3NQYXRoID0gcGFzc05hbWUuc3BsaXQoXCIuXCIpO1xuXHRcdFx0XHRwYXNzID0gdGFyZ2V0O1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhc3NQYXRoLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBhc3MgPSBwYXNzW3Bhc3NQYXRoW2ldXTtcblx0XHRcdFx0XHRpZiAocGFzcyA9PSBudWxsKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKChwYXNzICE9IG51bGwpICYmIChwYXNzIGluc3RhbmNlb2YgUGFzcykpXG5cdFx0XHRcdHJldHVybiBwYXNzO1xuXG5cdFx0XHRpZiAoc3RyaWN0ICE9PSBmYWxzZSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwYXNzIFxcXCJcIiArIHBhc3NOYW1lICsgXCJcXFwiLlwiKTtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblxuXHRcdFBhc3MudmFsaWRhdGVBbGwgPSBmdW5jdGlvbihlbmRQYXNzKVxuXHRcdHtcblx0XHRcdHZhciBpc0FzeW5jID0gX2lzQXN5bmM7XG5cdFx0XHRfaXNBc3luYyA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoKGVuZFBhc3MgIT0gbnVsbCkgJiYgIShlbmRQYXNzIGluc3RhbmNlb2YgUGFzcykpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBlbmRQYXNzIG11c3QgYmUgb2YgdHlwZSBcIiArIENsYXNzLmdldE5hbWUoUGFzcykgKyBcIi5cIik7XG5cblx0XHRcdGlmIChfaXNWYWxpZGF0aW5nIHx8IChfdmFsaWRhdGVMaXN0Lmxlbmd0aCA9PT0gMCkpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dmFyIHN0YXRzTGlzdCA9IFBhc3MuZGVidWcgPyBbXSA6IG51bGw7XG5cdFx0XHR2YXIgc3RhdHNTdW1tYXJ5ID0gc3RhdHNMaXN0ID8gRGVidWdTdGF0cy5iZWdpbigpIDogbnVsbDtcblx0XHRcdHZhciBzdGF0cztcblxuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdF9pc1ZhbGlkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRfdmFsaWRhdGVFbmRQYXNzID0gZW5kUGFzcztcblx0XHRcdFx0X3ZhbGlkYXRlQ291bnQrKztcblxuXHRcdFx0XHRmb3IgKF92YWxpZGF0ZUluZGV4ID0gMDsgX3ZhbGlkYXRlSW5kZXggPCBfdmFsaWRhdGVMaXN0Lmxlbmd0aDsgX3ZhbGlkYXRlSW5kZXgrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF92YWxpZGF0ZVBhc3MgPSBfdmFsaWRhdGVMaXN0W192YWxpZGF0ZUluZGV4XTtcblx0XHRcdFx0XHRpZiAoX3ZhbGlkYXRlRW5kUGFzcyAmJiAoX3ZhbGlkYXRlRW5kUGFzcy5fb3JkZXIgPCBfdmFsaWRhdGVQYXNzLl9vcmRlcikpXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGlmIChzdGF0c0xpc3QpXG5cdFx0XHRcdFx0XHRzdGF0cyA9IF9kZWJ1Z1N0YXRzID0gRGVidWdTdGF0cy5iZWdpbihfdmFsaWRhdGVQYXNzKTtcblxuXHRcdFx0XHRcdF92YWxpZGF0ZVBhc3MudmFsaWRhdGVBbGwoKTtcblxuXHRcdFx0XHRcdGlmIChzdGF0c0xpc3QpXG5cdFx0XHRcdFx0XHRzdGF0c0xpc3QucHVzaChEZWJ1Z1N0YXRzLmVuZChzdGF0cykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmaW5hbGx5XG5cdFx0XHR7XG5cdFx0XHRcdF92YWxpZGF0ZUluZGV4ID0gLTE7XG5cdFx0XHRcdF92YWxpZGF0ZVBhc3MgPSBudWxsO1xuXHRcdFx0XHRfdmFsaWRhdGVFbmRQYXNzID0gbnVsbDtcblx0XHRcdFx0X2lzVmFsaWRhdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRfZGVidWdTdGF0cyA9IG51bGw7XG5cblx0XHRcdFx0X2RlcXVldWVWYWxpZFBhc3NlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3RhdHNMaXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRzdGF0c0xpc3QucHVzaChEZWJ1Z1N0YXRzLmVuZChzdGF0c1N1bW1hcnkpKTtcblx0XHRcdFx0RGVidWdTdGF0cy5yZW5kZXIoc3RhdHNMaXN0LCBfdmFsaWRhdGVDb3VudCwgaXNBc3luYyk7XG5cdFx0XHRcdGlmIChfdmFsaWRhdGVMaXN0Lmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0RGVidWdTdGF0cy5yZW5kZXJXYXJuaW5nKF92YWxpZGF0ZUxpc3QsIGVuZFBhc3MpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQYXNzLm1hcmtWYWxpZCA9IGZ1bmN0aW9uKHRhcmdldClcblx0XHR7XG5cdFx0XHR2YXIgdmFsaWRhdGVMaXN0ID0gX3ZhbGlkYXRlTGlzdC5jb25jYXQoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdmFsaWRhdGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dmFsaWRhdGVMaXN0W2ldLm1hcmtWYWxpZCh0YXJnZXQpO1xuXHRcdH07XG5cblx0XHRQYXNzLmlzVmFsaWQgPSBmdW5jdGlvbih0YXJnZXQpXG5cdFx0e1xuXHRcdFx0dmFyIHZhbGlkYXRlTGlzdCA9IF92YWxpZGF0ZUxpc3QuY29uY2F0KCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZhbGlkYXRlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghdmFsaWRhdGVMaXN0W2ldLmlzVmFsaWQodGFyZ2V0KSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHRQYXNzLmlzVmFsaWRhdGluZyA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2lzVmFsaWRhdGluZztcblx0XHR9O1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0dmFyIF9lbnF1ZXVlUGFzcyA9IGZ1bmN0aW9uKHBhc3MpXG5cdFx0e1xuXHRcdFx0aWYgKF92YWxpZGF0ZVNldC5oYXMocGFzcykpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dmFyIGluZGV4ID0gLUFycmF5VXRpbC5iaW5hcnlTZWFyY2goX3ZhbGlkYXRlTGlzdCwgcGFzcywgX3Bhc3NDb21wYXJhdG9yKSAtIDE7XG5cdFx0XHRpZiAoaW5kZXggPCBfdmFsaWRhdGVMaXN0Lmxlbmd0aClcblx0XHRcdFx0X3ZhbGlkYXRlTGlzdC5zcGxpY2UoaW5kZXgsIDAsIHBhc3MpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRfdmFsaWRhdGVMaXN0LnB1c2gocGFzcyk7XG5cblx0XHRcdF92YWxpZGF0ZVNldC5hZGQocGFzcyk7XG5cblx0XHRcdGlmIChpbmRleCA8PSBfdmFsaWRhdGVJbmRleClcblx0XHRcdFx0X3ZhbGlkYXRlSW5kZXgrKztcblxuXHRcdFx0aWYgKF92YWxpZGF0ZUxpc3QubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRfdmFsaWRhdGVDbG9jay5vbihfdmFsaWRhdGVDbG9jay5mcmFtZVRpY2ssIF92YWxpZGF0ZUNsb2NrVGljaywgbnVsbCwgUGFzcy5GUkFNRV9QUklPUklUWSk7XG5cdFx0fTtcblxuXHRcdHZhciBfZGVxdWV1ZVZhbGlkUGFzc2VzID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHZhciBwYXNzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IF92YWxpZGF0ZUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR7XG5cdFx0XHRcdHBhc3MgPSBfdmFsaWRhdGVMaXN0W2ldO1xuXHRcdFx0XHRpZiAocGFzcy5fdGFyZ2V0TWFwLnNpemUoKSA9PT0gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF92YWxpZGF0ZUxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdF92YWxpZGF0ZVNldC5kZWwocGFzcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKF92YWxpZGF0ZUxpc3QubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRfdmFsaWRhdGVDbG9jay5vZmYoX3ZhbGlkYXRlQ2xvY2suZnJhbWVUaWNrLCBfdmFsaWRhdGVDbG9ja1RpY2spO1xuXHRcdH07XG5cblx0XHR2YXIgX3ZhbGlkYXRlQ2xvY2tUaWNrID0gZnVuY3Rpb24oZSlcblx0XHR7XG5cdFx0XHRfaXNBc3luYyA9IHRydWU7XG5cdFx0XHRQYXNzLnZhbGlkYXRlQWxsKCk7XG5cdFx0fTtcblxuXHRcdHZhciBfcGFzc0NvbXBhcmF0b3IgPSBmdW5jdGlvbihwYXNzMSwgcGFzczIpXG5cdFx0e1xuXHRcdFx0aWYgKHBhc3MxLl9vcmRlciA8PSBwYXNzMi5fb3JkZXIpXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH07XG5cblx0XHR2YXIgX3RvcERvd25Db21wYXJhdG9yID0gZnVuY3Rpb24odGFyZ2V0SW5mbzEsIHRhcmdldEluZm8yKVxuXHRcdHtcblx0XHRcdGlmICh0YXJnZXRJbmZvMS5kZXB0aCA8IHRhcmdldEluZm8yLmRlcHRoKVxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRpZiAodGFyZ2V0SW5mbzEuZGVwdGggPiB0YXJnZXRJbmZvMi5kZXB0aClcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXG5cdFx0dmFyIF9ib3R0b21VcENvbXBhcmF0b3IgPSBmdW5jdGlvbih0YXJnZXRJbmZvMSwgdGFyZ2V0SW5mbzIpXG5cdFx0e1xuXHRcdFx0aWYgKHRhcmdldEluZm8xLmRlcHRoID4gdGFyZ2V0SW5mbzIuZGVwdGgpXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdGlmICh0YXJnZXRJbmZvMS5kZXB0aCA8IHRhcmdldEluZm8yLmRlcHRoKVxuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cblx0XHR2YXIgX3dyYXBDb21wYXJhdG9yID0gZnVuY3Rpb24oY29tcGFyYXRvciwgZGlyZWN0aW9uKVxuXHRcdHtcblx0XHRcdHJldHVybiBmdW5jdGlvbih0YXJnZXRJbmZvMSwgdGFyZ2V0SW5mbzIpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiAoY29tcGFyYXRvcih0YXJnZXRJbmZvMS50YXJnZXQsIHRhcmdldEluZm8yLnRhcmdldCkgKiBkaXJlY3Rpb24pO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gUHVibGljIEV2ZW50c1xuXG5cdFx0dGhpcy5pbnZhbGlkYXRlZCA9IG51bGw7XG5cdFx0dGhpcy52YWxpZGF0ZWQgPSBudWxsO1xuXG5cdFx0Ly8gUHJpdmF0ZSBQcm9wZXJ0aWVzXG5cblx0XHR0aGlzLl9uYW1lID0gbnVsbDtcblx0XHR0aGlzLl9vcmRlciA9IDA7XG5cdFx0dGhpcy5fZGlyZWN0aW9uID0gXCJub25lXCI7XG5cdFx0dGhpcy5fY29tcGFyYXRvciA9IG51bGw7XG5cdFx0dGhpcy5fdGFyZ2V0TWFwID0gbnVsbDtcblxuXHRcdC8vIENvbnN0cnVjdG9yXG5cblx0XHR0aGlzLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24obmFtZSwgb3JkZXIsIGRpcmVjdGlvbilcblx0XHR7XG5cdFx0XHRpZiAobmFtZSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbmFtZSBtdXN0IGJlIG5vbi1udWxsLlwiKTtcblx0XHRcdGlmICghQ2xhc3MuaXNTdHJpbmcobmFtZSkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBuYW1lIG11c3QgYmUgb2YgdHlwZSBTdHJpbmcuXCIpO1xuXHRcdFx0aWYgKChvcmRlciAhPSBudWxsKSAmJiAhQ2xhc3MuaXNOdW1iZXIob3JkZXIpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgb3JkZXIgbXVzdCBiZSBvZiB0eXBlIE51bWJlci5cIik7XG5cdFx0XHRpZiAoKGRpcmVjdGlvbiAhPSBudWxsKSAmJiAhQ2xhc3MuaXNTdHJpbmcoZGlyZWN0aW9uKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGRpcmVjdGlvbiBtdXN0IGJlIG9mIHR5cGUgU3RyaW5nLlwiKTtcblxuXHRcdFx0dGhpcy5fbmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLl9vcmRlciA9ICgob3JkZXIgIT0gbnVsbCkgJiYgIWlzTmFOKG9yZGVyKSkgPyBvcmRlciA6IDA7XG5cdFx0XHR0aGlzLl9kaXJlY3Rpb24gPSAoKGRpcmVjdGlvbiA9PT0gXCJ0b3BEb3duXCIpIHx8IChkaXJlY3Rpb24gPT09IFwiYm90dG9tVXBcIikpID8gZGlyZWN0aW9uIDogXCJub25lXCI7XG5cblx0XHRcdHRoaXMuX3RhcmdldE1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdFx0dGhpcy5pbnZhbGlkYXRlZCA9IG5ldyBDaGFpbmVkRXZlbnQobmFtZSArIFwiLmludmFsaWRhdGVkXCIsIFBhc3MuaW52YWxpZGF0ZWQpO1xuXHRcdFx0dGhpcy52YWxpZGF0ZWQgPSBuZXcgQ2hhaW5lZEV2ZW50KG5hbWUgKyBcIi52YWxpZGF0ZWRcIiwgUGFzcy52YWxpZGF0ZWQpO1xuXHRcdH07XG5cblx0XHQvLyBQdWJsaWMgQWNjZXNzb3IgTWV0aG9kc1xuXG5cdFx0dGhpcy5uYW1lID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9uYW1lO1xuXHRcdH07XG5cblx0XHR0aGlzLm9yZGVyID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9vcmRlcjtcblx0XHR9O1xuXG5cdFx0dGhpcy5kaXJlY3Rpb24gPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RpcmVjdGlvbjtcblx0XHR9O1xuXG5cdFx0dGhpcy5jb21wYXJhdG9yID0gZnVuY3Rpb24odmFsdWUpXG5cdFx0e1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY29tcGFyYXRvcjtcblxuXHRcdFx0aWYgKCh2YWx1ZSAhPSBudWxsKSAmJiAhQ2xhc3MuaXNGdW5jdGlvbih2YWx1ZSkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBjb21wYXJhdG9yIG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi5cIik7XG5cblx0XHRcdHRoaXMuX2NvbXBhcmF0b3IgPSB2YWx1ZSB8fCBudWxsO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0Ly8gUHVibGljIE1ldGhvZHNcblxuXHRcdHRoaXMuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKHRhcmdldClcblx0XHR7XG5cdFx0XHR2YXIgdGFyZ2V0TWFwID0gdGhpcy5fdGFyZ2V0TWFwO1xuXHRcdFx0aWYgKHRhcmdldE1hcC5oYXModGFyZ2V0KSlcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR2YXIgbWV0aG9kID0gdGFyZ2V0W3RoaXMuX25hbWVdO1xuXHRcdFx0aWYgKChtZXRob2QgPT0gbnVsbCkgfHwgIUNsYXNzLmlzRnVuY3Rpb24obWV0aG9kKSlcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR0YXJnZXRNYXAuc2V0KHRhcmdldCwgeyB0YXJnZXQ6IHRhcmdldCwgbWV0aG9kOiBtZXRob2QsIGRlcHRoOiAwIH0pO1xuXHRcdFx0aWYgKHRhcmdldE1hcC5zaXplKCkgPT09IDEpXG5cdFx0XHRcdF9lbnF1ZXVlUGFzcyh0aGlzKTtcblxuXHRcdFx0aWYgKHRhcmdldC5pc0V2ZW50VGFyZ2V0KVxuXHRcdFx0XHR0YXJnZXQuZmlyZSh0aGlzLmludmFsaWRhdGVkLCBuZXcgUGFzc0V2ZW50RGF0YSh0aGlzKSk7XG5cdFx0fTtcblxuXHRcdHRoaXMudmFsaWRhdGUgPSBmdW5jdGlvbih0YXJnZXQpXG5cdFx0e1xuXHRcdFx0dmFyIHRhcmdldEluZm8gPSB0aGlzLl90YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG5cdFx0XHRpZiAoIXRhcmdldEluZm8pXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdHRhcmdldEluZm8ubWV0aG9kLmNhbGwodGFyZ2V0KTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKVxuXHRcdFx0e1xuXHRcdFx0XHRFcnJvclV0aWwubm9uQmxvY2tpbmdUaHJvdyhlKTtcblx0XHRcdH1cblx0XHRcdGZpbmFsbHlcblx0XHRcdHtcblx0XHRcdFx0aWYgKHRhcmdldEluZm8udGFyZ2V0KVxuXHRcdFx0XHRcdHRoaXMubWFya1ZhbGlkKHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMudmFsaWRhdGVBbGwgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblx0XHRcdHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcblx0XHRcdHZhciB0YXJnZXRJbmZvTGlzdCA9IHRoaXMuX3RhcmdldE1hcC52YWx1ZXMoKTtcblx0XHRcdHZhciB0YXJnZXRJbmZvQ291bnQgPSB0YXJnZXRJbmZvTGlzdC5sZW5ndGg7XG5cdFx0XHR2YXIgdGFyZ2V0SW5mbztcblx0XHRcdHZhciB0YXJnZXQ7XG5cdFx0XHR2YXIgZGVwdGg7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0aWYgKHRhcmdldEluZm9Db3VudCA9PT0gMClcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRpZiAoY29tcGFyYXRvcilcblx0XHRcdHtcblx0XHRcdFx0Y29tcGFyYXRvciA9IF93cmFwQ29tcGFyYXRvcihjb21wYXJhdG9yLCAoZGlyZWN0aW9uID09PSBcImJvdHRvbVVwXCIpID8gLTEgOiAxKTtcblx0XHRcdFx0dGFyZ2V0SW5mb0xpc3Quc29ydChjb21wYXJhdG9yKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGRpcmVjdGlvbiAhPT0gXCJub25lXCIpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRJbmZvQ291bnQ7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRhcmdldEluZm8gPSB0YXJnZXRJbmZvTGlzdFtpXTtcblx0XHRcdFx0XHRkZXB0aCA9ICt0YXJnZXRJbmZvLnRhcmdldC5nZXRWYWxpZGF0ZURlcHRoKCk7XG5cdFx0XHRcdFx0dGFyZ2V0SW5mby5kZXB0aCA9ICFpc05hTihkZXB0aCkgPyBkZXB0aCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZGlyZWN0aW9uID09PSBcImJvdHRvbVVwXCIpXG5cdFx0XHRcdFx0dGFyZ2V0SW5mb0xpc3Quc29ydChfYm90dG9tVXBDb21wYXJhdG9yKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRhcmdldEluZm9MaXN0LnNvcnQoX3RvcERvd25Db21wYXJhdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldEluZm9Db3VudDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHR0YXJnZXQgPSB0YXJnZXRJbmZvTGlzdFtpXS50YXJnZXQ7XG5cdFx0XHRcdGlmICh0YXJnZXQpXG5cdFx0XHRcdFx0dGhpcy52YWxpZGF0ZSh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLm1hcmtWYWxpZCA9IGZ1bmN0aW9uKHRhcmdldClcblx0XHR7XG5cdFx0XHR2YXIgdGFyZ2V0TWFwID0gdGhpcy5fdGFyZ2V0TWFwO1xuXHRcdFx0dmFyIHRhcmdldEluZm8gPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG5cdFx0XHRpZiAoIXRhcmdldEluZm8pXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dGFyZ2V0TWFwLmRlbCh0YXJnZXQpO1xuXHRcdFx0dGFyZ2V0SW5mby50YXJnZXQgPSBudWxsO1xuXHRcdFx0dGFyZ2V0SW5mby5tZXRob2QgPSBudWxsO1xuXG5cdFx0XHRpZiAoX2RlYnVnU3RhdHMgJiYgKF9kZWJ1Z1N0YXRzLnBhc3MgPT09IHRoaXMpKVxuXHRcdFx0XHRfZGVidWdTdGF0cy50YXJnZXRzKys7XG5cblx0XHRcdGlmICh0YXJnZXQuaXNFdmVudFRhcmdldClcblx0XHRcdFx0dGFyZ2V0LmZpcmUodGhpcy52YWxpZGF0ZWQsIG5ldyBQYXNzRXZlbnREYXRhKHRoaXMpKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5pc1ZhbGlkID0gZnVuY3Rpb24odGFyZ2V0KVxuXHRcdHtcblx0XHRcdHJldHVybiAhdGhpcy5fdGFyZ2V0TWFwLmhhcyh0YXJnZXQpO1xuXHRcdH07XG5cblx0XHR0aGlzLmlzVmFsaWRhdGluZyA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gKF9pc1ZhbGlkYXRpbmcgJiYgKChfdmFsaWRhdGVFbmRQYXNzID09IG51bGwpIHx8IChfdmFsaWRhdGVFbmRQYXNzLl9vcmRlciA+PSB0aGlzLl9vcmRlcikpKTtcblx0XHR9O1xuXG5cdFx0Ly8gUHJpdmF0ZSBOZXN0ZWQgQ2xhc3Nlc1xuXG5cdFx0dmFyIERlYnVnU3RhdHMgPSBDbGFzcyhmdW5jdGlvbihEZWJ1Z1N0YXRzKVxuXHRcdHtcblxuXHRcdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgQ29uc3RhbnRzXG5cblx0XHRcdHZhciBfUl9ERUNJTUFMID0gL15bXlxcLmVdKihbXiRdKikkLztcblx0XHRcdHZhciBfUl9JTkZJTklUWSA9IC9eXFwtP0luZmluaXR5JC87XG5cblx0XHRcdC8vIFB1YmxpYyBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0XHREZWJ1Z1N0YXRzLmJlZ2luID0gZnVuY3Rpb24ocGFzcylcblx0XHRcdHtcblx0XHRcdFx0dmFyIHN0YXRzID0ge307XG5cdFx0XHRcdHN0YXRzLnBhc3MgPSBwYXNzIHx8IG51bGw7XG5cdFx0XHRcdHN0YXRzLnRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdFx0aWYgKHBhc3MpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdGF0cy5uYW1lID0gcGFzcy5fbmFtZTtcblx0XHRcdFx0XHRzdGF0cy5vcmRlciA9IHBhc3MuX29yZGVyO1xuXHRcdFx0XHRcdHN0YXRzLnRhcmdldHMgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdGF0cztcblx0XHRcdH07XG5cblx0XHRcdERlYnVnU3RhdHMuZW5kID0gZnVuY3Rpb24oc3RhdHMpXG5cdFx0XHR7XG5cdFx0XHRcdHN0YXRzLnRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXRzLnRpbWU7XG5cdFx0XHRcdHJldHVybiBzdGF0cztcblx0XHRcdH07XG5cblx0XHRcdERlYnVnU3RhdHMucmVuZGVyID0gZnVuY3Rpb24oc3RhdHNMaXN0LCBpdGVyYXRpb25Db3VudCwgaXNBc3luYylcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFHbG9iYWwuY29uc29sZSB8fCAhR2xvYmFsLmNvbnNvbGUubG9nKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRfZm9ybWF0RGF0YShzdGF0c0xpc3QpO1xuXG5cdFx0XHRcdHZhciB0aXRsZSA9IFwiQVNZTkMgUEFTUyBWQUxJREFUSU9OIC0gaXRlcmF0aW9uIFwiICsgaXRlcmF0aW9uQ291bnQgKyAoIWlzQXN5bmMgPyBcIiAoRk9SQ0VEIFNZTkMpXCIgOiBcIlwiKTtcblxuXHRcdFx0XHR2YXIgY29sdW1ucyA9IFtdO1xuXHRcdFx0XHRjb2x1bW5zLnB1c2goeyBoZWFkaW5nOiBcIm5hbWVcIiwgZmllbGQ6IFwibmFtZVwiLCBhbGlnbjogXCJsZWZ0XCIgfSk7XG5cdFx0XHRcdGNvbHVtbnMucHVzaCh7IGhlYWRpbmc6IFwib3JkZXJcIiwgZmllbGQ6IFwib3JkZXJcIiwgYWxpZ246IFwicmlnaHRcIiB9KTtcblx0XHRcdFx0Y29sdW1ucy5wdXNoKHsgaGVhZGluZzogXCJ0YXJnZXRzXCIsIGZpZWxkOiBcInRhcmdldHNcIiwgYWxpZ246IFwicmlnaHRcIiB9KTtcblx0XHRcdFx0Y29sdW1ucy5wdXNoKHsgaGVhZGluZzogXCJ0aW1lXCIsIGZpZWxkOiBcInRpbWVcIiwgYWxpZ246IFwicmlnaHRcIiB9KTtcblxuXHRcdFx0XHR2YXIgc3RyID0gXCJcXG5cIiArIF9yZW5kZXJUYWJsZSh0aXRsZSwgY29sdW1ucywgc3RhdHNMaXN0LCB0cnVlKSArIFwiXFxuXCI7XG5cblx0XHRcdFx0dHJ5XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRHbG9iYWwuY29uc29sZS5sb2coc3RyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIGlnbm9yZSBlcnJvcnNcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0RGVidWdTdGF0cy5yZW5kZXJXYXJuaW5nID0gZnVuY3Rpb24ocGFzc0xpc3QsIGVuZFBhc3MpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghR2xvYmFsLmNvbnNvbGUgfHwgIUdsb2JhbC5jb25zb2xlLndhcm4pXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdHZhciBkYXRhTGlzdCA9IFtdO1xuXHRcdFx0XHR2YXIgcGFzcztcblxuXHRcdFx0XHQvLyBwb3B1bGF0ZSBkYXRhTGlzdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhc3NMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBhc3MgPSBwYXNzTGlzdFtpXTtcblx0XHRcdFx0XHRpZiAoZW5kUGFzcyAmJiAoZW5kUGFzcy5fb3JkZXIgPCBwYXNzLl9vcmRlcikpXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRhdGFMaXN0LnB1c2goeyBuYW1lOiBwYXNzLl9uYW1lLCBvcmRlcjogcGFzcy5fb3JkZXIsIHRhcmdldHM6IHBhc3MuX3RhcmdldE1hcC5zaXplKCkgfSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBiYWlsIGlmIG5vIHBhc3NlcyBvY2N1ciBiZWZvcmUgZW5kUGFzc1xuXHRcdFx0XHRpZiAoZGF0YUxpc3QubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRfZm9ybWF0RGF0YShkYXRhTGlzdCk7XG5cblx0XHRcdFx0dmFyIG1lc3NhZ2UgPSBcIldBUk5JTkc6IFZhbGlkYXRpb24gY3ljbGUgZGV0ZWN0ZWQuXCI7XG5cblx0XHRcdFx0dmFyIHRpdGxlID0gXCJQYXNzZXMgcXVldWVkIGZvciBuZXh0IGl0ZXJhdGlvbi4uLlwiO1xuXG5cdFx0XHRcdHZhciBjb2x1bW5zID0gW107XG5cdFx0XHRcdGNvbHVtbnMucHVzaCh7IGhlYWRpbmc6IFwibmFtZVwiLCBmaWVsZDogXCJuYW1lXCIsIGFsaWduOiBcImxlZnRcIiB9KTtcblx0XHRcdFx0Y29sdW1ucy5wdXNoKHsgaGVhZGluZzogXCJvcmRlclwiLCBmaWVsZDogXCJvcmRlclwiLCBhbGlnbjogXCJyaWdodFwiIH0pO1xuXHRcdFx0XHRjb2x1bW5zLnB1c2goeyBoZWFkaW5nOiBcInRhcmdldHNcIiwgZmllbGQ6IFwidGFyZ2V0c1wiLCBhbGlnbjogXCJyaWdodFwiIH0pO1xuXG5cdFx0XHRcdHZhciBzdHIgPSBtZXNzYWdlICsgXCJcXG5cXG5cIiArIF9yZW5kZXJUYWJsZSh0aXRsZSwgY29sdW1ucywgZGF0YUxpc3QpICsgXCJcXG5cIjtcblxuXHRcdFx0XHR0cnlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdEdsb2JhbC5jb25zb2xlLndhcm4oc3RyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIGlnbm9yZSBlcnJvcnNcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0XHR2YXIgX2Zvcm1hdERhdGEgPSBmdW5jdGlvbihkYXRhTGlzdClcblx0XHRcdHtcblx0XHRcdFx0dmFyIGRhdGFDb3VudCA9IGRhdGFMaXN0Lmxlbmd0aDtcblx0XHRcdFx0dmFyIGRhdGE7XG5cdFx0XHRcdHZhciBkZWNpbWFsV2lkdGggPSAwO1xuXHRcdFx0XHR2YXIgaTtcblxuXHRcdFx0XHQvLyBtZWFzdXJlIGRlY2ltYWwgd2lkdGggb2YgXCJvcmRlclwiIGZpZWxkc1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUNvdW50OyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRkYXRhID0gZGF0YUxpc3RbaV07XG5cdFx0XHRcdFx0aWYgKE9iamVjdFV0aWwuaGFzKGRhdGEsIFwib3JkZXJcIikpXG5cdFx0XHRcdFx0XHRkZWNpbWFsV2lkdGggPSBNYXRoLm1heChkZWNpbWFsV2lkdGgsIF9tZWFzdXJlRGVjaW1hbChkYXRhLm9yZGVyKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmb3JtYXQgXCJvcmRlclwiIGFuZCBcInRpbWVcIiBmaWVsZHNcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFDb3VudDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFMaXN0W2ldO1xuXHRcdFx0XHRcdGlmIChPYmplY3RVdGlsLmhhcyhkYXRhLCBcIm9yZGVyXCIpKVxuXHRcdFx0XHRcdFx0ZGF0YS5vcmRlciA9IF9mb3JtYXREZWNpbWFsKGRhdGEub3JkZXIsIGRlY2ltYWxXaWR0aCk7XG5cdFx0XHRcdFx0aWYgKE9iamVjdFV0aWwuaGFzKGRhdGEsIFwidGltZVwiKSlcblx0XHRcdFx0XHRcdGRhdGEudGltZSA9IF9mb3JtYXRUaW1lKGRhdGEudGltZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGF0YUxpc3Q7XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgX3JlbmRlclRhYmxlID0gZnVuY3Rpb24odGl0bGUsIGNvbHVtbkxpc3QsIGRhdGFMaXN0LCBoYXNGb290ZXIpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjb2x1bW5Db3VudCA9IGNvbHVtbkxpc3QubGVuZ3RoO1xuXHRcdFx0XHR2YXIgY29sdW1uO1xuXHRcdFx0XHR2YXIgZGF0YUNvdW50ID0gZGF0YUxpc3QubGVuZ3RoO1xuXHRcdFx0XHR2YXIgZGF0YTtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdHZhciBqO1xuXG5cdFx0XHRcdHZhciB3aWR0aCA9IChjb2x1bW5Db3VudCAtIDEpICogMjtcblx0XHRcdFx0dmFyIGNvbHVtbldpZHRocyA9IFtdO1xuXHRcdFx0XHR2YXIgY29sdW1uV2lkdGg7XG5cblx0XHRcdFx0Ly8gbWVhc3VyZSBjb2x1bW5zXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29sdW1uID0gY29sdW1uTGlzdFtpXTtcblx0XHRcdFx0XHRjb2x1bW5XaWR0aCA9IF9tZWFzdXJlVmFsdWUoY29sdW1uLmhlYWRpbmcpO1xuXG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGRhdGFDb3VudDsgaisrKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhTGlzdFtqXTtcblx0XHRcdFx0XHRcdGNvbHVtbldpZHRoID0gTWF0aC5tYXgoY29sdW1uV2lkdGgsIF9tZWFzdXJlVmFsdWUoT2JqZWN0VXRpbC5nZXQoZGF0YSwgY29sdW1uLmZpZWxkKSkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdpZHRoICs9IGNvbHVtbldpZHRoO1xuXHRcdFx0XHRcdGNvbHVtbldpZHRocy5wdXNoKGNvbHVtbldpZHRoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG1lYXN1cmUgdGl0bGUgYW5kIGFkanVzdCBjb2x1bW4gd2lkdGhzIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAodGl0bGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgdGl0bGVXaWR0aCA9IF9tZWFzdXJlVmFsdWUodGl0bGUpO1xuXHRcdFx0XHRcdGlmICh0aXRsZVdpZHRoID4gd2lkdGgpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGRpZmYgPSAodGl0bGVXaWR0aCAtIHdpZHRoKTtcblx0XHRcdFx0XHRcdHdpZHRoID0gdGl0bGVXaWR0aDtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkaWZmOyBpKyspXG5cdFx0XHRcdFx0XHRcdGNvbHVtbldpZHRoc1tpICUgY29sdW1uQ291bnRdKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHN0ciA9IFwiXCI7XG5cdFx0XHRcdHZhciBkaXZpZGVyID0gX3JlbmRlclZhbHVlKFwiXCIsIHdpZHRoLCBcImxlZnRcIiwgXCItXCIpO1xuXG5cdFx0XHRcdC8vIHJlbmRlciB0aXRsZVxuXHRcdFx0XHRpZiAodGl0bGUpXG5cdFx0XHRcdFx0c3RyICs9IF9yZW5kZXJWYWx1ZSh0aXRsZSwgd2lkdGgpICsgXCJcXG5cXG5cIjtcblxuXHRcdFx0XHQvLyByZW5kZXIgaGVhZGluZ3Ncblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5MaXN0W2ldO1xuXHRcdFx0XHRcdHN0ciArPSBfcmVuZGVyVmFsdWUoY29sdW1uLmhlYWRpbmcsIGNvbHVtbldpZHRoc1tpXSwgY29sdW1uLmFsaWduKTtcblx0XHRcdFx0XHRzdHIgKz0gKGkgPCAoY29sdW1uQ291bnQgLSAxKSkgPyBcIiAgXCIgOiBcIlxcblwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0ciArPSBkaXZpZGVyICsgXCJcXG5cIjtcblxuXHRcdFx0XHQvLyByZW5kZXIgcm93c1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUNvdW50OyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRkYXRhID0gZGF0YUxpc3RbaV07XG5cblx0XHRcdFx0XHRpZiAoaGFzRm9vdGVyICYmIChpID09PSAoZGF0YUNvdW50IC0gMSkpKVxuXHRcdFx0XHRcdFx0c3RyICs9IGRpdmlkZXIgKyBcIlxcblwiO1xuXG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGNvbHVtbkNvdW50OyBqKyspXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29sdW1uID0gY29sdW1uTGlzdFtqXTtcblx0XHRcdFx0XHRcdHN0ciArPSBfcmVuZGVyVmFsdWUoT2JqZWN0VXRpbC5nZXQoZGF0YSwgY29sdW1uLmZpZWxkKSwgY29sdW1uV2lkdGhzW2pdLCBjb2x1bW4uYWxpZ24pO1xuXHRcdFx0XHRcdFx0c3RyICs9IChqIDwgKGNvbHVtbkNvdW50IC0gMSkpID8gXCIgIFwiIDogXCJcXG5cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc3RyO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIF9tZWFzdXJlVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKHZhbHVlID09IG51bGwpXG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cblx0XHRcdFx0cmV0dXJuIChcIlwiICsgdmFsdWUpLmxlbmd0aDtcblx0XHRcdH07XG5cblx0XHRcdHZhciBfcmVuZGVyVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgd2lkdGgsIGFsaWduLCBwYWRDaGFyKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXBhZENoYXIpXG5cdFx0XHRcdFx0cGFkQ2hhciA9IFwiIFwiO1xuXG5cdFx0XHRcdHZhciBzdHIgPSAodmFsdWUgIT0gbnVsbCkgPyAoXCJcIiArIHZhbHVlKSA6IFwiXCI7XG5cdFx0XHRcdHZhciBpO1xuXG5cdFx0XHRcdGlmIChhbGlnbiA9PT0gXCJyaWdodFwiKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChpID0gc3RyLmxlbmd0aDsgaSA8IHdpZHRoOyBpKyspXG5cdFx0XHRcdFx0XHRzdHIgPSBwYWRDaGFyICsgc3RyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoaSA9IHN0ci5sZW5ndGg7IGkgPCB3aWR0aDsgaSsrKVxuXHRcdFx0XHRcdFx0c3RyICs9IHBhZENoYXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc3RyO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIF9tZWFzdXJlRGVjaW1hbCA9IGZ1bmN0aW9uKHZhbHVlKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodmFsdWUgPT0gbnVsbClcblx0XHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0XHR2YXIgbWF0Y2ggPSAoXCJcIiArIHZhbHVlKS5tYXRjaChfUl9ERUNJTUFMKTtcblx0XHRcdFx0aWYgKG1hdGNoKVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaFsxXS5sZW5ndGg7XG5cblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgX2Zvcm1hdERlY2ltYWwgPSBmdW5jdGlvbih2YWx1ZSwgZGVjaW1hbFdpZHRoKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodmFsdWUgPT0gbnVsbClcblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcblxuXHRcdFx0XHR2YXIgc3RyID0gXCJcIiArIHZhbHVlO1xuXHRcdFx0XHRpZiAoX1JfSU5GSU5JVFkudGVzdChzdHIpKVxuXHRcdFx0XHRcdHJldHVybiBzdHI7XG5cblx0XHRcdFx0dmFyIG1hdGNoID0gc3RyLm1hdGNoKF9SX0RFQ0lNQUwpO1xuXHRcdFx0XHRpZiAobWF0Y2gpXG5cdFx0XHRcdFx0ZGVjaW1hbFdpZHRoIC09IG1hdGNoWzFdLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlY2ltYWxXaWR0aDsgaSsrKVxuXHRcdFx0XHRcdHN0ciArPSBcIiBcIjtcblxuXHRcdFx0XHRyZXR1cm4gc3RyO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIF9mb3JtYXRUaW1lID0gZnVuY3Rpb24odmFsdWUpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PSBudWxsKVxuXHRcdFx0XHRcdHJldHVybiBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiAodmFsdWUgKyBcIiBtc1wiKTtcblx0XHRcdH07XG5cblx0XHR9KTtcblxuXHR9KTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9qZ19saWIvYXN5bmMvUGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9qZ19saWIvYXN5bmMvUGFzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/jg_lib/async/FrameClock":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Clock = __webpack_require__(\"contrib/jg_lib/async/Clock\");\n\tvar ClockEventData = __webpack_require__(\"contrib/jg_lib/async/ClockEventData\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\tvar Event = __webpack_require__(\"contrib/jg_lib/events/Event\");\n\tvar Global = __webpack_require__(\"contrib/jg_lib/utils/Global\");\n\n\treturn Class(module.id, Clock, function(FrameClock, base)\n\t{\n\n\t\t// Private Static Properties\n\n\t\tvar _instance = null;\n\t\tvar _instantiating = false;\n\t\tvar _timeMS = 0;\n\t\tvar _isRunning = false;\n\t\tvar _isTickPending = false;\n\n\t\t// Public Static Methods\n\n\t\tFrameClock.getInstance = function()\n\t\t{\n\t\t\tif (!_instance)\n\t\t\t{\n\t\t\t\t_instantiating = true;\n\t\t\t\t_instance = new FrameClock();\n\t\t\t\t_instantiating = false;\n\t\t\t}\n\t\t\treturn _instance;\n\t\t};\n\n\t\t// Private Static Methods\n\n\t\tvar _requestAnimationFrame =\n\t\t\tGlobal.requestAnimationFrame ||\n\t\t\tGlobal.webkitRequestAnimationFrame ||\n\t\t\tGlobal.mozRequestAnimationFrame ||\n\t\t\tGlobal.msRequestAnimationFrame ||\n\t\t\tGlobal.oRequestAnimationFrame ||\n\t\t\tfunction(callback) { setTimeout(callback, 1000 / 60); };\n\n\t\tvar _start = function()\n\t\t{\n\t\t\t_isRunning = true;\n\n\t\t\tif (_isTickPending)\n\t\t\t\treturn;\n\n\t\t\t_isTickPending = true;\n\t\t\t_timeMS = new Date().getTime();\n\t\t\t_requestAnimationFrame(_tick);\n\t\t};\n\n\t\tvar _stop = function()\n\t\t{\n\t\t\t_isRunning = false;\n\t\t};\n\n\t\tvar _tick = function()\n\t\t{\n\t\t\tif (!_isRunning)\n\t\t\t{\n\t\t\t\t_isTickPending = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar timeMS = new Date().getTime();\n\t\t\tvar deltaTimeMS = timeMS - _timeMS;\n\t\t\t_timeMS = timeMS;\n\n\t\t\t_requestAnimationFrame(_tick);\n\n\t\t\tif (deltaTimeMS > 0)\n\t\t\t{\n\t\t\t\tvar eventData = new ClockEventData(timeMS / 1000, deltaTimeMS / 1000);\n\t\t\t\t_instance.fire(_instance.tick, eventData);\n\t\t\t\t_instance.fire(_instance.frameTick, eventData);\n\t\t\t}\n\t\t};\n\n\t\t// Public Events\n\n\t\tthis.frameTick = new Event(\"frameTick\", ClockEventData);\n\n\t\t// Constructor\n\n\t\tthis.constructor = function()\n\t\t{\n\t\t\tif (!_instantiating)\n\t\t\t\tthrow new Error(\"Singleton class. Use \" + Class.getName(FrameClock) + \".getInstance() to retrieve the instance of this class.\");\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.on = function(event, listener, scope, priority)\n\t\t{\n\t\t\tbase.on.call(this, event, listener, scope, priority);\n\n\t\t\tif (!_isRunning && (_instance.hasListeners(_instance.tick) || _instance.hasListeners(_instance.frameTick)))\n\t\t\t\t_start();\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.off = function(event, listener, scope)\n\t\t{\n\t\t\tbase.off.call(this, event, listener, scope);\n\n\t\t\tif (_isRunning && !(_instance.hasListeners(_instance.tick) || _instance.hasListeners(_instance.frameTick)))\n\t\t\t\t_stop();\n\n\t\t\treturn this;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2FzeW5jL0ZyYW1lQ2xvY2suanM/ODE4ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7O0FBRXhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvYXN5bmMvRnJhbWVDbG9jay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIENsb2NrID0gcmVxdWlyZShcIi4vQ2xvY2tcIik7XG5cdHZhciBDbG9ja0V2ZW50RGF0YSA9IHJlcXVpcmUoXCIuL0Nsb2NrRXZlbnREYXRhXCIpO1xuXHR2YXIgQ2xhc3MgPSByZXF1aXJlKFwiLi4vQ2xhc3NcIik7XG5cdHZhciBFdmVudCA9IHJlcXVpcmUoXCIuLi9ldmVudHMvRXZlbnRcIik7XG5cdHZhciBHbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbHMvR2xvYmFsXCIpO1xuXG5cdHJldHVybiBDbGFzcyhtb2R1bGUuaWQsIENsb2NrLCBmdW5jdGlvbihGcmFtZUNsb2NrLCBiYXNlKVxuXHR7XG5cblx0XHQvLyBQcml2YXRlIFN0YXRpYyBQcm9wZXJ0aWVzXG5cblx0XHR2YXIgX2luc3RhbmNlID0gbnVsbDtcblx0XHR2YXIgX2luc3RhbnRpYXRpbmcgPSBmYWxzZTtcblx0XHR2YXIgX3RpbWVNUyA9IDA7XG5cdFx0dmFyIF9pc1J1bm5pbmcgPSBmYWxzZTtcblx0XHR2YXIgX2lzVGlja1BlbmRpbmcgPSBmYWxzZTtcblxuXHRcdC8vIFB1YmxpYyBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0RnJhbWVDbG9jay5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAoIV9pbnN0YW5jZSlcblx0XHRcdHtcblx0XHRcdFx0X2luc3RhbnRpYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRfaW5zdGFuY2UgPSBuZXcgRnJhbWVDbG9jaygpO1xuXHRcdFx0XHRfaW5zdGFudGlhdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF9pbnN0YW5jZTtcblx0XHR9O1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0dmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuXHRcdFx0R2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0R2xvYmFsLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0R2xvYmFsLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0R2xvYmFsLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHRHbG9iYWwub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0ZnVuY3Rpb24oY2FsbGJhY2spIHsgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTsgfTtcblxuXHRcdHZhciBfc3RhcnQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0X2lzUnVubmluZyA9IHRydWU7XG5cblx0XHRcdGlmIChfaXNUaWNrUGVuZGluZylcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRfaXNUaWNrUGVuZGluZyA9IHRydWU7XG5cdFx0XHRfdGltZU1TID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHRfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aWNrKTtcblx0XHR9O1xuXG5cdFx0dmFyIF9zdG9wID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdF9pc1J1bm5pbmcgPSBmYWxzZTtcblx0XHR9O1xuXG5cdFx0dmFyIF90aWNrID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICghX2lzUnVubmluZylcblx0XHRcdHtcblx0XHRcdFx0X2lzVGlja1BlbmRpbmcgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGltZU1TID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHR2YXIgZGVsdGFUaW1lTVMgPSB0aW1lTVMgLSBfdGltZU1TO1xuXHRcdFx0X3RpbWVNUyA9IHRpbWVNUztcblxuXHRcdFx0X3JlcXVlc3RBbmltYXRpb25GcmFtZShfdGljayk7XG5cblx0XHRcdGlmIChkZWx0YVRpbWVNUyA+IDApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBldmVudERhdGEgPSBuZXcgQ2xvY2tFdmVudERhdGEodGltZU1TIC8gMTAwMCwgZGVsdGFUaW1lTVMgLyAxMDAwKTtcblx0XHRcdFx0X2luc3RhbmNlLmZpcmUoX2luc3RhbmNlLnRpY2ssIGV2ZW50RGF0YSk7XG5cdFx0XHRcdF9pbnN0YW5jZS5maXJlKF9pbnN0YW5jZS5mcmFtZVRpY2ssIGV2ZW50RGF0YSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFB1YmxpYyBFdmVudHNcblxuXHRcdHRoaXMuZnJhbWVUaWNrID0gbmV3IEV2ZW50KFwiZnJhbWVUaWNrXCIsIENsb2NrRXZlbnREYXRhKTtcblxuXHRcdC8vIENvbnN0cnVjdG9yXG5cblx0XHR0aGlzLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICghX2luc3RhbnRpYXRpbmcpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNpbmdsZXRvbiBjbGFzcy4gVXNlIFwiICsgQ2xhc3MuZ2V0TmFtZShGcmFtZUNsb2NrKSArIFwiLmdldEluc3RhbmNlKCkgdG8gcmV0cmlldmUgdGhlIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXCIpO1xuXHRcdH07XG5cblx0XHQvLyBQdWJsaWMgTWV0aG9kc1xuXG5cdFx0dGhpcy5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lciwgc2NvcGUsIHByaW9yaXR5KVxuXHRcdHtcblx0XHRcdGJhc2Uub24uY2FsbCh0aGlzLCBldmVudCwgbGlzdGVuZXIsIHNjb3BlLCBwcmlvcml0eSk7XG5cblx0XHRcdGlmICghX2lzUnVubmluZyAmJiAoX2luc3RhbmNlLmhhc0xpc3RlbmVycyhfaW5zdGFuY2UudGljaykgfHwgX2luc3RhbmNlLmhhc0xpc3RlbmVycyhfaW5zdGFuY2UuZnJhbWVUaWNrKSkpXG5cdFx0XHRcdF9zdGFydCgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0dGhpcy5vZmYgPSBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIsIHNjb3BlKVxuXHRcdHtcblx0XHRcdGJhc2Uub2ZmLmNhbGwodGhpcywgZXZlbnQsIGxpc3RlbmVyLCBzY29wZSk7XG5cblx0XHRcdGlmIChfaXNSdW5uaW5nICYmICEoX2luc3RhbmNlLmhhc0xpc3RlbmVycyhfaW5zdGFuY2UudGljaykgfHwgX2luc3RhbmNlLmhhc0xpc3RlbmVycyhfaW5zdGFuY2UuZnJhbWVUaWNrKSkpXG5cdFx0XHRcdF9zdG9wKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0fSk7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2FzeW5jL0ZyYW1lQ2xvY2suanNcbi8vIG1vZHVsZSBpZCA9IGNvbnRyaWIvamdfbGliL2FzeW5jL0ZyYW1lQ2xvY2tcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/async/Clock":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar ClockEventData = __webpack_require__(\"contrib/jg_lib/async/ClockEventData\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\tvar Event = __webpack_require__(\"contrib/jg_lib/events/Event\");\n\tvar MEventTarget = __webpack_require__(\"contrib/jg_lib/events/MEventTarget\");\n\n\treturn Class(module.id, Object, function(Clock, base)\n\t{\n\n\t\tClass.mixin(this, MEventTarget);\n\n\t\t// Public Events\n\n\t\tthis.tick = new Event(\"tick\", ClockEventData);\n\n\t\t// Constructor\n\n\t\tthis.constructor = function()\n\t\t{\n\t\t\t// noop\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2FzeW5jL0Nsb2NrLmpzPzYxMzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUYsQ0FBQyIsImZpbGUiOiJjb250cmliL2pnX2xpYi9hc3luYy9DbG9jay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIENsb2NrRXZlbnREYXRhID0gcmVxdWlyZShcIi4vQ2xvY2tFdmVudERhdGFcIik7XG5cdHZhciBDbGFzcyA9IHJlcXVpcmUoXCIuLi9DbGFzc1wiKTtcblx0dmFyIEV2ZW50ID0gcmVxdWlyZShcIi4uL2V2ZW50cy9FdmVudFwiKTtcblx0dmFyIE1FdmVudFRhcmdldCA9IHJlcXVpcmUoXCIuLi9ldmVudHMvTUV2ZW50VGFyZ2V0XCIpO1xuXG5cdHJldHVybiBDbGFzcyhtb2R1bGUuaWQsIE9iamVjdCwgZnVuY3Rpb24oQ2xvY2ssIGJhc2UpXG5cdHtcblxuXHRcdENsYXNzLm1peGluKHRoaXMsIE1FdmVudFRhcmdldCk7XG5cblx0XHQvLyBQdWJsaWMgRXZlbnRzXG5cblx0XHR0aGlzLnRpY2sgPSBuZXcgRXZlbnQoXCJ0aWNrXCIsIENsb2NrRXZlbnREYXRhKTtcblxuXHRcdC8vIENvbnN0cnVjdG9yXG5cblx0XHR0aGlzLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdC8vIG5vb3Bcblx0XHR9O1xuXG5cdH0pO1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL2pnX2xpYi9hc3luYy9DbG9jay5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9qZ19saWIvYXN5bmMvQ2xvY2tcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/async/ClockEventData":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\tvar EventData = __webpack_require__(\"contrib/jg_lib/events/EventData\");\n\n\treturn Class(module.id, EventData, function(ClockEventData, base)\n\t{\n\n\t\t// Public Properties\n\n\t\tthis.time = 0;\n\t\tthis.deltaTime = 0;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(time, deltaTime)\n\t\t{\n\t\t\tthis.time = time;\n\t\t\tthis.deltaTime = deltaTime;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2FzeW5jL0Nsb2NrRXZlbnREYXRhLmpzP2U2YzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUYsQ0FBQyIsImZpbGUiOiJjb250cmliL2pnX2xpYi9hc3luYy9DbG9ja0V2ZW50RGF0YS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIENsYXNzID0gcmVxdWlyZShcIi4uL0NsYXNzXCIpO1xuXHR2YXIgRXZlbnREYXRhID0gcmVxdWlyZShcIi4uL2V2ZW50cy9FdmVudERhdGFcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgRXZlbnREYXRhLCBmdW5jdGlvbihDbG9ja0V2ZW50RGF0YSwgYmFzZSlcblx0e1xuXG5cdFx0Ly8gUHVibGljIFByb3BlcnRpZXNcblxuXHRcdHRoaXMudGltZSA9IDA7XG5cdFx0dGhpcy5kZWx0YVRpbWUgPSAwO1xuXG5cdFx0Ly8gQ29uc3RydWN0b3JcblxuXHRcdHRoaXMuY29uc3RydWN0b3IgPSBmdW5jdGlvbih0aW1lLCBkZWx0YVRpbWUpXG5cdFx0e1xuXHRcdFx0dGhpcy50aW1lID0gdGltZTtcblx0XHRcdHRoaXMuZGVsdGFUaW1lID0gZGVsdGFUaW1lO1xuXHRcdH07XG5cblx0fSk7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2FzeW5jL0Nsb2NrRXZlbnREYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL2pnX2xpYi9hc3luYy9DbG9ja0V2ZW50RGF0YVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/jg_lib/Class":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\tvar _toString = Object.prototype.toString;\n\n\tvar _classList = [];\n\tvar _classNameList = [];\n\tvar _classNameMap = {};\n\tvar _classNativeCount = 0;\n\n\tvar _registerClassName = function(cls, name, isNative)\n\t{\n\t\t_classList.push(cls);\n\t\t_classNameList.push(name);\n\t\tif (!_hasOwnProperty.call(_classNameMap, name))\n\t\t\t_classNameMap[name] = cls;\n\t\tif (isNative)\n\t\t\t_classNativeCount++;\n\t};\n\n\tvar _anonymize = function(func)\n\t{\n\t\treturn func;\n\t};\n\n\tvar Class = function(name, baseClass, callback)\n\t{\n\t\tif (callback != null)\n\t\t{\n\t\t\tif (name == null)\n\t\t\t\tthrow new Error(\"Parameter name must be non-null.\");\n\t\t\tif (!Class.isString(name))\n\t\t\t\tthrow new Error(\"Parameter name must be of type String.\");\n\t\t\tif (baseClass == null)\n\t\t\t\tthrow new Error(\"Parameter baseClass must be non-null.\");\n\t\t\tif (!Class.isFunction(baseClass))\n\t\t\t\tthrow new Error(\"Parameter baseClass must be of type Function.\");\n\t\t\tif (!Class.isFunction(callback))\n\t\t\t\tthrow new Error(\"Parameter callback must be of type Function.\");\n\t\t}\n\t\telse if (baseClass != null)\n\t\t{\n\t\t\tcallback = baseClass;\n\t\t\tbaseClass = name;\n\n\t\t\tif (name == null)\n\t\t\t\tthrow new Error(\"Parameter 0 must be non-null.\");\n\n\t\t\tif (Class.isString(name))\n\t\t\t\tbaseClass = null;\n\t\t\telse if (Class.isFunction(name))\n\t\t\t\tname = null;\n\t\t\telse\n\t\t\t\tthrow new Error(\"Parameter 0 must be of type String or Function.\");\n\n\t\t\tif (!Class.isFunction(callback))\n\t\t\t\tthrow new Error(\"Parameter callback must be of type Function.\");\n\t\t}\n\t\telse if (name != null)\n\t\t{\n\t\t\tcallback = name;\n\t\t\tbaseClass = null;\n\t\t\tname = null;\n\n\t\t\tif (!Class.isFunction(callback))\n\t\t\t\tthrow new Error(\"Parameter callback must be of type Function.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Error(\"Expecting at least 1 parameter.\");\n\t\t}\n\n\t\tif (baseClass != null)\n\t\t{\n\t\t\tvar constructor = baseClass;\n\n\t\t\tvar Subclass = _anonymize(function()\n\t\t\t{\n\t\t\t\tif (constructor !== baseClass)\n\t\t\t\t\treturn constructor.apply(this, arguments);\n\t\t\t\tconstructor.apply(this, arguments);\n\t\t\t});\n\n\t\t\tvar Prototype = _anonymize(function(){});\n\t\t\tvar base = Prototype.prototype = baseClass.prototype;\n\t\t\tvar proto = Subclass.prototype = new Prototype();\n\t\t\tproto.constructor = Subclass;\n\n\t\t\tcallback.call(proto, Subclass, base, proto);\n\n\t\t\tif (proto.constructor !== Subclass)\n\t\t\t{\n\t\t\t\tconstructor = proto.constructor;\n\t\t\t\tproto.constructor = Subclass;\n\t\t\t}\n\n\t\t\tif (name)\n\t\t\t\t_registerClassName(Subclass, name);\n\n\t\t\treturn Subclass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar StaticClass = {};\n\n\t\t\tcallback.call(StaticClass, StaticClass);\n\n\t\t\tif (name)\n\t\t\t\t_registerClassName(StaticClass, name);\n\n\t\t\treturn StaticClass;\n\t\t}\n\t};\n\n\tClass.mixin = function(target, source)\n\t{\n\t\tif (target == null)\n\t\t\tthrow new Error(\"Parameter target must be non-null.\");\n\t\tif (source == null)\n\t\t\tthrow new Error(\"Parameter source must be non-null.\");\n\n\t\tvar p;\n\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t{\n\t\t\tsource = arguments[i];\n\t\t\tif (source == null)\n\t\t\t\tthrow new Error(\"Parameter source must be non-null.\");\n\n\t\t\tfor (p in source)\n\t\t\t{\n\t\t\t\tif (_hasOwnProperty.call(source, p))\n\t\t\t\t\ttarget[p] = source[p];\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t};\n\n\tClass.fromName = function(name)\n\t{\n\t\tif (name == null)\n\t\t\tthrow new Error(\"Parameter name must be non-null.\");\n\n\t\tif (_hasOwnProperty.call(_classNameMap, name))\n\t\t\treturn _classNameMap[name];\n\n\t\treturn null;\n\t};\n\n\tClass.getName = function(cls)\n\t{\n\t\tif (cls == null)\n\t\t\tthrow new Error(\"Parameter cls must be non-null.\");\n\n\t\tfor (var i = 0, l = _classList.length; i < l; i++)\n\t\t{\n\t\t\tif (_classList[i] === cls)\n\t\t\t\treturn _classNameList[i];\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tClass.getClassList = function()\n\t{\n\t\treturn _classList.slice(_classNativeCount);\n\t};\n\n\tClass.getClassNameList = function()\n\t{\n\t\treturn _classNameList.slice(_classNativeCount);\n\t};\n\n\tClass.getTypeChecker = function(cls)\n\t{\n\t\tif (cls == null)\n\t\t\tthrow new Error(\"Parameter cls must be non-null.\");\n\n\t\tswitch (cls)\n\t\t{\n\t\t\tcase Array:\n\t\t\t\treturn Class.isArray;\n\t\t\tcase Boolean:\n\t\t\t\treturn Class.isBoolean;\n\t\t\tcase Date:\n\t\t\t\treturn Class.isDate;\n\t\t\tcase Function:\n\t\t\t\treturn Class.isFunction;\n\t\t\tcase Number:\n\t\t\t\treturn Class.isNumber;\n\t\t\tcase Object:\n\t\t\t\treturn Class.isObject;\n\t\t\tcase RegExp:\n\t\t\t\treturn Class.isRegExp;\n\t\t\tcase String:\n\t\t\t\treturn Class.isString;\n\t\t\tdefault:\n\t\t\t\treturn function(value) { return (value instanceof cls); };\n\t\t}\n\t};\n\n\tClass.getBaseClass = function(cls)\n\t{\n\t\tif (cls == null)\n\t\t\tthrow new Error(\"Parameter cls must be non-null.\");\n\n\t\tif (cls === Object)\n\t\t\treturn null;\n\n\t\tvar proto = cls.prototype;\n\t\tif (proto == null)\n\t\t\treturn null;\n\n\t\tvar baseClass = proto.constructor;\n\t\tif (_hasOwnProperty.call(proto, \"constructor\"))\n\t\t{\n\t\t\tvar temp = baseClass;\n\t\t\tdelete proto.constructor;\n\t\t\tbaseClass = proto.constructor;\n\t\t\tproto.constructor = temp;\n\t\t}\n\n\t\tif ((baseClass == null) || (baseClass === cls))\n\t\t\treturn null;\n\n\t\treturn baseClass;\n\t};\n\n\tClass.isSubclassOf = function(cls, baseClass)\n\t{\n\t\tif (cls == null)\n\t\t\tthrow new Error(\"Parameter cls must be non-null.\");\n\t\tif (baseClass == null)\n\t\t\tthrow new Error(\"Parameter baseClass must be non-null.\");\n\n\t\tif (cls === baseClass)\n\t\t\treturn false;\n\n\t\tvar proto = cls.prototype;\n\t\tif (proto == null)\n\t\t\treturn false;\n\n\t\treturn (proto instanceof baseClass);\n\t};\n\n\t// The following methods are adapted from underscore.js\n\n\tClass.isArray = function(value)\n\t{\n\t\treturn ((value instanceof Array) || (_toString.call(value) === \"[object Array]\"));\n\t};\n\n\tClass.isBoolean = function(value)\n\t{\n\t\treturn ((typeof value === \"boolean\") || (_toString.call(value) === \"[object Boolean]\"));\n\t};\n\n\tClass.isDate = function(value)\n\t{\n\t\treturn ((value instanceof Date) || (_toString.call(value) === \"[object Date]\"));\n\t};\n\n\tif (true)\n\t{\n\t\tClass.isFunction = function(value)\n\t\t{\n\t\t\treturn ((typeof value === \"function\") || false);\n\t\t};\n\t}\n\telse\n\t{\n\t\tClass.isFunction = function(value)\n\t\t{\n\t\t\treturn ((value instanceof Function) || (_toString.call(value) === \"[object Function]\"));\n\t\t};\n\t}\n\n\tClass.isNumber = function(value)\n\t{\n\t\treturn ((typeof value === \"number\") || (_toString.call(value) === \"[object Number]\"));\n\t};\n\n\tClass.isObject = function(value)\n\t{\n\t\treturn ((value != null) && ((typeof value === \"object\") || (typeof value === \"function\")));\n\t};\n\n\tClass.isRegExp = function(value)\n\t{\n\t\treturn ((value instanceof RegExp) || (_toString.call(value) === \"[object RegExp]\"));\n\t};\n\n\tClass.isString = function(value)\n\t{\n\t\treturn ((typeof value === \"string\") || (_toString.call(value) === \"[object String]\"));\n\t};\n\n\t_registerClassName(Array, \"Array\", true);\n\t_registerClassName(Boolean, \"Boolean\", true);\n\t_registerClassName(Date, \"Date\", true);\n\t_registerClassName(Function, \"Function\", true);\n\t_registerClassName(Math, \"Math\", true);\n\t_registerClassName(Number, \"Number\", true);\n\t_registerClassName(Object, \"Object\", true);\n\t_registerClassName(RegExp, \"RegExp\", true);\n\t_registerClassName(String, \"String\", true);\n\t_registerClassName(Class, module.id);\n\n\treturn Class;\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL0NsYXNzLmpzPzc4NzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiJjb250cmliL2pnX2xpYi9DbGFzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5cdHZhciBfY2xhc3NMaXN0ID0gW107XG5cdHZhciBfY2xhc3NOYW1lTGlzdCA9IFtdO1xuXHR2YXIgX2NsYXNzTmFtZU1hcCA9IHt9O1xuXHR2YXIgX2NsYXNzTmF0aXZlQ291bnQgPSAwO1xuXG5cdHZhciBfcmVnaXN0ZXJDbGFzc05hbWUgPSBmdW5jdGlvbihjbHMsIG5hbWUsIGlzTmF0aXZlKVxuXHR7XG5cdFx0X2NsYXNzTGlzdC5wdXNoKGNscyk7XG5cdFx0X2NsYXNzTmFtZUxpc3QucHVzaChuYW1lKTtcblx0XHRpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKF9jbGFzc05hbWVNYXAsIG5hbWUpKVxuXHRcdFx0X2NsYXNzTmFtZU1hcFtuYW1lXSA9IGNscztcblx0XHRpZiAoaXNOYXRpdmUpXG5cdFx0XHRfY2xhc3NOYXRpdmVDb3VudCsrO1xuXHR9O1xuXG5cdHZhciBfYW5vbnltaXplID0gZnVuY3Rpb24oZnVuYylcblx0e1xuXHRcdHJldHVybiBmdW5jO1xuXHR9O1xuXG5cdHZhciBDbGFzcyA9IGZ1bmN0aW9uKG5hbWUsIGJhc2VDbGFzcywgY2FsbGJhY2spXG5cdHtcblx0XHRpZiAoY2FsbGJhY2sgIT0gbnVsbClcblx0XHR7XG5cdFx0XHRpZiAobmFtZSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbmFtZSBtdXN0IGJlIG5vbi1udWxsLlwiKTtcblx0XHRcdGlmICghQ2xhc3MuaXNTdHJpbmcobmFtZSkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBuYW1lIG11c3QgYmUgb2YgdHlwZSBTdHJpbmcuXCIpO1xuXHRcdFx0aWYgKGJhc2VDbGFzcyA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgYmFzZUNsYXNzIG11c3QgYmUgbm9uLW51bGwuXCIpO1xuXHRcdFx0aWYgKCFDbGFzcy5pc0Z1bmN0aW9uKGJhc2VDbGFzcykpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBiYXNlQ2xhc3MgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLlwiKTtcblx0XHRcdGlmICghQ2xhc3MuaXNGdW5jdGlvbihjYWxsYmFjaykpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBjYWxsYmFjayBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uXCIpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChiYXNlQ2xhc3MgIT0gbnVsbClcblx0XHR7XG5cdFx0XHRjYWxsYmFjayA9IGJhc2VDbGFzcztcblx0XHRcdGJhc2VDbGFzcyA9IG5hbWU7XG5cblx0XHRcdGlmIChuYW1lID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciAwIG11c3QgYmUgbm9uLW51bGwuXCIpO1xuXG5cdFx0XHRpZiAoQ2xhc3MuaXNTdHJpbmcobmFtZSkpXG5cdFx0XHRcdGJhc2VDbGFzcyA9IG51bGw7XG5cdFx0XHRlbHNlIGlmIChDbGFzcy5pc0Z1bmN0aW9uKG5hbWUpKVxuXHRcdFx0XHRuYW1lID0gbnVsbDtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIDAgbXVzdCBiZSBvZiB0eXBlIFN0cmluZyBvciBGdW5jdGlvbi5cIik7XG5cblx0XHRcdGlmICghQ2xhc3MuaXNGdW5jdGlvbihjYWxsYmFjaykpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBjYWxsYmFjayBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uXCIpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChuYW1lICE9IG51bGwpXG5cdFx0e1xuXHRcdFx0Y2FsbGJhY2sgPSBuYW1lO1xuXHRcdFx0YmFzZUNsYXNzID0gbnVsbDtcblx0XHRcdG5hbWUgPSBudWxsO1xuXG5cdFx0XHRpZiAoIUNsYXNzLmlzRnVuY3Rpb24oY2FsbGJhY2spKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgY2FsbGJhY2sgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLlwiKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBhdCBsZWFzdCAxIHBhcmFtZXRlci5cIik7XG5cdFx0fVxuXG5cdFx0aWYgKGJhc2VDbGFzcyAhPSBudWxsKVxuXHRcdHtcblx0XHRcdHZhciBjb25zdHJ1Y3RvciA9IGJhc2VDbGFzcztcblxuXHRcdFx0dmFyIFN1YmNsYXNzID0gX2Fub255bWl6ZShmdW5jdGlvbigpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChjb25zdHJ1Y3RvciAhPT0gYmFzZUNsYXNzKVxuXHRcdFx0XHRcdHJldHVybiBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZhciBQcm90b3R5cGUgPSBfYW5vbnltaXplKGZ1bmN0aW9uKCl7fSk7XG5cdFx0XHR2YXIgYmFzZSA9IFByb3RvdHlwZS5wcm90b3R5cGUgPSBiYXNlQ2xhc3MucHJvdG90eXBlO1xuXHRcdFx0dmFyIHByb3RvID0gU3ViY2xhc3MucHJvdG90eXBlID0gbmV3IFByb3RvdHlwZSgpO1xuXHRcdFx0cHJvdG8uY29uc3RydWN0b3IgPSBTdWJjbGFzcztcblxuXHRcdFx0Y2FsbGJhY2suY2FsbChwcm90bywgU3ViY2xhc3MsIGJhc2UsIHByb3RvKTtcblxuXHRcdFx0aWYgKHByb3RvLmNvbnN0cnVjdG9yICE9PSBTdWJjbGFzcylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3RydWN0b3IgPSBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRcdFx0cHJvdG8uY29uc3RydWN0b3IgPSBTdWJjbGFzcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5hbWUpXG5cdFx0XHRcdF9yZWdpc3RlckNsYXNzTmFtZShTdWJjbGFzcywgbmFtZSk7XG5cblx0XHRcdHJldHVybiBTdWJjbGFzcztcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHZhciBTdGF0aWNDbGFzcyA9IHt9O1xuXG5cdFx0XHRjYWxsYmFjay5jYWxsKFN0YXRpY0NsYXNzLCBTdGF0aWNDbGFzcyk7XG5cblx0XHRcdGlmIChuYW1lKVxuXHRcdFx0XHRfcmVnaXN0ZXJDbGFzc05hbWUoU3RhdGljQ2xhc3MsIG5hbWUpO1xuXG5cdFx0XHRyZXR1cm4gU3RhdGljQ2xhc3M7XG5cdFx0fVxuXHR9O1xuXG5cdENsYXNzLm1peGluID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpXG5cdHtcblx0XHRpZiAodGFyZ2V0ID09IG51bGwpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgdGFyZ2V0IG11c3QgYmUgbm9uLW51bGwuXCIpO1xuXHRcdGlmIChzb3VyY2UgPT0gbnVsbClcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBzb3VyY2UgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cblx0XHR2YXIgcDtcblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0e1xuXHRcdFx0c291cmNlID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKHNvdXJjZSA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgc291cmNlIG11c3QgYmUgbm9uLW51bGwuXCIpO1xuXG5cdFx0XHRmb3IgKHAgaW4gc291cmNlKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwKSlcblx0XHRcdFx0XHR0YXJnZXRbcF0gPSBzb3VyY2VbcF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHRDbGFzcy5mcm9tTmFtZSA9IGZ1bmN0aW9uKG5hbWUpXG5cdHtcblx0XHRpZiAobmFtZSA9PSBudWxsKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG5hbWUgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cblx0XHRpZiAoX2hhc093blByb3BlcnR5LmNhbGwoX2NsYXNzTmFtZU1hcCwgbmFtZSkpXG5cdFx0XHRyZXR1cm4gX2NsYXNzTmFtZU1hcFtuYW1lXTtcblxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdENsYXNzLmdldE5hbWUgPSBmdW5jdGlvbihjbHMpXG5cdHtcblx0XHRpZiAoY2xzID09IG51bGwpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgY2xzIG11c3QgYmUgbm9uLW51bGwuXCIpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBfY2xhc3NMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHR7XG5cdFx0XHRpZiAoX2NsYXNzTGlzdFtpXSA9PT0gY2xzKVxuXHRcdFx0XHRyZXR1cm4gX2NsYXNzTmFtZUxpc3RbaV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0Q2xhc3MuZ2V0Q2xhc3NMaXN0ID0gZnVuY3Rpb24oKVxuXHR7XG5cdFx0cmV0dXJuIF9jbGFzc0xpc3Quc2xpY2UoX2NsYXNzTmF0aXZlQ291bnQpO1xuXHR9O1xuXG5cdENsYXNzLmdldENsYXNzTmFtZUxpc3QgPSBmdW5jdGlvbigpXG5cdHtcblx0XHRyZXR1cm4gX2NsYXNzTmFtZUxpc3Quc2xpY2UoX2NsYXNzTmF0aXZlQ291bnQpO1xuXHR9O1xuXG5cdENsYXNzLmdldFR5cGVDaGVja2VyID0gZnVuY3Rpb24oY2xzKVxuXHR7XG5cdFx0aWYgKGNscyA9PSBudWxsKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGNscyBtdXN0IGJlIG5vbi1udWxsLlwiKTtcblxuXHRcdHN3aXRjaCAoY2xzKVxuXHRcdHtcblx0XHRcdGNhc2UgQXJyYXk6XG5cdFx0XHRcdHJldHVybiBDbGFzcy5pc0FycmF5O1xuXHRcdFx0Y2FzZSBCb29sZWFuOlxuXHRcdFx0XHRyZXR1cm4gQ2xhc3MuaXNCb29sZWFuO1xuXHRcdFx0Y2FzZSBEYXRlOlxuXHRcdFx0XHRyZXR1cm4gQ2xhc3MuaXNEYXRlO1xuXHRcdFx0Y2FzZSBGdW5jdGlvbjpcblx0XHRcdFx0cmV0dXJuIENsYXNzLmlzRnVuY3Rpb247XG5cdFx0XHRjYXNlIE51bWJlcjpcblx0XHRcdFx0cmV0dXJuIENsYXNzLmlzTnVtYmVyO1xuXHRcdFx0Y2FzZSBPYmplY3Q6XG5cdFx0XHRcdHJldHVybiBDbGFzcy5pc09iamVjdDtcblx0XHRcdGNhc2UgUmVnRXhwOlxuXHRcdFx0XHRyZXR1cm4gQ2xhc3MuaXNSZWdFeHA7XG5cdFx0XHRjYXNlIFN0cmluZzpcblx0XHRcdFx0cmV0dXJuIENsYXNzLmlzU3RyaW5nO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBjbHMpOyB9O1xuXHRcdH1cblx0fTtcblxuXHRDbGFzcy5nZXRCYXNlQ2xhc3MgPSBmdW5jdGlvbihjbHMpXG5cdHtcblx0XHRpZiAoY2xzID09IG51bGwpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgY2xzIG11c3QgYmUgbm9uLW51bGwuXCIpO1xuXG5cdFx0aWYgKGNscyA9PT0gT2JqZWN0KVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgcHJvdG8gPSBjbHMucHJvdG90eXBlO1xuXHRcdGlmIChwcm90byA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgYmFzZUNsYXNzID0gcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0aWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpKVxuXHRcdHtcblx0XHRcdHZhciB0ZW1wID0gYmFzZUNsYXNzO1xuXHRcdFx0ZGVsZXRlIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdFx0YmFzZUNsYXNzID0gcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0XHRwcm90by5jb25zdHJ1Y3RvciA9IHRlbXA7XG5cdFx0fVxuXG5cdFx0aWYgKChiYXNlQ2xhc3MgPT0gbnVsbCkgfHwgKGJhc2VDbGFzcyA9PT0gY2xzKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0cmV0dXJuIGJhc2VDbGFzcztcblx0fTtcblxuXHRDbGFzcy5pc1N1YmNsYXNzT2YgPSBmdW5jdGlvbihjbHMsIGJhc2VDbGFzcylcblx0e1xuXHRcdGlmIChjbHMgPT0gbnVsbClcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBjbHMgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cdFx0aWYgKGJhc2VDbGFzcyA9PSBudWxsKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGJhc2VDbGFzcyBtdXN0IGJlIG5vbi1udWxsLlwiKTtcblxuXHRcdGlmIChjbHMgPT09IGJhc2VDbGFzcylcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBwcm90byA9IGNscy5wcm90b3R5cGU7XG5cdFx0aWYgKHByb3RvID09IG51bGwpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRyZXR1cm4gKHByb3RvIGluc3RhbmNlb2YgYmFzZUNsYXNzKTtcblx0fTtcblxuXHQvLyBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIGFkYXB0ZWQgZnJvbSB1bmRlcnNjb3JlLmpzXG5cblx0Q2xhc3MuaXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlKVxuXHR7XG5cdFx0cmV0dXJuICgodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgfHwgKF90b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSk7XG5cdH07XG5cblx0Q2xhc3MuaXNCb29sZWFuID0gZnVuY3Rpb24odmFsdWUpXG5cdHtcblx0XHRyZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB8fCAoX3RvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgQm9vbGVhbl1cIikpO1xuXHR9O1xuXG5cdENsYXNzLmlzRGF0ZSA9IGZ1bmN0aW9uKHZhbHVlKVxuXHR7XG5cdFx0cmV0dXJuICgodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB8fCAoX3RvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgRGF0ZV1cIikpO1xuXHR9O1xuXG5cdGlmICh0eXBlb2YgLy4vICE9PSBcImZ1bmN0aW9uXCIpXG5cdHtcblx0XHRDbGFzcy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHx8IGZhbHNlKTtcblx0XHR9O1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdENsYXNzLmlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gKCh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCAoX3RvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpKTtcblx0XHR9O1xuXHR9XG5cblx0Q2xhc3MuaXNOdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSlcblx0e1xuXHRcdHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikgfHwgKF90b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE51bWJlcl1cIikpO1xuXHR9O1xuXG5cdENsYXNzLmlzT2JqZWN0ID0gZnVuY3Rpb24odmFsdWUpXG5cdHtcblx0XHRyZXR1cm4gKCh2YWx1ZSAhPSBudWxsKSAmJiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSkpO1xuXHR9O1xuXG5cdENsYXNzLmlzUmVnRXhwID0gZnVuY3Rpb24odmFsdWUpXG5cdHtcblx0XHRyZXR1cm4gKCh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkgfHwgKF90b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIikpO1xuXHR9O1xuXG5cdENsYXNzLmlzU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpXG5cdHtcblx0XHRyZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHx8IChfdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBTdHJpbmddXCIpKTtcblx0fTtcblxuXHRfcmVnaXN0ZXJDbGFzc05hbWUoQXJyYXksIFwiQXJyYXlcIiwgdHJ1ZSk7XG5cdF9yZWdpc3RlckNsYXNzTmFtZShCb29sZWFuLCBcIkJvb2xlYW5cIiwgdHJ1ZSk7XG5cdF9yZWdpc3RlckNsYXNzTmFtZShEYXRlLCBcIkRhdGVcIiwgdHJ1ZSk7XG5cdF9yZWdpc3RlckNsYXNzTmFtZShGdW5jdGlvbiwgXCJGdW5jdGlvblwiLCB0cnVlKTtcblx0X3JlZ2lzdGVyQ2xhc3NOYW1lKE1hdGgsIFwiTWF0aFwiLCB0cnVlKTtcblx0X3JlZ2lzdGVyQ2xhc3NOYW1lKE51bWJlciwgXCJOdW1iZXJcIiwgdHJ1ZSk7XG5cdF9yZWdpc3RlckNsYXNzTmFtZShPYmplY3QsIFwiT2JqZWN0XCIsIHRydWUpO1xuXHRfcmVnaXN0ZXJDbGFzc05hbWUoUmVnRXhwLCBcIlJlZ0V4cFwiLCB0cnVlKTtcblx0X3JlZ2lzdGVyQ2xhc3NOYW1lKFN0cmluZywgXCJTdHJpbmdcIiwgdHJ1ZSk7XG5cdF9yZWdpc3RlckNsYXNzTmFtZShDbGFzcywgbW9kdWxlLmlkKTtcblxuXHRyZXR1cm4gQ2xhc3M7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL0NsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL2pnX2xpYi9DbGFzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/jg_lib/events/EventData":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, Object, function(EventData, base)\n\t{\n\n\t\t// Public Properties\n\n\t\tthis.event = null;\n\t\tthis.target = null;\n\t\tthis.currentEvent = null;\n\t\tthis.currentTarget = null;\n\n\t\t// Private Properties\n\n\t\tthis._isDefaultPrevented = false;\n\t\tthis._isPropagationStopped = false;\n\t\tthis._isImmediatePropagationStopped = false;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function()\n\t\t{\n\t\t\t// noop\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.preventDefault = function()\n\t\t{\n\t\t\tthis._isDefaultPrevented = true;\n\t\t};\n\n\t\tthis.stopPropagation = function()\n\t\t{\n\t\t\tthis._isPropagationStopped = true;\n\t\t};\n\n\t\tthis.stopImmediatePropagation = function()\n\t\t{\n\t\t\tthis._isImmediatePropagationStopped = true;\n\t\t\tthis.stopPropagation();\n\t\t};\n\n\t\tthis.isDefaultPrevented = function()\n\t\t{\n\t\t\treturn this._isDefaultPrevented;\n\t\t};\n\n\t\tthis.isPropagationStopped = function()\n\t\t{\n\t\t\treturn this._isPropagationStopped;\n\t\t};\n\n\t\tthis.isImmediatePropagationStopped = function()\n\t\t{\n\t\t\treturn this._isImmediatePropagationStopped;\n\t\t};\n\n\t\tthis.resetPropagation = function()\n\t\t{\n\t\t\tthis._isPropagationStopped = false;\n\t\t\tthis._isImmediatePropagationStopped = false;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2V2ZW50cy9FdmVudERhdGEuanM/NTYxYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvZXZlbnRzL0V2ZW50RGF0YS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIENsYXNzID0gcmVxdWlyZShcIi4uL0NsYXNzXCIpO1xuXG5cdHJldHVybiBDbGFzcyhtb2R1bGUuaWQsIE9iamVjdCwgZnVuY3Rpb24oRXZlbnREYXRhLCBiYXNlKVxuXHR7XG5cblx0XHQvLyBQdWJsaWMgUHJvcGVydGllc1xuXG5cdFx0dGhpcy5ldmVudCA9IG51bGw7XG5cdFx0dGhpcy50YXJnZXQgPSBudWxsO1xuXHRcdHRoaXMuY3VycmVudEV2ZW50ID0gbnVsbDtcblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXG5cdFx0Ly8gUHJpdmF0ZSBQcm9wZXJ0aWVzXG5cblx0XHR0aGlzLl9pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2lzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHQvLyBub29wXG5cdFx0fTtcblxuXHRcdC8vIFB1YmxpYyBNZXRob2RzXG5cblx0XHR0aGlzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHRoaXMuX2lzRGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHRoaXMuX2lzUHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dGhpcy5faXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2lzRGVmYXVsdFByZXZlbnRlZDtcblx0XHR9O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5faXNQcm9wYWdhdGlvblN0b3BwZWQ7XG5cdFx0fTtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2lzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkO1xuXHRcdH07XG5cblx0XHR0aGlzLnJlc2V0UHJvcGFnYXRpb24gPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dGhpcy5faXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2lzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFx0fTtcblxuXHR9KTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9qZ19saWIvZXZlbnRzL0V2ZW50RGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9qZ19saWIvZXZlbnRzL0V2ZW50RGF0YVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/jg_lib/events/Event":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar EventData = __webpack_require__(\"contrib/jg_lib/events/EventData\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\tvar ErrorUtil = __webpack_require__(\"contrib/jg_lib/utils/ErrorUtil\");\n\tvar Map = __webpack_require__(\"contrib/jg_lib/utils/Map\");\n\tvar ObjectUtil = __webpack_require__(\"contrib/jg_lib/utils/ObjectUtil\");\n\tvar TrieMap = __webpack_require__(\"contrib/jg_lib/utils/TrieMap\");\n\tvar UID = __webpack_require__(\"contrib/jg_lib/utils/UID\");\n\tvar WeakMap = __webpack_require__(\"contrib/jg_lib/utils/WeakMap\");\n\n\treturn Class(module.id, Object, function(Event, base)\n\t{\n\n\t\t// Private Static Constants\n\n\t\tvar _DEBUG_KEY = \"__DEBUG_EVENTS__\";\n\n\t\t// Public Static Properties\n\n\t\tEvent.debug = false;\n\n\t\t// Private Static Properties\n\n\t\tvar _contextMaps = new WeakMap();\n\n\t\t// Public Static Methods\n\n\t\tEvent.resolve = function(target, event, strict)\n\t\t{\n\t\t\tif (target == null)\n\t\t\t\tthrow new Error(\"Parameter target must be non-null.\");\n\t\t\tif (event == null)\n\t\t\t\tthrow new Error(\"Parameter event must be non-null.\");\n\n\t\t\tif (event instanceof Event)\n\t\t\t\treturn event;\n\n\t\t\tif (!Class.isString(event))\n\t\t\t\tthrow new Error(\"Parameter event must be of type String or \" + Class.getName(Event) + \".\");\n\n\t\t\tvar eventName = event;\n\t\t\tif (eventName.indexOf(\".\") < 0)\n\t\t\t{\n\t\t\t\tevent = target[eventName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar eventPath = eventName.split(\".\");\n\t\t\t\tevent = target;\n\t\t\t\tfor (var i = 0, l = eventPath.length; i < l; i++)\n\t\t\t\t{\n\t\t\t\t\tevent = event[eventPath[i]];\n\t\t\t\t\tif (event == null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((event != null) && (event instanceof Event))\n\t\t\t\treturn event;\n\n\t\t\tif (strict !== false)\n\t\t\t\tthrow new Error(\"Unknown event \\\"\" + eventName + \"\\\".\");\n\n\t\t\treturn null;\n\t\t};\n\n\t\tEvent.offAll = function(target)\n\t\t{\n\t\t\tvar contextMap = _contextMaps.get(target);\n\t\t\tif (!contextMap)\n\t\t\t\treturn;\n\n\t\t\tvar eventList = contextMap.keys();\n\t\t\tfor (var i = 0, l = eventList.length; i < l; i++)\n\t\t\t\teventList[i].offAll(target);\n\t\t};\n\n\t\tEvent.hasListeners = function(target)\n\t\t{\n\t\t\tvar contextMap = _contextMaps.get(target);\n\t\t\tif (!contextMap)\n\t\t\t\treturn false;\n\n\t\t\tvar eventList = contextMap.keys();\n\t\t\tfor (var i = 0, l = eventList.length; i < l; i++)\n\t\t\t{\n\t\t\t\tif (eventList[i].hasListeners(target))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\t// Private Static Methods\n\n\t\tvar _debug = function(context)\n\t\t{\n\t\t\tvar target = context.target;\n\t\t\tvar debugMap = ObjectUtil.get(target, _DEBUG_KEY);\n\t\t\tif (!debugMap)\n\t\t\t\tdebugMap = target[_DEBUG_KEY] = {};\n\n\t\t\tvar event = context.event;\n\t\t\tvar debugEventKey = event.name() + \" #\" + UID.get(event);\n\t\t\tvar listenerCount = context.listenerMap.size();\n\t\t\tif (listenerCount > 0)\n\t\t\t\tdebugMap[debugEventKey] = listenerCount;\n\t\t\telse\n\t\t\t\tdelete debugMap[debugEventKey];\n\t\t};\n\n\t\tvar _listenerInfoComparator = function(listenerInfo1, listenerInfo2)\n\t\t{\n\t\t\tif (listenerInfo1.priority > listenerInfo2.priority)\n\t\t\t\treturn -1;\n\t\t\tif (listenerInfo1.priority < listenerInfo2.priority)\n\t\t\t\treturn 1;\n\t\t\tif (listenerInfo1._order < listenerInfo2._order)\n\t\t\t\treturn -1;\n\t\t\tif (listenerInfo1._order > listenerInfo2._order)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t};\n\n\t\t// Private Properties\n\n\t\tthis._name = null;\n\t\tthis._type = null;\n\t\tthis._bubbles = false;\n\t\tthis._cancelable = false;\n\t\tthis._defaultAction = null;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(name, type, bubbles, cancelable)\n\t\t{\n\t\t\tif (name == null)\n\t\t\t\tthrow new Error(\"Parameter name must be non-null.\");\n\t\t\tif (!Class.isString(name))\n\t\t\t\tthrow new Error(\"Parameter name must be of type String.\");\n\n\t\t\tif (type == null)\n\t\t\t\ttype = EventData;\n\t\t\telse if (!Class.isFunction(type))\n\t\t\t\tthrow new Error(\"Parameter type must be of type Function.\");\n\t\t\telse if ((type !== EventData) && !Class.isSubclassOf(type, EventData))\n\t\t\t\tthrow new Error(\"Parameter type must be a subclass of \" + Class.getName(EventData) + \".\");\n\n\t\t\tthis._name = name;\n\t\t\tthis._type = type;\n\n\t\t\tif (bubbles != null)\n\t\t\t\tthis.bubbles(bubbles);\n\t\t\tif (cancelable != null)\n\t\t\t\tthis.cancelable(cancelable);\n\t\t};\n\n\t\t// Public Accessor Methods\n\n\t\tthis.name = function()\n\t\t{\n\t\t\treturn this._name;\n\t\t};\n\n\t\tthis.type = function()\n\t\t{\n\t\t\treturn this._type;\n\t\t};\n\n\t\tthis.bubbles = function(value)\n\t\t{\n\t\t\tif (!arguments.length)\n\t\t\t\treturn this._bubbles;\n\n\t\t\tif ((value != null) && !Class.isBoolean(value))\n\t\t\t\tthrow new Error(\"Parameter bubbles must be of type Boolean.\");\n\n\t\t\tthis._bubbles = (value === true);\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.cancelable = function(value)\n\t\t{\n\t\t\tif (!arguments.length)\n\t\t\t\treturn this._cancelable;\n\n\t\t\tif ((value != null) && !Class.isBoolean(value))\n\t\t\t\tthrow new Error(\"Parameter cancelable must be of type Boolean.\");\n\n\t\t\tthis._cancelable = (value === true);\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.defaultAction = function(value)\n\t\t{\n\t\t\tif (!arguments.length)\n\t\t\t\treturn this._defaultAction;\n\n\t\t\tif ((value != null) && !Class.isFunction(value))\n\t\t\t\tthrow new Error(\"Parameter defaultAction must be of type Function.\");\n\n\t\t\tthis._defaultAction = value || null;\n\n\t\t\treturn this;\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.on = function(target, listener, scope, priority)\n\t\t{\n\t\t\tvar context = this.getContext(target);\n\t\t\tthis.addListener(context, listener, scope, priority);\n\t\t};\n\n\t\tthis.off = function(target, listener, scope)\n\t\t{\n\t\t\tvar context = this.getContext(target, false);\n\t\t\tif (!context)\n\t\t\t\treturn;\n\n\t\t\tthis.removeListener(context, listener, scope);\n\t\t\tif (context.listenerMap.size() > 0)\n\t\t\t\treturn;\n\n\t\t\tthis.delContext(target);\n\t\t};\n\n\t\tthis.offAll = function(target)\n\t\t{\n\t\t\tvar context = this.getContext(target, false);\n\t\t\tif (!context)\n\t\t\t\treturn;\n\n\t\t\tvar listenerList = this.getListeners(context, false);\n\t\t\tvar listenerInfo;\n\t\t\tfor (var i = 0, l = listenerList.length; i < l; i++)\n\t\t\t{\n\t\t\t\tlistenerInfo = listenerList[i];\n\t\t\t\tif (listenerInfo.listener)\n\t\t\t\t\tthis.off(target, listenerInfo.listener, listenerInfo.scope);\n\t\t\t}\n\t\t};\n\n\t\tthis.fire = function(target, eventData)\n\t\t{\n\t\t\tif (eventData.isPropagationStopped())\n\t\t\t\treturn !(this._cancelable && eventData.isDefaultPrevented());\n\n\t\t\tif (!eventData.event)\n\t\t\t\teventData.event = this;\n\t\t\tif (!eventData.target)\n\t\t\t\teventData.target = target;\n\n\t\t\tvar isRootDispatch = ((eventData.event === this) && (eventData.target === target));\n\n\t\t\tvar bubbleTargets = this.getBubbleTargets(target);\n\t\t\tthis.notifyListeners(target, eventData);\n\t\t\tif (bubbleTargets && (bubbleTargets.length > 0) && !eventData.isPropagationStopped())\n\t\t\t\tthis.notifyBubbleListeners(bubbleTargets, eventData);\n\n\t\t\teventData.resetPropagation();\n\n\t\t\tif (this._cancelable && eventData.isDefaultPrevented())\n\t\t\t\treturn false;\n\n\t\t\tif (isRootDispatch)\n\t\t\t\tthis.executeDefault(target, eventData);\n\n\t\t\treturn true;\n\t\t};\n\n\t\tthis.hasListeners = function(target)\n\t\t{\n\t\t\tvar context = this.getContext(target, false);\n\t\t\tif (!context)\n\t\t\t\treturn false;\n\n\t\t\treturn (context.listenerMap.size() > 0);\n\t\t};\n\n\t\tthis.notifyListeners = function(target, eventData)\n\t\t{\n\t\t\tvar context = this.getContext(target, false);\n\t\t\tif (!context)\n\t\t\t\treturn;\n\n\t\t\tvar originalCurrentEvent = eventData.currentEvent;\n\t\t\tvar originalCurrentTarget = eventData.currentTarget;\n\n\t\t\teventData.currentEvent = this;\n\t\t\teventData.currentTarget = target;\n\n\t\t\tvar listenerList = this.getListeners(context);\n\t\t\tvar listenerInfo;\n\t\t\tfor (var i = 0, l = listenerList.length; i < l; i++)\n\t\t\t{\n\t\t\t\tlistenerInfo = listenerList[i];\n\t\t\t\tif (listenerInfo.listener)\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tlistenerInfo.listener.call(listenerInfo.scope, eventData);\n\t\t\t\t\t\tif (eventData.isImmediatePropagationStopped())\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e)\n\t\t\t\t\t{\n\t\t\t\t\t\tErrorUtil.nonBlockingThrow(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\teventData.currentEvent = originalCurrentEvent;\n\t\t\teventData.currentTarget = originalCurrentTarget;\n\t\t};\n\n\t\tthis.notifyBubbleListeners = function(bubbleTargets, eventData)\n\t\t{\n\t\t\tfor (var i = 0, l = bubbleTargets.length; i < l; i++)\n\t\t\t{\n\t\t\t\tthis.notifyListeners(bubbleTargets[i], eventData);\n\t\t\t\tif (eventData.isPropagationStopped())\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tthis.executeDefault = function(target, eventData)\n\t\t{\n\t\t\tif (this._defaultAction)\n\t\t\t\tthis._defaultAction.call(target, eventData);\n\t\t};\n\n\t\tthis.getBubbleTargets = function(target)\n\t\t{\n\t\t\tif (!this._bubbles)\n\t\t\t\treturn null;\n\n\t\t\tvar bubbleTargets = [];\n\t\t\tvar bubbleTarget = target.getBubbleTarget();\n\t\t\twhile (bubbleTarget && bubbleTarget.isEventTarget)\n\t\t\t{\n\t\t\t\tbubbleTargets.push(bubbleTarget);\n\t\t\t\tbubbleTarget = bubbleTarget.getBubbleTarget();\n\t\t\t}\n\n\t\t\treturn bubbleTargets;\n\t\t};\n\n\t\tthis.getTypeName = function()\n\t\t{\n\t\t\treturn Class.getName(this._type) || (this._name + \".type\");\n\t\t};\n\n\t\tthis.isValidType = function(eventData)\n\t\t{\n\t\t\treturn (eventData instanceof this._type);\n\t\t};\n\n\t\tthis.createEventData = function()\n\t\t{\n\t\t\treturn new this._type();\n\t\t};\n\n\t\t// Protected Methods\n\n\t\tthis.getContext = function(target, create)\n\t\t{\n\t\t\tvar contextMap = _contextMaps.get(target);\n\t\t\tif (!contextMap)\n\t\t\t{\n\t\t\t\tif (create === false)\n\t\t\t\t\treturn null;\n\n\t\t\t\tcontextMap = new Map();\n\t\t\t\t_contextMaps.set(target, contextMap);\n\t\t\t}\n\n\t\t\tvar context = contextMap.get(this);\n\t\t\tif (!context)\n\t\t\t{\n\t\t\t\tif (create === false)\n\t\t\t\t\treturn null;\n\n\t\t\t\tcontext = { target: target, event: this };\n\t\t\t\tcontextMap.set(this, context);\n\n\t\t\t\tthis.setupContext(context);\n\t\t\t}\n\n\t\t\treturn context;\n\t\t};\n\n\t\tthis.delContext = function(target)\n\t\t{\n\t\t\tvar contextMap = _contextMaps.get(target);\n\t\t\tif (!contextMap)\n\t\t\t\treturn;\n\n\t\t\tvar context = contextMap.get(this);\n\t\t\tif (!context)\n\t\t\t\treturn;\n\n\t\t\tcontextMap.del(this);\n\t\t\tif (contextMap.size() === 0)\n\t\t\t\t_contextMaps.del(target);\n\n\t\t\tthis.teardownContext(context);\n\t\t};\n\n\t\tthis.setupContext = function(context)\n\t\t{\n\t\t\tcontext.listenerMap = new TrieMap();\n\t\t\tcontext._listenerList = null;\n\t\t\tcontext._listenerOrder = 0;\n\t\t};\n\n\t\tthis.teardownContext = function(context)\n\t\t{\n\t\t\tcontext.listenerMap = null;\n\t\t\tcontext._listenerList = null;\n\t\t};\n\n\t\tthis.addListener = function(context, listener, scope, priority)\n\t\t{\n\t\t\tvar listenerMap = context.listenerMap;\n\t\t\tvar listenerKeys = [ listener, scope ];\n\t\t\tvar listenerInfo = listenerMap.get(listenerKeys);\n\t\t\tif (!listenerInfo)\n\t\t\t{\n\t\t\t\tlistenerInfo = { listener: listener, scope: scope, priority: priority, _order: (++context._listenerOrder) };\n\t\t\t\tlistenerMap.set(listenerKeys, listenerInfo);\n\t\t\t}\n\t\t\telse if (listenerInfo.priority !== priority)\n\t\t\t{\n\t\t\t\tlistenerInfo.priority = priority;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcontext._listenerList = null;\n\n\t\t\tif (Event.debug)\n\t\t\t\t_debug(context);\n\t\t};\n\n\t\tthis.removeListener = function(context, listener, scope)\n\t\t{\n\t\t\tvar listenerMap = context.listenerMap;\n\t\t\tvar listenerKeys = [ listener, scope ];\n\t\t\tvar listenerInfo = listenerMap.get(listenerKeys);\n\t\t\tif (!listenerInfo)\n\t\t\t\treturn;\n\n\t\t\tlistenerMap.del(listenerKeys);\n\t\t\tlistenerInfo.listener = null;\n\t\t\tlistenerInfo.scope = null;\n\n\t\t\tcontext._listenerList = null;\n\n\t\t\tif (Event.debug)\n\t\t\t\t_debug(context);\n\t\t};\n\n\t\tthis.getListeners = function(context, sorted)\n\t\t{\n\t\t\tvar listenerList = context._listenerList;\n\t\t\tif (!listenerList)\n\t\t\t{\n\t\t\t\tlistenerList = context._listenerList = context.listenerMap.values();\n\t\t\t\tlistenerList._isSorted = false;\n\t\t\t}\n\n\t\t\tif ((sorted !== false) && !listenerList._isSorted)\n\t\t\t{\n\t\t\t\tlistenerList.sort(_listenerInfoComparator);\n\t\t\t\tlistenerList._isSorted = true;\n\t\t\t}\n\n\t\t\treturn listenerList;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2V2ZW50cy9FdmVudC5qcz8xZWIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvZXZlbnRzL0V2ZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNiBKYXNvbiBHYXR0XG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSlcbntcblxuXHR2YXIgRXZlbnREYXRhID0gcmVxdWlyZShcIi4vRXZlbnREYXRhXCIpO1xuXHR2YXIgQ2xhc3MgPSByZXF1aXJlKFwiLi4vQ2xhc3NcIik7XG5cdHZhciBFcnJvclV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbHMvRXJyb3JVdGlsXCIpO1xuXHR2YXIgTWFwID0gcmVxdWlyZShcIi4uL3V0aWxzL01hcFwiKTtcblx0dmFyIE9iamVjdFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbHMvT2JqZWN0VXRpbFwiKTtcblx0dmFyIFRyaWVNYXAgPSByZXF1aXJlKFwiLi4vdXRpbHMvVHJpZU1hcFwiKTtcblx0dmFyIFVJRCA9IHJlcXVpcmUoXCIuLi91dGlscy9VSURcIik7XG5cdHZhciBXZWFrTWFwID0gcmVxdWlyZShcIi4uL3V0aWxzL1dlYWtNYXBcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgT2JqZWN0LCBmdW5jdGlvbihFdmVudCwgYmFzZSlcblx0e1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgQ29uc3RhbnRzXG5cblx0XHR2YXIgX0RFQlVHX0tFWSA9IFwiX19ERUJVR19FVkVOVFNfX1wiO1xuXG5cdFx0Ly8gUHVibGljIFN0YXRpYyBQcm9wZXJ0aWVzXG5cblx0XHRFdmVudC5kZWJ1ZyA9IGZhbHNlO1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgUHJvcGVydGllc1xuXG5cdFx0dmFyIF9jb250ZXh0TWFwcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHQvLyBQdWJsaWMgU3RhdGljIE1ldGhvZHNcblxuXHRcdEV2ZW50LnJlc29sdmUgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBzdHJpY3QpXG5cdFx0e1xuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgdGFyZ2V0IG11c3QgYmUgbm9uLW51bGwuXCIpO1xuXHRcdFx0aWYgKGV2ZW50ID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBldmVudCBtdXN0IGJlIG5vbi1udWxsLlwiKTtcblxuXHRcdFx0aWYgKGV2ZW50IGluc3RhbmNlb2YgRXZlbnQpXG5cdFx0XHRcdHJldHVybiBldmVudDtcblxuXHRcdFx0aWYgKCFDbGFzcy5pc1N0cmluZyhldmVudCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBldmVudCBtdXN0IGJlIG9mIHR5cGUgU3RyaW5nIG9yIFwiICsgQ2xhc3MuZ2V0TmFtZShFdmVudCkgKyBcIi5cIik7XG5cblx0XHRcdHZhciBldmVudE5hbWUgPSBldmVudDtcblx0XHRcdGlmIChldmVudE5hbWUuaW5kZXhPZihcIi5cIikgPCAwKVxuXHRcdFx0e1xuXHRcdFx0XHRldmVudCA9IHRhcmdldFtldmVudE5hbWVdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZXZlbnRQYXRoID0gZXZlbnROYW1lLnNwbGl0KFwiLlwiKTtcblx0XHRcdFx0ZXZlbnQgPSB0YXJnZXQ7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnRQYXRoLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGV2ZW50ID0gZXZlbnRbZXZlbnRQYXRoW2ldXTtcblx0XHRcdFx0XHRpZiAoZXZlbnQgPT0gbnVsbClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICgoZXZlbnQgIT0gbnVsbCkgJiYgKGV2ZW50IGluc3RhbmNlb2YgRXZlbnQpKVxuXHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cblx0XHRcdGlmIChzdHJpY3QgIT09IGZhbHNlKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV2ZW50IFxcXCJcIiArIGV2ZW50TmFtZSArIFwiXFxcIi5cIik7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHRFdmVudC5vZmZBbGwgPSBmdW5jdGlvbih0YXJnZXQpXG5cdFx0e1xuXHRcdFx0dmFyIGNvbnRleHRNYXAgPSBfY29udGV4dE1hcHMuZ2V0KHRhcmdldCk7XG5cdFx0XHRpZiAoIWNvbnRleHRNYXApXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dmFyIGV2ZW50TGlzdCA9IGNvbnRleHRNYXAua2V5cygpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBldmVudExpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRldmVudExpc3RbaV0ub2ZmQWxsKHRhcmdldCk7XG5cdFx0fTtcblxuXHRcdEV2ZW50Lmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKHRhcmdldClcblx0XHR7XG5cdFx0XHR2YXIgY29udGV4dE1hcCA9IF9jb250ZXh0TWFwcy5nZXQodGFyZ2V0KTtcblx0XHRcdGlmICghY29udGV4dE1hcClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR2YXIgZXZlbnRMaXN0ID0gY29udGV4dE1hcC5rZXlzKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50TGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChldmVudExpc3RbaV0uaGFzTGlzdGVuZXJzKHRhcmdldCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0dmFyIF9kZWJ1ZyA9IGZ1bmN0aW9uKGNvbnRleHQpXG5cdFx0e1xuXHRcdFx0dmFyIHRhcmdldCA9IGNvbnRleHQudGFyZ2V0O1xuXHRcdFx0dmFyIGRlYnVnTWFwID0gT2JqZWN0VXRpbC5nZXQodGFyZ2V0LCBfREVCVUdfS0VZKTtcblx0XHRcdGlmICghZGVidWdNYXApXG5cdFx0XHRcdGRlYnVnTWFwID0gdGFyZ2V0W19ERUJVR19LRVldID0ge307XG5cblx0XHRcdHZhciBldmVudCA9IGNvbnRleHQuZXZlbnQ7XG5cdFx0XHR2YXIgZGVidWdFdmVudEtleSA9IGV2ZW50Lm5hbWUoKSArIFwiICNcIiArIFVJRC5nZXQoZXZlbnQpO1xuXHRcdFx0dmFyIGxpc3RlbmVyQ291bnQgPSBjb250ZXh0Lmxpc3RlbmVyTWFwLnNpemUoKTtcblx0XHRcdGlmIChsaXN0ZW5lckNvdW50ID4gMClcblx0XHRcdFx0ZGVidWdNYXBbZGVidWdFdmVudEtleV0gPSBsaXN0ZW5lckNvdW50O1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRkZWxldGUgZGVidWdNYXBbZGVidWdFdmVudEtleV07XG5cdFx0fTtcblxuXHRcdHZhciBfbGlzdGVuZXJJbmZvQ29tcGFyYXRvciA9IGZ1bmN0aW9uKGxpc3RlbmVySW5mbzEsIGxpc3RlbmVySW5mbzIpXG5cdFx0e1xuXHRcdFx0aWYgKGxpc3RlbmVySW5mbzEucHJpb3JpdHkgPiBsaXN0ZW5lckluZm8yLnByaW9yaXR5KVxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRpZiAobGlzdGVuZXJJbmZvMS5wcmlvcml0eSA8IGxpc3RlbmVySW5mbzIucHJpb3JpdHkpXG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0aWYgKGxpc3RlbmVySW5mbzEuX29yZGVyIDwgbGlzdGVuZXJJbmZvMi5fb3JkZXIpXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdGlmIChsaXN0ZW5lckluZm8xLl9vcmRlciA+IGxpc3RlbmVySW5mbzIuX29yZGVyKVxuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cblx0XHQvLyBQcml2YXRlIFByb3BlcnRpZXNcblxuXHRcdHRoaXMuX25hbWUgPSBudWxsO1xuXHRcdHRoaXMuX3R5cGUgPSBudWxsO1xuXHRcdHRoaXMuX2J1YmJsZXMgPSBmYWxzZTtcblx0XHR0aGlzLl9jYW5jZWxhYmxlID0gZmFsc2U7XG5cdFx0dGhpcy5fZGVmYXVsdEFjdGlvbiA9IG51bGw7XG5cblx0XHQvLyBDb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpXG5cdFx0e1xuXHRcdFx0aWYgKG5hbWUgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG5hbWUgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cdFx0XHRpZiAoIUNsYXNzLmlzU3RyaW5nKG5hbWUpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbmFtZSBtdXN0IGJlIG9mIHR5cGUgU3RyaW5nLlwiKTtcblxuXHRcdFx0aWYgKHR5cGUgPT0gbnVsbClcblx0XHRcdFx0dHlwZSA9IEV2ZW50RGF0YTtcblx0XHRcdGVsc2UgaWYgKCFDbGFzcy5pc0Z1bmN0aW9uKHR5cGUpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgdHlwZSBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uXCIpO1xuXHRcdFx0ZWxzZSBpZiAoKHR5cGUgIT09IEV2ZW50RGF0YSkgJiYgIUNsYXNzLmlzU3ViY2xhc3NPZih0eXBlLCBFdmVudERhdGEpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgdHlwZSBtdXN0IGJlIGEgc3ViY2xhc3Mgb2YgXCIgKyBDbGFzcy5nZXROYW1lKEV2ZW50RGF0YSkgKyBcIi5cIik7XG5cblx0XHRcdHRoaXMuX25hbWUgPSBuYW1lO1xuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cblx0XHRcdGlmIChidWJibGVzICE9IG51bGwpXG5cdFx0XHRcdHRoaXMuYnViYmxlcyhidWJibGVzKTtcblx0XHRcdGlmIChjYW5jZWxhYmxlICE9IG51bGwpXG5cdFx0XHRcdHRoaXMuY2FuY2VsYWJsZShjYW5jZWxhYmxlKTtcblx0XHR9O1xuXG5cdFx0Ly8gUHVibGljIEFjY2Vzc29yIE1ldGhvZHNcblxuXHRcdHRoaXMubmFtZSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0XHR9O1xuXG5cdFx0dGhpcy50eXBlID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHRcdH07XG5cblx0XHR0aGlzLmJ1YmJsZXMgPSBmdW5jdGlvbih2YWx1ZSlcblx0XHR7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9idWJibGVzO1xuXG5cdFx0XHRpZiAoKHZhbHVlICE9IG51bGwpICYmICFDbGFzcy5pc0Jvb2xlYW4odmFsdWUpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgYnViYmxlcyBtdXN0IGJlIG9mIHR5cGUgQm9vbGVhbi5cIik7XG5cblx0XHRcdHRoaXMuX2J1YmJsZXMgPSAodmFsdWUgPT09IHRydWUpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0dGhpcy5jYW5jZWxhYmxlID0gZnVuY3Rpb24odmFsdWUpXG5cdFx0e1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FuY2VsYWJsZTtcblxuXHRcdFx0aWYgKCh2YWx1ZSAhPSBudWxsKSAmJiAhQ2xhc3MuaXNCb29sZWFuKHZhbHVlKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGNhbmNlbGFibGUgbXVzdCBiZSBvZiB0eXBlIEJvb2xlYW4uXCIpO1xuXG5cdFx0XHR0aGlzLl9jYW5jZWxhYmxlID0gKHZhbHVlID09PSB0cnVlKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHRoaXMuZGVmYXVsdEFjdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKVxuXHRcdHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2RlZmF1bHRBY3Rpb247XG5cblx0XHRcdGlmICgodmFsdWUgIT0gbnVsbCkgJiYgIUNsYXNzLmlzRnVuY3Rpb24odmFsdWUpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgZGVmYXVsdEFjdGlvbiBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uXCIpO1xuXG5cdFx0XHR0aGlzLl9kZWZhdWx0QWN0aW9uID0gdmFsdWUgfHwgbnVsbDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdC8vIFB1YmxpYyBNZXRob2RzXG5cblx0XHR0aGlzLm9uID0gZnVuY3Rpb24odGFyZ2V0LCBsaXN0ZW5lciwgc2NvcGUsIHByaW9yaXR5KVxuXHRcdHtcblx0XHRcdHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KHRhcmdldCk7XG5cdFx0XHR0aGlzLmFkZExpc3RlbmVyKGNvbnRleHQsIGxpc3RlbmVyLCBzY29wZSwgcHJpb3JpdHkpO1xuXHRcdH07XG5cblx0XHR0aGlzLm9mZiA9IGZ1bmN0aW9uKHRhcmdldCwgbGlzdGVuZXIsIHNjb3BlKVxuXHRcdHtcblx0XHRcdHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KHRhcmdldCwgZmFsc2UpO1xuXHRcdFx0aWYgKCFjb250ZXh0KVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdHRoaXMucmVtb3ZlTGlzdGVuZXIoY29udGV4dCwgbGlzdGVuZXIsIHNjb3BlKTtcblx0XHRcdGlmIChjb250ZXh0Lmxpc3RlbmVyTWFwLnNpemUoKSA+IDApXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dGhpcy5kZWxDb250ZXh0KHRhcmdldCk7XG5cdFx0fTtcblxuXHRcdHRoaXMub2ZmQWxsID0gZnVuY3Rpb24odGFyZ2V0KVxuXHRcdHtcblx0XHRcdHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KHRhcmdldCwgZmFsc2UpO1xuXHRcdFx0aWYgKCFjb250ZXh0KVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdHZhciBsaXN0ZW5lckxpc3QgPSB0aGlzLmdldExpc3RlbmVycyhjb250ZXh0LCBmYWxzZSk7XG5cdFx0XHR2YXIgbGlzdGVuZXJJbmZvO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRsaXN0ZW5lckluZm8gPSBsaXN0ZW5lckxpc3RbaV07XG5cdFx0XHRcdGlmIChsaXN0ZW5lckluZm8ubGlzdGVuZXIpXG5cdFx0XHRcdFx0dGhpcy5vZmYodGFyZ2V0LCBsaXN0ZW5lckluZm8ubGlzdGVuZXIsIGxpc3RlbmVySW5mby5zY29wZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuZmlyZSA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnREYXRhKVxuXHRcdHtcblx0XHRcdGlmIChldmVudERhdGEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlcblx0XHRcdFx0cmV0dXJuICEodGhpcy5fY2FuY2VsYWJsZSAmJiBldmVudERhdGEuaXNEZWZhdWx0UHJldmVudGVkKCkpO1xuXG5cdFx0XHRpZiAoIWV2ZW50RGF0YS5ldmVudClcblx0XHRcdFx0ZXZlbnREYXRhLmV2ZW50ID0gdGhpcztcblx0XHRcdGlmICghZXZlbnREYXRhLnRhcmdldClcblx0XHRcdFx0ZXZlbnREYXRhLnRhcmdldCA9IHRhcmdldDtcblxuXHRcdFx0dmFyIGlzUm9vdERpc3BhdGNoID0gKChldmVudERhdGEuZXZlbnQgPT09IHRoaXMpICYmIChldmVudERhdGEudGFyZ2V0ID09PSB0YXJnZXQpKTtcblxuXHRcdFx0dmFyIGJ1YmJsZVRhcmdldHMgPSB0aGlzLmdldEJ1YmJsZVRhcmdldHModGFyZ2V0KTtcblx0XHRcdHRoaXMubm90aWZ5TGlzdGVuZXJzKHRhcmdldCwgZXZlbnREYXRhKTtcblx0XHRcdGlmIChidWJibGVUYXJnZXRzICYmIChidWJibGVUYXJnZXRzLmxlbmd0aCA+IDApICYmICFldmVudERhdGEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlcblx0XHRcdFx0dGhpcy5ub3RpZnlCdWJibGVMaXN0ZW5lcnMoYnViYmxlVGFyZ2V0cywgZXZlbnREYXRhKTtcblxuXHRcdFx0ZXZlbnREYXRhLnJlc2V0UHJvcGFnYXRpb24oKTtcblxuXHRcdFx0aWYgKHRoaXMuX2NhbmNlbGFibGUgJiYgZXZlbnREYXRhLmlzRGVmYXVsdFByZXZlbnRlZCgpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdGlmIChpc1Jvb3REaXNwYXRjaClcblx0XHRcdFx0dGhpcy5leGVjdXRlRGVmYXVsdCh0YXJnZXQsIGV2ZW50RGF0YSk7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHR0aGlzLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKHRhcmdldClcblx0XHR7XG5cdFx0XHR2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCh0YXJnZXQsIGZhbHNlKTtcblx0XHRcdGlmICghY29udGV4dClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRyZXR1cm4gKGNvbnRleHQubGlzdGVuZXJNYXAuc2l6ZSgpID4gMCk7XG5cdFx0fTtcblxuXHRcdHRoaXMubm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudERhdGEpXG5cdFx0e1xuXHRcdFx0dmFyIGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQodGFyZ2V0LCBmYWxzZSk7XG5cdFx0XHRpZiAoIWNvbnRleHQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dmFyIG9yaWdpbmFsQ3VycmVudEV2ZW50ID0gZXZlbnREYXRhLmN1cnJlbnRFdmVudDtcblx0XHRcdHZhciBvcmlnaW5hbEN1cnJlbnRUYXJnZXQgPSBldmVudERhdGEuY3VycmVudFRhcmdldDtcblxuXHRcdFx0ZXZlbnREYXRhLmN1cnJlbnRFdmVudCA9IHRoaXM7XG5cdFx0XHRldmVudERhdGEuY3VycmVudFRhcmdldCA9IHRhcmdldDtcblxuXHRcdFx0dmFyIGxpc3RlbmVyTGlzdCA9IHRoaXMuZ2V0TGlzdGVuZXJzKGNvbnRleHQpO1xuXHRcdFx0dmFyIGxpc3RlbmVySW5mbztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0bGlzdGVuZXJJbmZvID0gbGlzdGVuZXJMaXN0W2ldO1xuXHRcdFx0XHRpZiAobGlzdGVuZXJJbmZvLmxpc3RlbmVyKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dHJ5XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bGlzdGVuZXJJbmZvLmxpc3RlbmVyLmNhbGwobGlzdGVuZXJJbmZvLnNjb3BlLCBldmVudERhdGEpO1xuXHRcdFx0XHRcdFx0aWYgKGV2ZW50RGF0YS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0RXJyb3JVdGlsLm5vbkJsb2NraW5nVGhyb3coZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50RGF0YS5jdXJyZW50RXZlbnQgPSBvcmlnaW5hbEN1cnJlbnRFdmVudDtcblx0XHRcdGV2ZW50RGF0YS5jdXJyZW50VGFyZ2V0ID0gb3JpZ2luYWxDdXJyZW50VGFyZ2V0O1xuXHRcdH07XG5cblx0XHR0aGlzLm5vdGlmeUJ1YmJsZUxpc3RlbmVycyA9IGZ1bmN0aW9uKGJ1YmJsZVRhcmdldHMsIGV2ZW50RGF0YSlcblx0XHR7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGJ1YmJsZVRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLm5vdGlmeUxpc3RlbmVycyhidWJibGVUYXJnZXRzW2ldLCBldmVudERhdGEpO1xuXHRcdFx0XHRpZiAoZXZlbnREYXRhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuZXhlY3V0ZURlZmF1bHQgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50RGF0YSlcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fZGVmYXVsdEFjdGlvbilcblx0XHRcdFx0dGhpcy5fZGVmYXVsdEFjdGlvbi5jYWxsKHRhcmdldCwgZXZlbnREYXRhKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRCdWJibGVUYXJnZXRzID0gZnVuY3Rpb24odGFyZ2V0KVxuXHRcdHtcblx0XHRcdGlmICghdGhpcy5fYnViYmxlcylcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdHZhciBidWJibGVUYXJnZXRzID0gW107XG5cdFx0XHR2YXIgYnViYmxlVGFyZ2V0ID0gdGFyZ2V0LmdldEJ1YmJsZVRhcmdldCgpO1xuXHRcdFx0d2hpbGUgKGJ1YmJsZVRhcmdldCAmJiBidWJibGVUYXJnZXQuaXNFdmVudFRhcmdldClcblx0XHRcdHtcblx0XHRcdFx0YnViYmxlVGFyZ2V0cy5wdXNoKGJ1YmJsZVRhcmdldCk7XG5cdFx0XHRcdGJ1YmJsZVRhcmdldCA9IGJ1YmJsZVRhcmdldC5nZXRCdWJibGVUYXJnZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1YmJsZVRhcmdldHM7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIENsYXNzLmdldE5hbWUodGhpcy5fdHlwZSkgfHwgKHRoaXMuX25hbWUgKyBcIi50eXBlXCIpO1xuXHRcdH07XG5cblx0XHR0aGlzLmlzVmFsaWRUeXBlID0gZnVuY3Rpb24oZXZlbnREYXRhKVxuXHRcdHtcblx0XHRcdHJldHVybiAoZXZlbnREYXRhIGluc3RhbmNlb2YgdGhpcy5fdHlwZSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuY3JlYXRlRXZlbnREYXRhID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5fdHlwZSgpO1xuXHRcdH07XG5cblx0XHQvLyBQcm90ZWN0ZWQgTWV0aG9kc1xuXG5cdFx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24odGFyZ2V0LCBjcmVhdGUpXG5cdFx0e1xuXHRcdFx0dmFyIGNvbnRleHRNYXAgPSBfY29udGV4dE1hcHMuZ2V0KHRhcmdldCk7XG5cdFx0XHRpZiAoIWNvbnRleHRNYXApXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChjcmVhdGUgPT09IGZhbHNlKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdGNvbnRleHRNYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdF9jb250ZXh0TWFwcy5zZXQodGFyZ2V0LCBjb250ZXh0TWFwKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvbnRleHQgPSBjb250ZXh0TWFwLmdldCh0aGlzKTtcblx0XHRcdGlmICghY29udGV4dClcblx0XHRcdHtcblx0XHRcdFx0aWYgKGNyZWF0ZSA9PT0gZmFsc2UpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0Y29udGV4dCA9IHsgdGFyZ2V0OiB0YXJnZXQsIGV2ZW50OiB0aGlzIH07XG5cdFx0XHRcdGNvbnRleHRNYXAuc2V0KHRoaXMsIGNvbnRleHQpO1xuXG5cdFx0XHRcdHRoaXMuc2V0dXBDb250ZXh0KGNvbnRleHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29udGV4dDtcblx0XHR9O1xuXG5cdFx0dGhpcy5kZWxDb250ZXh0ID0gZnVuY3Rpb24odGFyZ2V0KVxuXHRcdHtcblx0XHRcdHZhciBjb250ZXh0TWFwID0gX2NvbnRleHRNYXBzLmdldCh0YXJnZXQpO1xuXHRcdFx0aWYgKCFjb250ZXh0TWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdHZhciBjb250ZXh0ID0gY29udGV4dE1hcC5nZXQodGhpcyk7XG5cdFx0XHRpZiAoIWNvbnRleHQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Y29udGV4dE1hcC5kZWwodGhpcyk7XG5cdFx0XHRpZiAoY29udGV4dE1hcC5zaXplKCkgPT09IDApXG5cdFx0XHRcdF9jb250ZXh0TWFwcy5kZWwodGFyZ2V0KTtcblxuXHRcdFx0dGhpcy50ZWFyZG93bkNvbnRleHQoY29udGV4dCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0dXBDb250ZXh0ID0gZnVuY3Rpb24oY29udGV4dClcblx0XHR7XG5cdFx0XHRjb250ZXh0Lmxpc3RlbmVyTWFwID0gbmV3IFRyaWVNYXAoKTtcblx0XHRcdGNvbnRleHQuX2xpc3RlbmVyTGlzdCA9IG51bGw7XG5cdFx0XHRjb250ZXh0Ll9saXN0ZW5lck9yZGVyID0gMDtcblx0XHR9O1xuXG5cdFx0dGhpcy50ZWFyZG93bkNvbnRleHQgPSBmdW5jdGlvbihjb250ZXh0KVxuXHRcdHtcblx0XHRcdGNvbnRleHQubGlzdGVuZXJNYXAgPSBudWxsO1xuXHRcdFx0Y29udGV4dC5fbGlzdGVuZXJMaXN0ID0gbnVsbDtcblx0XHR9O1xuXG5cdFx0dGhpcy5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGNvbnRleHQsIGxpc3RlbmVyLCBzY29wZSwgcHJpb3JpdHkpXG5cdFx0e1xuXHRcdFx0dmFyIGxpc3RlbmVyTWFwID0gY29udGV4dC5saXN0ZW5lck1hcDtcblx0XHRcdHZhciBsaXN0ZW5lcktleXMgPSBbIGxpc3RlbmVyLCBzY29wZSBdO1xuXHRcdFx0dmFyIGxpc3RlbmVySW5mbyA9IGxpc3RlbmVyTWFwLmdldChsaXN0ZW5lcktleXMpO1xuXHRcdFx0aWYgKCFsaXN0ZW5lckluZm8pXG5cdFx0XHR7XG5cdFx0XHRcdGxpc3RlbmVySW5mbyA9IHsgbGlzdGVuZXI6IGxpc3RlbmVyLCBzY29wZTogc2NvcGUsIHByaW9yaXR5OiBwcmlvcml0eSwgX29yZGVyOiAoKytjb250ZXh0Ll9saXN0ZW5lck9yZGVyKSB9O1xuXHRcdFx0XHRsaXN0ZW5lck1hcC5zZXQobGlzdGVuZXJLZXlzLCBsaXN0ZW5lckluZm8pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobGlzdGVuZXJJbmZvLnByaW9yaXR5ICE9PSBwcmlvcml0eSlcblx0XHRcdHtcblx0XHRcdFx0bGlzdGVuZXJJbmZvLnByaW9yaXR5ID0gcHJpb3JpdHk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29udGV4dC5fbGlzdGVuZXJMaXN0ID0gbnVsbDtcblxuXHRcdFx0aWYgKEV2ZW50LmRlYnVnKVxuXHRcdFx0XHRfZGVidWcoY29udGV4dCk7XG5cdFx0fTtcblxuXHRcdHRoaXMucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihjb250ZXh0LCBsaXN0ZW5lciwgc2NvcGUpXG5cdFx0e1xuXHRcdFx0dmFyIGxpc3RlbmVyTWFwID0gY29udGV4dC5saXN0ZW5lck1hcDtcblx0XHRcdHZhciBsaXN0ZW5lcktleXMgPSBbIGxpc3RlbmVyLCBzY29wZSBdO1xuXHRcdFx0dmFyIGxpc3RlbmVySW5mbyA9IGxpc3RlbmVyTWFwLmdldChsaXN0ZW5lcktleXMpO1xuXHRcdFx0aWYgKCFsaXN0ZW5lckluZm8pXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0bGlzdGVuZXJNYXAuZGVsKGxpc3RlbmVyS2V5cyk7XG5cdFx0XHRsaXN0ZW5lckluZm8ubGlzdGVuZXIgPSBudWxsO1xuXHRcdFx0bGlzdGVuZXJJbmZvLnNjb3BlID0gbnVsbDtcblxuXHRcdFx0Y29udGV4dC5fbGlzdGVuZXJMaXN0ID0gbnVsbDtcblxuXHRcdFx0aWYgKEV2ZW50LmRlYnVnKVxuXHRcdFx0XHRfZGVidWcoY29udGV4dCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24oY29udGV4dCwgc29ydGVkKVxuXHRcdHtcblx0XHRcdHZhciBsaXN0ZW5lckxpc3QgPSBjb250ZXh0Ll9saXN0ZW5lckxpc3Q7XG5cdFx0XHRpZiAoIWxpc3RlbmVyTGlzdClcblx0XHRcdHtcblx0XHRcdFx0bGlzdGVuZXJMaXN0ID0gY29udGV4dC5fbGlzdGVuZXJMaXN0ID0gY29udGV4dC5saXN0ZW5lck1hcC52YWx1ZXMoKTtcblx0XHRcdFx0bGlzdGVuZXJMaXN0Ll9pc1NvcnRlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKHNvcnRlZCAhPT0gZmFsc2UpICYmICFsaXN0ZW5lckxpc3QuX2lzU29ydGVkKVxuXHRcdFx0e1xuXHRcdFx0XHRsaXN0ZW5lckxpc3Quc29ydChfbGlzdGVuZXJJbmZvQ29tcGFyYXRvcik7XG5cdFx0XHRcdGxpc3RlbmVyTGlzdC5faXNTb3J0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGlzdGVuZXJMaXN0O1xuXHRcdH07XG5cblx0fSk7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2V2ZW50cy9FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9qZ19saWIvZXZlbnRzL0V2ZW50XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "contrib/jg_lib/utils/ErrorUtil":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Global = __webpack_require__(\"contrib/jg_lib/utils/Global\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, function(ErrorUtil)\n\t{\n\n\t\t// Public Static Methods\n\n\t\tErrorUtil.nonBlockingThrow = function(err)\n\t\t{\n\t\t\tif (Global.console && Global.console.error)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tGlobal.console.error(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\t// ignore console errors\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetTimeout(function() { throw err; }, 0);\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL0Vycm9yVXRpbC5qcz9jZTJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFdBQVcsRUFBRTtBQUN2Qzs7QUFFQSxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvdXRpbHMvRXJyb3JVdGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNiBKYXNvbiBHYXR0XG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSlcbntcblxuXHR2YXIgR2xvYmFsID0gcmVxdWlyZShcIi4vR2xvYmFsXCIpO1xuXHR2YXIgQ2xhc3MgPSByZXF1aXJlKFwiLi4vQ2xhc3NcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgZnVuY3Rpb24oRXJyb3JVdGlsKVxuXHR7XG5cblx0XHQvLyBQdWJsaWMgU3RhdGljIE1ldGhvZHNcblxuXHRcdEVycm9yVXRpbC5ub25CbG9ja2luZ1Rocm93ID0gZnVuY3Rpb24oZXJyKVxuXHRcdHtcblx0XHRcdGlmIChHbG9iYWwuY29uc29sZSAmJiBHbG9iYWwuY29uc29sZS5lcnJvcilcblx0XHRcdHtcblx0XHRcdFx0dHJ5XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRHbG9iYWwuY29uc29sZS5lcnJvcihlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIGlnbm9yZSBjb25zb2xlIGVycm9yc1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGVycjsgfSwgMCk7XG5cdFx0fTtcblxuXHR9KTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9qZ19saWIvdXRpbHMvRXJyb3JVdGlsLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL2pnX2xpYi91dGlscy9FcnJvclV0aWxcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/utils/Global":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function()\n{\n\n\treturn (function() { return this; })();\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL0dsb2JhbC5qcz9kNzgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWEsRUFBRTs7QUFFcEMsQ0FBQyIsImZpbGUiOiJjb250cmliL2pnX2xpYi91dGlscy9HbG9iYWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAwNy0yMDE2IEphc29uIEdhdHRcbiAqIFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5kZWZpbmUoZnVuY3Rpb24oKVxue1xuXG5cdHJldHVybiAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL2pnX2xpYi91dGlscy9HbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IGNvbnRyaWIvamdfbGliL3V0aWxzL0dsb2JhbFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/jg_lib/utils/Map":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar UID = __webpack_require__(\"contrib/jg_lib/utils/UID\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, Object, function(Map, base)\n\t{\n\n\t\t// Private Properties\n\n\t\tthis._entries = null;\n\t\tthis._size = 0;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(entries)\n\t\t{\n\t\t\tthis._entries = {};\n\n\t\t\tif (entries != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0, l = entries.length; i < l; i++)\n\t\t\t\t\tthis.set(entries[i][0], entries[i][1]);\n\t\t\t}\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.get = function(key)\n\t\t{\n\t\t\tvar uid = UID.get(key, false);\n\t\t\tif (!uid || !this._entries.hasOwnProperty(uid))\n\t\t\t\treturn void(0);\n\n\t\t\treturn this._entries[uid][1];\n\t\t};\n\n\t\tthis.set = function(key, value)\n\t\t{\n\t\t\tvar uid = UID.get(key);\n\t\t\tif (this._entries.hasOwnProperty(uid))\n\t\t\t{\n\t\t\t\tthis._entries[uid][1] = value;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tthis._entries[uid] = [ key, value ];\n\t\t\tthis._size++;\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.del = function(key)\n\t\t{\n\t\t\tvar uid = UID.get(key, false);\n\t\t\tif (!uid || !this._entries.hasOwnProperty(uid))\n\t\t\t\treturn this;\n\n\t\t\tdelete this._entries[uid];\n\t\t\tthis._size--;\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.has = function(key)\n\t\t{\n\t\t\tvar uid = UID.get(key, false);\n\t\t\tif (!uid || !this._entries.hasOwnProperty(uid))\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t};\n\n\t\tthis.size = function()\n\t\t{\n\t\t\treturn this._size;\n\t\t};\n\n\t\tthis.clear = function()\n\t\t{\n\t\t\tif (this._size === 0)\n\t\t\t\treturn this;\n\n\t\t\tthis._entries = {};\n\t\t\tthis._size = 0;\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.keys = function()\n\t\t{\n\t\t\tvar keys = [];\n\t\t\tvar entries = this._entries;\n\t\t\tfor (var uid in entries)\n\t\t\t{\n\t\t\t\tif (entries.hasOwnProperty(uid))\n\t\t\t\t\tkeys.push(entries[uid][0]);\n\t\t\t}\n\t\t\treturn keys;\n\t\t};\n\n\t\tthis.values = function()\n\t\t{\n\t\t\tvar values = [];\n\t\t\tvar entries = this._entries;\n\t\t\tfor (var uid in entries)\n\t\t\t{\n\t\t\t\tif (entries.hasOwnProperty(uid))\n\t\t\t\t\tvalues.push(entries[uid][1]);\n\t\t\t}\n\t\t\treturn values;\n\t\t};\n\n\t\tthis.pairs = function()\n\t\t{\n\t\t\tvar pairs = [];\n\t\t\tvar entries = this._entries;\n\t\t\tfor (var uid in entries)\n\t\t\t{\n\t\t\t\tif (entries.hasOwnProperty(uid))\n\t\t\t\t\tpairs.push(entries[uid].concat());\n\t\t\t}\n\t\t\treturn pairs;\n\t\t};\n\n\t\tthis.entries = function()\n\t\t{\n\t\t\treturn this.pairs();\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL01hcC5qcz8wYWFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRixDQUFDIiwiZmlsZSI6ImNvbnRyaWIvamdfbGliL3V0aWxzL01hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIFVJRCA9IHJlcXVpcmUoXCIuL1VJRFwiKTtcblx0dmFyIENsYXNzID0gcmVxdWlyZShcIi4uL0NsYXNzXCIpO1xuXG5cdHJldHVybiBDbGFzcyhtb2R1bGUuaWQsIE9iamVjdCwgZnVuY3Rpb24oTWFwLCBiYXNlKVxuXHR7XG5cblx0XHQvLyBQcml2YXRlIFByb3BlcnRpZXNcblxuXHRcdHRoaXMuX2VudHJpZXMgPSBudWxsO1xuXHRcdHRoaXMuX3NpemUgPSAwO1xuXG5cdFx0Ly8gQ29uc3RydWN0b3JcblxuXHRcdHRoaXMuY29uc3RydWN0b3IgPSBmdW5jdGlvbihlbnRyaWVzKVxuXHRcdHtcblx0XHRcdHRoaXMuX2VudHJpZXMgPSB7fTtcblxuXHRcdFx0aWYgKGVudHJpZXMgIT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHR0aGlzLnNldChlbnRyaWVzW2ldWzBdLCBlbnRyaWVzW2ldWzFdKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gUHVibGljIE1ldGhvZHNcblxuXHRcdHRoaXMuZ2V0ID0gZnVuY3Rpb24oa2V5KVxuXHRcdHtcblx0XHRcdHZhciB1aWQgPSBVSUQuZ2V0KGtleSwgZmFsc2UpO1xuXHRcdFx0aWYgKCF1aWQgfHwgIXRoaXMuX2VudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0cmV0dXJuIHZvaWQoMCk7XG5cblx0XHRcdHJldHVybiB0aGlzLl9lbnRyaWVzW3VpZF1bMV07XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSlcblx0XHR7XG5cdFx0XHR2YXIgdWlkID0gVUlELmdldChrZXkpO1xuXHRcdFx0aWYgKHRoaXMuX2VudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fZW50cmllc1t1aWRdWzFdID0gdmFsdWU7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9lbnRyaWVzW3VpZF0gPSBbIGtleSwgdmFsdWUgXTtcblx0XHRcdHRoaXMuX3NpemUrKztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHR0aGlzLmRlbCA9IGZ1bmN0aW9uKGtleSlcblx0XHR7XG5cdFx0XHR2YXIgdWlkID0gVUlELmdldChrZXksIGZhbHNlKTtcblx0XHRcdGlmICghdWlkIHx8ICF0aGlzLl9lbnRyaWVzLmhhc093blByb3BlcnR5KHVpZCkpXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRkZWxldGUgdGhpcy5fZW50cmllc1t1aWRdO1xuXHRcdFx0dGhpcy5fc2l6ZS0tO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHRoaXMuaGFzID0gZnVuY3Rpb24oa2V5KVxuXHRcdHtcblx0XHRcdHZhciB1aWQgPSBVSUQuZ2V0KGtleSwgZmFsc2UpO1xuXHRcdFx0aWYgKCF1aWQgfHwgIXRoaXMuX2VudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zaXplID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9zaXplO1xuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0dGhpcy5fZW50cmllcyA9IHt9O1xuXHRcdFx0dGhpcy5fc2l6ZSA9IDA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0dGhpcy5rZXlzID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHZhciBrZXlzID0gW107XG5cdFx0XHR2YXIgZW50cmllcyA9IHRoaXMuX2VudHJpZXM7XG5cdFx0XHRmb3IgKHZhciB1aWQgaW4gZW50cmllcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGVudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0XHRrZXlzLnB1c2goZW50cmllc1t1aWRdWzBdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBrZXlzO1xuXHRcdH07XG5cblx0XHR0aGlzLnZhbHVlcyA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR2YXIgdmFsdWVzID0gW107XG5cdFx0XHR2YXIgZW50cmllcyA9IHRoaXMuX2VudHJpZXM7XG5cdFx0XHRmb3IgKHZhciB1aWQgaW4gZW50cmllcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGVudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChlbnRyaWVzW3VpZF1bMV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHR9O1xuXG5cdFx0dGhpcy5wYWlycyA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR2YXIgcGFpcnMgPSBbXTtcblx0XHRcdHZhciBlbnRyaWVzID0gdGhpcy5fZW50cmllcztcblx0XHRcdGZvciAodmFyIHVpZCBpbiBlbnRyaWVzKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZW50cmllcy5oYXNPd25Qcm9wZXJ0eSh1aWQpKVxuXHRcdFx0XHRcdHBhaXJzLnB1c2goZW50cmllc1t1aWRdLmNvbmNhdCgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYWlycztcblx0XHR9O1xuXG5cdFx0dGhpcy5lbnRyaWVzID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnBhaXJzKCk7XG5cdFx0fTtcblxuXHR9KTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9qZ19saWIvdXRpbHMvTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL2pnX2xpYi91dGlscy9NYXBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/utils/UID":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, function(UID)\n\t{\n\n\t\t// Private Static Constants\n\n\t\tvar _UID_KEY;  // value initialized below\n\n\t\t// Private Static Properties\n\n\t\tvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\tvar _uidCount = 0;\n\n\t\t// Public Static Methods\n\n\t\tUID.get = function(value, create)\n\t\t{\n\t\t\tif (value == null)\n\t\t\t\treturn (\"\" + value);\n\n\t\t\tvar type = (typeof value);\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\t\tcase \"object\":\n\t\t\t\tcase \"function\":\n\t\t\t\t\tif (_hasOwnProperty.call(value, _UID_KEY))\n\t\t\t\t\t\treturn value[_UID_KEY];\n\t\t\t\t\tif (create === false)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\treturn (value[_UID_KEY] = type + (++_uidCount));\n\t\t\t\tdefault:\n\t\t\t\t\treturn (type + value);\n\t\t\t}\n\t\t};\n\n\t\tUID.random = function(digits, radix)\n\t\t{\n\t\t\tdigits = (digits != null) ? +digits : 16;\n\t\t\tradix = (radix != null) ? +radix : 16;\n\n\t\t\tvar str = \"\";\n\t\t\tfor (var i = 0; i < digits; i++)\n\t\t\t\tstr += Math.floor(radix * Math.random()).toString(radix);\n\t\t\treturn str;\n\t\t};\n\n\t\t// Initialization\n\n\t\t_UID_KEY = \"__uid_\" + UID.random() + \"__\";\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL1VJRC5qcz8wZDFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvdXRpbHMvVUlELmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNiBKYXNvbiBHYXR0XG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSlcbntcblxuXHR2YXIgQ2xhc3MgPSByZXF1aXJlKFwiLi4vQ2xhc3NcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgZnVuY3Rpb24oVUlEKVxuXHR7XG5cblx0XHQvLyBQcml2YXRlIFN0YXRpYyBDb25zdGFudHNcblxuXHRcdHZhciBfVUlEX0tFWTsgIC8vIHZhbHVlIGluaXRpYWxpemVkIGJlbG93XG5cblx0XHQvLyBQcml2YXRlIFN0YXRpYyBQcm9wZXJ0aWVzXG5cblx0XHR2YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0XHR2YXIgX3VpZENvdW50ID0gMDtcblxuXHRcdC8vIFB1YmxpYyBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0VUlELmdldCA9IGZ1bmN0aW9uKHZhbHVlLCBjcmVhdGUpXG5cdFx0e1xuXHRcdFx0aWYgKHZhbHVlID09IG51bGwpXG5cdFx0XHRcdHJldHVybiAoXCJcIiArIHZhbHVlKTtcblxuXHRcdFx0dmFyIHR5cGUgPSAodHlwZW9mIHZhbHVlKTtcblx0XHRcdHN3aXRjaCAodHlwZSlcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSBcIm9iamVjdFwiOlxuXHRcdFx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRcdFx0XHRpZiAoX2hhc093blByb3BlcnR5LmNhbGwodmFsdWUsIF9VSURfS0VZKSlcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZVtfVUlEX0tFWV07XG5cdFx0XHRcdFx0aWYgKGNyZWF0ZSA9PT0gZmFsc2UpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gKHZhbHVlW19VSURfS0VZXSA9IHR5cGUgKyAoKytfdWlkQ291bnQpKTtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRyZXR1cm4gKHR5cGUgKyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFVJRC5yYW5kb20gPSBmdW5jdGlvbihkaWdpdHMsIHJhZGl4KVxuXHRcdHtcblx0XHRcdGRpZ2l0cyA9IChkaWdpdHMgIT0gbnVsbCkgPyArZGlnaXRzIDogMTY7XG5cdFx0XHRyYWRpeCA9IChyYWRpeCAhPSBudWxsKSA/ICtyYWRpeCA6IDE2O1xuXG5cdFx0XHR2YXIgc3RyID0gXCJcIjtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGlnaXRzOyBpKyspXG5cdFx0XHRcdHN0ciArPSBNYXRoLmZsb29yKHJhZGl4ICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcocmFkaXgpO1xuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9O1xuXG5cdFx0Ly8gSW5pdGlhbGl6YXRpb25cblxuXHRcdF9VSURfS0VZID0gXCJfX3VpZF9cIiArIFVJRC5yYW5kb20oKSArIFwiX19cIjtcblxuXHR9KTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9qZ19saWIvdXRpbHMvVUlELmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL2pnX2xpYi91dGlscy9VSURcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/utils/ObjectUtil":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, function(ObjectUtil)\n\t{\n\n\t\t// Private Static Properties\n\n\t\tvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\t\t// Public Static Methods\n\n\t\tObjectUtil.extend = function(obj, source)\n\t\t{\n\t\t\tvar p;\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t{\n\t\t\t\tsource = arguments[i];\n\t\t\t\tfor (p in source)\n\t\t\t\t{\n\t\t\t\t\tif (_hasOwnProperty.call(source, p))\n\t\t\t\t\t\tobj[p] = source[p];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\n\t\tObjectUtil.get = function(obj, key)\n\t\t{\n\t\t\treturn _hasOwnProperty.call(obj, key) ? obj[key] : void(0);\n\t\t};\n\n\t\tObjectUtil.has = function(obj, key)\n\t\t{\n\t\t\treturn _hasOwnProperty.call(obj, key);\n\t\t};\n\n\t\tObjectUtil.keys = function(obj)\n\t\t{\n\t\t\tvar keys = [];\n\t\t\tfor (var key in obj)\n\t\t\t{\n\t\t\t\tif (_hasOwnProperty.call(obj, key))\n\t\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t\treturn keys;\n\t\t};\n\n\t\tObjectUtil.values = function(obj)\n\t\t{\n\t\t\tvar values = [];\n\t\t\tfor (var key in obj)\n\t\t\t{\n\t\t\t\tif (_hasOwnProperty.call(obj, key))\n\t\t\t\t\tvalues.push(obj[key]);\n\t\t\t}\n\t\t\treturn values;\n\t\t};\n\n\t\tObjectUtil.pairs = function(obj)\n\t\t{\n\t\t\tvar pairs = [];\n\t\t\tfor (var key in obj)\n\t\t\t{\n\t\t\t\tif (_hasOwnProperty.call(obj, key))\n\t\t\t\t\tpairs.push([ key, obj[key] ]);\n\t\t\t}\n\t\t\treturn pairs;\n\t\t};\n\n\t\tObjectUtil.isEmpty = function(obj)\n\t\t{\n\t\t\tfor (var key in obj)\n\t\t\t{\n\t\t\t\tif (_hasOwnProperty.call(obj, key))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL09iamVjdFV0aWwuanM/YTRiNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUYsQ0FBQyIsImZpbGUiOiJjb250cmliL2pnX2xpYi91dGlscy9PYmplY3RVdGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNiBKYXNvbiBHYXR0XG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSlcbntcblxuXHR2YXIgQ2xhc3MgPSByZXF1aXJlKFwiLi4vQ2xhc3NcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgZnVuY3Rpb24oT2JqZWN0VXRpbClcblx0e1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgUHJvcGVydGllc1xuXG5cdFx0dmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0XHQvLyBQdWJsaWMgU3RhdGljIE1ldGhvZHNcblxuXHRcdE9iamVjdFV0aWwuZXh0ZW5kID0gZnVuY3Rpb24ob2JqLCBzb3VyY2UpXG5cdFx0e1xuXHRcdFx0dmFyIHA7XG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR7XG5cdFx0XHRcdHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Zm9yIChwIGluIHNvdXJjZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHApKVxuXHRcdFx0XHRcdFx0b2JqW3BdID0gc291cmNlW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cblx0XHRPYmplY3RVdGlsLmdldCA9IGZ1bmN0aW9uKG9iaiwga2V5KVxuXHRcdHtcblx0XHRcdHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgPyBvYmpba2V5XSA6IHZvaWQoMCk7XG5cdFx0fTtcblxuXHRcdE9iamVjdFV0aWwuaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcblx0XHR9O1xuXG5cdFx0T2JqZWN0VXRpbC5rZXlzID0gZnVuY3Rpb24ob2JqKVxuXHRcdHtcblx0XHRcdHZhciBrZXlzID0gW107XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKVxuXHRcdFx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGtleXM7XG5cdFx0fTtcblxuXHRcdE9iamVjdFV0aWwudmFsdWVzID0gZnVuY3Rpb24ob2JqKVxuXHRcdHtcblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblx0XHRcdGZvciAodmFyIGtleSBpbiBvYmopXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2gob2JqW2tleV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHR9O1xuXG5cdFx0T2JqZWN0VXRpbC5wYWlycyA9IGZ1bmN0aW9uKG9iailcblx0XHR7XG5cdFx0XHR2YXIgcGFpcnMgPSBbXTtcblx0XHRcdGZvciAodmFyIGtleSBpbiBvYmopXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpXG5cdFx0XHRcdFx0cGFpcnMucHVzaChbIGtleSwgb2JqW2tleV0gXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFpcnM7XG5cdFx0fTtcblxuXHRcdE9iamVjdFV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iailcblx0XHR7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0fSk7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL09iamVjdFV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IGNvbnRyaWIvamdfbGliL3V0aWxzL09iamVjdFV0aWxcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/utils/TrieMap":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar UID = __webpack_require__(\"contrib/jg_lib/utils/UID\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, Object, function(TrieMap, base)\n\t{\n\n\t\t// Private Static Methods\n\n\t\tvar _get = function(node, keyIndex, keyCount, keys)\n\t\t{\n\t\t\tif (keyIndex < keyCount)\n\t\t\t{\n\t\t\t\tvar entries = node._entries;\n\t\t\t\tvar uid = UID.get(keys[keyIndex], false);\n\t\t\t\tif (!uid || !entries.hasOwnProperty(uid))\n\t\t\t\t\treturn void(0);\n\n\t\t\t\treturn _get(entries[uid], keyIndex + 1, keyCount, keys);\n\t\t\t}\n\n\t\t\tif (!node.hasOwnProperty(\"value\"))\n\t\t\t\treturn void(0);\n\n\t\t\treturn node.value;\n\t\t};\n\n\t\tvar _set = function(node, keyIndex, keyCount, keys, value)\n\t\t{\n\t\t\tif (keyIndex < keyCount)\n\t\t\t{\n\t\t\t\tvar entries = node._entries;\n\t\t\t\tvar uid = UID.get(keys[keyIndex]);\n\t\t\t\tif (!entries.hasOwnProperty(uid))\n\t\t\t\t\tentries[uid] = { _entries: {}, _size: 0, key: keys[keyIndex] };\n\n\t\t\t\tif (!_set(entries[uid], keyIndex + 1, keyCount, keys, value))\n\t\t\t\t\treturn false;\n\n\t\t\t\tnode._size++;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (node.hasOwnProperty(\"value\"))\n\t\t\t{\n\t\t\t\tnode.value = value;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tnode.value = value;\n\t\t\tnode._size++;\n\t\t\treturn true;\n\t\t};\n\n\t\tvar _del = function(node, keyIndex, keyCount, keys)\n\t\t{\n\t\t\tif (keyIndex < keyCount)\n\t\t\t{\n\t\t\t\tvar entries = node._entries;\n\t\t\t\tvar uid = UID.get(keys[keyIndex], false);\n\t\t\t\tif (!uid || !entries.hasOwnProperty(uid))\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (!_del(entries[uid], keyIndex + 1, keyCount, keys))\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (entries[uid]._size === 0)\n\t\t\t\t\tdelete entries[uid];\n\n\t\t\t\tnode._size--;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!node.hasOwnProperty(\"value\"))\n\t\t\t\treturn false;\n\n\t\t\tdelete node.value;\n\t\t\tnode._size--;\n\t\t\treturn true;\n\t\t};\n\n\t\tvar _has = function(node, keyIndex, keyCount, keys)\n\t\t{\n\t\t\tif (keyIndex < keyCount)\n\t\t\t{\n\t\t\t\tvar entries = node._entries;\n\t\t\t\tvar uid = UID.get(keys[keyIndex], false);\n\t\t\t\tif (!uid || !entries.hasOwnProperty(uid))\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn _has(entries[uid], keyIndex + 1, keyCount, keys);\n\t\t\t}\n\n\t\t\treturn node.hasOwnProperty(\"value\");\n\t\t};\n\n\t\tvar _size = function(node, keyIndex, keyCount, prefixKeys)\n\t\t{\n\t\t\tif (keyIndex < keyCount)\n\t\t\t{\n\t\t\t\tvar entries = node._entries;\n\t\t\t\tvar uid = UID.get(prefixKeys[keyIndex], false);\n\t\t\t\tif (!uid || !entries.hasOwnProperty(uid))\n\t\t\t\t\treturn 0;\n\n\t\t\t\treturn _size(entries[uid], keyIndex + 1, keyCount, prefixKeys);\n\t\t\t}\n\n\t\t\treturn node._size;\n\t\t};\n\n\t\tvar _clear = function(node, keyIndex, keyCount, prefixKeys)\n\t\t{\n\t\t\tvar clearCount;\n\n\t\t\tif (keyIndex < keyCount)\n\t\t\t{\n\t\t\t\tvar entries = node._entries;\n\t\t\t\tvar uid = UID.get(prefixKeys[keyIndex], false);\n\t\t\t\tif (!uid || !entries.hasOwnProperty(uid))\n\t\t\t\t\treturn 0;\n\n\t\t\t\tclearCount = _clear(entries[uid], keyIndex + 1, keyCount, prefixKeys);\n\t\t\t\tif (clearCount === 0)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tif (entries[uid]._size === 0)\n\t\t\t\t\tdelete entries[uid];\n\n\t\t\t\tnode._size -= clearCount;\n\t\t\t\treturn clearCount;\n\t\t\t}\n\n\t\t\tclearCount = node._size;\n\t\t\tif (clearCount === 0)\n\t\t\t\treturn 0;\n\n\t\t\tdelete node.value;\n\t\t\tnode._entries = {};\n\t\t\tnode._size = 0;\n\t\t\treturn clearCount;\n\t\t};\n\n\t\tvar _keys = function(node, keyIndex, keyCount, prefixKeys, outKeys, pathKeys)\n\t\t{\n\t\t\tif (!pathKeys)\n\t\t\t\tpathKeys = [];\n\n\t\t\tvar entries = node._entries;\n\t\t\tvar uid;\n\n\t\t\tif (keyIndex < keyCount)\n\t\t\t{\n\t\t\t\tuid = UID.get(prefixKeys[keyIndex], false);\n\t\t\t\tif (!uid || !entries.hasOwnProperty(uid))\n\t\t\t\t\treturn;\n\n\t\t\t\tpathKeys.push(entries[uid].key);\n\t\t\t\t_keys(entries[uid], keyIndex + 1, keyCount, prefixKeys, outKeys, pathKeys);\n\t\t\t\tpathKeys.pop();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (node.hasOwnProperty(\"value\"))\n\t\t\t\toutKeys.push(pathKeys.concat());\n\n\t\t\tfor (uid in entries)\n\t\t\t{\n\t\t\t\tif (entries.hasOwnProperty(uid))\n\t\t\t\t{\n\t\t\t\t\tpathKeys.push(entries[uid].key);\n\t\t\t\t\t_keys(entries[uid], keyIndex, keyCount, prefixKeys, outKeys, pathKeys);\n\t\t\t\t\tpathKeys.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tvar _values = function(node, keyIndex, keyCount, prefixKeys, outValues)\n\t\t{\n\t\t\tvar entries = node._entries;\n\t\t\tvar uid;\n\n\t\t\tif (keyIndex < keyCount)\n\t\t\t{\n\t\t\t\tuid = UID.get(prefixKeys[keyIndex], false);\n\t\t\t\tif (!uid || !entries.hasOwnProperty(uid))\n\t\t\t\t\treturn;\n\n\t\t\t\t_values(entries[uid], keyIndex + 1, keyCount, prefixKeys, outValues);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (node.hasOwnProperty(\"value\"))\n\t\t\t\toutValues.push(node.value);\n\n\t\t\tfor (uid in entries)\n\t\t\t{\n\t\t\t\tif (entries.hasOwnProperty(uid))\n\t\t\t\t\t_values(entries[uid], keyIndex, keyCount, prefixKeys, outValues);\n\t\t\t}\n\t\t};\n\n\t\tvar _pairs = function(node, keyIndex, keyCount, prefixKeys, outPairs, pathKeys)\n\t\t{\n\t\t\tif (!pathKeys)\n\t\t\t\tpathKeys = [];\n\n\t\t\tvar entries = node._entries;\n\t\t\tvar uid;\n\n\t\t\tif (keyIndex < keyCount)\n\t\t\t{\n\t\t\t\tuid = UID.get(prefixKeys[keyIndex], false);\n\t\t\t\tif (!uid || !entries.hasOwnProperty(uid))\n\t\t\t\t\treturn;\n\n\t\t\t\tpathKeys.push(entries[uid].key);\n\t\t\t\t_pairs(entries[uid], keyIndex + 1, keyCount, prefixKeys, outPairs, pathKeys);\n\t\t\t\tpathKeys.pop();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (node.hasOwnProperty(\"value\"))\n\t\t\t\toutPairs.push([ pathKeys.concat(), node.value ]);\n\n\t\t\tfor (uid in entries)\n\t\t\t{\n\t\t\t\tif (entries.hasOwnProperty(uid))\n\t\t\t\t{\n\t\t\t\t\tpathKeys.push(entries[uid].key);\n\t\t\t\t\t_pairs(entries[uid], keyIndex, keyCount, prefixKeys, outPairs, pathKeys);\n\t\t\t\t\tpathKeys.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Private Properties\n\n\t\tthis._entries = null;\n\t\tthis._size = 0;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(entries)\n\t\t{\n\t\t\tthis._entries = {};\n\n\t\t\tif (entries != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0, l = entries.length; i < l; i++)\n\t\t\t\t\tthis.set(entries[i][0], entries[i][1]);\n\t\t\t}\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.get = function(keys)\n\t\t{\n\t\t\tif (keys == null)\n\t\t\t\tthrow new Error(\"Parameter keys must be non-null.\");\n\t\t\tif (!Class.isArray(keys))\n\t\t\t\tthrow new Error(\"Parameter keys must be of type Array.\");\n\n\t\t\tvar keyCount = keys.length;\n\t\t\tif (keyCount === 0)\n\t\t\t\tthrow new Error(\"Parameter keys must be non-empty.\");\n\n\t\t\treturn _get(this, 0, keyCount, keys);\n\t\t};\n\n\t\tthis.set = function(keys, value)\n\t\t{\n\t\t\tif (keys == null)\n\t\t\t\tthrow new Error(\"Parameter keys must be non-null.\");\n\t\t\tif (!Class.isArray(keys))\n\t\t\t\tthrow new Error(\"Parameter keys must be of type Array.\");\n\n\t\t\tvar keyCount = keys.length;\n\t\t\tif (keyCount === 0)\n\t\t\t\tthrow new Error(\"Parameter keys must be non-empty.\");\n\n\t\t\t_set(this, 0, keyCount, keys, value);\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.del = function(keys)\n\t\t{\n\t\t\tif (keys == null)\n\t\t\t\tthrow new Error(\"Parameter keys must be non-null.\");\n\t\t\tif (!Class.isArray(keys))\n\t\t\t\tthrow new Error(\"Parameter keys must be of type Array.\");\n\n\t\t\tvar keyCount = keys.length;\n\t\t\tif (keyCount === 0)\n\t\t\t\tthrow new Error(\"Parameter keys must be non-empty.\");\n\n\t\t\t_del(this, 0, keyCount, keys);\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.has = function(keys)\n\t\t{\n\t\t\tif (keys == null)\n\t\t\t\tthrow new Error(\"Parameter keys must be non-null.\");\n\t\t\tif (!Class.isArray(keys))\n\t\t\t\tthrow new Error(\"Parameter keys must be of type Array.\");\n\n\t\t\tvar keyCount = keys.length;\n\t\t\tif (keyCount === 0)\n\t\t\t\tthrow new Error(\"Parameter keys must be non-empty.\");\n\n\t\t\treturn _has(this, 0, keyCount, keys);\n\t\t};\n\n\t\tthis.size = function(prefixKeys)\n\t\t{\n\t\t\tif (prefixKeys == null)\n\t\t\t\treturn _size(this, 0, 0, null);\n\t\t\telse if (Class.isArray(prefixKeys))\n\t\t\t\treturn _size(this, 0, prefixKeys.length, prefixKeys);\n\t\t\telse\n\t\t\t\tthrow new Error(\"Parameter prefixKeys must be of type Array.\");\n\t\t};\n\n\t\tthis.clear = function(prefixKeys)\n\t\t{\n\t\t\tif (prefixKeys == null)\n\t\t\t\t_clear(this, 0, 0, null);\n\t\t\telse if (Class.isArray(prefixKeys))\n\t\t\t\t_clear(this, 0, prefixKeys.length, prefixKeys);\n\t\t\telse\n\t\t\t\tthrow new Error(\"Parameter prefixKeys must be of type Array.\");\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.keys = function(prefixKeys)\n\t\t{\n\t\t\tvar keys = [];\n\n\t\t\tif (prefixKeys == null)\n\t\t\t\t_keys(this, 0, 0, null, keys);\n\t\t\telse if (Class.isArray(prefixKeys))\n\t\t\t\t_keys(this, 0, prefixKeys.length, prefixKeys, keys);\n\t\t\telse\n\t\t\t\tthrow new Error(\"Parameter prefixKeys must be of type Array.\");\n\n\t\t\treturn keys;\n\t\t};\n\n\t\tthis.values = function(prefixKeys)\n\t\t{\n\t\t\tvar values = [];\n\n\t\t\tif (prefixKeys == null)\n\t\t\t\t_values(this, 0, 0, null, values);\n\t\t\telse if (Class.isArray(prefixKeys))\n\t\t\t\t_values(this, 0, prefixKeys.length, prefixKeys, values);\n\t\t\telse\n\t\t\t\tthrow new Error(\"Parameter prefixKeys must be of type Array.\");\n\n\t\t\treturn values;\n\t\t};\n\n\t\tthis.pairs = function(prefixKeys)\n\t\t{\n\t\t\tvar pairs = [];\n\n\t\t\tif (prefixKeys == null)\n\t\t\t\t_pairs(this, 0, 0, null, pairs);\n\t\t\telse if (Class.isArray(prefixKeys))\n\t\t\t\t_pairs(this, 0, prefixKeys.length, prefixKeys, pairs);\n\t\t\telse\n\t\t\t\tthrow new Error(\"Parameter prefixKeys must be of type Array.\");\n\n\t\t\treturn pairs;\n\t\t};\n\n\t\tthis.entries = function(prefixKeys)\n\t\t{\n\t\t\treturn this.pairs(prefixKeys);\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL1RyaWVNYXAuanM/MzRmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUYsQ0FBQyIsImZpbGUiOiJjb250cmliL2pnX2xpYi91dGlscy9UcmllTWFwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNiBKYXNvbiBHYXR0XG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSlcbntcblxuXHR2YXIgVUlEID0gcmVxdWlyZShcIi4vVUlEXCIpO1xuXHR2YXIgQ2xhc3MgPSByZXF1aXJlKFwiLi4vQ2xhc3NcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgT2JqZWN0LCBmdW5jdGlvbihUcmllTWFwLCBiYXNlKVxuXHR7XG5cblx0XHQvLyBQcml2YXRlIFN0YXRpYyBNZXRob2RzXG5cblx0XHR2YXIgX2dldCA9IGZ1bmN0aW9uKG5vZGUsIGtleUluZGV4LCBrZXlDb3VudCwga2V5cylcblx0XHR7XG5cdFx0XHRpZiAoa2V5SW5kZXggPCBrZXlDb3VudClcblx0XHRcdHtcblx0XHRcdFx0dmFyIGVudHJpZXMgPSBub2RlLl9lbnRyaWVzO1xuXHRcdFx0XHR2YXIgdWlkID0gVUlELmdldChrZXlzW2tleUluZGV4XSwgZmFsc2UpO1xuXHRcdFx0XHRpZiAoIXVpZCB8fCAhZW50cmllcy5oYXNPd25Qcm9wZXJ0eSh1aWQpKVxuXHRcdFx0XHRcdHJldHVybiB2b2lkKDApO1xuXG5cdFx0XHRcdHJldHVybiBfZ2V0KGVudHJpZXNbdWlkXSwga2V5SW5kZXggKyAxLCBrZXlDb3VudCwga2V5cyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghbm9kZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuXHRcdFx0XHRyZXR1cm4gdm9pZCgwKTtcblxuXHRcdFx0cmV0dXJuIG5vZGUudmFsdWU7XG5cdFx0fTtcblxuXHRcdHZhciBfc2V0ID0gZnVuY3Rpb24obm9kZSwga2V5SW5kZXgsIGtleUNvdW50LCBrZXlzLCB2YWx1ZSlcblx0XHR7XG5cdFx0XHRpZiAoa2V5SW5kZXggPCBrZXlDb3VudClcblx0XHRcdHtcblx0XHRcdFx0dmFyIGVudHJpZXMgPSBub2RlLl9lbnRyaWVzO1xuXHRcdFx0XHR2YXIgdWlkID0gVUlELmdldChrZXlzW2tleUluZGV4XSk7XG5cdFx0XHRcdGlmICghZW50cmllcy5oYXNPd25Qcm9wZXJ0eSh1aWQpKVxuXHRcdFx0XHRcdGVudHJpZXNbdWlkXSA9IHsgX2VudHJpZXM6IHt9LCBfc2l6ZTogMCwga2V5OiBrZXlzW2tleUluZGV4XSB9O1xuXG5cdFx0XHRcdGlmICghX3NldChlbnRyaWVzW3VpZF0sIGtleUluZGV4ICsgMSwga2V5Q291bnQsIGtleXMsIHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0bm9kZS5fc2l6ZSsrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5vZGUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcblx0XHRcdHtcblx0XHRcdFx0bm9kZS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdG5vZGUudmFsdWUgPSB2YWx1ZTtcblx0XHRcdG5vZGUuX3NpemUrKztcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHR2YXIgX2RlbCA9IGZ1bmN0aW9uKG5vZGUsIGtleUluZGV4LCBrZXlDb3VudCwga2V5cylcblx0XHR7XG5cdFx0XHRpZiAoa2V5SW5kZXggPCBrZXlDb3VudClcblx0XHRcdHtcblx0XHRcdFx0dmFyIGVudHJpZXMgPSBub2RlLl9lbnRyaWVzO1xuXHRcdFx0XHR2YXIgdWlkID0gVUlELmdldChrZXlzW2tleUluZGV4XSwgZmFsc2UpO1xuXHRcdFx0XHRpZiAoIXVpZCB8fCAhZW50cmllcy5oYXNPd25Qcm9wZXJ0eSh1aWQpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRpZiAoIV9kZWwoZW50cmllc1t1aWRdLCBrZXlJbmRleCArIDEsIGtleUNvdW50LCBrZXlzKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0aWYgKGVudHJpZXNbdWlkXS5fc2l6ZSA9PT0gMClcblx0XHRcdFx0XHRkZWxldGUgZW50cmllc1t1aWRdO1xuXG5cdFx0XHRcdG5vZGUuX3NpemUtLTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghbm9kZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdGRlbGV0ZSBub2RlLnZhbHVlO1xuXHRcdFx0bm9kZS5fc2l6ZS0tO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdHZhciBfaGFzID0gZnVuY3Rpb24obm9kZSwga2V5SW5kZXgsIGtleUNvdW50LCBrZXlzKVxuXHRcdHtcblx0XHRcdGlmIChrZXlJbmRleCA8IGtleUNvdW50KVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZW50cmllcyA9IG5vZGUuX2VudHJpZXM7XG5cdFx0XHRcdHZhciB1aWQgPSBVSUQuZ2V0KGtleXNba2V5SW5kZXhdLCBmYWxzZSk7XG5cdFx0XHRcdGlmICghdWlkIHx8ICFlbnRyaWVzLmhhc093blByb3BlcnR5KHVpZCkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdHJldHVybiBfaGFzKGVudHJpZXNbdWlkXSwga2V5SW5kZXggKyAxLCBrZXlDb3VudCwga2V5cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBub2RlLmhhc093blByb3BlcnR5KFwidmFsdWVcIik7XG5cdFx0fTtcblxuXHRcdHZhciBfc2l6ZSA9IGZ1bmN0aW9uKG5vZGUsIGtleUluZGV4LCBrZXlDb3VudCwgcHJlZml4S2V5cylcblx0XHR7XG5cdFx0XHRpZiAoa2V5SW5kZXggPCBrZXlDb3VudClcblx0XHRcdHtcblx0XHRcdFx0dmFyIGVudHJpZXMgPSBub2RlLl9lbnRyaWVzO1xuXHRcdFx0XHR2YXIgdWlkID0gVUlELmdldChwcmVmaXhLZXlzW2tleUluZGV4XSwgZmFsc2UpO1xuXHRcdFx0XHRpZiAoIXVpZCB8fCAhZW50cmllcy5oYXNPd25Qcm9wZXJ0eSh1aWQpKVxuXHRcdFx0XHRcdHJldHVybiAwO1xuXG5cdFx0XHRcdHJldHVybiBfc2l6ZShlbnRyaWVzW3VpZF0sIGtleUluZGV4ICsgMSwga2V5Q291bnQsIHByZWZpeEtleXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbm9kZS5fc2l6ZTtcblx0XHR9O1xuXG5cdFx0dmFyIF9jbGVhciA9IGZ1bmN0aW9uKG5vZGUsIGtleUluZGV4LCBrZXlDb3VudCwgcHJlZml4S2V5cylcblx0XHR7XG5cdFx0XHR2YXIgY2xlYXJDb3VudDtcblxuXHRcdFx0aWYgKGtleUluZGV4IDwga2V5Q291bnQpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBlbnRyaWVzID0gbm9kZS5fZW50cmllcztcblx0XHRcdFx0dmFyIHVpZCA9IFVJRC5nZXQocHJlZml4S2V5c1trZXlJbmRleF0sIGZhbHNlKTtcblx0XHRcdFx0aWYgKCF1aWQgfHwgIWVudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0XHRjbGVhckNvdW50ID0gX2NsZWFyKGVudHJpZXNbdWlkXSwga2V5SW5kZXggKyAxLCBrZXlDb3VudCwgcHJlZml4S2V5cyk7XG5cdFx0XHRcdGlmIChjbGVhckNvdW50ID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiAwO1xuXG5cdFx0XHRcdGlmIChlbnRyaWVzW3VpZF0uX3NpemUgPT09IDApXG5cdFx0XHRcdFx0ZGVsZXRlIGVudHJpZXNbdWlkXTtcblxuXHRcdFx0XHRub2RlLl9zaXplIC09IGNsZWFyQ291bnQ7XG5cdFx0XHRcdHJldHVybiBjbGVhckNvdW50O1xuXHRcdFx0fVxuXG5cdFx0XHRjbGVhckNvdW50ID0gbm9kZS5fc2l6ZTtcblx0XHRcdGlmIChjbGVhckNvdW50ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0ZGVsZXRlIG5vZGUudmFsdWU7XG5cdFx0XHRub2RlLl9lbnRyaWVzID0ge307XG5cdFx0XHRub2RlLl9zaXplID0gMDtcblx0XHRcdHJldHVybiBjbGVhckNvdW50O1xuXHRcdH07XG5cblx0XHR2YXIgX2tleXMgPSBmdW5jdGlvbihub2RlLCBrZXlJbmRleCwga2V5Q291bnQsIHByZWZpeEtleXMsIG91dEtleXMsIHBhdGhLZXlzKVxuXHRcdHtcblx0XHRcdGlmICghcGF0aEtleXMpXG5cdFx0XHRcdHBhdGhLZXlzID0gW107XG5cblx0XHRcdHZhciBlbnRyaWVzID0gbm9kZS5fZW50cmllcztcblx0XHRcdHZhciB1aWQ7XG5cblx0XHRcdGlmIChrZXlJbmRleCA8IGtleUNvdW50KVxuXHRcdFx0e1xuXHRcdFx0XHR1aWQgPSBVSUQuZ2V0KHByZWZpeEtleXNba2V5SW5kZXhdLCBmYWxzZSk7XG5cdFx0XHRcdGlmICghdWlkIHx8ICFlbnRyaWVzLmhhc093blByb3BlcnR5KHVpZCkpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdHBhdGhLZXlzLnB1c2goZW50cmllc1t1aWRdLmtleSk7XG5cdFx0XHRcdF9rZXlzKGVudHJpZXNbdWlkXSwga2V5SW5kZXggKyAxLCBrZXlDb3VudCwgcHJlZml4S2V5cywgb3V0S2V5cywgcGF0aEtleXMpO1xuXHRcdFx0XHRwYXRoS2V5cy5wb3AoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuXHRcdFx0XHRvdXRLZXlzLnB1c2gocGF0aEtleXMuY29uY2F0KCkpO1xuXG5cdFx0XHRmb3IgKHVpZCBpbiBlbnRyaWVzKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZW50cmllcy5oYXNPd25Qcm9wZXJ0eSh1aWQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGF0aEtleXMucHVzaChlbnRyaWVzW3VpZF0ua2V5KTtcblx0XHRcdFx0XHRfa2V5cyhlbnRyaWVzW3VpZF0sIGtleUluZGV4LCBrZXlDb3VudCwgcHJlZml4S2V5cywgb3V0S2V5cywgcGF0aEtleXMpO1xuXHRcdFx0XHRcdHBhdGhLZXlzLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBfdmFsdWVzID0gZnVuY3Rpb24obm9kZSwga2V5SW5kZXgsIGtleUNvdW50LCBwcmVmaXhLZXlzLCBvdXRWYWx1ZXMpXG5cdFx0e1xuXHRcdFx0dmFyIGVudHJpZXMgPSBub2RlLl9lbnRyaWVzO1xuXHRcdFx0dmFyIHVpZDtcblxuXHRcdFx0aWYgKGtleUluZGV4IDwga2V5Q291bnQpXG5cdFx0XHR7XG5cdFx0XHRcdHVpZCA9IFVJRC5nZXQocHJlZml4S2V5c1trZXlJbmRleF0sIGZhbHNlKTtcblx0XHRcdFx0aWYgKCF1aWQgfHwgIWVudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0X3ZhbHVlcyhlbnRyaWVzW3VpZF0sIGtleUluZGV4ICsgMSwga2V5Q291bnQsIHByZWZpeEtleXMsIG91dFZhbHVlcyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5vZGUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcblx0XHRcdFx0b3V0VmFsdWVzLnB1c2gobm9kZS52YWx1ZSk7XG5cblx0XHRcdGZvciAodWlkIGluIGVudHJpZXMpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChlbnRyaWVzLmhhc093blByb3BlcnR5KHVpZCkpXG5cdFx0XHRcdFx0X3ZhbHVlcyhlbnRyaWVzW3VpZF0sIGtleUluZGV4LCBrZXlDb3VudCwgcHJlZml4S2V5cywgb3V0VmFsdWVzKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIF9wYWlycyA9IGZ1bmN0aW9uKG5vZGUsIGtleUluZGV4LCBrZXlDb3VudCwgcHJlZml4S2V5cywgb3V0UGFpcnMsIHBhdGhLZXlzKVxuXHRcdHtcblx0XHRcdGlmICghcGF0aEtleXMpXG5cdFx0XHRcdHBhdGhLZXlzID0gW107XG5cblx0XHRcdHZhciBlbnRyaWVzID0gbm9kZS5fZW50cmllcztcblx0XHRcdHZhciB1aWQ7XG5cblx0XHRcdGlmIChrZXlJbmRleCA8IGtleUNvdW50KVxuXHRcdFx0e1xuXHRcdFx0XHR1aWQgPSBVSUQuZ2V0KHByZWZpeEtleXNba2V5SW5kZXhdLCBmYWxzZSk7XG5cdFx0XHRcdGlmICghdWlkIHx8ICFlbnRyaWVzLmhhc093blByb3BlcnR5KHVpZCkpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdHBhdGhLZXlzLnB1c2goZW50cmllc1t1aWRdLmtleSk7XG5cdFx0XHRcdF9wYWlycyhlbnRyaWVzW3VpZF0sIGtleUluZGV4ICsgMSwga2V5Q291bnQsIHByZWZpeEtleXMsIG91dFBhaXJzLCBwYXRoS2V5cyk7XG5cdFx0XHRcdHBhdGhLZXlzLnBvcCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChub2RlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG5cdFx0XHRcdG91dFBhaXJzLnB1c2goWyBwYXRoS2V5cy5jb25jYXQoKSwgbm9kZS52YWx1ZSBdKTtcblxuXHRcdFx0Zm9yICh1aWQgaW4gZW50cmllcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGVudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBhdGhLZXlzLnB1c2goZW50cmllc1t1aWRdLmtleSk7XG5cdFx0XHRcdFx0X3BhaXJzKGVudHJpZXNbdWlkXSwga2V5SW5kZXgsIGtleUNvdW50LCBwcmVmaXhLZXlzLCBvdXRQYWlycywgcGF0aEtleXMpO1xuXHRcdFx0XHRcdHBhdGhLZXlzLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFByaXZhdGUgUHJvcGVydGllc1xuXG5cdFx0dGhpcy5fZW50cmllcyA9IG51bGw7XG5cdFx0dGhpcy5fc2l6ZSA9IDA7XG5cblx0XHQvLyBDb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGVudHJpZXMpXG5cdFx0e1xuXHRcdFx0dGhpcy5fZW50cmllcyA9IHt9O1xuXG5cdFx0XHRpZiAoZW50cmllcyAhPSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGVudHJpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHRoaXMuc2V0KGVudHJpZXNbaV1bMF0sIGVudHJpZXNbaV1bMV0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBQdWJsaWMgTWV0aG9kc1xuXG5cdFx0dGhpcy5nZXQgPSBmdW5jdGlvbihrZXlzKVxuXHRcdHtcblx0XHRcdGlmIChrZXlzID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBrZXlzIG11c3QgYmUgbm9uLW51bGwuXCIpO1xuXHRcdFx0aWYgKCFDbGFzcy5pc0FycmF5KGtleXMpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIga2V5cyBtdXN0IGJlIG9mIHR5cGUgQXJyYXkuXCIpO1xuXG5cdFx0XHR2YXIga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcblx0XHRcdGlmIChrZXlDb3VudCA9PT0gMClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGtleXMgbXVzdCBiZSBub24tZW1wdHkuXCIpO1xuXG5cdFx0XHRyZXR1cm4gX2dldCh0aGlzLCAwLCBrZXlDb3VudCwga2V5cyk7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0ID0gZnVuY3Rpb24oa2V5cywgdmFsdWUpXG5cdFx0e1xuXHRcdFx0aWYgKGtleXMgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGtleXMgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cdFx0XHRpZiAoIUNsYXNzLmlzQXJyYXkoa2V5cykpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBrZXlzIG11c3QgYmUgb2YgdHlwZSBBcnJheS5cIik7XG5cblx0XHRcdHZhciBrZXlDb3VudCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0aWYgKGtleUNvdW50ID09PSAwKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIga2V5cyBtdXN0IGJlIG5vbi1lbXB0eS5cIik7XG5cblx0XHRcdF9zZXQodGhpcywgMCwga2V5Q291bnQsIGtleXMsIHZhbHVlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHR0aGlzLmRlbCA9IGZ1bmN0aW9uKGtleXMpXG5cdFx0e1xuXHRcdFx0aWYgKGtleXMgPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGtleXMgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cdFx0XHRpZiAoIUNsYXNzLmlzQXJyYXkoa2V5cykpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBrZXlzIG11c3QgYmUgb2YgdHlwZSBBcnJheS5cIik7XG5cblx0XHRcdHZhciBrZXlDb3VudCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0aWYgKGtleUNvdW50ID09PSAwKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIga2V5cyBtdXN0IGJlIG5vbi1lbXB0eS5cIik7XG5cblx0XHRcdF9kZWwodGhpcywgMCwga2V5Q291bnQsIGtleXMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHRoaXMuaGFzID0gZnVuY3Rpb24oa2V5cylcblx0XHR7XG5cdFx0XHRpZiAoa2V5cyA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIga2V5cyBtdXN0IGJlIG5vbi1udWxsLlwiKTtcblx0XHRcdGlmICghQ2xhc3MuaXNBcnJheShrZXlzKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGtleXMgbXVzdCBiZSBvZiB0eXBlIEFycmF5LlwiKTtcblxuXHRcdFx0dmFyIGtleUNvdW50ID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRpZiAoa2V5Q291bnQgPT09IDApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBrZXlzIG11c3QgYmUgbm9uLWVtcHR5LlwiKTtcblxuXHRcdFx0cmV0dXJuIF9oYXModGhpcywgMCwga2V5Q291bnQsIGtleXMpO1xuXHRcdH07XG5cblx0XHR0aGlzLnNpemUgPSBmdW5jdGlvbihwcmVmaXhLZXlzKVxuXHRcdHtcblx0XHRcdGlmIChwcmVmaXhLZXlzID09IG51bGwpXG5cdFx0XHRcdHJldHVybiBfc2l6ZSh0aGlzLCAwLCAwLCBudWxsKTtcblx0XHRcdGVsc2UgaWYgKENsYXNzLmlzQXJyYXkocHJlZml4S2V5cykpXG5cdFx0XHRcdHJldHVybiBfc2l6ZSh0aGlzLCAwLCBwcmVmaXhLZXlzLmxlbmd0aCwgcHJlZml4S2V5cyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBwcmVmaXhLZXlzIG11c3QgYmUgb2YgdHlwZSBBcnJheS5cIik7XG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbihwcmVmaXhLZXlzKVxuXHRcdHtcblx0XHRcdGlmIChwcmVmaXhLZXlzID09IG51bGwpXG5cdFx0XHRcdF9jbGVhcih0aGlzLCAwLCAwLCBudWxsKTtcblx0XHRcdGVsc2UgaWYgKENsYXNzLmlzQXJyYXkocHJlZml4S2V5cykpXG5cdFx0XHRcdF9jbGVhcih0aGlzLCAwLCBwcmVmaXhLZXlzLmxlbmd0aCwgcHJlZml4S2V5cyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBwcmVmaXhLZXlzIG11c3QgYmUgb2YgdHlwZSBBcnJheS5cIik7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHR0aGlzLmtleXMgPSBmdW5jdGlvbihwcmVmaXhLZXlzKVxuXHRcdHtcblx0XHRcdHZhciBrZXlzID0gW107XG5cblx0XHRcdGlmIChwcmVmaXhLZXlzID09IG51bGwpXG5cdFx0XHRcdF9rZXlzKHRoaXMsIDAsIDAsIG51bGwsIGtleXMpO1xuXHRcdFx0ZWxzZSBpZiAoQ2xhc3MuaXNBcnJheShwcmVmaXhLZXlzKSlcblx0XHRcdFx0X2tleXModGhpcywgMCwgcHJlZml4S2V5cy5sZW5ndGgsIHByZWZpeEtleXMsIGtleXMpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgcHJlZml4S2V5cyBtdXN0IGJlIG9mIHR5cGUgQXJyYXkuXCIpO1xuXG5cdFx0XHRyZXR1cm4ga2V5cztcblx0XHR9O1xuXG5cdFx0dGhpcy52YWx1ZXMgPSBmdW5jdGlvbihwcmVmaXhLZXlzKVxuXHRcdHtcblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0aWYgKHByZWZpeEtleXMgPT0gbnVsbClcblx0XHRcdFx0X3ZhbHVlcyh0aGlzLCAwLCAwLCBudWxsLCB2YWx1ZXMpO1xuXHRcdFx0ZWxzZSBpZiAoQ2xhc3MuaXNBcnJheShwcmVmaXhLZXlzKSlcblx0XHRcdFx0X3ZhbHVlcyh0aGlzLCAwLCBwcmVmaXhLZXlzLmxlbmd0aCwgcHJlZml4S2V5cywgdmFsdWVzKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIHByZWZpeEtleXMgbXVzdCBiZSBvZiB0eXBlIEFycmF5LlwiKTtcblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHR9O1xuXG5cdFx0dGhpcy5wYWlycyA9IGZ1bmN0aW9uKHByZWZpeEtleXMpXG5cdFx0e1xuXHRcdFx0dmFyIHBhaXJzID0gW107XG5cblx0XHRcdGlmIChwcmVmaXhLZXlzID09IG51bGwpXG5cdFx0XHRcdF9wYWlycyh0aGlzLCAwLCAwLCBudWxsLCBwYWlycyk7XG5cdFx0XHRlbHNlIGlmIChDbGFzcy5pc0FycmF5KHByZWZpeEtleXMpKVxuXHRcdFx0XHRfcGFpcnModGhpcywgMCwgcHJlZml4S2V5cy5sZW5ndGgsIHByZWZpeEtleXMsIHBhaXJzKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIHByZWZpeEtleXMgbXVzdCBiZSBvZiB0eXBlIEFycmF5LlwiKTtcblxuXHRcdFx0cmV0dXJuIHBhaXJzO1xuXHRcdH07XG5cblx0XHR0aGlzLmVudHJpZXMgPSBmdW5jdGlvbihwcmVmaXhLZXlzKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnBhaXJzKHByZWZpeEtleXMpO1xuXHRcdH07XG5cblx0fSk7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL1RyaWVNYXAuanNcbi8vIG1vZHVsZSBpZCA9IGNvbnRyaWIvamdfbGliL3V0aWxzL1RyaWVNYXBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/utils/WeakMap":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar UID = __webpack_require__(\"contrib/jg_lib/utils/UID\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, Object, function(WeakMap, base)\n\t{\n\n\t\t// Private Static Constants\n\n\t\tvar _WEAK_MAP_KEY = \"__weakMap_\" + UID.random() + \"__\";\n\n\t\t// Private Static Properties\n\n\t\tvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\t\t// Private Properties\n\n\t\tthis._uid = null;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(entries)\n\t\t{\n\t\t\tthis._uid = UID.get(this);\n\n\t\t\tif (entries != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0, l = entries.length; i < l; i++)\n\t\t\t\t\tthis.set(entries[i][0], entries[i][1]);\n\t\t\t}\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.get = function(key)\n\t\t{\n\t\t\tif ((key == null) || !_hasOwnProperty.call(key, _WEAK_MAP_KEY))\n\t\t\t\treturn void(0);\n\n\t\t\tvar weakMap = key[_WEAK_MAP_KEY];\n\t\t\tif (!weakMap._entries.hasOwnProperty(this._uid))\n\t\t\t\treturn void(0);\n\n\t\t\treturn weakMap._entries[this._uid];\n\t\t};\n\n\t\tthis.set = function(key, value)\n\t\t{\n\t\t\tif (key == null)\n\t\t\t\tthrow new Error(\"Parameter key must be non-null.\");\n\n\t\t\tvar weakMap;\n\t\t\tif (_hasOwnProperty.call(key, _WEAK_MAP_KEY))\n\t\t\t{\n\t\t\t\tweakMap = key[_WEAK_MAP_KEY];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!Class.isObject(key))\n\t\t\t\t\tthrow new Error(\"Parameter key must be of type Object.\");\n\n\t\t\t\tweakMap = key[_WEAK_MAP_KEY] = { _entries: {}, _size: 0 };\n\t\t\t}\n\n\t\t\tif (weakMap._entries.hasOwnProperty(this._uid))\n\t\t\t{\n\t\t\t\tweakMap._entries[this._uid] = value;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tweakMap._entries[this._uid] = value;\n\t\t\tweakMap._size++;\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.del = function(key)\n\t\t{\n\t\t\tif ((key == null) || !_hasOwnProperty.call(key, _WEAK_MAP_KEY))\n\t\t\t\treturn this;\n\n\t\t\tvar weakMap = key[_WEAK_MAP_KEY];\n\t\t\tif (!weakMap._entries.hasOwnProperty(this._uid))\n\t\t\t\treturn this;\n\n\t\t\tdelete weakMap._entries[this._uid];\n\t\t\tweakMap._size--;\n\t\t\tif (weakMap._size === 0)\n\t\t\t\tdelete key[_WEAK_MAP_KEY];\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.has = function(key)\n\t\t{\n\t\t\tif ((key == null) || !_hasOwnProperty.call(key, _WEAK_MAP_KEY))\n\t\t\t\treturn false;\n\n\t\t\tvar weakMap = key[_WEAK_MAP_KEY];\n\t\t\tif (!weakMap._entries.hasOwnProperty(this._uid))\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL1dlYWtNYXAuanM/M2NhYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLGFBQWE7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvdXRpbHMvV2Vha01hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIFVJRCA9IHJlcXVpcmUoXCIuL1VJRFwiKTtcblx0dmFyIENsYXNzID0gcmVxdWlyZShcIi4uL0NsYXNzXCIpO1xuXG5cdHJldHVybiBDbGFzcyhtb2R1bGUuaWQsIE9iamVjdCwgZnVuY3Rpb24oV2Vha01hcCwgYmFzZSlcblx0e1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgQ29uc3RhbnRzXG5cblx0XHR2YXIgX1dFQUtfTUFQX0tFWSA9IFwiX193ZWFrTWFwX1wiICsgVUlELnJhbmRvbSgpICsgXCJfX1wiO1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgUHJvcGVydGllc1xuXG5cdFx0dmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0XHQvLyBQcml2YXRlIFByb3BlcnRpZXNcblxuXHRcdHRoaXMuX3VpZCA9IG51bGw7XG5cblx0XHQvLyBDb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGVudHJpZXMpXG5cdFx0e1xuXHRcdFx0dGhpcy5fdWlkID0gVUlELmdldCh0aGlzKTtcblxuXHRcdFx0aWYgKGVudHJpZXMgIT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHR0aGlzLnNldChlbnRyaWVzW2ldWzBdLCBlbnRyaWVzW2ldWzFdKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gUHVibGljIE1ldGhvZHNcblxuXHRcdHRoaXMuZ2V0ID0gZnVuY3Rpb24oa2V5KVxuXHRcdHtcblx0XHRcdGlmICgoa2V5ID09IG51bGwpIHx8ICFfaGFzT3duUHJvcGVydHkuY2FsbChrZXksIF9XRUFLX01BUF9LRVkpKVxuXHRcdFx0XHRyZXR1cm4gdm9pZCgwKTtcblxuXHRcdFx0dmFyIHdlYWtNYXAgPSBrZXlbX1dFQUtfTUFQX0tFWV07XG5cdFx0XHRpZiAoIXdlYWtNYXAuX2VudHJpZXMuaGFzT3duUHJvcGVydHkodGhpcy5fdWlkKSlcblx0XHRcdFx0cmV0dXJuIHZvaWQoMCk7XG5cblx0XHRcdHJldHVybiB3ZWFrTWFwLl9lbnRyaWVzW3RoaXMuX3VpZF07XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSlcblx0XHR7XG5cdFx0XHRpZiAoa2V5ID09IG51bGwpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBrZXkgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cblx0XHRcdHZhciB3ZWFrTWFwO1xuXHRcdFx0aWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKGtleSwgX1dFQUtfTUFQX0tFWSkpXG5cdFx0XHR7XG5cdFx0XHRcdHdlYWtNYXAgPSBrZXlbX1dFQUtfTUFQX0tFWV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghQ2xhc3MuaXNPYmplY3Qoa2V5KSlcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIga2V5IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuXCIpO1xuXG5cdFx0XHRcdHdlYWtNYXAgPSBrZXlbX1dFQUtfTUFQX0tFWV0gPSB7IF9lbnRyaWVzOiB7fSwgX3NpemU6IDAgfTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHdlYWtNYXAuX2VudHJpZXMuaGFzT3duUHJvcGVydHkodGhpcy5fdWlkKSlcblx0XHRcdHtcblx0XHRcdFx0d2Vha01hcC5fZW50cmllc1t0aGlzLl91aWRdID0gdmFsdWU7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHR3ZWFrTWFwLl9lbnRyaWVzW3RoaXMuX3VpZF0gPSB2YWx1ZTtcblx0XHRcdHdlYWtNYXAuX3NpemUrKztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHR0aGlzLmRlbCA9IGZ1bmN0aW9uKGtleSlcblx0XHR7XG5cdFx0XHRpZiAoKGtleSA9PSBudWxsKSB8fCAhX2hhc093blByb3BlcnR5LmNhbGwoa2V5LCBfV0VBS19NQVBfS0VZKSlcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdHZhciB3ZWFrTWFwID0ga2V5W19XRUFLX01BUF9LRVldO1xuXHRcdFx0aWYgKCF3ZWFrTWFwLl9lbnRyaWVzLmhhc093blByb3BlcnR5KHRoaXMuX3VpZCkpXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRkZWxldGUgd2Vha01hcC5fZW50cmllc1t0aGlzLl91aWRdO1xuXHRcdFx0d2Vha01hcC5fc2l6ZS0tO1xuXHRcdFx0aWYgKHdlYWtNYXAuX3NpemUgPT09IDApXG5cdFx0XHRcdGRlbGV0ZSBrZXlbX1dFQUtfTUFQX0tFWV07XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHR0aGlzLmhhcyA9IGZ1bmN0aW9uKGtleSlcblx0XHR7XG5cdFx0XHRpZiAoKGtleSA9PSBudWxsKSB8fCAhX2hhc093blByb3BlcnR5LmNhbGwoa2V5LCBfV0VBS19NQVBfS0VZKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR2YXIgd2Vha01hcCA9IGtleVtfV0VBS19NQVBfS0VZXTtcblx0XHRcdGlmICghd2Vha01hcC5fZW50cmllcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLl91aWQpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0fSk7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL1dlYWtNYXAuanNcbi8vIG1vZHVsZSBpZCA9IGNvbnRyaWIvamdfbGliL3V0aWxzL1dlYWtNYXBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/events/MEventTarget":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Event = __webpack_require__(\"contrib/jg_lib/events/Event\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, function(MEventTarget)\n\t{\n\n\t\t// Public Properties\n\n\t\tthis.isEventTarget = true;\n\n\t\t// Public Methods\n\n\t\tthis.on = function(event, listener, scope, priority)\n\t\t{\n\t\t\tevent = Event.resolve(this, event);\n\n\t\t\tif (listener == null)\n\t\t\t\tthrow new Error(\"Parameter listener must be non-null.\");\n\t\t\tif (!Class.isFunction(listener))\n\t\t\t\tthrow new Error(\"Parameter listener must be of type Function.\");\n\t\t\tif ((priority != null) && !Class.isNumber(priority))\n\t\t\t\tthrow new Error(\"Parameter priority must be of type Number.\");\n\n\t\t\tif (scope == null)\n\t\t\t\tscope = this;\n\t\t\tif ((priority == null) || isNaN(priority))\n\t\t\t\tpriority = 0;\n\n\t\t\tevent.on(this, listener, scope, priority);\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.off = function(event, listener, scope)\n\t\t{\n\t\t\tif (scope != null)\n\t\t\t{\n\t\t\t\tevent = Event.resolve(this, event);\n\n\t\t\t\tif (listener == null)\n\t\t\t\t\tthrow new Error(\"Parameter listener must be non-null.\");\n\t\t\t\tif (!Class.isFunction(listener))\n\t\t\t\t\tthrow new Error(\"Parameter listener must be of type Function.\");\n\n\t\t\t\tevent.off(this, listener, scope);\n\t\t\t}\n\t\t\telse if (listener != null)\n\t\t\t{\n\t\t\t\tevent = Event.resolve(this, event);\n\n\t\t\t\tif (!Class.isFunction(listener))\n\t\t\t\t\tthrow new Error(\"Parameter listener must be of type Function.\");\n\n\t\t\t\tevent.off(this, listener, this);\n\t\t\t}\n\t\t\telse if (event != null)\n\t\t\t{\n\t\t\t\tevent = Event.resolve(this, event);\n\n\t\t\t\tevent.offAll(this);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tEvent.offAll(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.fire = function(event, eventData)\n\t\t{\n\t\t\tevent = Event.resolve(this, event);\n\n\t\t\tif (eventData == null)\n\t\t\t\teventData = event.createEventData();\n\t\t\telse if (!event.isValidType(eventData))\n\t\t\t\tthrow new Error(\"Data fired on event \\\"\" + event.name() + \"\\\" must be of type \" + event.getTypeName() + \".\");\n\n\t\t\treturn event.fire(this, eventData);\n\t\t};\n\n\t\tthis.hasListeners = function(event)\n\t\t{\n\t\t\tif (event != null)\n\t\t\t{\n\t\t\t\tevent = Event.resolve(this, event);\n\n\t\t\t\treturn event.hasListeners(this);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn Event.hasListeners(this);\n\t\t\t}\n\t\t};\n\n\t\tthis.getBubbleTarget = function()\n\t\t{\n\t\t\treturn null;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2V2ZW50cy9NRXZlbnRUYXJnZXQuanM/Y2U5MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUYsQ0FBQyIsImZpbGUiOiJjb250cmliL2pnX2xpYi9ldmVudHMvTUV2ZW50VGFyZ2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNiBKYXNvbiBHYXR0XG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSlcbntcblxuXHR2YXIgRXZlbnQgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcblx0dmFyIENsYXNzID0gcmVxdWlyZShcIi4uL0NsYXNzXCIpO1xuXG5cdHJldHVybiBDbGFzcyhtb2R1bGUuaWQsIGZ1bmN0aW9uKE1FdmVudFRhcmdldClcblx0e1xuXG5cdFx0Ly8gUHVibGljIFByb3BlcnRpZXNcblxuXHRcdHRoaXMuaXNFdmVudFRhcmdldCA9IHRydWU7XG5cblx0XHQvLyBQdWJsaWMgTWV0aG9kc1xuXG5cdFx0dGhpcy5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lciwgc2NvcGUsIHByaW9yaXR5KVxuXHRcdHtcblx0XHRcdGV2ZW50ID0gRXZlbnQucmVzb2x2ZSh0aGlzLCBldmVudCk7XG5cblx0XHRcdGlmIChsaXN0ZW5lciA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbGlzdGVuZXIgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cdFx0XHRpZiAoIUNsYXNzLmlzRnVuY3Rpb24obGlzdGVuZXIpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbGlzdGVuZXIgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLlwiKTtcblx0XHRcdGlmICgocHJpb3JpdHkgIT0gbnVsbCkgJiYgIUNsYXNzLmlzTnVtYmVyKHByaW9yaXR5KSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIHByaW9yaXR5IG11c3QgYmUgb2YgdHlwZSBOdW1iZXIuXCIpO1xuXG5cdFx0XHRpZiAoc2NvcGUgPT0gbnVsbClcblx0XHRcdFx0c2NvcGUgPSB0aGlzO1xuXHRcdFx0aWYgKChwcmlvcml0eSA9PSBudWxsKSB8fCBpc05hTihwcmlvcml0eSkpXG5cdFx0XHRcdHByaW9yaXR5ID0gMDtcblxuXHRcdFx0ZXZlbnQub24odGhpcywgbGlzdGVuZXIsIHNjb3BlLCBwcmlvcml0eSk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHR0aGlzLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lciwgc2NvcGUpXG5cdFx0e1xuXHRcdFx0aWYgKHNjb3BlICE9IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdGV2ZW50ID0gRXZlbnQucmVzb2x2ZSh0aGlzLCBldmVudCk7XG5cblx0XHRcdFx0aWYgKGxpc3RlbmVyID09IG51bGwpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGxpc3RlbmVyIG11c3QgYmUgbm9uLW51bGwuXCIpO1xuXHRcdFx0XHRpZiAoIUNsYXNzLmlzRnVuY3Rpb24obGlzdGVuZXIpKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBsaXN0ZW5lciBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uXCIpO1xuXG5cdFx0XHRcdGV2ZW50Lm9mZih0aGlzLCBsaXN0ZW5lciwgc2NvcGUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobGlzdGVuZXIgIT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0ZXZlbnQgPSBFdmVudC5yZXNvbHZlKHRoaXMsIGV2ZW50KTtcblxuXHRcdFx0XHRpZiAoIUNsYXNzLmlzRnVuY3Rpb24obGlzdGVuZXIpKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBsaXN0ZW5lciBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uXCIpO1xuXG5cdFx0XHRcdGV2ZW50Lm9mZih0aGlzLCBsaXN0ZW5lciwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChldmVudCAhPSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRldmVudCA9IEV2ZW50LnJlc29sdmUodGhpcywgZXZlbnQpO1xuXG5cdFx0XHRcdGV2ZW50Lm9mZkFsbCh0aGlzKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0RXZlbnQub2ZmQWxsKHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0dGhpcy5maXJlID0gZnVuY3Rpb24oZXZlbnQsIGV2ZW50RGF0YSlcblx0XHR7XG5cdFx0XHRldmVudCA9IEV2ZW50LnJlc29sdmUodGhpcywgZXZlbnQpO1xuXG5cdFx0XHRpZiAoZXZlbnREYXRhID09IG51bGwpXG5cdFx0XHRcdGV2ZW50RGF0YSA9IGV2ZW50LmNyZWF0ZUV2ZW50RGF0YSgpO1xuXHRcdFx0ZWxzZSBpZiAoIWV2ZW50LmlzVmFsaWRUeXBlKGV2ZW50RGF0YSkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRhdGEgZmlyZWQgb24gZXZlbnQgXFxcIlwiICsgZXZlbnQubmFtZSgpICsgXCJcXFwiIG11c3QgYmUgb2YgdHlwZSBcIiArIGV2ZW50LmdldFR5cGVOYW1lKCkgKyBcIi5cIik7XG5cblx0XHRcdHJldHVybiBldmVudC5maXJlKHRoaXMsIGV2ZW50RGF0YSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpXG5cdFx0e1xuXHRcdFx0aWYgKGV2ZW50ICE9IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdGV2ZW50ID0gRXZlbnQucmVzb2x2ZSh0aGlzLCBldmVudCk7XG5cblx0XHRcdFx0cmV0dXJuIGV2ZW50Lmhhc0xpc3RlbmVycyh0aGlzKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIEV2ZW50Lmhhc0xpc3RlbmVycyh0aGlzKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRCdWJibGVUYXJnZXQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblxuXHR9KTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9qZ19saWIvZXZlbnRzL01FdmVudFRhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9qZ19saWIvZXZlbnRzL01FdmVudFRhcmdldFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/jg_lib/async/PassEventData":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\tvar EventData = __webpack_require__(\"contrib/jg_lib/events/EventData\");\n\n\treturn Class(module.id, EventData, function(PassEventData, base)\n\t{\n\n\t\t// Public Properties\n\n\t\tthis.pass = null;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(pass)\n\t\t{\n\t\t\tthis.pass = pass;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2FzeW5jL1Bhc3NFdmVudERhdGEuanM/NTNmMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvYXN5bmMvUGFzc0V2ZW50RGF0YS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIENsYXNzID0gcmVxdWlyZShcIi4uL0NsYXNzXCIpO1xuXHR2YXIgRXZlbnREYXRhID0gcmVxdWlyZShcIi4uL2V2ZW50cy9FdmVudERhdGFcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgRXZlbnREYXRhLCBmdW5jdGlvbihQYXNzRXZlbnREYXRhLCBiYXNlKVxuXHR7XG5cblx0XHQvLyBQdWJsaWMgUHJvcGVydGllc1xuXG5cdFx0dGhpcy5wYXNzID0gbnVsbDtcblxuXHRcdC8vIENvbnN0cnVjdG9yXG5cblx0XHR0aGlzLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24ocGFzcylcblx0XHR7XG5cdFx0XHR0aGlzLnBhc3MgPSBwYXNzO1xuXHRcdH07XG5cblx0fSk7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2FzeW5jL1Bhc3NFdmVudERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IGNvbnRyaWIvamdfbGliL2FzeW5jL1Bhc3NFdmVudERhdGFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/events/ChainedEvent":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Event = __webpack_require__(\"contrib/jg_lib/events/Event\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, Event, function(ChainedEvent, base)\n\t{\n\n\t\t// Private Properties\n\n\t\tthis._parentEvent = null;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(name, parentEvent, type, bubbles, cancelable)\n\t\t{\n\t\t\tif (parentEvent == null)\n\t\t\t\tthrow new Error(\"Parameter parentEvent must be non-null.\");\n\t\t\tif (!(parentEvent instanceof Event))\n\t\t\t\tthrow new Error(\"Parameter parentEvent must be of type \" + Class.getName(Event) + \".\");\n\n\t\t\tvar parentType = parentEvent.type();\n\t\t\tif (type == null)\n\t\t\t\ttype = parentType;\n\t\t\telse if (!Class.isFunction(type))\n\t\t\t\tthrow new Error(\"Parameter type must be of type Function.\");\n\t\t\telse if ((type !== parentType) && !Class.isSubclassOf(type, parentType))\n\t\t\t\tthrow new Error(\"Parameter type must be a subclass of \" + (Class.getName(parentType) || \"parentEvent.type\") + \".\");\n\n\t\t\tif (bubbles == null)\n\t\t\t\tbubbles = parentEvent.bubbles();\n\t\t\tif (cancelable == null)\n\t\t\t\tcancelable = parentEvent.cancelable();\n\n\t\t\tbase.constructor.call(this, name, type, bubbles, cancelable);\n\n\t\t\tthis._parentEvent = parentEvent;\n\t\t};\n\n\t\t// Public Accessor Methods\n\n\t\tthis.parentEvent = function()\n\t\t{\n\t\t\treturn this._parentEvent;\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.notifyListeners = function(target, eventData)\n\t\t{\n\t\t\tbase.notifyListeners.call(this, target, eventData);\n\t\t\tif (!eventData.isPropagationStopped())\n\t\t\t\tthis._parentEvent.notifyListeners(target, eventData);\n\t\t};\n\n\t\tthis.notifyBubbleListeners = function(bubbleTargets, eventData)\n\t\t{\n\t\t\tif (this.bubbles())\n\t\t\t\tbase.notifyBubbleListeners.call(this, bubbleTargets, eventData);\n\t\t\telse\n\t\t\t\tthis._parentEvent.notifyBubbleListeners(bubbleTargets, eventData);\n\t\t};\n\n\t\tthis.getBubbleTargets = function(target)\n\t\t{\n\t\t\tif (this.bubbles())\n\t\t\t\treturn base.getBubbleTargets.call(this, target);\n\t\t\telse\n\t\t\t\treturn this._parentEvent.getBubbleTargets(target);\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2V2ZW50cy9DaGFpbmVkRXZlbnQuanM/Nzc3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRixDQUFDIiwiZmlsZSI6ImNvbnRyaWIvamdfbGliL2V2ZW50cy9DaGFpbmVkRXZlbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAwNy0yMDE2IEphc29uIEdhdHRcbiAqIFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKVxue1xuXG5cdHZhciBFdmVudCA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuXHR2YXIgQ2xhc3MgPSByZXF1aXJlKFwiLi4vQ2xhc3NcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgRXZlbnQsIGZ1bmN0aW9uKENoYWluZWRFdmVudCwgYmFzZSlcblx0e1xuXG5cdFx0Ly8gUHJpdmF0ZSBQcm9wZXJ0aWVzXG5cblx0XHR0aGlzLl9wYXJlbnRFdmVudCA9IG51bGw7XG5cblx0XHQvLyBDb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKG5hbWUsIHBhcmVudEV2ZW50LCB0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKVxuXHRcdHtcblx0XHRcdGlmIChwYXJlbnRFdmVudCA9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgcGFyZW50RXZlbnQgbXVzdCBiZSBub24tbnVsbC5cIik7XG5cdFx0XHRpZiAoIShwYXJlbnRFdmVudCBpbnN0YW5jZW9mIEV2ZW50KSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIHBhcmVudEV2ZW50IG11c3QgYmUgb2YgdHlwZSBcIiArIENsYXNzLmdldE5hbWUoRXZlbnQpICsgXCIuXCIpO1xuXG5cdFx0XHR2YXIgcGFyZW50VHlwZSA9IHBhcmVudEV2ZW50LnR5cGUoKTtcblx0XHRcdGlmICh0eXBlID09IG51bGwpXG5cdFx0XHRcdHR5cGUgPSBwYXJlbnRUeXBlO1xuXHRcdFx0ZWxzZSBpZiAoIUNsYXNzLmlzRnVuY3Rpb24odHlwZSkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciB0eXBlIG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi5cIik7XG5cdFx0XHRlbHNlIGlmICgodHlwZSAhPT0gcGFyZW50VHlwZSkgJiYgIUNsYXNzLmlzU3ViY2xhc3NPZih0eXBlLCBwYXJlbnRUeXBlKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIHR5cGUgbXVzdCBiZSBhIHN1YmNsYXNzIG9mIFwiICsgKENsYXNzLmdldE5hbWUocGFyZW50VHlwZSkgfHwgXCJwYXJlbnRFdmVudC50eXBlXCIpICsgXCIuXCIpO1xuXG5cdFx0XHRpZiAoYnViYmxlcyA9PSBudWxsKVxuXHRcdFx0XHRidWJibGVzID0gcGFyZW50RXZlbnQuYnViYmxlcygpO1xuXHRcdFx0aWYgKGNhbmNlbGFibGUgPT0gbnVsbClcblx0XHRcdFx0Y2FuY2VsYWJsZSA9IHBhcmVudEV2ZW50LmNhbmNlbGFibGUoKTtcblxuXHRcdFx0YmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG5hbWUsIHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXG5cdFx0XHR0aGlzLl9wYXJlbnRFdmVudCA9IHBhcmVudEV2ZW50O1xuXHRcdH07XG5cblx0XHQvLyBQdWJsaWMgQWNjZXNzb3IgTWV0aG9kc1xuXG5cdFx0dGhpcy5wYXJlbnRFdmVudCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGFyZW50RXZlbnQ7XG5cdFx0fTtcblxuXHRcdC8vIFB1YmxpYyBNZXRob2RzXG5cblx0XHR0aGlzLm5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnREYXRhKVxuXHRcdHtcblx0XHRcdGJhc2Uubm90aWZ5TGlzdGVuZXJzLmNhbGwodGhpcywgdGFyZ2V0LCBldmVudERhdGEpO1xuXHRcdFx0aWYgKCFldmVudERhdGEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlcblx0XHRcdFx0dGhpcy5fcGFyZW50RXZlbnQubm90aWZ5TGlzdGVuZXJzKHRhcmdldCwgZXZlbnREYXRhKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5ub3RpZnlCdWJibGVMaXN0ZW5lcnMgPSBmdW5jdGlvbihidWJibGVUYXJnZXRzLCBldmVudERhdGEpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuYnViYmxlcygpKVxuXHRcdFx0XHRiYXNlLm5vdGlmeUJ1YmJsZUxpc3RlbmVycy5jYWxsKHRoaXMsIGJ1YmJsZVRhcmdldHMsIGV2ZW50RGF0YSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRoaXMuX3BhcmVudEV2ZW50Lm5vdGlmeUJ1YmJsZUxpc3RlbmVycyhidWJibGVUYXJnZXRzLCBldmVudERhdGEpO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldEJ1YmJsZVRhcmdldHMgPSBmdW5jdGlvbih0YXJnZXQpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuYnViYmxlcygpKVxuXHRcdFx0XHRyZXR1cm4gYmFzZS5nZXRCdWJibGVUYXJnZXRzLmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhcmVudEV2ZW50LmdldEJ1YmJsZVRhcmdldHModGFyZ2V0KTtcblx0XHR9O1xuXG5cdH0pO1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL2pnX2xpYi9ldmVudHMvQ2hhaW5lZEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL2pnX2xpYi9ldmVudHMvQ2hhaW5lZEV2ZW50XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "contrib/jg_lib/utils/ArrayUtil":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, function(ArrayUtil)\n\t{\n\n\t\t// Public Static Methods\n\n\t\tArrayUtil.indexOf = function(arr, value, start)\n\t\t{\n\t\t\tvar l = arr.length;\n\t\t\tvar i = 0;\n\n\t\t\tif (start != null)\n\t\t\t{\n\t\t\t\tstart = +start;\n\t\t\t\tif (start >= 0)\n\t\t\t\t\ti = Math.floor(start);\n\t\t\t\telse if (start < 0)\n\t\t\t\t\ti = Math.max(l + Math.ceil(start), 0);\n\t\t\t}\n\n\t\t\tfor (i; i < l; i++)\n\t\t\t{\n\t\t\t\tif (arr[i] === value)\n\t\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t};\n\n\t\tArrayUtil.lastIndexOf = function(arr, value, start)\n\t\t{\n\t\t\tvar l = arr.length;\n\t\t\tvar i = l - 1;\n\n\t\t\tif (start != null)\n\t\t\t{\n\t\t\t\tstart = +start;\n\t\t\t\tif (start >= 0)\n\t\t\t\t\ti = Math.min(Math.floor(start), l - 1);\n\t\t\t\telse if (start < 0)\n\t\t\t\t\ti = l + Math.ceil(start);\n\t\t\t}\n\n\t\t\tfor (i; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif (arr[i] === value)\n\t\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t};\n\n\t\tArrayUtil.binarySearch = function(arr, value, comparator)\n\t\t{\n\t\t\tvar high = arr.length - 1;\n\t\t\tif (high < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (!comparator)\n\t\t\t\tcomparator = _naturalComparator;\n\n\t\t\tvar low = 0;\n\t\t\tvar mid;\n\t\t\tvar comp;\n\n\t\t\twhile (low <= high)\n\t\t\t{\n\t\t\t\tmid = low + Math.floor((high - low) / 2);\n\t\t\t\tcomp = comparator(arr[mid], value);\n\t\t\t\tif (comp < 0)\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\telse if (comp > 0)\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\telse\n\t\t\t\t\treturn mid;\n\t\t\t}\n\n\t\t\treturn -low - 1;\n\t\t};\n\n\t\t// Private Static Methods\n\n\t\tvar _naturalComparator = function(value1, value2)\n\t\t{\n\t\t\tif (value1 < value2)\n\t\t\t\treturn -1;\n\t\t\tif (value1 > value2)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL0FycmF5VXRpbC5qcz81OTEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvdXRpbHMvQXJyYXlVdGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAxNiBKYXNvbiBHYXR0XG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSlcbntcblxuXHR2YXIgQ2xhc3MgPSByZXF1aXJlKFwiLi4vQ2xhc3NcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgZnVuY3Rpb24oQXJyYXlVdGlsKVxuXHR7XG5cblx0XHQvLyBQdWJsaWMgU3RhdGljIE1ldGhvZHNcblxuXHRcdEFycmF5VXRpbC5pbmRleE9mID0gZnVuY3Rpb24oYXJyLCB2YWx1ZSwgc3RhcnQpXG5cdFx0e1xuXHRcdFx0dmFyIGwgPSBhcnIubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSAwO1xuXG5cdFx0XHRpZiAoc3RhcnQgIT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0c3RhcnQgPSArc3RhcnQ7XG5cdFx0XHRcdGlmIChzdGFydCA+PSAwKVxuXHRcdFx0XHRcdGkgPSBNYXRoLmZsb29yKHN0YXJ0KTtcblx0XHRcdFx0ZWxzZSBpZiAoc3RhcnQgPCAwKVxuXHRcdFx0XHRcdGkgPSBNYXRoLm1heChsICsgTWF0aC5jZWlsKHN0YXJ0KSwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoaTsgaSA8IGw7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGFycltpXSA9PT0gdmFsdWUpXG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXG5cdFx0QXJyYXlVdGlsLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyLCB2YWx1ZSwgc3RhcnQpXG5cdFx0e1xuXHRcdFx0dmFyIGwgPSBhcnIubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSBsIC0gMTtcblxuXHRcdFx0aWYgKHN0YXJ0ICE9IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdHN0YXJ0ID0gK3N0YXJ0O1xuXHRcdFx0XHRpZiAoc3RhcnQgPj0gMClcblx0XHRcdFx0XHRpID0gTWF0aC5taW4oTWF0aC5mbG9vcihzdGFydCksIGwgLSAxKTtcblx0XHRcdFx0ZWxzZSBpZiAoc3RhcnQgPCAwKVxuXHRcdFx0XHRcdGkgPSBsICsgTWF0aC5jZWlsKHN0YXJ0KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpOyBpID49IDA7IGktLSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGFycltpXSA9PT0gdmFsdWUpXG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXG5cdFx0QXJyYXlVdGlsLmJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uKGFyciwgdmFsdWUsIGNvbXBhcmF0b3IpXG5cdFx0e1xuXHRcdFx0dmFyIGhpZ2ggPSBhcnIubGVuZ3RoIC0gMTtcblx0XHRcdGlmIChoaWdoIDwgMClcblx0XHRcdFx0cmV0dXJuIC0xO1xuXG5cdFx0XHRpZiAoIWNvbXBhcmF0b3IpXG5cdFx0XHRcdGNvbXBhcmF0b3IgPSBfbmF0dXJhbENvbXBhcmF0b3I7XG5cblx0XHRcdHZhciBsb3cgPSAwO1xuXHRcdFx0dmFyIG1pZDtcblx0XHRcdHZhciBjb21wO1xuXG5cdFx0XHR3aGlsZSAobG93IDw9IGhpZ2gpXG5cdFx0XHR7XG5cdFx0XHRcdG1pZCA9IGxvdyArIE1hdGguZmxvb3IoKGhpZ2ggLSBsb3cpIC8gMik7XG5cdFx0XHRcdGNvbXAgPSBjb21wYXJhdG9yKGFyclttaWRdLCB2YWx1ZSk7XG5cdFx0XHRcdGlmIChjb21wIDwgMClcblx0XHRcdFx0XHRsb3cgPSBtaWQgKyAxO1xuXHRcdFx0XHRlbHNlIGlmIChjb21wID4gMClcblx0XHRcdFx0XHRoaWdoID0gbWlkIC0gMTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHJldHVybiBtaWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAtbG93IC0gMTtcblx0XHR9O1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0dmFyIF9uYXR1cmFsQ29tcGFyYXRvciA9IGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKVxuXHRcdHtcblx0XHRcdGlmICh2YWx1ZTEgPCB2YWx1ZTIpXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdGlmICh2YWx1ZTEgPiB2YWx1ZTIpXG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblxuXHR9KTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9qZ19saWIvdXRpbHMvQXJyYXlVdGlsLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL2pnX2xpYi91dGlscy9BcnJheVV0aWxcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/utils/Set":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar UID = __webpack_require__(\"contrib/jg_lib/utils/UID\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, Object, function(Set, base)\n\t{\n\n\t\t// Private Properties\n\n\t\tthis._entries = null;\n\t\tthis._size = 0;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(entries)\n\t\t{\n\t\t\tthis._entries = {};\n\n\t\t\tif (entries != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0, l = entries.length; i < l; i++)\n\t\t\t\t\tthis.add(entries[i]);\n\t\t\t}\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.add = function(key)\n\t\t{\n\t\t\tvar uid = UID.get(key);\n\t\t\tif (this._entries.hasOwnProperty(uid))\n\t\t\t\treturn this;\n\n\t\t\tthis._entries[uid] = key;\n\t\t\tthis._size++;\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.del = function(key)\n\t\t{\n\t\t\tvar uid = UID.get(key, false);\n\t\t\tif (!uid || !this._entries.hasOwnProperty(uid))\n\t\t\t\treturn this;\n\n\t\t\tdelete this._entries[uid];\n\t\t\tthis._size--;\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.has = function(key)\n\t\t{\n\t\t\tvar uid = UID.get(key, false);\n\t\t\tif (!uid || !this._entries.hasOwnProperty(uid))\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t};\n\n\t\tthis.size = function()\n\t\t{\n\t\t\treturn this._size;\n\t\t};\n\n\t\tthis.clear = function()\n\t\t{\n\t\t\tif (this._size === 0)\n\t\t\t\treturn this;\n\n\t\t\tthis._entries = {};\n\t\t\tthis._size = 0;\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.keys = function()\n\t\t{\n\t\t\tvar keys = [];\n\t\t\tvar entries = this._entries;\n\t\t\tfor (var uid in entries)\n\t\t\t{\n\t\t\t\tif (entries.hasOwnProperty(uid))\n\t\t\t\t\tkeys.push(entries[uid]);\n\t\t\t}\n\t\t\treturn keys;\n\t\t};\n\n\t\tthis.values = function()\n\t\t{\n\t\t\treturn this.keys();\n\t\t};\n\n\t\tthis.entries = function()\n\t\t{\n\t\t\treturn this.keys();\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL3V0aWxzL1NldC5qcz8yZWJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUYsQ0FBQyIsImZpbGUiOiJjb250cmliL2pnX2xpYi91dGlscy9TZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAwNy0yMDE2IEphc29uIEdhdHRcbiAqIFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKVxue1xuXG5cdHZhciBVSUQgPSByZXF1aXJlKFwiLi9VSURcIik7XG5cdHZhciBDbGFzcyA9IHJlcXVpcmUoXCIuLi9DbGFzc1wiKTtcblxuXHRyZXR1cm4gQ2xhc3MobW9kdWxlLmlkLCBPYmplY3QsIGZ1bmN0aW9uKFNldCwgYmFzZSlcblx0e1xuXG5cdFx0Ly8gUHJpdmF0ZSBQcm9wZXJ0aWVzXG5cblx0XHR0aGlzLl9lbnRyaWVzID0gbnVsbDtcblx0XHR0aGlzLl9zaXplID0gMDtcblxuXHRcdC8vIENvbnN0cnVjdG9yXG5cblx0XHR0aGlzLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oZW50cmllcylcblx0XHR7XG5cdFx0XHR0aGlzLl9lbnRyaWVzID0ge307XG5cblx0XHRcdGlmIChlbnRyaWVzICE9IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZW50cmllcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5hZGQoZW50cmllc1tpXSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFB1YmxpYyBNZXRob2RzXG5cblx0XHR0aGlzLmFkZCA9IGZ1bmN0aW9uKGtleSlcblx0XHR7XG5cdFx0XHR2YXIgdWlkID0gVUlELmdldChrZXkpO1xuXHRcdFx0aWYgKHRoaXMuX2VudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdHRoaXMuX2VudHJpZXNbdWlkXSA9IGtleTtcblx0XHRcdHRoaXMuX3NpemUrKztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHR0aGlzLmRlbCA9IGZ1bmN0aW9uKGtleSlcblx0XHR7XG5cdFx0XHR2YXIgdWlkID0gVUlELmdldChrZXksIGZhbHNlKTtcblx0XHRcdGlmICghdWlkIHx8ICF0aGlzLl9lbnRyaWVzLmhhc093blByb3BlcnR5KHVpZCkpXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRkZWxldGUgdGhpcy5fZW50cmllc1t1aWRdO1xuXHRcdFx0dGhpcy5fc2l6ZS0tO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHRoaXMuaGFzID0gZnVuY3Rpb24oa2V5KVxuXHRcdHtcblx0XHRcdHZhciB1aWQgPSBVSUQuZ2V0KGtleSwgZmFsc2UpO1xuXHRcdFx0aWYgKCF1aWQgfHwgIXRoaXMuX2VudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zaXplID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9zaXplO1xuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0dGhpcy5fZW50cmllcyA9IHt9O1xuXHRcdFx0dGhpcy5fc2l6ZSA9IDA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0dGhpcy5rZXlzID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHZhciBrZXlzID0gW107XG5cdFx0XHR2YXIgZW50cmllcyA9IHRoaXMuX2VudHJpZXM7XG5cdFx0XHRmb3IgKHZhciB1aWQgaW4gZW50cmllcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGVudHJpZXMuaGFzT3duUHJvcGVydHkodWlkKSlcblx0XHRcdFx0XHRrZXlzLnB1c2goZW50cmllc1t1aWRdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBrZXlzO1xuXHRcdH07XG5cblx0XHR0aGlzLnZhbHVlcyA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5rZXlzKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZW50cmllcyA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5rZXlzKCk7XG5cdFx0fTtcblxuXHR9KTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9qZ19saWIvdXRpbHMvU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL2pnX2xpYi91dGlscy9TZXRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/async/MPassTarget":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Pass = __webpack_require__(\"contrib/jg_lib/async/Pass\");\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\n\treturn Class(module.id, function(MPassTarget)\n\t{\n\n\t\t// Public Events\n\n\t\tthis.invalidated = Pass.invalidated;\n\t\tthis.validated = Pass.validated;\n\n\t\t// Public Properties\n\n\t\tthis.isPassTarget = true;\n\n\t\t// Public Methods\n\n\t\tthis.invalidate = function(pass)\n\t\t{\n\t\t\tpass = Pass.resolve(this, pass);\n\n\t\t\tpass.invalidate(this);\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.validate = function(pass)\n\t\t{\n\t\t\tif (pass != null)\n\t\t\t\tpass = Pass.resolve(this, pass);\n\n\t\t\tPass.validateAll(pass);\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.markValid = function(pass)\n\t\t{\n\t\t\tif (pass != null)\n\t\t\t{\n\t\t\t\tpass = Pass.resolve(this, pass);\n\n\t\t\t\tpass.markValid(this);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPass.markValid(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.isValid = function(pass)\n\t\t{\n\t\t\tif (pass != null)\n\t\t\t{\n\t\t\t\tpass = Pass.resolve(this, pass);\n\n\t\t\t\treturn pass.isValid(this);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn Pass.isValid(this);\n\t\t\t}\n\t\t};\n\n\t\tthis.isValidating = function(pass)\n\t\t{\n\t\t\tif (pass != null)\n\t\t\t{\n\t\t\t\tpass = Pass.resolve(this, pass);\n\n\t\t\t\treturn pass.isValidating();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn Pass.isValidating();\n\t\t\t}\n\t\t};\n\n\t\tthis.getValidateDepth = function()\n\t\t{\n\t\t\treturn 0;\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2FzeW5jL01QYXNzVGFyZ2V0LmpzP2IxMmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUYsQ0FBQyIsImZpbGUiOiJjb250cmliL2pnX2xpYi9hc3luYy9NUGFzc1RhcmdldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMTYgSmFzb24gR2F0dFxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpXG57XG5cblx0dmFyIFBhc3MgPSByZXF1aXJlKFwiLi9QYXNzXCIpO1xuXHR2YXIgQ2xhc3MgPSByZXF1aXJlKFwiLi4vQ2xhc3NcIik7XG5cblx0cmV0dXJuIENsYXNzKG1vZHVsZS5pZCwgZnVuY3Rpb24oTVBhc3NUYXJnZXQpXG5cdHtcblxuXHRcdC8vIFB1YmxpYyBFdmVudHNcblxuXHRcdHRoaXMuaW52YWxpZGF0ZWQgPSBQYXNzLmludmFsaWRhdGVkO1xuXHRcdHRoaXMudmFsaWRhdGVkID0gUGFzcy52YWxpZGF0ZWQ7XG5cblx0XHQvLyBQdWJsaWMgUHJvcGVydGllc1xuXG5cdFx0dGhpcy5pc1Bhc3NUYXJnZXQgPSB0cnVlO1xuXG5cdFx0Ly8gUHVibGljIE1ldGhvZHNcblxuXHRcdHRoaXMuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKHBhc3MpXG5cdFx0e1xuXHRcdFx0cGFzcyA9IFBhc3MucmVzb2x2ZSh0aGlzLCBwYXNzKTtcblxuXHRcdFx0cGFzcy5pbnZhbGlkYXRlKHRoaXMpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0dGhpcy52YWxpZGF0ZSA9IGZ1bmN0aW9uKHBhc3MpXG5cdFx0e1xuXHRcdFx0aWYgKHBhc3MgIT0gbnVsbClcblx0XHRcdFx0cGFzcyA9IFBhc3MucmVzb2x2ZSh0aGlzLCBwYXNzKTtcblxuXHRcdFx0UGFzcy52YWxpZGF0ZUFsbChwYXNzKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHRoaXMubWFya1ZhbGlkID0gZnVuY3Rpb24ocGFzcylcblx0XHR7XG5cdFx0XHRpZiAocGFzcyAhPSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRwYXNzID0gUGFzcy5yZXNvbHZlKHRoaXMsIHBhc3MpO1xuXG5cdFx0XHRcdHBhc3MubWFya1ZhbGlkKHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRQYXNzLm1hcmtWYWxpZCh0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHRoaXMuaXNWYWxpZCA9IGZ1bmN0aW9uKHBhc3MpXG5cdFx0e1xuXHRcdFx0aWYgKHBhc3MgIT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0cGFzcyA9IFBhc3MucmVzb2x2ZSh0aGlzLCBwYXNzKTtcblxuXHRcdFx0XHRyZXR1cm4gcGFzcy5pc1ZhbGlkKHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gUGFzcy5pc1ZhbGlkKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLmlzVmFsaWRhdGluZyA9IGZ1bmN0aW9uKHBhc3MpXG5cdFx0e1xuXHRcdFx0aWYgKHBhc3MgIT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0cGFzcyA9IFBhc3MucmVzb2x2ZSh0aGlzLCBwYXNzKTtcblxuXHRcdFx0XHRyZXR1cm4gcGFzcy5pc1ZhbGlkYXRpbmcoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIFBhc3MuaXNWYWxpZGF0aW5nKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0VmFsaWRhdGVEZXB0aCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXG5cdH0pO1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL2pnX2xpYi9hc3luYy9NUGFzc1RhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9qZ19saWIvYXN5bmMvTVBhc3NUYXJnZXRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "helpers/Printer":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(\"shim/jquery\"),\n            __webpack_require__(\"require/backbone\"),\n            __webpack_require__(\"shim/splunk.print\"),\n            __webpack_require__(\"global/GlobalReflowQueue\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n            $,\n            Backbone,\n            SplunkPrint,\n            GlobalReflowQueue\n        ) {\n\n    var Printer = $.extend({}, Backbone.Events, {\n\n        PRINT_START: SplunkPrint.prototype.START_EVENT,\n        PRINT_END: SplunkPrint.prototype.END_EVENT,\n        PRINT_PAGE_WIDTH: +SplunkPrint.prototype.PAGE_WIDTH.replace('px', ''),\n\n        printPage: function() {\n            $(document).trigger(SplunkPrint.prototype.PAGE_EVENT);\n        },\n\n        // make sure the legacy print handler is initialized as soon as the DOM is ready.\n        // also bind our own DOM listeners\n        onDomReady: function() {\n            var legacyPrinter = SplunkPrint.getInstance();\n\n            $(document).on(SplunkPrint.prototype.START_EVENT, function() {\n                Printer.trigger(Printer.PRINT_START);\n                GlobalReflowQueue.validateViews();\n            });\n            $(document).on(SplunkPrint.prototype.END_EVENT, function() {\n                Printer.trigger(Printer.PRINT_END);\n                GlobalReflowQueue.validateViews();\n            });\n        }\n\n    });\n\n    $(function() { Printer.onDomReady(); });\n\n    return Printer;\n\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2hlbHBlcnMvUHJpbnRlci5qcz9jNzIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsS0FBSzs7QUFFTCxrQkFBa0Isc0JBQXNCLEVBQUU7O0FBRTFDOztBQUVBLENBQUMiLCJmaWxlIjoiaGVscGVycy9QcmludGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcbiAgICAgICAgICAgICdqcXVlcnknLFxuICAgICAgICAgICAgJ2JhY2tib25lJyxcbiAgICAgICAgICAgICdzcGx1bmsucHJpbnQnLFxuICAgICAgICAgICAgJ2dsb2JhbC9HbG9iYWxSZWZsb3dRdWV1ZSdcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24oXG4gICAgICAgICAgICAkLFxuICAgICAgICAgICAgQmFja2JvbmUsXG4gICAgICAgICAgICBTcGx1bmtQcmludCxcbiAgICAgICAgICAgIEdsb2JhbFJlZmxvd1F1ZXVlXG4gICAgICAgICkge1xuXG4gICAgdmFyIFByaW50ZXIgPSAkLmV4dGVuZCh7fSwgQmFja2JvbmUuRXZlbnRzLCB7XG5cbiAgICAgICAgUFJJTlRfU1RBUlQ6IFNwbHVua1ByaW50LnByb3RvdHlwZS5TVEFSVF9FVkVOVCxcbiAgICAgICAgUFJJTlRfRU5EOiBTcGx1bmtQcmludC5wcm90b3R5cGUuRU5EX0VWRU5ULFxuICAgICAgICBQUklOVF9QQUdFX1dJRFRIOiArU3BsdW5rUHJpbnQucHJvdG90eXBlLlBBR0VfV0lEVEgucmVwbGFjZSgncHgnLCAnJyksXG5cbiAgICAgICAgcHJpbnRQYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIoU3BsdW5rUHJpbnQucHJvdG90eXBlLlBBR0VfRVZFTlQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgbGVnYWN5IHByaW50IGhhbmRsZXIgaXMgaW5pdGlhbGl6ZWQgYXMgc29vbiBhcyB0aGUgRE9NIGlzIHJlYWR5LlxuICAgICAgICAvLyBhbHNvIGJpbmQgb3VyIG93biBET00gbGlzdGVuZXJzXG4gICAgICAgIG9uRG9tUmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxlZ2FjeVByaW50ZXIgPSBTcGx1bmtQcmludC5nZXRJbnN0YW5jZSgpO1xuXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vbihTcGx1bmtQcmludC5wcm90b3R5cGUuU1RBUlRfRVZFTlQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIFByaW50ZXIudHJpZ2dlcihQcmludGVyLlBSSU5UX1NUQVJUKTtcbiAgICAgICAgICAgICAgICBHbG9iYWxSZWZsb3dRdWV1ZS52YWxpZGF0ZVZpZXdzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKFNwbHVua1ByaW50LnByb3RvdHlwZS5FTkRfRVZFTlQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIFByaW50ZXIudHJpZ2dlcihQcmludGVyLlBSSU5UX0VORCk7XG4gICAgICAgICAgICAgICAgR2xvYmFsUmVmbG93UXVldWUudmFsaWRhdGVWaWV3cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgJChmdW5jdGlvbigpIHsgUHJpbnRlci5vbkRvbVJlYWR5KCk7IH0pO1xuXG4gICAgcmV0dXJuIFByaW50ZXI7XG5cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9oZWxwZXJzL1ByaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IGhlbHBlcnMvUHJpbnRlclxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "shim/splunk.print":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/jquery\"), __webpack_require__(\"shim/lowpro\"), __webpack_require__(\"shim/splunk\"), __webpack_require__(\"shim/splunk.logger\"), __webpack_require__(263)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, lowpro, Splunk) {\n    return Splunk.Print;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vc3BsdW5rLnByaW50LmpzPzNmY2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InNoaW0vc3BsdW5rLnByaW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFsnanF1ZXJ5JywgJ2xvd3BybycsICdzcGx1bmsnLCAnc3BsdW5rLmxvZ2dlcicsICdpbXBvcnRzPyQ9anF1ZXJ5IXByaW50J10sIGZ1bmN0aW9uKCQsIGxvd3BybywgU3BsdW5rKSB7XG4gICAgcmV0dXJuIFNwbHVuay5QcmludDtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zaGltL3NwbHVuay5wcmludC5qc1xuLy8gbW9kdWxlIGlkID0gc2hpbS9zcGx1bmsucHJpbnRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "shim/lowpro":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/jquery\"), __webpack_require__(262)], __WEBPACK_AMD_DEFINE_RESULT__ = function($) {\n    return $.klass;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vbG93cHJvLmpzPzc2YjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InNoaW0vbG93cHJvLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFsnanF1ZXJ5JywgJ2ltcG9ydHM/alF1ZXJ5PWpxdWVyeSFjb250cmliL2xvd3Byb19mb3JfanF1ZXJ5J10sIGZ1bmN0aW9uKCQpIHtcbiAgICByZXR1cm4gJC5rbGFzcztcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zaGltL2xvd3Byby5qc1xuLy8gbW9kdWxlIGlkID0gc2hpbS9sb3dwcm9cbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 262:
/***/ (function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(\"shim/jquery\");\n\n(function($) {\n  \n  var addMethods = function(source) {\n    var ancestor   = this.superclass && this.superclass.prototype;\n    var properties = $.keys(source);\n\n    if (!$.keys({ toString: true }).length) properties.push(\"toString\", \"valueOf\");\n\n    for (var i = 0, length = properties.length; i < length; i++) {\n      var property = properties[i], value = source[property];\n      if (ancestor && $.isFunction(value) && $.argumentNames(value)[0] == \"$super\") {\n        \n        var method = value, value = $.extend($.wrap((function(m) {\n          return function() { return ancestor[m].apply(this, arguments) };\n        })(property), method), {\n          valueOf:  function() { return method },\n          toString: function() { return method.toString() }\n        });\n      }\n      this.prototype[property] = value;\n    }\n\n    return this;\n  }\n  \n  $.extend({\n    keys: function(obj) {\n      var keys = [];\n      for (var key in obj) keys.push(key);\n      return keys;\n    },\n\n    argumentNames: function(func) {\n      var names = func.toString().match(/^[\\s\\(]*function[^(]*\\((.*?)\\)/)[1].split(/, ?/);\n      return names.length == 1 && !names[0] ? [] : names;\n    },\n\n    bind: function(func, scope) {\n      return function() {\n        return func.apply(scope, $.makeArray(arguments));\n      }\n    },\n\n    wrap: function(func, wrapper) {\n      var __method = func;\n      return function() {\n        return wrapper.apply(this, [$.bind(__method, this)].concat($.makeArray(arguments)));\n      }\n    },\n    \n    klass: function() {\n      var parent = null, properties = $.makeArray(arguments);\n      if ($.isFunction(properties[0])) parent = properties.shift();\n\n      var klass = function() { \n        this.initialize.apply(this, arguments);\n      };\n\n      klass.superclass = parent;\n      klass.subclasses = [];\n      klass.addMethods = addMethods;\n\n      if (parent) {\n        var subclass = function() { };\n        subclass.prototype = parent.prototype;\n        klass.prototype = new subclass;\n        parent.subclasses.push(klass);\n      }\n\n      for (var i = 0; i < properties.length; i++)\n        klass.addMethods(properties[i]);\n\n      if (!klass.prototype.initialize)\n        klass.prototype.initialize = function() {};\n\n      klass.prototype.constructor = klass;\n\n      return klass;\n    }/*,\n    delegate: function(rules) {\n      return function(e) {\n        var target = $(e.target);\n        for (var selector in rules) {\n          if (target.is(selector) || ((target = target.parents(selector)) && target.length > 0)) \n            return rules[selector].apply(this, [target].concat($.makeArray(arguments)));\n        }\n      }\n    }*/\n  });\n  \n  var bindEvents = function(instance) {\n    for (var member in instance) {\n      if (member.match(/^on(.+)/) && typeof instance[member] == 'function') {\n        instance.element.bind(RegExp.$1, $.bind(instance[member], instance));\n      }\n    }\n  }\n  \n  var behaviorWrapper = function(behavior) {\n    return $.klass(behavior, {\n      initialize: function($super, element, args) {\n        this.element = $(element);\n        if ($super) $super.apply(this, args);\n      }\n    });\n  }\n  \n  var attachBehavior = function(el, behavior, args) {\n      var wrapper = behaviorWrapper(behavior);\n      instance = new wrapper(el, args);\n\n      bindEvents(instance);\n\n      if (!behavior.instances) behavior.instances = [];\n\n      behavior.instances.push(instance);\n      \n      return instance;\n  };\n  \n  \n  $.fn.extend({\n    attach: function() {\n      var args = $.makeArray(arguments), behavior = args.shift();\n      \n      if ($.livequery && this.selector) {\n        return this.livequery(function() {\n          attachBehavior(this, behavior, args);\n        });\n      } else {\n        return this.each(function() {\n          attachBehavior(this, behavior, args);\n        });\n      }\n    },\n    attachAndReturn: function() {\n      var args = $.makeArray(arguments), behavior = args.shift();\n      \n      return $.map(this, function(el) {\n        return attachBehavior(el, behavior, args);\n      });\n    },\n    /*delegate: function(type, rules) {\n      return this.bind(type, $.delegate(rules));\n    },*/\n    attached: function(behavior) {\n      var instances = [];\n      \n      if (!behavior.instances) return instances;\n      \n      this.each(function(i, element) {\n        $.each(behavior.instances, function(i, instance) {\n          if (instance.element.get(0) == element) instances.push(instance);\n        });\n      });\n      \n      return instances;\n    },\n    firstAttached: function(behavior) {\n      return this.attached(behavior)[0];\n    }\n  });\n  \n  var Remote = $.klass({\n    initialize: function(options) {\n      if (this.element.attr('nodeName') == 'FORM') this.element.attach(Remote.Form, options);\n      else this.element.attach(Remote.Link, options);\n    }\n  });\n  \n  Remote.Base = $.klass({\n    initialize : function(options) {\n      this.options = $.extend({\n        \n      }, options || {});\n    },\n    _makeRequest : function(options) {\n      $.ajax(options);\n      return false;\n    }\n  });\n  \n  Remote.Link = $.klass(Remote.Base, {\n    onclick: function() {\n      var options = $.extend({ url: this.element.attr('href'), type: 'GET' }, this.options);\n      return this._makeRequest(options);\n    }\n  });\n  \n  Remote.Form = $.klass(Remote.Base, {\n    onclick: function(e) {\n      var target = e.target;\n      \n      if ($.inArray(target.nodeName.toLowerCase(), ['input', 'button']) >= 0 && target.type.match(/submit|image/))\n        this._submitButton = target;\n    },\n    onsubmit: function() {\n      var data = this.element.serializeArray();\n      \n      if (this._submitButton) data.push({ name: this._submitButton.name, value: this._submitButton.value });\n      \n      var options = $.extend({\n        url : this.element.attr('action'),\n        type : this.element.attr('method') || 'GET',\n        data : data\n      }, this.options);\n      \n      this._makeRequest(options);\n      \n      return false;\n    }\n  });\n  \n  $.ajaxSetup({ \n    beforeSend: function(xhr) {\n      xhr.setRequestHeader(\"Accept\", \"text/javascript, text/html, application/xml, text/xml, */*\");\n    } \n  });\n  \n})(jQuery);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbG93cHJvX2Zvcl9qcXVlcnkuanM/Njk0YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCOztBQUVsQywrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVCxnQ0FBZ0MsZ0JBQWdCO0FBQ2hELGdDQUFnQztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLDhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHVCQUF1QjtBQUM1Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxlQUFlO0FBQ3RCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBOEM7QUFDNUU7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx5Q0FBeUMsaUVBQWlFOztBQUUxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUgsZTtBQUNBO0FBQ0E7QUFDQSxLO0FBQ0EsR0FBRzs7QUFFSCxDQUFDIiwiZmlsZSI6IjI2Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xuXG4oZnVuY3Rpb24oJCkge1xuICBcbiAgdmFyIGFkZE1ldGhvZHMgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICB2YXIgYW5jZXN0b3IgICA9IHRoaXMuc3VwZXJjbGFzcyAmJiB0aGlzLnN1cGVyY2xhc3MucHJvdG90eXBlO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gJC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAoISQua2V5cyh7IHRvU3RyaW5nOiB0cnVlIH0pLmxlbmd0aCkgcHJvcGVydGllcy5wdXNoKFwidG9TdHJpbmdcIiwgXCJ2YWx1ZU9mXCIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV0sIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgIGlmIChhbmNlc3RvciAmJiAkLmlzRnVuY3Rpb24odmFsdWUpICYmICQuYXJndW1lbnROYW1lcyh2YWx1ZSlbMF0gPT0gXCIkc3VwZXJcIikge1xuICAgICAgICBcbiAgICAgICAgdmFyIG1ldGhvZCA9IHZhbHVlLCB2YWx1ZSA9ICQuZXh0ZW5kKCQud3JhcCgoZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGFuY2VzdG9yW21dLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfTtcbiAgICAgICAgfSkocHJvcGVydHkpLCBtZXRob2QpLCB7XG4gICAgICAgICAgdmFsdWVPZjogIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kIH0sXG4gICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kLnRvU3RyaW5nKCkgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvdG90eXBlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIFxuICAkLmV4dGVuZCh7XG4gICAga2V5czogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9LFxuXG4gICAgYXJndW1lbnROYW1lczogZnVuY3Rpb24oZnVuYykge1xuICAgICAgdmFyIG5hbWVzID0gZnVuYy50b1N0cmluZygpLm1hdGNoKC9eW1xcc1xcKF0qZnVuY3Rpb25bXihdKlxcKCguKj8pXFwpLylbMV0uc3BsaXQoLywgPy8pO1xuICAgICAgcmV0dXJuIG5hbWVzLmxlbmd0aCA9PSAxICYmICFuYW1lc1swXSA/IFtdIDogbmFtZXM7XG4gICAgfSxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uKGZ1bmMsIHNjb3BlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHNjb3BlLCAkLm1ha2VBcnJheShhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JhcDogZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgICAgdmFyIF9fbWV0aG9kID0gZnVuYztcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgWyQuYmluZChfX21ldGhvZCwgdGhpcyldLmNvbmNhdCgkLm1ha2VBcnJheShhcmd1bWVudHMpKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBrbGFzczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbnVsbCwgcHJvcGVydGllcyA9ICQubWFrZUFycmF5KGFyZ3VtZW50cyk7XG4gICAgICBpZiAoJC5pc0Z1bmN0aW9uKHByb3BlcnRpZXNbMF0pKSBwYXJlbnQgPSBwcm9wZXJ0aWVzLnNoaWZ0KCk7XG5cbiAgICAgIHZhciBrbGFzcyA9IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBrbGFzcy5zdXBlcmNsYXNzID0gcGFyZW50O1xuICAgICAga2xhc3Muc3ViY2xhc3NlcyA9IFtdO1xuICAgICAga2xhc3MuYWRkTWV0aG9kcyA9IGFkZE1ldGhvZHM7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIHN1YmNsYXNzID0gZnVuY3Rpb24oKSB7IH07XG4gICAgICAgIHN1YmNsYXNzLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZSA9IG5ldyBzdWJjbGFzcztcbiAgICAgICAgcGFyZW50LnN1YmNsYXNzZXMucHVzaChrbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKylcbiAgICAgICAga2xhc3MuYWRkTWV0aG9kcyhwcm9wZXJ0aWVzW2ldKTtcblxuICAgICAgaWYgKCFrbGFzcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSlcbiAgICAgICAga2xhc3MucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgICBrbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBrbGFzcztcblxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH0vKixcbiAgICBkZWxlZ2F0ZTogZnVuY3Rpb24ocnVsZXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gcnVsZXMpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0LmlzKHNlbGVjdG9yKSB8fCAoKHRhcmdldCA9IHRhcmdldC5wYXJlbnRzKHNlbGVjdG9yKSkgJiYgdGFyZ2V0Lmxlbmd0aCA+IDApKSBcbiAgICAgICAgICAgIHJldHVybiBydWxlc1tzZWxlY3Rvcl0uYXBwbHkodGhpcywgW3RhcmdldF0uY29uY2F0KCQubWFrZUFycmF5KGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0qL1xuICB9KTtcbiAgXG4gIHZhciBiaW5kRXZlbnRzID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICBmb3IgKHZhciBtZW1iZXIgaW4gaW5zdGFuY2UpIHtcbiAgICAgIGlmIChtZW1iZXIubWF0Y2goL15vbiguKykvKSAmJiB0eXBlb2YgaW5zdGFuY2VbbWVtYmVyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmVsZW1lbnQuYmluZChSZWdFeHAuJDEsICQuYmluZChpbnN0YW5jZVttZW1iZXJdLCBpbnN0YW5jZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgdmFyIGJlaGF2aW9yV3JhcHBlciA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuICQua2xhc3MoYmVoYXZpb3IsIHtcbiAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCRzdXBlciwgZWxlbWVudCwgYXJncykge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICBpZiAoJHN1cGVyKSAkc3VwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIHZhciBhdHRhY2hCZWhhdmlvciA9IGZ1bmN0aW9uKGVsLCBiZWhhdmlvciwgYXJncykge1xuICAgICAgdmFyIHdyYXBwZXIgPSBiZWhhdmlvcldyYXBwZXIoYmVoYXZpb3IpO1xuICAgICAgaW5zdGFuY2UgPSBuZXcgd3JhcHBlcihlbCwgYXJncyk7XG5cbiAgICAgIGJpbmRFdmVudHMoaW5zdGFuY2UpO1xuXG4gICAgICBpZiAoIWJlaGF2aW9yLmluc3RhbmNlcykgYmVoYXZpb3IuaW5zdGFuY2VzID0gW107XG5cbiAgICAgIGJlaGF2aW9yLmluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuICBcbiAgXG4gICQuZm4uZXh0ZW5kKHtcbiAgICBhdHRhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSAkLm1ha2VBcnJheShhcmd1bWVudHMpLCBiZWhhdmlvciA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgIFxuICAgICAgaWYgKCQubGl2ZXF1ZXJ5ICYmIHRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl2ZXF1ZXJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGF0dGFjaEJlaGF2aW9yKHRoaXMsIGJlaGF2aW9yLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGF0dGFjaEJlaGF2aW9yKHRoaXMsIGJlaGF2aW9yLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhdHRhY2hBbmRSZXR1cm46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSAkLm1ha2VBcnJheShhcmd1bWVudHMpLCBiZWhhdmlvciA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICQubWFwKHRoaXMsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBhdHRhY2hCZWhhdmlvcihlbCwgYmVoYXZpb3IsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvKmRlbGVnYXRlOiBmdW5jdGlvbih0eXBlLCBydWxlcykge1xuICAgICAgcmV0dXJuIHRoaXMuYmluZCh0eXBlLCAkLmRlbGVnYXRlKHJ1bGVzKSk7XG4gICAgfSwqL1xuICAgIGF0dGFjaGVkOiBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgICAgXG4gICAgICBpZiAoIWJlaGF2aW9yLmluc3RhbmNlcykgcmV0dXJuIGluc3RhbmNlcztcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksIGVsZW1lbnQpIHtcbiAgICAgICAgJC5lYWNoKGJlaGF2aW9yLmluc3RhbmNlcywgZnVuY3Rpb24oaSwgaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuZWxlbWVudC5nZXQoMCkgPT0gZWxlbWVudCkgaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gaW5zdGFuY2VzO1xuICAgIH0sXG4gICAgZmlyc3RBdHRhY2hlZDogZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dGFjaGVkKGJlaGF2aW9yKVswXTtcbiAgICB9XG4gIH0pO1xuICBcbiAgdmFyIFJlbW90ZSA9ICQua2xhc3Moe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuYXR0cignbm9kZU5hbWUnKSA9PSAnRk9STScpIHRoaXMuZWxlbWVudC5hdHRhY2goUmVtb3RlLkZvcm0sIG9wdGlvbnMpO1xuICAgICAgZWxzZSB0aGlzLmVsZW1lbnQuYXR0YWNoKFJlbW90ZS5MaW5rLCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgUmVtb3RlLkJhc2UgPSAkLmtsYXNzKHtcbiAgICBpbml0aWFsaXplIDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICBcbiAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuICAgIH0sXG4gICAgX21ha2VSZXF1ZXN0IDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgJC5hamF4KG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIFxuICBSZW1vdGUuTGluayA9ICQua2xhc3MoUmVtb3RlLkJhc2UsIHtcbiAgICBvbmNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoeyB1cmw6IHRoaXMuZWxlbWVudC5hdHRyKCdocmVmJyksIHR5cGU6ICdHRVQnIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5fbWFrZVJlcXVlc3Qob3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbiAgXG4gIFJlbW90ZS5Gb3JtID0gJC5rbGFzcyhSZW1vdGUuQmFzZSwge1xuICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIFxuICAgICAgaWYgKCQuaW5BcnJheSh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgWydpbnB1dCcsICdidXR0b24nXSkgPj0gMCAmJiB0YXJnZXQudHlwZS5tYXRjaCgvc3VibWl0fGltYWdlLykpXG4gICAgICAgIHRoaXMuX3N1Ym1pdEJ1dHRvbiA9IHRhcmdldDtcbiAgICB9LFxuICAgIG9uc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5lbGVtZW50LnNlcmlhbGl6ZUFycmF5KCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLl9zdWJtaXRCdXR0b24pIGRhdGEucHVzaCh7IG5hbWU6IHRoaXMuX3N1Ym1pdEJ1dHRvbi5uYW1lLCB2YWx1ZTogdGhpcy5fc3VibWl0QnV0dG9uLnZhbHVlIH0pO1xuICAgICAgXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgdXJsIDogdGhpcy5lbGVtZW50LmF0dHIoJ2FjdGlvbicpLFxuICAgICAgICB0eXBlIDogdGhpcy5lbGVtZW50LmF0dHIoJ21ldGhvZCcpIHx8ICdHRVQnLFxuICAgICAgICBkYXRhIDogZGF0YVxuICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIFxuICAgICAgdGhpcy5fbWFrZVJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICBcbiAgJC5hamF4U2V0dXAoeyBcbiAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbih4aHIpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwidGV4dC9qYXZhc2NyaXB0LCB0ZXh0L2h0bWwsIGFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwsICovKlwiKTtcbiAgICB9IFxuICB9KTtcbiAgXG59KShqUXVlcnkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ltcG9ydHMtbG9hZGVyP2pRdWVyeT1qcXVlcnkhLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbG93cHJvX2Zvcl9qcXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDI2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 263:
/***/ (function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar $ = __webpack_require__(\"shim/jquery\");\n\nSplunk.namespace(\"Splunk.Print\");\n/**\n * A simple class that dispatches jQuery document events Splunk.Print.START_EVENT, Splunk.Print.END_EVENT and Splunk.Print.PAGE_EVENT.\n * Flash movies are replaced with an image overlay if Flash printing not supported.\n * Dependencies on Splunk.util, Splunk.JABridge and jQuery.\n * \n * w00t print it is!\n * \n * @author Doc Yes\n */\n\nvar agentString = window.navigator.userAgent,\n    isIE = /msie/i.test(agentString),\n    isIE7 = /msie 7\\.0/i.test(agentString),\n    isIE8 = /msie 8\\.0/i.test(agentString);\n\nSplunk.Print = $.klass({\n    START_EVENT: \"PrintStart\",\n    END_EVENT: \"PrintEnd\",\n    PAGE_EVENT: \"PrintPage\",\n    // IE less than 9 is very inconsistent when it comes to setting print widths, so we err on the side of caution with 700px\n    // all other browsers work great with a standard 800px\n    PAGE_WIDTH: (isIE7 || isIE8) ? \"700px\" : \"800px\",\n    WINDOW_PRINT_END_EVENT_DELAY: 1000,\n    /**\n     * Initializes Print.\n     */\n    initialize: function(){\n        this.logger = Splunk.Logger.getLogger(\"Splunk.Print\");\n        $(document).bind(this.START_EVENT, this.onPrintStart.bind(this));\n        $(document).bind(this.END_EVENT, this.onPrintEnd.bind(this));\n        $(document).bind(this.PAGE_EVENT, this.onPrintPage.bind(this));\n        \n        // try binding to native print events\n        this.bindPrintEvents();\n    },\n    /**\n     * End of UI print event.\n     * \n     * @param {Object) event The jQuery passed event.\n     */\n    onPrintEnd: function(event){\n        this.logger.info(\"Splunk.Print.END_EVENT fired\");\n    },\n    /**\n     * Print page, emulates complete print lifecyle (PRINT_START event, window.print and PRINT_END event).\n     * NOTE: The excessive setTimeout use gives execution sequence.\n     * \n     * @param {Object} event The jQuery pass event.\n     */\n    onPrintPage: function(event) {\n        var bodyStyle = $('body')[0].style,\n            currentX = window.pageXOffset, \n            currentY = window.pageYOffset,\n            \n            printPrepare = function() {\n                $('body').addClass('print').css({\n                    'width': this.PAGE_WIDTH,\n                    'min-width': 0\n                });\n                window.scrollTo(0, document.body.offsetHeight);\n            }.bind(this),\n            \n            printCleanup = function() {\n                $('body').removeClass('print');\n                bodyStyle.width = \"\";\n                bodyStyle['min-width'] = '';\n                window.scrollTo(currentX, currentY);\n            };\n        \n        this.logger.info(\"Splunk.Print.PAGE_EVENT fired\");\n        if(isIE) {\n            printPrepare();\n            $(document).trigger(this.START_EVENT);\n            window.print();\n            printCleanup();\n            $(document).trigger(this.END_EVENT);\n        }\n        else if(this.isChromeThirteenPlus()) {\n            // have to special-case the newer versions of Chrome because they might or might not use the \"print preview\" feature\n            var printPreviewMode = false;\n            $(window).bind('blur.splunkPrint', function() {\n                // listen for an on-blur event, indicating that print preview mode has popped open a new tab\n                // in this case, attach an on-focus event that will perform the print cleanup\n                printPreviewMode = true;\n                $(window).bind('focus.splunkPrint', function() {\n                    printCleanup();\n                    $(document).trigger(this.END_EVENT);\n                    // now that our print preview handling work is done, clean up the event listeners\n                    $(window).unbind('.splunkPrint');\n                }.bind(this));\n            }.bind(this));\n            printPrepare();\n            setTimeout(function() {\n                $(document).trigger(this.START_EVENT);\n            }.bind(this),0);\n            setTimeout(function() {\n                window.print();\n                setTimeout(function() {\n                    // only trigger the print cleanup here if we are NOT in print preview mode,\n                    // because if we are we had no guarantee that window.print() was a synchronous operation\n                    if(!printPreviewMode) {\n                        printCleanup();\n                        // do the unbinding here too just in case\n                        $(window).unbind('.splunkPrint');\n                        $(document).trigger(this.END_EVENT);\n                    }\n                }.bind(this), this.WINDOW_PRINT_END_EVENT_DELAY);\n            }.bind(this), 0);\n        }\n        else {\n            printPrepare();\n            setTimeout(function() {\n                $(document).trigger(this.START_EVENT);\n            }.bind(this),0);\n            setTimeout(function() {\n                window.print();\n                setTimeout(function() {\n                    printCleanup();\n                    $(document).trigger(this.END_EVENT);\n                }.bind(this), this.WINDOW_PRINT_END_EVENT_DELAY);\n            }.bind(this), 0);\n        }\n    },\n    /**\n     * Start of a new UI print event. Find all JABridge instances, toggle visibility to hidden, replace with an overlay base64 snapshot received from flash (w00t!).\n     * \n     * @param {Object) event The jQuery passed event.\n     */\n    onPrintStart: function(event){\n        this.logger.info(\"Splunk.Print.START_EVENT fired\");\n    },\n    \n    bindPrintEvents: function() {\n        var onBeforePrint = function() {\n            $('body').css('width', this.PAGE_WIDTH);\n            $(document).trigger(this.START_EVENT);\n        }.bind(this);\n\n        var onAfterPrint = function() {\n            $('body').css('width', \"\");\n            $(document).trigger(this.END_EVENT);\n        }.bind(this);\n\n        if (window.onbeforeprint !== undefined) {\n            if (window.addEventListener) {\n                window.addEventListener('beforeprint', onBeforePrint, false);\n                window.addEventListener('afterprint', onAfterPrint, false);\n            } else if (window.attachEvent) {\n                window.attachEvent('onbeforeprint', onBeforePrint);\n                window.attachEvent('onafterprint', onAfterPrint);\n            }\n        } else if (window.matchMedia) {\n            var mediaQueryList = window.matchMedia('print');\n            if (mediaQueryList && mediaQueryList.addListener) {\n                mediaQueryList.addListener(function(mql) {\n                    if (mql) {\n                        if (mql.matches) {\n                            onBeforePrint();\n                        } else {\n                            onAfterPrint();\n                        }\n                    }\n                });\n            }\n        }\n    },\n    \n    // returns true if the user agent is Chrome and the version is 13 or higher\n    isChromeThirteenPlus: function() {\n        var chromeRegex = /chrome\\/(\\d+)/i,\n            chromeInfo = chromeRegex.exec(navigator.userAgent);\n        \n        return !!(chromeInfo && (parseInt(chromeInfo[1], 10) >= 13));\n    }\n    \n});\nSplunk.Print.instance = null;\n/**\n * Singleton reference to a Print object.\n *\n * @return A reference to a shared Print object.\n * @type Object\n */\nSplunk.Print.getInstance = function(){\n    if(!Splunk.Print.instance){\n        Splunk.Print.instance = new Splunk.Print();\n    }\n    return Splunk.Print.instance;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ByaW50LmpzPzRlMDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI2My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcblxuU3BsdW5rLm5hbWVzcGFjZShcIlNwbHVuay5QcmludFwiKTtcbi8qKlxuICogQSBzaW1wbGUgY2xhc3MgdGhhdCBkaXNwYXRjaGVzIGpRdWVyeSBkb2N1bWVudCBldmVudHMgU3BsdW5rLlByaW50LlNUQVJUX0VWRU5ULCBTcGx1bmsuUHJpbnQuRU5EX0VWRU5UIGFuZCBTcGx1bmsuUHJpbnQuUEFHRV9FVkVOVC5cbiAqIEZsYXNoIG1vdmllcyBhcmUgcmVwbGFjZWQgd2l0aCBhbiBpbWFnZSBvdmVybGF5IGlmIEZsYXNoIHByaW50aW5nIG5vdCBzdXBwb3J0ZWQuXG4gKiBEZXBlbmRlbmNpZXMgb24gU3BsdW5rLnV0aWwsIFNwbHVuay5KQUJyaWRnZSBhbmQgalF1ZXJ5LlxuICogXG4gKiB3MDB0IHByaW50IGl0IGlzIVxuICogXG4gKiBAYXV0aG9yIERvYyBZZXNcbiAqL1xuXG52YXIgYWdlbnRTdHJpbmcgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICBpc0lFID0gL21zaWUvaS50ZXN0KGFnZW50U3RyaW5nKSxcbiAgICBpc0lFNyA9IC9tc2llIDdcXC4wL2kudGVzdChhZ2VudFN0cmluZyksXG4gICAgaXNJRTggPSAvbXNpZSA4XFwuMC9pLnRlc3QoYWdlbnRTdHJpbmcpO1xuXG5TcGx1bmsuUHJpbnQgPSAkLmtsYXNzKHtcbiAgICBTVEFSVF9FVkVOVDogXCJQcmludFN0YXJ0XCIsXG4gICAgRU5EX0VWRU5UOiBcIlByaW50RW5kXCIsXG4gICAgUEFHRV9FVkVOVDogXCJQcmludFBhZ2VcIixcbiAgICAvLyBJRSBsZXNzIHRoYW4gOSBpcyB2ZXJ5IGluY29uc2lzdGVudCB3aGVuIGl0IGNvbWVzIHRvIHNldHRpbmcgcHJpbnQgd2lkdGhzLCBzbyB3ZSBlcnIgb24gdGhlIHNpZGUgb2YgY2F1dGlvbiB3aXRoIDcwMHB4XG4gICAgLy8gYWxsIG90aGVyIGJyb3dzZXJzIHdvcmsgZ3JlYXQgd2l0aCBhIHN0YW5kYXJkIDgwMHB4XG4gICAgUEFHRV9XSURUSDogKGlzSUU3IHx8IGlzSUU4KSA/IFwiNzAwcHhcIiA6IFwiODAwcHhcIixcbiAgICBXSU5ET1dfUFJJTlRfRU5EX0VWRU5UX0RFTEFZOiAxMDAwLFxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFByaW50LlxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gU3BsdW5rLkxvZ2dlci5nZXRMb2dnZXIoXCJTcGx1bmsuUHJpbnRcIik7XG4gICAgICAgICQoZG9jdW1lbnQpLmJpbmQodGhpcy5TVEFSVF9FVkVOVCwgdGhpcy5vblByaW50U3RhcnQuYmluZCh0aGlzKSk7XG4gICAgICAgICQoZG9jdW1lbnQpLmJpbmQodGhpcy5FTkRfRVZFTlQsIHRoaXMub25QcmludEVuZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgJChkb2N1bWVudCkuYmluZCh0aGlzLlBBR0VfRVZFTlQsIHRoaXMub25QcmludFBhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIFxuICAgICAgICAvLyB0cnkgYmluZGluZyB0byBuYXRpdmUgcHJpbnQgZXZlbnRzXG4gICAgICAgIHRoaXMuYmluZFByaW50RXZlbnRzKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmQgb2YgVUkgcHJpbnQgZXZlbnQuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtPYmplY3QpIGV2ZW50IFRoZSBqUXVlcnkgcGFzc2VkIGV2ZW50LlxuICAgICAqL1xuICAgIG9uUHJpbnRFbmQ6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIlNwbHVuay5QcmludC5FTkRfRVZFTlQgZmlyZWRcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQcmludCBwYWdlLCBlbXVsYXRlcyBjb21wbGV0ZSBwcmludCBsaWZlY3lsZSAoUFJJTlRfU1RBUlQgZXZlbnQsIHdpbmRvdy5wcmludCBhbmQgUFJJTlRfRU5EIGV2ZW50KS5cbiAgICAgKiBOT1RFOiBUaGUgZXhjZXNzaXZlIHNldFRpbWVvdXQgdXNlIGdpdmVzIGV4ZWN1dGlvbiBzZXF1ZW5jZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGpRdWVyeSBwYXNzIGV2ZW50LlxuICAgICAqL1xuICAgIG9uUHJpbnRQYWdlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgYm9keVN0eWxlID0gJCgnYm9keScpWzBdLnN0eWxlLFxuICAgICAgICAgICAgY3VycmVudFggPSB3aW5kb3cucGFnZVhPZmZzZXQsIFxuICAgICAgICAgICAgY3VycmVudFkgPSB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHByaW50UHJlcGFyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQoJ2JvZHknKS5hZGRDbGFzcygncHJpbnQnKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOiB0aGlzLlBBR0VfV0lEVEgsXG4gICAgICAgICAgICAgICAgICAgICdtaW4td2lkdGgnOiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcHJpbnRDbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdwcmludCcpO1xuICAgICAgICAgICAgICAgIGJvZHlTdHlsZS53aWR0aCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgYm9keVN0eWxlWydtaW4td2lkdGgnXSA9ICcnO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhjdXJyZW50WCwgY3VycmVudFkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJTcGx1bmsuUHJpbnQuUEFHRV9FVkVOVCBmaXJlZFwiKTtcbiAgICAgICAgaWYoaXNJRSkge1xuICAgICAgICAgICAgcHJpbnRQcmVwYXJlKCk7XG4gICAgICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKHRoaXMuU1RBUlRfRVZFTlQpO1xuICAgICAgICAgICAgd2luZG93LnByaW50KCk7XG4gICAgICAgICAgICBwcmludENsZWFudXAoKTtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIodGhpcy5FTkRfRVZFTlQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhpcy5pc0Nocm9tZVRoaXJ0ZWVuUGx1cygpKSB7XG4gICAgICAgICAgICAvLyBoYXZlIHRvIHNwZWNpYWwtY2FzZSB0aGUgbmV3ZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGJlY2F1c2UgdGhleSBtaWdodCBvciBtaWdodCBub3QgdXNlIHRoZSBcInByaW50IHByZXZpZXdcIiBmZWF0dXJlXG4gICAgICAgICAgICB2YXIgcHJpbnRQcmV2aWV3TW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgJCh3aW5kb3cpLmJpbmQoJ2JsdXIuc3BsdW5rUHJpbnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW4gZm9yIGFuIG9uLWJsdXIgZXZlbnQsIGluZGljYXRpbmcgdGhhdCBwcmludCBwcmV2aWV3IG1vZGUgaGFzIHBvcHBlZCBvcGVuIGEgbmV3IHRhYlxuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSwgYXR0YWNoIGFuIG9uLWZvY3VzIGV2ZW50IHRoYXQgd2lsbCBwZXJmb3JtIHRoZSBwcmludCBjbGVhbnVwXG4gICAgICAgICAgICAgICAgcHJpbnRQcmV2aWV3TW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgJCh3aW5kb3cpLmJpbmQoJ2ZvY3VzLnNwbHVua1ByaW50JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50Q2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKHRoaXMuRU5EX0VWRU5UKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm93IHRoYXQgb3VyIHByaW50IHByZXZpZXcgaGFuZGxpbmcgd29yayBpcyBkb25lLCBjbGVhbiB1cCB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgICAgICQod2luZG93KS51bmJpbmQoJy5zcGx1bmtQcmludCcpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcHJpbnRQcmVwYXJlKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIodGhpcy5TVEFSVF9FVkVOVCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksMCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5wcmludCgpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciB0aGUgcHJpbnQgY2xlYW51cCBoZXJlIGlmIHdlIGFyZSBOT1QgaW4gcHJpbnQgcHJldmlldyBtb2RlLFxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGlmIHdlIGFyZSB3ZSBoYWQgbm8gZ3VhcmFudGVlIHRoYXQgd2luZG93LnByaW50KCkgd2FzIGEgc3luY2hyb25vdXMgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmKCFwcmludFByZXZpZXdNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludENsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIHRoZSB1bmJpbmRpbmcgaGVyZSB0b28ganVzdCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHdpbmRvdykudW5iaW5kKCcuc3BsdW5rUHJpbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIodGhpcy5FTkRfRVZFTlQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLldJTkRPV19QUklOVF9FTkRfRVZFTlRfREVMQVkpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByaW50UHJlcGFyZSgpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKHRoaXMuU1RBUlRfRVZFTlQpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLDApO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucHJpbnQoKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBwcmludENsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudCkudHJpZ2dlcih0aGlzLkVORF9FVkVOVCk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLldJTkRPV19QUklOVF9FTkRfRVZFTlRfREVMQVkpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogU3RhcnQgb2YgYSBuZXcgVUkgcHJpbnQgZXZlbnQuIEZpbmQgYWxsIEpBQnJpZGdlIGluc3RhbmNlcywgdG9nZ2xlIHZpc2liaWxpdHkgdG8gaGlkZGVuLCByZXBsYWNlIHdpdGggYW4gb3ZlcmxheSBiYXNlNjQgc25hcHNob3QgcmVjZWl2ZWQgZnJvbSBmbGFzaCAodzAwdCEpLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0KSBldmVudCBUaGUgalF1ZXJ5IHBhc3NlZCBldmVudC5cbiAgICAgKi9cbiAgICBvblByaW50U3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIlNwbHVuay5QcmludC5TVEFSVF9FVkVOVCBmaXJlZFwiKTtcbiAgICB9LFxuICAgIFxuICAgIGJpbmRQcmludEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbkJlZm9yZVByaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKCdib2R5JykuY3NzKCd3aWR0aCcsIHRoaXMuUEFHRV9XSURUSCk7XG4gICAgICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKHRoaXMuU1RBUlRfRVZFTlQpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdmFyIG9uQWZ0ZXJQcmludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCgnYm9keScpLmNzcygnd2lkdGgnLCBcIlwiKTtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIodGhpcy5FTkRfRVZFTlQpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5vbmJlZm9yZXByaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVwcmludCcsIG9uQmVmb3JlUHJpbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYWZ0ZXJwcmludCcsIG9uQWZ0ZXJQcmludCwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29uYmVmb3JlcHJpbnQnLCBvbkJlZm9yZVByaW50KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29uYWZ0ZXJwcmludCcsIG9uQWZ0ZXJQcmludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICAgIHZhciBtZWRpYVF1ZXJ5TGlzdCA9IHdpbmRvdy5tYXRjaE1lZGlhKCdwcmludCcpO1xuICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnlMaXN0ICYmIG1lZGlhUXVlcnlMaXN0LmFkZExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbWVkaWFRdWVyeUxpc3QuYWRkTGlzdGVuZXIoZnVuY3Rpb24obXFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtcWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtcWwubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQmVmb3JlUHJpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25BZnRlclByaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgLy8gcmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIGFnZW50IGlzIENocm9tZSBhbmQgdGhlIHZlcnNpb24gaXMgMTMgb3IgaGlnaGVyXG4gICAgaXNDaHJvbWVUaGlydGVlblBsdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hyb21lUmVnZXggPSAvY2hyb21lXFwvKFxcZCspL2ksXG4gICAgICAgICAgICBjaHJvbWVJbmZvID0gY2hyb21lUmVnZXguZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAhIShjaHJvbWVJbmZvICYmIChwYXJzZUludChjaHJvbWVJbmZvWzFdLCAxMCkgPj0gMTMpKTtcbiAgICB9XG4gICAgXG59KTtcblNwbHVuay5QcmludC5pbnN0YW5jZSA9IG51bGw7XG4vKipcbiAqIFNpbmdsZXRvbiByZWZlcmVuY2UgdG8gYSBQcmludCBvYmplY3QuXG4gKlxuICogQHJldHVybiBBIHJlZmVyZW5jZSB0byBhIHNoYXJlZCBQcmludCBvYmplY3QuXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xuU3BsdW5rLlByaW50LmdldEluc3RhbmNlID0gZnVuY3Rpb24oKXtcbiAgICBpZighU3BsdW5rLlByaW50Lmluc3RhbmNlKXtcbiAgICAgICAgU3BsdW5rLlByaW50Lmluc3RhbmNlID0gbmV3IFNwbHVuay5QcmludCgpO1xuICAgIH1cbiAgICByZXR1cm4gU3BsdW5rLlByaW50Lmluc3RhbmNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pbXBvcnRzLWxvYWRlcj8kPWpxdWVyeSEuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvcHJpbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "mixins/DataSourceMixin":
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n__webpack_require__(10);\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _underscore = __webpack_require__(\"require/underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar DataSourceMixin = {\n    getAllDataSources: function getAllDataSources() {\n        return this.dataSources || [];\n    },\n    getDataSource: function getDataSource(dataSourceName) {\n        return (0, _underscore2.default)(this.getAllDataSources()).find(function (ds) {\n            return ds.name === dataSourceName;\n        });\n    },\n    getPrimaryDataSource: function getPrimaryDataSource() {\n        return this.getDataSource('primary');\n    }\n};\n\nexports.default = DataSourceMixin;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL21peGlucy9EYXRhU291cmNlTWl4aW4uZXM/M2UyZCJdLCJuYW1lcyI6WyJEYXRhU291cmNlTWl4aW4iLCJnZXRBbGxEYXRhU291cmNlcyIsImRhdGFTb3VyY2VzIiwiZ2V0RGF0YVNvdXJjZSIsImRhdGFTb3VyY2VOYW1lIiwiZmluZCIsImRzIiwibmFtZSIsImdldFByaW1hcnlEYXRhU291cmNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7QUFFQSxJQUFNQSxrQkFBa0I7QUFDcEJDLHFCQURvQiwrQkFDQTtBQUNoQixlQUFPLEtBQUtDLFdBQUwsSUFBb0IsRUFBM0I7QUFDSCxLQUhtQjtBQUlwQkMsaUJBSm9CLHlCQUlOQyxjQUpNLEVBSVU7QUFDMUIsZUFBTywwQkFBRSxLQUFLSCxpQkFBTCxFQUFGLEVBQTRCSSxJQUE1QixDQUFpQztBQUFBLG1CQUNwQ0MsR0FBR0MsSUFBSCxLQUFZSCxjQUR3QjtBQUFBLFNBQWpDLENBQVA7QUFHSCxLQVJtQjtBQVNwQkksd0JBVG9CLGtDQVNHO0FBQ25CLGVBQU8sS0FBS0wsYUFBTCxDQUFtQixTQUFuQixDQUFQO0FBQ0g7QUFYbUIsQ0FBeEI7O2tCQWNlSCxlIiwiZmlsZSI6Im1peGlucy9EYXRhU291cmNlTWl4aW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxuY29uc3QgRGF0YVNvdXJjZU1peGluID0ge1xuICAgIGdldEFsbERhdGFTb3VyY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlcyB8fCBbXTtcbiAgICB9LFxuICAgIGdldERhdGFTb3VyY2UoZGF0YVNvdXJjZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF8odGhpcy5nZXRBbGxEYXRhU291cmNlcygpKS5maW5kKGRzID0+IChcbiAgICAgICAgICAgIGRzLm5hbWUgPT09IGRhdGFTb3VyY2VOYW1lXG4gICAgICAgICkpO1xuICAgIH0sXG4gICAgZ2V0UHJpbWFyeURhdGFTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFTb3VyY2UoJ3ByaW1hcnknKTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YVNvdXJjZU1peGluO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9taXhpbnMvRGF0YVNvdXJjZU1peGluLmVzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "shim/jquery.resize":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"shim/jquery.ui.core\"),\n        __webpack_require__(\"shim/jquery.ui.widget\"),\n        __webpack_require__(\"shim/jquery.ui.mouse\"),\n        __webpack_require__(267)], __WEBPACK_AMD_DEFINE_RESULT__ = function($) {\n    // The plugin itself does not prevent bubbling of the resize events, add that here.\n    $.event.special.elementResize.noBubble = true;\n    return $;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vanF1ZXJ5LnJlc2l6ZS5qcz83YmYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJzaGltL2pxdWVyeS5yZXNpemUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydqcXVlcnknLFxuICAgICAgICAnanF1ZXJ5LnVpLmNvcmUnLFxuICAgICAgICAnanF1ZXJ5LnVpLndpZGdldCcsXG4gICAgICAgICdqcXVlcnkudWkubW91c2UnLFxuICAgICAgICAnaW1wb3J0cz9qUXVlcnk9anF1ZXJ5LHRoaXM9PndpbmRvdyFjb250cmliL2pxdWVyeS1yZXNpemUnXSwgZnVuY3Rpb24oJCkge1xuICAgIC8vIFRoZSBwbHVnaW4gaXRzZWxmIGRvZXMgbm90IHByZXZlbnQgYnViYmxpbmcgb2YgdGhlIHJlc2l6ZSBldmVudHMsIGFkZCB0aGF0IGhlcmUuXG4gICAgJC5ldmVudC5zcGVjaWFsLmVsZW1lbnRSZXNpemUubm9CdWJibGUgPSB0cnVlO1xuICAgIHJldHVybiAkO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vanF1ZXJ5LnJlc2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gc2hpbS9qcXVlcnkucmVzaXplXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "shim/jquery.ui.core":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/jquery\"), __webpack_require__(264)], __WEBPACK_AMD_DEFINE_RESULT__ = function($) {\n    return $;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vanF1ZXJ5LnVpLmNvcmUuanM/NzgzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoic2hpbS9qcXVlcnkudWkuY29yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbJ2pxdWVyeScsICdpbXBvcnRzP2pRdWVyeT1qcXVlcnkhY29udHJpYi9qcXVlcnktdWktMS4xMC40L2pxdWVyeS51aS5jb3JlJ10sIGZ1bmN0aW9uKCQpIHtcbiAgICByZXR1cm4gJDtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zaGltL2pxdWVyeS51aS5jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSBzaGltL2pxdWVyeS51aS5jb3JlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 264:
/***/ (function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(\"shim/jquery\");\n\n/*!\n * jQuery UI Core 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n(function( $, undefined ) {\n\nvar uuid = 0,\n\truniqueId = /^ui-id-\\d+$/;\n\n// $.ui might exist from components with no dependencies, e.g., $.ui.position\n$.ui = $.ui || {};\n\n$.extend( $.ui, {\n\tversion: \"1.10.4\",\n\n\tkeyCode: {\n\t\tBACKSPACE: 8,\n\t\tCOMMA: 188,\n\t\tDELETE: 46,\n\t\tDOWN: 40,\n\t\tEND: 35,\n\t\tENTER: 13,\n\t\tESCAPE: 27,\n\t\tHOME: 36,\n\t\tLEFT: 37,\n\t\tNUMPAD_ADD: 107,\n\t\tNUMPAD_DECIMAL: 110,\n\t\tNUMPAD_DIVIDE: 111,\n\t\tNUMPAD_ENTER: 108,\n\t\tNUMPAD_MULTIPLY: 106,\n\t\tNUMPAD_SUBTRACT: 109,\n\t\tPAGE_DOWN: 34,\n\t\tPAGE_UP: 33,\n\t\tPERIOD: 190,\n\t\tRIGHT: 39,\n\t\tSPACE: 32,\n\t\tTAB: 9,\n\t\tUP: 38\n\t}\n});\n\n// plugins\n$.fn.extend({\n\tfocus: (function( orig ) {\n\t\treturn function( delay, fn ) {\n\t\t\treturn typeof delay === \"number\" ?\n\t\t\t\tthis.each(function() {\n\t\t\t\t\tvar elem = this;\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t$( elem ).focus();\n\t\t\t\t\t\tif ( fn ) {\n\t\t\t\t\t\t\tfn.call( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay );\n\t\t\t\t}) :\n\t\t\t\torig.apply( this, arguments );\n\t\t};\n\t})( $.fn.focus ),\n\n\tscrollParent: function() {\n\t\tvar scrollParent;\n\t\tif (($.ui.ie && (/(static|relative)/).test(this.css(\"position\"))) || (/absolute/).test(this.css(\"position\"))) {\n\t\t\tscrollParent = this.parents().filter(function() {\n\t\t\t\treturn (/(relative|absolute|fixed)/).test($.css(this,\"position\")) && (/(auto|scroll)/).test($.css(this,\"overflow\")+$.css(this,\"overflow-y\")+$.css(this,\"overflow-x\"));\n\t\t\t}).eq(0);\n\t\t} else {\n\t\t\tscrollParent = this.parents().filter(function() {\n\t\t\t\treturn (/(auto|scroll)/).test($.css(this,\"overflow\")+$.css(this,\"overflow-y\")+$.css(this,\"overflow-x\"));\n\t\t\t}).eq(0);\n\t\t}\n\n\t\treturn (/fixed/).test(this.css(\"position\")) || !scrollParent.length ? $(document) : scrollParent;\n\t},\n\n\tzIndex: function( zIndex ) {\n\t\tif ( zIndex !== undefined ) {\n\t\t\treturn this.css( \"zIndex\", zIndex );\n\t\t}\n\n\t\tif ( this.length ) {\n\t\t\tvar elem = $( this[ 0 ] ), position, value;\n\t\t\twhile ( elem.length && elem[ 0 ] !== document ) {\n\t\t\t\t// Ignore z-index if position is set to a value where z-index is ignored by the browser\n\t\t\t\t// This makes behavior of this function consistent across browsers\n\t\t\t\t// WebKit always returns auto if the element is positioned\n\t\t\t\tposition = elem.css( \"position\" );\n\t\t\t\tif ( position === \"absolute\" || position === \"relative\" || position === \"fixed\" ) {\n\t\t\t\t\t// IE returns 0 when zIndex is not specified\n\t\t\t\t\t// other browsers return a string\n\t\t\t\t\t// we ignore the case of nested elements with an explicit value of 0\n\t\t\t\t\t// <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n\t\t\t\t\tvalue = parseInt( elem.css( \"zIndex\" ), 10 );\n\t\t\t\t\tif ( !isNaN( value ) && value !== 0 ) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telem = elem.parent();\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t},\n\n\tuniqueId: function() {\n\t\treturn this.each(function() {\n\t\t\tif ( !this.id ) {\n\t\t\t\tthis.id = \"ui-id-\" + (++uuid);\n\t\t\t}\n\t\t});\n\t},\n\n\tremoveUniqueId: function() {\n\t\treturn this.each(function() {\n\t\t\tif ( runiqueId.test( this.id ) ) {\n\t\t\t\t$( this ).removeAttr( \"id\" );\n\t\t\t}\n\t\t});\n\t}\n});\n\n// selectors\nfunction focusable( element, isTabIndexNotNaN ) {\n\tvar map, mapName, img,\n\t\tnodeName = element.nodeName.toLowerCase();\n\tif ( \"area\" === nodeName ) {\n\t\tmap = element.parentNode;\n\t\tmapName = map.name;\n\t\tif ( !element.href || !mapName || map.nodeName.toLowerCase() !== \"map\" ) {\n\t\t\treturn false;\n\t\t}\n\t\timg = $( \"img[usemap=#\" + mapName + \"]\" )[0];\n\t\treturn !!img && visible( img );\n\t}\n\treturn ( /input|select|textarea|button|object/.test( nodeName ) ?\n\t\t!element.disabled :\n\t\t\"a\" === nodeName ?\n\t\t\telement.href || isTabIndexNotNaN :\n\t\t\tisTabIndexNotNaN) &&\n\t\t// the element and all of its ancestors must be visible\n\t\tvisible( element );\n}\n\nfunction visible( element ) {\n\treturn $.expr.filters.visible( element ) &&\n\t\t!$( element ).parents().addBack().filter(function() {\n\t\t\treturn $.css( this, \"visibility\" ) === \"hidden\";\n\t\t}).length;\n}\n\n$.extend( $.expr[ \":\" ], {\n\tdata: $.expr.createPseudo ?\n\t\t$.expr.createPseudo(function( dataName ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn !!$.data( elem, dataName );\n\t\t\t};\n\t\t}) :\n\t\t// support: jQuery <1.8\n\t\tfunction( elem, i, match ) {\n\t\t\treturn !!$.data( elem, match[ 3 ] );\n\t\t},\n\n\tfocusable: function( element ) {\n\t\treturn focusable( element, !isNaN( $.attr( element, \"tabindex\" ) ) );\n\t},\n\n\ttabbable: function( element ) {\n\t\tvar tabIndex = $.attr( element, \"tabindex\" ),\n\t\t\tisTabIndexNaN = isNaN( tabIndex );\n\t\treturn ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n\t}\n});\n\n// support: jQuery <1.8\nif ( !$( \"<a>\" ).outerWidth( 1 ).jquery ) {\n\t$.each( [ \"Width\", \"Height\" ], function( i, name ) {\n\t\tvar side = name === \"Width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ],\n\t\t\ttype = name.toLowerCase(),\n\t\t\torig = {\n\t\t\t\tinnerWidth: $.fn.innerWidth,\n\t\t\t\tinnerHeight: $.fn.innerHeight,\n\t\t\t\touterWidth: $.fn.outerWidth,\n\t\t\t\touterHeight: $.fn.outerHeight\n\t\t\t};\n\n\t\tfunction reduce( elem, size, border, margin ) {\n\t\t\t$.each( side, function() {\n\t\t\t\tsize -= parseFloat( $.css( elem, \"padding\" + this ) ) || 0;\n\t\t\t\tif ( border ) {\n\t\t\t\t\tsize -= parseFloat( $.css( elem, \"border\" + this + \"Width\" ) ) || 0;\n\t\t\t\t}\n\t\t\t\tif ( margin ) {\n\t\t\t\t\tsize -= parseFloat( $.css( elem, \"margin\" + this ) ) || 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn size;\n\t\t}\n\n\t\t$.fn[ \"inner\" + name ] = function( size ) {\n\t\t\tif ( size === undefined ) {\n\t\t\t\treturn orig[ \"inner\" + name ].call( this );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\t$( this ).css( type, reduce( this, size ) + \"px\" );\n\t\t\t});\n\t\t};\n\n\t\t$.fn[ \"outer\" + name] = function( size, margin ) {\n\t\t\tif ( typeof size !== \"number\" ) {\n\t\t\t\treturn orig[ \"outer\" + name ].call( this, size );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\t$( this).css( type, reduce( this, size, true, margin ) + \"px\" );\n\t\t\t});\n\t\t};\n\t});\n}\n\n// support: jQuery <1.8\nif ( !$.fn.addBack ) {\n\t$.fn.addBack = function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t};\n}\n\n// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\nif ( $( \"<a>\" ).data( \"a-b\", \"a\" ).removeData( \"a-b\" ).data( \"a-b\" ) ) {\n\t$.fn.removeData = (function( removeData ) {\n\t\treturn function( key ) {\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn removeData.call( this, $.camelCase( key ) );\n\t\t\t} else {\n\t\t\t\treturn removeData.call( this );\n\t\t\t}\n\t\t};\n\t})( $.fn.removeData );\n}\n\n\n\n\n\n// deprecated\n$.ui.ie = !!/msie [\\w.]+/.exec( navigator.userAgent.toLowerCase() );\n\n$.support.selectstart = \"onselectstart\" in document.createElement( \"div\" );\n$.fn.extend({\n\tdisableSelection: function() {\n\t\treturn this.bind( ( $.support.selectstart ? \"selectstart\" : \"mousedown\" ) +\n\t\t\t\".ui-disableSelection\", function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\t},\n\n\tenableSelection: function() {\n\t\treturn this.unbind( \".ui-disableSelection\" );\n\t}\n});\n\n$.extend( $.ui, {\n\t// $.ui.plugin is deprecated. Use $.widget() extensions instead.\n\tplugin: {\n\t\tadd: function( module, option, set ) {\n\t\t\tvar i,\n\t\t\t\tproto = $.ui[ module ].prototype;\n\t\t\tfor ( i in set ) {\n\t\t\t\tproto.plugins[ i ] = proto.plugins[ i ] || [];\n\t\t\t\tproto.plugins[ i ].push( [ option, set[ i ] ] );\n\t\t\t}\n\t\t},\n\t\tcall: function( instance, name, args ) {\n\t\t\tvar i,\n\t\t\t\tset = instance.plugins[ name ];\n\t\t\tif ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < set.length; i++ ) {\n\t\t\t\tif ( instance.options[ set[ i ][ 0 ] ] ) {\n\t\t\t\t\tset[ i ][ 1 ].apply( instance.element, args );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// only used by resizable\n\thasScroll: function( el, a ) {\n\n\t\t//If overflow is hidden, the element might have extra content, but the user wants to hide it\n\t\tif ( $( el ).css( \"overflow\" ) === \"hidden\") {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar scroll = ( a && a === \"left\" ) ? \"scrollLeft\" : \"scrollTop\",\n\t\t\thas = false;\n\n\t\tif ( el[ scroll ] > 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// TODO: determine which cases actually cause this to happen\n\t\t// if the element doesn't have the scroll set, see if it's possible to\n\t\t// set the scroll\n\t\tel[ scroll ] = 1;\n\t\thas = ( el[ scroll ] > 0 );\n\t\tel[ scroll ] = 0;\n\t\treturn has;\n\t}\n});\n\n})( jQuery );\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvanF1ZXJ5LXVpLTEuMTAuNC9qcXVlcnkudWkuY29yZS5qcz9lOWIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7OztBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDIiwiZmlsZSI6IjI2NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBDb3JlIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9jYXRlZ29yeS91aS1jb3JlL1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHV1aWQgPSAwLFxuXHRydW5pcXVlSWQgPSAvXnVpLWlkLVxcZCskLztcblxuLy8gJC51aSBtaWdodCBleGlzdCBmcm9tIGNvbXBvbmVudHMgd2l0aCBubyBkZXBlbmRlbmNpZXMsIGUuZy4sICQudWkucG9zaXRpb25cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG4kLmV4dGVuZCggJC51aSwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuNFwiLFxuXG5cdGtleUNvZGU6IHtcblx0XHRCQUNLU1BBQ0U6IDgsXG5cdFx0Q09NTUE6IDE4OCxcblx0XHRERUxFVEU6IDQ2LFxuXHRcdERPV046IDQwLFxuXHRcdEVORDogMzUsXG5cdFx0RU5URVI6IDEzLFxuXHRcdEVTQ0FQRTogMjcsXG5cdFx0SE9NRTogMzYsXG5cdFx0TEVGVDogMzcsXG5cdFx0TlVNUEFEX0FERDogMTA3LFxuXHRcdE5VTVBBRF9ERUNJTUFMOiAxMTAsXG5cdFx0TlVNUEFEX0RJVklERTogMTExLFxuXHRcdE5VTVBBRF9FTlRFUjogMTA4LFxuXHRcdE5VTVBBRF9NVUxUSVBMWTogMTA2LFxuXHRcdE5VTVBBRF9TVUJUUkFDVDogMTA5LFxuXHRcdFBBR0VfRE9XTjogMzQsXG5cdFx0UEFHRV9VUDogMzMsXG5cdFx0UEVSSU9EOiAxOTAsXG5cdFx0UklHSFQ6IDM5LFxuXHRcdFNQQUNFOiAzMixcblx0XHRUQUI6IDksXG5cdFx0VVA6IDM4XG5cdH1cbn0pO1xuXG4vLyBwbHVnaW5zXG4kLmZuLmV4dGVuZCh7XG5cdGZvY3VzOiAoZnVuY3Rpb24oIG9yaWcgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBkZWxheSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiID9cblx0XHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0JCggZWxlbSApLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRpZiAoIGZuICkge1xuXHRcdFx0XHRcdFx0XHRmbi5jYWxsKCBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgZGVsYXkgKTtcblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXHR9KSggJC5mbi5mb2N1cyApLFxuXG5cdHNjcm9sbFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjcm9sbFBhcmVudDtcblx0XHRpZiAoKCQudWkuaWUgJiYgKC8oc3RhdGljfHJlbGF0aXZlKS8pLnRlc3QodGhpcy5jc3MoXCJwb3NpdGlvblwiKSkpIHx8ICgvYWJzb2x1dGUvKS50ZXN0KHRoaXMuY3NzKFwicG9zaXRpb25cIikpKSB7XG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0aGlzLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAoLyhyZWxhdGl2ZXxhYnNvbHV0ZXxmaXhlZCkvKS50ZXN0KCQuY3NzKHRoaXMsXCJwb3NpdGlvblwiKSkgJiYgKC8oYXV0b3xzY3JvbGwpLykudGVzdCgkLmNzcyh0aGlzLFwib3ZlcmZsb3dcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXlcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXhcIikpO1xuXHRcdFx0fSkuZXEoMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoJC5jc3ModGhpcyxcIm92ZXJmbG93XCIpKyQuY3NzKHRoaXMsXCJvdmVyZmxvdy15XCIpKyQuY3NzKHRoaXMsXCJvdmVyZmxvdy14XCIpKTtcblx0XHRcdH0pLmVxKDApO1xuXHRcdH1cblxuXHRcdHJldHVybiAoL2ZpeGVkLykudGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKSB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/ICQoZG9jdW1lbnQpIDogc2Nyb2xsUGFyZW50O1xuXHR9LFxuXG5cdHpJbmRleDogZnVuY3Rpb24oIHpJbmRleCApIHtcblx0XHRpZiAoIHpJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3NzKCBcInpJbmRleFwiLCB6SW5kZXggKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzWyAwIF0gKSwgcG9zaXRpb24sIHZhbHVlO1xuXHRcdFx0d2hpbGUgKCBlbGVtLmxlbmd0aCAmJiBlbGVtWyAwIF0gIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHQvLyBJZ25vcmUgei1pbmRleCBpZiBwb3NpdGlvbiBpcyBzZXQgdG8gYSB2YWx1ZSB3aGVyZSB6LWluZGV4IGlzIGlnbm9yZWQgYnkgdGhlIGJyb3dzZXJcblx0XHRcdFx0Ly8gVGhpcyBtYWtlcyBiZWhhdmlvciBvZiB0aGlzIGZ1bmN0aW9uIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzXG5cdFx0XHRcdC8vIFdlYktpdCBhbHdheXMgcmV0dXJucyBhdXRvIGlmIHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWRcblx0XHRcdFx0cG9zaXRpb24gPSBlbGVtLmNzcyggXCJwb3NpdGlvblwiICk7XG5cdFx0XHRcdGlmICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHRcdFx0Ly8gSUUgcmV0dXJucyAwIHdoZW4gekluZGV4IGlzIG5vdCBzcGVjaWZpZWRcblx0XHRcdFx0XHQvLyBvdGhlciBicm93c2VycyByZXR1cm4gYSBzdHJpbmdcblx0XHRcdFx0XHQvLyB3ZSBpZ25vcmUgdGhlIGNhc2Ugb2YgbmVzdGVkIGVsZW1lbnRzIHdpdGggYW4gZXhwbGljaXQgdmFsdWUgb2YgMFxuXHRcdFx0XHRcdC8vIDxkaXYgc3R5bGU9XCJ6LWluZGV4OiAtMTA7XCI+PGRpdiBzdHlsZT1cInotaW5kZXg6IDA7XCI+PC9kaXY+PC9kaXY+XG5cdFx0XHRcdFx0dmFsdWUgPSBwYXJzZUludCggZWxlbS5jc3MoIFwiekluZGV4XCIgKSwgMTAgKTtcblx0XHRcdFx0XHRpZiAoICFpc05hTiggdmFsdWUgKSAmJiB2YWx1ZSAhPT0gMCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbSA9IGVsZW0ucGFyZW50KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0dW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICF0aGlzLmlkICkge1xuXHRcdFx0XHR0aGlzLmlkID0gXCJ1aS1pZC1cIiArICgrK3V1aWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHJlbW92ZVVuaXF1ZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBydW5pcXVlSWQudGVzdCggdGhpcy5pZCApICkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQXR0ciggXCJpZFwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4vLyBzZWxlY3RvcnNcbmZ1bmN0aW9uIGZvY3VzYWJsZSggZWxlbWVudCwgaXNUYWJJbmRleE5vdE5hTiApIHtcblx0dmFyIG1hcCwgbWFwTmFtZSwgaW1nLFxuXHRcdG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoIFwiYXJlYVwiID09PSBub2RlTmFtZSApIHtcblx0XHRtYXAgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0bWFwTmFtZSA9IG1hcC5uYW1lO1xuXHRcdGlmICggIWVsZW1lbnQuaHJlZiB8fCAhbWFwTmFtZSB8fCBtYXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJtYXBcIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aW1nID0gJCggXCJpbWdbdXNlbWFwPSNcIiArIG1hcE5hbWUgKyBcIl1cIiApWzBdO1xuXHRcdHJldHVybiAhIWltZyAmJiB2aXNpYmxlKCBpbWcgKTtcblx0fVxuXHRyZXR1cm4gKCAvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QvLnRlc3QoIG5vZGVOYW1lICkgP1xuXHRcdCFlbGVtZW50LmRpc2FibGVkIDpcblx0XHRcImFcIiA9PT0gbm9kZU5hbWUgP1xuXHRcdFx0ZWxlbWVudC5ocmVmIHx8IGlzVGFiSW5kZXhOb3ROYU4gOlxuXHRcdFx0aXNUYWJJbmRleE5vdE5hTikgJiZcblx0XHQvLyB0aGUgZWxlbWVudCBhbmQgYWxsIG9mIGl0cyBhbmNlc3RvcnMgbXVzdCBiZSB2aXNpYmxlXG5cdFx0dmlzaWJsZSggZWxlbWVudCApO1xufVxuXG5mdW5jdGlvbiB2aXNpYmxlKCBlbGVtZW50ICkge1xuXHRyZXR1cm4gJC5leHByLmZpbHRlcnMudmlzaWJsZSggZWxlbWVudCApICYmXG5cdFx0ISQoIGVsZW1lbnQgKS5wYXJlbnRzKCkuYWRkQmFjaygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAkLmNzcyggdGhpcywgXCJ2aXNpYmlsaXR5XCIgKSA9PT0gXCJoaWRkZW5cIjtcblx0XHR9KS5sZW5ndGg7XG59XG5cbiQuZXh0ZW5kKCAkLmV4cHJbIFwiOlwiIF0sIHtcblx0ZGF0YTogJC5leHByLmNyZWF0ZVBzZXVkbyA/XG5cdFx0JC5leHByLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiggZGF0YU5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgZGF0YU5hbWUgKTtcblx0XHRcdH07XG5cdFx0fSkgOlxuXHRcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBtYXRjaFsgMyBdICk7XG5cdFx0fSxcblxuXHRmb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHJldHVybiBmb2N1c2FibGUoIGVsZW1lbnQsICFpc05hTiggJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSApICk7XG5cdH0sXG5cblx0dGFiYmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciB0YWJJbmRleCA9ICQuYXR0ciggZWxlbWVudCwgXCJ0YWJpbmRleFwiICksXG5cdFx0XHRpc1RhYkluZGV4TmFOID0gaXNOYU4oIHRhYkluZGV4ICk7XG5cdFx0cmV0dXJuICggaXNUYWJJbmRleE5hTiB8fCB0YWJJbmRleCA+PSAwICkgJiYgZm9jdXNhYmxlKCBlbGVtZW50LCAhaXNUYWJJbmRleE5hTiApO1xuXHR9XG59KTtcblxuLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQoIFwiPGE+XCIgKS5vdXRlcldpZHRoKCAxICkuanF1ZXJ5ICkge1xuXHQkLmVhY2goIFsgXCJXaWR0aFwiLCBcIkhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdHZhciBzaWRlID0gbmFtZSA9PT0gXCJXaWR0aFwiID8gWyBcIkxlZnRcIiwgXCJSaWdodFwiIF0gOiBbIFwiVG9wXCIsIFwiQm90dG9tXCIgXSxcblx0XHRcdHR5cGUgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRvcmlnID0ge1xuXHRcdFx0XHRpbm5lcldpZHRoOiAkLmZuLmlubmVyV2lkdGgsXG5cdFx0XHRcdGlubmVySGVpZ2h0OiAkLmZuLmlubmVySGVpZ2h0LFxuXHRcdFx0XHRvdXRlcldpZHRoOiAkLmZuLm91dGVyV2lkdGgsXG5cdFx0XHRcdG91dGVySGVpZ2h0OiAkLmZuLm91dGVySGVpZ2h0XG5cdFx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVkdWNlKCBlbGVtLCBzaXplLCBib3JkZXIsIG1hcmdpbiApIHtcblx0XHRcdCQuZWFjaCggc2lkZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNpemUgLT0gcGFyc2VGbG9hdCggJC5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0aWYgKCBib3JkZXIgKSB7XG5cdFx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJib3JkZXJcIiArIHRoaXMgKyBcIldpZHRoXCIgKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXJnaW4gKSB7XG5cdFx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJtYXJnaW5cIiArIHRoaXMgKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNpemU7XG5cdFx0fVxuXG5cdFx0JC5mblsgXCJpbm5lclwiICsgbmFtZSBdID0gZnVuY3Rpb24oIHNpemUgKSB7XG5cdFx0XHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWdbIFwiaW5uZXJcIiArIG5hbWUgXS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5jc3MoIHR5cGUsIHJlZHVjZSggdGhpcywgc2l6ZSApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0JC5mblsgXCJvdXRlclwiICsgbmFtZV0gPSBmdW5jdGlvbiggc2l6ZSwgbWFyZ2luICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2l6ZSAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWdbIFwib3V0ZXJcIiArIG5hbWUgXS5jYWxsKCB0aGlzLCBzaXplICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMpLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplLCB0cnVlLCBtYXJnaW4gKSArIFwicHhcIiApO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSk7XG59XG5cbi8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5pZiAoICEkLmZuLmFkZEJhY2sgKSB7XG5cdCQuZm4uYWRkQmFjayA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH07XG59XG5cbi8vIHN1cHBvcnQ6IGpRdWVyeSAxLjYuMSwgMS42LjIgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTMpXG5pZiAoICQoIFwiPGE+XCIgKS5kYXRhKCBcImEtYlwiLCBcImFcIiApLnJlbW92ZURhdGEoIFwiYS1iXCIgKS5kYXRhKCBcImEtYlwiICkgKSB7XG5cdCQuZm4ucmVtb3ZlRGF0YSA9IChmdW5jdGlvbiggcmVtb3ZlRGF0YSApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZURhdGEuY2FsbCggdGhpcywgJC5jYW1lbENhc2UoIGtleSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoICQuZm4ucmVtb3ZlRGF0YSApO1xufVxuXG5cblxuXG5cbi8vIGRlcHJlY2F0ZWRcbiQudWkuaWUgPSAhIS9tc2llIFtcXHcuXSsvLmV4ZWMoIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSApO1xuXG4kLnN1cHBvcnQuc2VsZWN0c3RhcnQgPSBcIm9uc2VsZWN0c3RhcnRcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG4kLmZuLmV4dGVuZCh7XG5cdGRpc2FibGVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJpbmQoICggJC5zdXBwb3J0LnNlbGVjdHN0YXJ0ID8gXCJzZWxlY3RzdGFydFwiIDogXCJtb3VzZWRvd25cIiApICtcblx0XHRcdFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0ZW5hYmxlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy51bmJpbmQoIFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cIiApO1xuXHR9XG59KTtcblxuJC5leHRlbmQoICQudWksIHtcblx0Ly8gJC51aS5wbHVnaW4gaXMgZGVwcmVjYXRlZC4gVXNlICQud2lkZ2V0KCkgZXh0ZW5zaW9ucyBpbnN0ZWFkLlxuXHRwbHVnaW46IHtcblx0XHRhZGQ6IGZ1bmN0aW9uKCBtb2R1bGUsIG9wdGlvbiwgc2V0ICkge1xuXHRcdFx0dmFyIGksXG5cdFx0XHRcdHByb3RvID0gJC51aVsgbW9kdWxlIF0ucHJvdG90eXBlO1xuXHRcdFx0Zm9yICggaSBpbiBzZXQgKSB7XG5cdFx0XHRcdHByb3RvLnBsdWdpbnNbIGkgXSA9IHByb3RvLnBsdWdpbnNbIGkgXSB8fCBbXTtcblx0XHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdLnB1c2goIFsgb3B0aW9uLCBzZXRbIGkgXSBdICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjYWxsOiBmdW5jdGlvbiggaW5zdGFuY2UsIG5hbWUsIGFyZ3MgKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0c2V0ID0gaW5zdGFuY2UucGx1Z2luc1sgbmFtZSBdO1xuXHRcdFx0aWYgKCAhc2V0IHx8ICFpbnN0YW5jZS5lbGVtZW50WyAwIF0ucGFyZW50Tm9kZSB8fCBpbnN0YW5jZS5lbGVtZW50WyAwIF0ucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggaW5zdGFuY2Uub3B0aW9uc1sgc2V0WyBpIF1bIDAgXSBdICkge1xuXHRcdFx0XHRcdHNldFsgaSBdWyAxIF0uYXBwbHkoIGluc3RhbmNlLmVsZW1lbnQsIGFyZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBvbmx5IHVzZWQgYnkgcmVzaXphYmxlXG5cdGhhc1Njcm9sbDogZnVuY3Rpb24oIGVsLCBhICkge1xuXG5cdFx0Ly9JZiBvdmVyZmxvdyBpcyBoaWRkZW4sIHRoZSBlbGVtZW50IG1pZ2h0IGhhdmUgZXh0cmEgY29udGVudCwgYnV0IHRoZSB1c2VyIHdhbnRzIHRvIGhpZGUgaXRcblx0XHRpZiAoICQoIGVsICkuY3NzKCBcIm92ZXJmbG93XCIgKSA9PT0gXCJoaWRkZW5cIikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBzY3JvbGwgPSAoIGEgJiYgYSA9PT0gXCJsZWZ0XCIgKSA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIixcblx0XHRcdGhhcyA9IGZhbHNlO1xuXG5cdFx0aWYgKCBlbFsgc2Nyb2xsIF0gPiAwICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogZGV0ZXJtaW5lIHdoaWNoIGNhc2VzIGFjdHVhbGx5IGNhdXNlIHRoaXMgdG8gaGFwcGVuXG5cdFx0Ly8gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIHRoZSBzY3JvbGwgc2V0LCBzZWUgaWYgaXQncyBwb3NzaWJsZSB0b1xuXHRcdC8vIHNldCB0aGUgc2Nyb2xsXG5cdFx0ZWxbIHNjcm9sbCBdID0gMTtcblx0XHRoYXMgPSAoIGVsWyBzY3JvbGwgXSA+IDAgKTtcblx0XHRlbFsgc2Nyb2xsIF0gPSAwO1xuXHRcdHJldHVybiBoYXM7XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pbXBvcnRzLWxvYWRlcj9qUXVlcnk9anF1ZXJ5IS4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL2pxdWVyeS11aS0xLjEwLjQvanF1ZXJ5LnVpLmNvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "shim/jquery.ui.widget":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/jquery\"), __webpack_require__(265)], __WEBPACK_AMD_DEFINE_RESULT__ = function($) {\n    return $;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vanF1ZXJ5LnVpLndpZGdldC5qcz8yZTcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJzaGltL2pxdWVyeS51aS53aWRnZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydqcXVlcnknLCAnaW1wb3J0cz9qUXVlcnk9anF1ZXJ5IWNvbnRyaWIvanF1ZXJ5LXVpLTEuMTAuNC9qcXVlcnkudWkud2lkZ2V0J10sIGZ1bmN0aW9uKCQpIHtcbiAgICByZXR1cm4gJDtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zaGltL2pxdWVyeS51aS53aWRnZXQuanNcbi8vIG1vZHVsZSBpZCA9IHNoaW0vanF1ZXJ5LnVpLndpZGdldFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 265:
/***/ (function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(\"shim/jquery\");\n\n/*!\n * jQuery UI Widget 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/jQuery.widget/\n */\n(function( $, undefined ) {\n\nvar uuid = 0,\n\tslice = Array.prototype.slice,\n\t_cleanData = $.cleanData;\n$.cleanData = function( elems ) {\n\tfor ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n\t\ttry {\n\t\t\t$( elem ).triggerHandler( \"remove\" );\n\t\t// http://bugs.jquery.com/ticket/8235\n\t\t} catch( e ) {}\n\t}\n\t_cleanData( elems );\n};\n\n$.widget = function( name, base, prototype ) {\n\tvar fullName, existingConstructor, constructor, basePrototype,\n\t\t// proxiedPrototype allows the provided prototype to remain unmodified\n\t\t// so that it can be used as a mixin for multiple widgets (#8876)\n\t\tproxiedPrototype = {},\n\t\tnamespace = name.split( \".\" )[ 0 ];\n\n\tname = name.split( \".\" )[ 1 ];\n\tfullName = namespace + \"-\" + name;\n\n\tif ( !prototype ) {\n\t\tprototype = base;\n\t\tbase = $.Widget;\n\t}\n\n\t// create selector for plugin\n\t$.expr[ \":\" ][ fullName.toLowerCase() ] = function( elem ) {\n\t\treturn !!$.data( elem, fullName );\n\t};\n\n\t$[ namespace ] = $[ namespace ] || {};\n\texistingConstructor = $[ namespace ][ name ];\n\tconstructor = $[ namespace ][ name ] = function( options, element ) {\n\t\t// allow instantiation without \"new\" keyword\n\t\tif ( !this._createWidget ) {\n\t\t\treturn new constructor( options, element );\n\t\t}\n\n\t\t// allow instantiation without initializing for simple inheritance\n\t\t// must use \"new\" keyword (the code above always passes args)\n\t\tif ( arguments.length ) {\n\t\t\tthis._createWidget( options, element );\n\t\t}\n\t};\n\t// extend with the existing constructor to carry over any static properties\n\t$.extend( constructor, existingConstructor, {\n\t\tversion: prototype.version,\n\t\t// copy the object used to create the prototype in case we need to\n\t\t// redefine the widget later\n\t\t_proto: $.extend( {}, prototype ),\n\t\t// track widgets that inherit from this widget in case this widget is\n\t\t// redefined after a widget inherits from it\n\t\t_childConstructors: []\n\t});\n\n\tbasePrototype = new base();\n\t// we need to make the options hash a property directly on the new instance\n\t// otherwise we'll modify the options hash on the prototype that we're\n\t// inheriting from\n\tbasePrototype.options = $.widget.extend( {}, basePrototype.options );\n\t$.each( prototype, function( prop, value ) {\n\t\tif ( !$.isFunction( value ) ) {\n\t\t\tproxiedPrototype[ prop ] = value;\n\t\t\treturn;\n\t\t}\n\t\tproxiedPrototype[ prop ] = (function() {\n\t\t\tvar _super = function() {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, arguments );\n\t\t\t\t},\n\t\t\t\t_superApply = function( args ) {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, args );\n\t\t\t\t};\n\t\t\treturn function() {\n\t\t\t\tvar __super = this._super,\n\t\t\t\t\t__superApply = this._superApply,\n\t\t\t\t\treturnValue;\n\n\t\t\t\tthis._super = _super;\n\t\t\t\tthis._superApply = _superApply;\n\n\t\t\t\treturnValue = value.apply( this, arguments );\n\n\t\t\t\tthis._super = __super;\n\t\t\t\tthis._superApply = __superApply;\n\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t})();\n\t});\n\tconstructor.prototype = $.widget.extend( basePrototype, {\n\t\t// TODO: remove support for widgetEventPrefix\n\t\t// always use the name + a colon as the prefix, e.g., draggable:start\n\t\t// don't prefix for widgets that aren't DOM-based\n\t\twidgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\n\t}, proxiedPrototype, {\n\t\tconstructor: constructor,\n\t\tnamespace: namespace,\n\t\twidgetName: name,\n\t\twidgetFullName: fullName\n\t});\n\n\t// If this widget is being redefined then we need to find all widgets that\n\t// are inheriting from it and redefine all of them so that they inherit from\n\t// the new version of this widget. We're essentially trying to replace one\n\t// level in the prototype chain.\n\tif ( existingConstructor ) {\n\t\t$.each( existingConstructor._childConstructors, function( i, child ) {\n\t\t\tvar childPrototype = child.prototype;\n\n\t\t\t// redefine the child widget using the same prototype that was\n\t\t\t// originally used, but inherit from the new version of the base\n\t\t\t$.widget( childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto );\n\t\t});\n\t\t// remove the list of existing child constructors from the old constructor\n\t\t// so the old child constructors can be garbage collected\n\t\tdelete existingConstructor._childConstructors;\n\t} else {\n\t\tbase._childConstructors.push( constructor );\n\t}\n\n\t$.widget.bridge( name, constructor );\n};\n\n$.widget.extend = function( target ) {\n\tvar input = slice.call( arguments, 1 ),\n\t\tinputIndex = 0,\n\t\tinputLength = input.length,\n\t\tkey,\n\t\tvalue;\n\tfor ( ; inputIndex < inputLength; inputIndex++ ) {\n\t\tfor ( key in input[ inputIndex ] ) {\n\t\t\tvalue = input[ inputIndex ][ key ];\n\t\t\tif ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\n\t\t\t\t// Clone objects\n\t\t\t\tif ( $.isPlainObject( value ) ) {\n\t\t\t\t\ttarget[ key ] = $.isPlainObject( target[ key ] ) ?\n\t\t\t\t\t\t$.widget.extend( {}, target[ key ], value ) :\n\t\t\t\t\t\t// Don't extend strings, arrays, etc. with objects\n\t\t\t\t\t\t$.widget.extend( {}, value );\n\t\t\t\t// Copy everything else by reference\n\t\t\t\t} else {\n\t\t\t\t\ttarget[ key ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n};\n\n$.widget.bridge = function( name, object ) {\n\tvar fullName = object.prototype.widgetFullName || name;\n\t$.fn[ name ] = function( options ) {\n\t\tvar isMethodCall = typeof options === \"string\",\n\t\t\targs = slice.call( arguments, 1 ),\n\t\t\treturnValue = this;\n\n\t\t// allow multiple hashes to be passed on init\n\t\toptions = !isMethodCall && args.length ?\n\t\t\t$.widget.extend.apply( null, [ options ].concat(args) ) :\n\t\t\toptions;\n\n\t\tif ( isMethodCall ) {\n\t\t\tthis.each(function() {\n\t\t\t\tvar methodValue,\n\t\t\t\t\tinstance = $.data( this, fullName );\n\t\t\t\tif ( !instance ) {\n\t\t\t\t\treturn $.error( \"cannot call methods on \" + name + \" prior to initialization; \" +\n\t\t\t\t\t\t\"attempted to call method '\" + options + \"'\" );\n\t\t\t\t}\n\t\t\t\tif ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === \"_\" ) {\n\t\t\t\t\treturn $.error( \"no such method '\" + options + \"' for \" + name + \" widget instance\" );\n\t\t\t\t}\n\t\t\t\tmethodValue = instance[ options ].apply( instance, args );\n\t\t\t\tif ( methodValue !== instance && methodValue !== undefined ) {\n\t\t\t\t\treturnValue = methodValue && methodValue.jquery ?\n\t\t\t\t\t\treturnValue.pushStack( methodValue.get() ) :\n\t\t\t\t\t\tmethodValue;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tthis.each(function() {\n\t\t\t\tvar instance = $.data( this, fullName );\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tinstance.option( options || {} )._init();\n\t\t\t\t} else {\n\t\t\t\t\t$.data( this, fullName, new object( options, this ) );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn returnValue;\n\t};\n};\n\n$.Widget = function( /* options, element */ ) {};\n$.Widget._childConstructors = [];\n\n$.Widget.prototype = {\n\twidgetName: \"widget\",\n\twidgetEventPrefix: \"\",\n\tdefaultElement: \"<div>\",\n\toptions: {\n\t\tdisabled: false,\n\n\t\t// callbacks\n\t\tcreate: null\n\t},\n\t_createWidget: function( options, element ) {\n\t\telement = $( element || this.defaultElement || this )[ 0 ];\n\t\tthis.element = $( element );\n\t\tthis.uuid = uuid++;\n\t\tthis.eventNamespace = \".\" + this.widgetName + this.uuid;\n\t\tthis.options = $.widget.extend( {},\n\t\t\tthis.options,\n\t\t\tthis._getCreateOptions(),\n\t\t\toptions );\n\n\t\tthis.bindings = $();\n\t\tthis.hoverable = $();\n\t\tthis.focusable = $();\n\n\t\tif ( element !== this ) {\n\t\t\t$.data( element, this.widgetFullName, this );\n\t\t\tthis._on( true, this.element, {\n\t\t\t\tremove: function( event ) {\n\t\t\t\t\tif ( event.target === element ) {\n\t\t\t\t\t\tthis.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.document = $( element.style ?\n\t\t\t\t// element within the document\n\t\t\t\telement.ownerDocument :\n\t\t\t\t// element is window or document\n\t\t\t\telement.document || element );\n\t\t\tthis.window = $( this.document[0].defaultView || this.document[0].parentWindow );\n\t\t}\n\n\t\tthis._create();\n\t\tthis._trigger( \"create\", null, this._getCreateEventData() );\n\t\tthis._init();\n\t},\n\t_getCreateOptions: $.noop,\n\t_getCreateEventData: $.noop,\n\t_create: $.noop,\n\t_init: $.noop,\n\n\tdestroy: function() {\n\t\tthis._destroy();\n\t\t// we can probably remove the unbind calls in 2.0\n\t\t// all event bindings should go through this._on()\n\t\tthis.element\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t// 1.9 BC for #7810\n\t\t\t// TODO remove dual storage\n\t\t\t.removeData( this.widgetName )\n\t\t\t.removeData( this.widgetFullName )\n\t\t\t// support: jquery <1.6.3\n\t\t\t// http://bugs.jquery.com/ticket/9413\n\t\t\t.removeData( $.camelCase( this.widgetFullName ) );\n\t\tthis.widget()\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t.removeAttr( \"aria-disabled\" )\n\t\t\t.removeClass(\n\t\t\t\tthis.widgetFullName + \"-disabled \" +\n\t\t\t\t\"ui-state-disabled\" );\n\n\t\t// clean up events and states\n\t\tthis.bindings.unbind( this.eventNamespace );\n\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\n\t\tthis.focusable.removeClass( \"ui-state-focus\" );\n\t},\n\t_destroy: $.noop,\n\n\twidget: function() {\n\t\treturn this.element;\n\t},\n\n\toption: function( key, value ) {\n\t\tvar options = key,\n\t\t\tparts,\n\t\t\tcurOption,\n\t\t\ti;\n\n\t\tif ( arguments.length === 0 ) {\n\t\t\t// don't return a reference to the internal hash\n\t\t\treturn $.widget.extend( {}, this.options );\n\t\t}\n\n\t\tif ( typeof key === \"string\" ) {\n\t\t\t// handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n\t\t\toptions = {};\n\t\t\tparts = key.split( \".\" );\n\t\t\tkey = parts.shift();\n\t\t\tif ( parts.length ) {\n\t\t\t\tcurOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\n\t\t\t\tfor ( i = 0; i < parts.length - 1; i++ ) {\n\t\t\t\t\tcurOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\n\t\t\t\t\tcurOption = curOption[ parts[ i ] ];\n\t\t\t\t}\n\t\t\t\tkey = parts.pop();\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn curOption[ key ] === undefined ? null : curOption[ key ];\n\t\t\t\t}\n\t\t\t\tcurOption[ key ] = value;\n\t\t\t} else {\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn this.options[ key ] === undefined ? null : this.options[ key ];\n\t\t\t\t}\n\t\t\t\toptions[ key ] = value;\n\t\t\t}\n\t\t}\n\n\t\tthis._setOptions( options );\n\n\t\treturn this;\n\t},\n\t_setOptions: function( options ) {\n\t\tvar key;\n\n\t\tfor ( key in options ) {\n\t\t\tthis._setOption( key, options[ key ] );\n\t\t}\n\n\t\treturn this;\n\t},\n\t_setOption: function( key, value ) {\n\t\tthis.options[ key ] = value;\n\n\t\tif ( key === \"disabled\" ) {\n\t\t\tthis.widget()\n\t\t\t\t.toggleClass( this.widgetFullName + \"-disabled ui-state-disabled\", !!value )\n\t\t\t\t.attr( \"aria-disabled\", value );\n\t\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\n\t\t\tthis.focusable.removeClass( \"ui-state-focus\" );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tenable: function() {\n\t\treturn this._setOption( \"disabled\", false );\n\t},\n\tdisable: function() {\n\t\treturn this._setOption( \"disabled\", true );\n\t},\n\n\t_on: function( suppressDisabledCheck, element, handlers ) {\n\t\tvar delegateElement,\n\t\t\tinstance = this;\n\n\t\t// no suppressDisabledCheck flag, shuffle arguments\n\t\tif ( typeof suppressDisabledCheck !== \"boolean\" ) {\n\t\t\thandlers = element;\n\t\t\telement = suppressDisabledCheck;\n\t\t\tsuppressDisabledCheck = false;\n\t\t}\n\n\t\t// no element argument, shuffle and use this.element\n\t\tif ( !handlers ) {\n\t\t\thandlers = element;\n\t\t\telement = this.element;\n\t\t\tdelegateElement = this.widget();\n\t\t} else {\n\t\t\t// accept selectors, DOM elements\n\t\t\telement = delegateElement = $( element );\n\t\t\tthis.bindings = this.bindings.add( element );\n\t\t}\n\n\t\t$.each( handlers, function( event, handler ) {\n\t\t\tfunction handlerProxy() {\n\t\t\t\t// allow widgets to customize the disabled handling\n\t\t\t\t// - disabled as an array instead of boolean\n\t\t\t\t// - disabled class as method for disabling individual parts\n\t\t\t\tif ( !suppressDisabledCheck &&\n\t\t\t\t\t\t( instance.options.disabled === true ||\n\t\t\t\t\t\t\t$( this ).hasClass( \"ui-state-disabled\" ) ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\n\t\t\t\t\t.apply( instance, arguments );\n\t\t\t}\n\n\t\t\t// copy the guid so direct unbinding works\n\t\t\tif ( typeof handler !== \"string\" ) {\n\t\t\t\thandlerProxy.guid = handler.guid =\n\t\t\t\t\thandler.guid || handlerProxy.guid || $.guid++;\n\t\t\t}\n\n\t\t\tvar match = event.match( /^(\\w+)\\s*(.*)$/ ),\n\t\t\t\teventName = match[1] + instance.eventNamespace,\n\t\t\t\tselector = match[2];\n\t\t\tif ( selector ) {\n\t\t\t\tdelegateElement.delegate( selector, eventName, handlerProxy );\n\t\t\t} else {\n\t\t\t\telement.bind( eventName, handlerProxy );\n\t\t\t}\n\t\t});\n\t},\n\n\t_off: function( element, eventName ) {\n\t\teventName = (eventName || \"\").split( \" \" ).join( this.eventNamespace + \" \" ) + this.eventNamespace;\n\t\telement.unbind( eventName ).undelegate( eventName );\n\t},\n\n\t_delay: function( handler, delay ) {\n\t\tfunction handlerProxy() {\n\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\n\t\t\t\t.apply( instance, arguments );\n\t\t}\n\t\tvar instance = this;\n\t\treturn setTimeout( handlerProxy, delay || 0 );\n\t},\n\n\t_hoverable: function( element ) {\n\t\tthis.hoverable = this.hoverable.add( element );\n\t\tthis._on( element, {\n\t\t\tmouseenter: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-hover\" );\n\t\t\t},\n\t\t\tmouseleave: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-hover\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_focusable: function( element ) {\n\t\tthis.focusable = this.focusable.add( element );\n\t\tthis._on( element, {\n\t\t\tfocusin: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-focus\" );\n\t\t\t},\n\t\t\tfocusout: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-focus\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_trigger: function( type, event, data ) {\n\t\tvar prop, orig,\n\t\t\tcallback = this.options[ type ];\n\n\t\tdata = data || {};\n\t\tevent = $.Event( event );\n\t\tevent.type = ( type === this.widgetEventPrefix ?\n\t\t\ttype :\n\t\t\tthis.widgetEventPrefix + type ).toLowerCase();\n\t\t// the original event may come from any element\n\t\t// so we need to reset the target on the new event\n\t\tevent.target = this.element[ 0 ];\n\n\t\t// copy original event properties over to the new event\n\t\torig = event.originalEvent;\n\t\tif ( orig ) {\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tif ( !( prop in event ) ) {\n\t\t\t\t\tevent[ prop ] = orig[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element.trigger( event, data );\n\t\treturn !( $.isFunction( callback ) &&\n\t\t\tcallback.apply( this.element[0], [ event ].concat( data ) ) === false ||\n\t\t\tevent.isDefaultPrevented() );\n\t}\n};\n\n$.each( { show: \"fadeIn\", hide: \"fadeOut\" }, function( method, defaultEffect ) {\n\t$.Widget.prototype[ \"_\" + method ] = function( element, options, callback ) {\n\t\tif ( typeof options === \"string\" ) {\n\t\t\toptions = { effect: options };\n\t\t}\n\t\tvar hasOptions,\n\t\t\teffectName = !options ?\n\t\t\t\tmethod :\n\t\t\t\toptions === true || typeof options === \"number\" ?\n\t\t\t\t\tdefaultEffect :\n\t\t\t\t\toptions.effect || defaultEffect;\n\t\toptions = options || {};\n\t\tif ( typeof options === \"number\" ) {\n\t\t\toptions = { duration: options };\n\t\t}\n\t\thasOptions = !$.isEmptyObject( options );\n\t\toptions.complete = callback;\n\t\tif ( options.delay ) {\n\t\t\telement.delay( options.delay );\n\t\t}\n\t\tif ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\n\t\t\telement[ method ]( options );\n\t\t} else if ( effectName !== method && element[ effectName ] ) {\n\t\t\telement[ effectName ]( options.duration, options.easing, callback );\n\t\t} else {\n\t\t\telement.queue(function( next ) {\n\t\t\t\t$( this )[ method ]();\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback.call( element[ 0 ] );\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\t};\n});\n\n})( jQuery );\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvanF1ZXJ5LXVpLTEuMTAuNC9qcXVlcnkudWkud2lkZ2V0LmpzPzY2NGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0EsOENBQThDLE9BQU8sV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxrQ0FBa0M7QUFDM0M7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQyIsImZpbGUiOiIyNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgV2lkZ2V0IDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkud2lkZ2V0L1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHV1aWQgPSAwLFxuXHRzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblx0X2NsZWFuRGF0YSA9ICQuY2xlYW5EYXRhO1xuJC5jbGVhbkRhdGEgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdHRyeSB7XG5cdFx0XHQkKCBlbGVtICkudHJpZ2dlckhhbmRsZXIoIFwicmVtb3ZlXCIgKTtcblx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84MjM1XG5cdFx0fSBjYXRjaCggZSApIHt9XG5cdH1cblx0X2NsZWFuRGF0YSggZWxlbXMgKTtcbn07XG5cbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcblx0dmFyIGZ1bGxOYW1lLCBleGlzdGluZ0NvbnN0cnVjdG9yLCBjb25zdHJ1Y3RvciwgYmFzZVByb3RvdHlwZSxcblx0XHQvLyBwcm94aWVkUHJvdG90eXBlIGFsbG93cyB0aGUgcHJvdmlkZWQgcHJvdG90eXBlIHRvIHJlbWFpbiB1bm1vZGlmaWVkXG5cdFx0Ly8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIGZvciBtdWx0aXBsZSB3aWRnZXRzICgjODg3Nilcblx0XHRwcm94aWVkUHJvdG90eXBlID0ge30sXG5cdFx0bmFtZXNwYWNlID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMCBdO1xuXG5cdG5hbWUgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAxIF07XG5cdGZ1bGxOYW1lID0gbmFtZXNwYWNlICsgXCItXCIgKyBuYW1lO1xuXG5cdGlmICggIXByb3RvdHlwZSApIHtcblx0XHRwcm90b3R5cGUgPSBiYXNlO1xuXHRcdGJhc2UgPSAkLldpZGdldDtcblx0fVxuXG5cdC8vIGNyZWF0ZSBzZWxlY3RvciBmb3IgcGx1Z2luXG5cdCQuZXhwclsgXCI6XCIgXVsgZnVsbE5hbWUudG9Mb3dlckNhc2UoKSBdID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBmdWxsTmFtZSApO1xuXHR9O1xuXG5cdCRbIG5hbWVzcGFjZSBdID0gJFsgbmFtZXNwYWNlIF0gfHwge307XG5cdGV4aXN0aW5nQ29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdO1xuXHRjb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF0gPSBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHQvLyBhbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgXCJuZXdcIiBrZXl3b3JkXG5cdFx0aWYgKCAhdGhpcy5fY3JlYXRlV2lkZ2V0ICkge1xuXHRcdFx0cmV0dXJuIG5ldyBjb25zdHJ1Y3Rvciggb3B0aW9ucywgZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBpbml0aWFsaXppbmcgZm9yIHNpbXBsZSBpbmhlcml0YW5jZVxuXHRcdC8vIG11c3QgdXNlIFwibmV3XCIga2V5d29yZCAodGhlIGNvZGUgYWJvdmUgYWx3YXlzIHBhc3NlcyBhcmdzKVxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuX2NyZWF0ZVdpZGdldCggb3B0aW9ucywgZWxlbWVudCApO1xuXHRcdH1cblx0fTtcblx0Ly8gZXh0ZW5kIHdpdGggdGhlIGV4aXN0aW5nIGNvbnN0cnVjdG9yIHRvIGNhcnJ5IG92ZXIgYW55IHN0YXRpYyBwcm9wZXJ0aWVzXG5cdCQuZXh0ZW5kKCBjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xuXHRcdHZlcnNpb246IHByb3RvdHlwZS52ZXJzaW9uLFxuXHRcdC8vIGNvcHkgdGhlIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGUgcHJvdG90eXBlIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHRcdC8vIHJlZGVmaW5lIHRoZSB3aWRnZXQgbGF0ZXJcblx0XHRfcHJvdG86ICQuZXh0ZW5kKCB7fSwgcHJvdG90eXBlICksXG5cdFx0Ly8gdHJhY2sgd2lkZ2V0cyB0aGF0IGluaGVyaXQgZnJvbSB0aGlzIHdpZGdldCBpbiBjYXNlIHRoaXMgd2lkZ2V0IGlzXG5cdFx0Ly8gcmVkZWZpbmVkIGFmdGVyIGEgd2lkZ2V0IGluaGVyaXRzIGZyb20gaXRcblx0XHRfY2hpbGRDb25zdHJ1Y3RvcnM6IFtdXG5cdH0pO1xuXG5cdGJhc2VQcm90b3R5cGUgPSBuZXcgYmFzZSgpO1xuXHQvLyB3ZSBuZWVkIHRvIG1ha2UgdGhlIG9wdGlvbnMgaGFzaCBhIHByb3BlcnR5IGRpcmVjdGx5IG9uIHRoZSBuZXcgaW5zdGFuY2Vcblx0Ly8gb3RoZXJ3aXNlIHdlJ2xsIG1vZGlmeSB0aGUgb3B0aW9ucyBoYXNoIG9uIHRoZSBwcm90b3R5cGUgdGhhdCB3ZSdyZVxuXHQvLyBpbmhlcml0aW5nIGZyb21cblx0YmFzZVByb3RvdHlwZS5vcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgYmFzZVByb3RvdHlwZS5vcHRpb25zICk7XG5cdCQuZWFjaCggcHJvdG90eXBlLCBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBfc3VwZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9zdXBlckFwcGx5ID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdFx0fTtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIF9fc3VwZXIgPSB0aGlzLl9zdXBlcixcblx0XHRcdFx0XHRfX3N1cGVyQXBwbHkgPSB0aGlzLl9zdXBlckFwcGx5LFxuXHRcdFx0XHRcdHJldHVyblZhbHVlO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX19zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdH07XG5cdFx0fSkoKTtcblx0fSk7XG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQud2lkZ2V0LmV4dGVuZCggYmFzZVByb3RvdHlwZSwge1xuXHRcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxuXHRcdC8vIGFsd2F5cyB1c2UgdGhlIG5hbWUgKyBhIGNvbG9uIGFzIHRoZSBwcmVmaXgsIGUuZy4sIGRyYWdnYWJsZTpzdGFydFxuXHRcdC8vIGRvbid0IHByZWZpeCBmb3Igd2lkZ2V0cyB0aGF0IGFyZW4ndCBET00tYmFzZWRcblx0XHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/IChiYXNlUHJvdG90eXBlLndpZGdldEV2ZW50UHJlZml4IHx8IG5hbWUpIDogbmFtZVxuXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXG5cdH0pO1xuXG5cdC8vIElmIHRoaXMgd2lkZ2V0IGlzIGJlaW5nIHJlZGVmaW5lZCB0aGVuIHdlIG5lZWQgdG8gZmluZCBhbGwgd2lkZ2V0cyB0aGF0XG5cdC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cblx0Ly8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcblx0Ly8gbGV2ZWwgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cblx0aWYgKCBleGlzdGluZ0NvbnN0cnVjdG9yICkge1xuXHRcdCQuZWFjaCggZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uKCBpLCBjaGlsZCApIHtcblx0XHRcdHZhciBjaGlsZFByb3RvdHlwZSA9IGNoaWxkLnByb3RvdHlwZTtcblxuXHRcdFx0Ly8gcmVkZWZpbmUgdGhlIGNoaWxkIHdpZGdldCB1c2luZyB0aGUgc2FtZSBwcm90b3R5cGUgdGhhdCB3YXNcblx0XHRcdC8vIG9yaWdpbmFsbHkgdXNlZCwgYnV0IGluaGVyaXQgZnJvbSB0aGUgbmV3IHZlcnNpb24gb2YgdGhlIGJhc2Vcblx0XHRcdCQud2lkZ2V0KCBjaGlsZFByb3RvdHlwZS5uYW1lc3BhY2UgKyBcIi5cIiArIGNoaWxkUHJvdG90eXBlLndpZGdldE5hbWUsIGNvbnN0cnVjdG9yLCBjaGlsZC5fcHJvdG8gKTtcblx0XHR9KTtcblx0XHQvLyByZW1vdmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2hpbGQgY29uc3RydWN0b3JzIGZyb20gdGhlIG9sZCBjb25zdHJ1Y3RvclxuXHRcdC8vIHNvIHRoZSBvbGQgY2hpbGQgY29uc3RydWN0b3JzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdGRlbGV0ZSBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycztcblx0fSBlbHNlIHtcblx0XHRiYXNlLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKCBjb25zdHJ1Y3RvciApO1xuXHR9XG5cblx0JC53aWRnZXQuYnJpZGdlKCBuYW1lLCBjb25zdHJ1Y3RvciApO1xufTtcblxuJC53aWRnZXQuZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0dmFyIGlucHV0ID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksXG5cdFx0aW5wdXRJbmRleCA9IDAsXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0a2V5LFxuXHRcdHZhbHVlO1xuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gQ2xvbmUgb2JqZWN0c1xuXHRcdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gJC5pc1BsYWluT2JqZWN0KCB0YXJnZXRbIGtleSBdICkgP1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdGFyZ2V0WyBrZXkgXSwgdmFsdWUgKSA6XG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIixcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRcdHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdC8vIGFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdG9wdGlvbnMgPSAhaXNNZXRob2RDYWxsICYmIGFyZ3MubGVuZ3RoID9cblx0XHRcdCQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KGFyZ3MpICkgOlxuXHRcdFx0b3B0aW9ucztcblxuXHRcdGlmICggaXNNZXRob2RDYWxsICkge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbWV0aG9kVmFsdWUsXG5cdFx0XHRcdFx0aW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggIWluc3RhbmNlICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBuYW1lICsgXCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICtcblx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggISQuaXNGdW5jdGlvbiggaW5zdGFuY2Vbb3B0aW9uc10gKSB8fCBvcHRpb25zLmNoYXJBdCggMCApID09PSBcIl9cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgKyBcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblx0XHRcdFx0aWYgKCBtZXRob2RWYWx1ZSAhPT0gaW5zdGFuY2UgJiYgbWV0aG9kVmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZS5wdXNoU3RhY2soIG1ldGhvZFZhbHVlLmdldCgpICkgOlxuXHRcdFx0XHRcdFx0bWV0aG9kVmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2Uub3B0aW9uKCBvcHRpb25zIHx8IHt9ICkuX2luaXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9O1xufTtcblxuJC5XaWRnZXQgPSBmdW5jdGlvbiggLyogb3B0aW9ucywgZWxlbWVudCAqLyApIHt9O1xuJC5XaWRnZXQuX2NoaWxkQ29uc3RydWN0b3JzID0gW107XG5cbiQuV2lkZ2V0LnByb3RvdHlwZSA9IHtcblx0d2lkZ2V0TmFtZTogXCJ3aWRnZXRcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwiXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxkaXY+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcblx0XHR0aGlzLmVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy51dWlkID0gdXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblxuXHRcdGlmICggZWxlbWVudCAhPT0gdGhpcyApIHtcblx0XHRcdCQuZGF0YSggZWxlbWVudCwgdGhpcy53aWRnZXRGdWxsTmFtZSwgdGhpcyApO1xuXHRcdFx0dGhpcy5fb24oIHRydWUsIHRoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gJCggZWxlbWVudC5zdHlsZSA/XG5cdFx0XHRcdC8vIGVsZW1lbnQgd2l0aGluIHRoZSBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50Lm93bmVyRG9jdW1lbnQgOlxuXHRcdFx0XHQvLyBlbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFswXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WzBdLnBhcmVudFdpbmRvdyApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NyZWF0ZSgpO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwiY3JlYXRlXCIsIG51bGwsIHRoaXMuX2dldENyZWF0ZUV2ZW50RGF0YSgpICk7XG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9LFxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogJC5ub29wLFxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXG5cdF9jcmVhdGU6ICQubm9vcCxcblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0Ly8gd2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC8vIDEuOSBCQyBmb3IgIzc4MTBcblx0XHRcdC8vIFRPRE8gcmVtb3ZlIGR1YWwgc3RvcmFnZVxuXHRcdFx0LnJlbW92ZURhdGEoIHRoaXMud2lkZ2V0TmFtZSApXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXRGdWxsTmFtZSApXG5cdFx0XHQvLyBzdXBwb3J0OiBqcXVlcnkgPDEuNi4zXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC85NDEzXG5cdFx0XHQucmVtb3ZlRGF0YSggJC5jYW1lbENhc2UoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKSApO1xuXHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiIClcblx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0dGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkIFwiICtcblx0XHRcdFx0XCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICk7XG5cblx0XHQvLyBjbGVhbiB1cCBldmVudHMgYW5kIHN0YXRlc1xuXHRcdHRoaXMuYmluZGluZ3MudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XG5cdFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0fSxcblx0X2Rlc3Ryb3k6ICQubm9vcCxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdH0sXG5cblx0b3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgb3B0aW9ucyA9IGtleSxcblx0XHRcdHBhcnRzLFxuXHRcdFx0Y3VyT3B0aW9uLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdC8vIGRvbid0IHJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgaGFzaFxuXHRcdFx0cmV0dXJuICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdC8vIGhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXCJmb28uYmFyXCIgPT4geyBmb286IHsgYmFyOiBfX18gfSB9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0XHRcdGN1ck9wdGlvblsgcGFydHNbIGkgXSBdID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gfHwge307XG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyT3B0aW9uWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN1ck9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uKCBrZXksIG9wdGlvbnNbIGtleSBdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLndpZGdldCgpXG5cdFx0XHRcdC50b2dnbGVDbGFzcyggdGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkIHVpLXN0YXRlLWRpc2FibGVkXCIsICEhdmFsdWUgKVxuXHRcdFx0XHQuYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIHZhbHVlICk7XG5cdFx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR0aGlzLmZvY3VzYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIGZhbHNlICk7XG5cdH0sXG5cdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgdHJ1ZSApO1xuXHR9LFxuXG5cdF9vbjogZnVuY3Rpb24oIHN1cHByZXNzRGlzYWJsZWRDaGVjaywgZWxlbWVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGRlbGVnYXRlRWxlbWVudCxcblx0XHRcdGluc3RhbmNlID0gdGhpcztcblxuXHRcdC8vIG5vIHN1cHByZXNzRGlzYWJsZWRDaGVjayBmbGFnLCBzaHVmZmxlIGFyZ3VtZW50c1xuXHRcdGlmICggdHlwZW9mIHN1cHByZXNzRGlzYWJsZWRDaGVjayAhPT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gc3VwcHJlc3NEaXNhYmxlZENoZWNrO1xuXHRcdFx0c3VwcHJlc3NEaXNhYmxlZENoZWNrID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gbm8gZWxlbWVudCBhcmd1bWVudCwgc2h1ZmZsZSBhbmQgdXNlIHRoaXMuZWxlbWVudFxuXHRcdGlmICggIWhhbmRsZXJzICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdGRlbGVnYXRlRWxlbWVudCA9IHRoaXMud2lkZ2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFjY2VwdCBzZWxlY3RvcnMsIERPTSBlbGVtZW50c1xuXHRcdFx0ZWxlbWVudCA9IGRlbGVnYXRlRWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZCggZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdCQuZWFjaCggaGFuZGxlcnMsIGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdFx0Ly8gYWxsb3cgd2lkZ2V0cyB0byBjdXN0b21pemUgdGhlIGRpc2FibGVkIGhhbmRsaW5nXG5cdFx0XHRcdC8vIC0gZGlzYWJsZWQgYXMgYW4gYXJyYXkgaW5zdGVhZCBvZiBib29sZWFuXG5cdFx0XHRcdC8vIC0gZGlzYWJsZWQgY2xhc3MgYXMgbWV0aG9kIGZvciBkaXNhYmxpbmcgaW5kaXZpZHVhbCBwYXJ0c1xuXHRcdFx0XHRpZiAoICFzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgJiZcblx0XHRcdFx0XHRcdCggaW5zdGFuY2Uub3B0aW9ucy5kaXNhYmxlZCA9PT0gdHJ1ZSB8fFxuXHRcdFx0XHRcdFx0XHQkKCB0aGlzICkuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb3B5IHRoZSBndWlkIHNvIGRpcmVjdCB1bmJpbmRpbmcgd29ya3Ncblx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGhhbmRsZXJQcm94eS5ndWlkID0gaGFuZGxlci5ndWlkID1cblx0XHRcdFx0XHRoYW5kbGVyLmd1aWQgfHwgaGFuZGxlclByb3h5Lmd1aWQgfHwgJC5ndWlkKys7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKCAvXihcXHcrKVxccyooLiopJC8gKSxcblx0XHRcdFx0ZXZlbnROYW1lID0gbWF0Y2hbMV0gKyBpbnN0YW5jZS5ldmVudE5hbWVzcGFjZSxcblx0XHRcdFx0c2VsZWN0b3IgPSBtYXRjaFsyXTtcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGRlbGVnYXRlRWxlbWVudC5kZWxlZ2F0ZSggc2VsZWN0b3IsIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LmJpbmQoIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IFwiXCIpLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICsgdGhpcy5ldmVudE5hbWVzcGFjZTtcblx0XHRlbGVtZW50LnVuYmluZCggZXZlbnROYW1lICkudW5kZWxlZ2F0ZSggZXZlbnROYW1lICk7XG5cdH0sXG5cblx0X2RlbGF5OiBmdW5jdGlvbiggaGFuZGxlciwgZGVsYXkgKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KCBoYW5kbGVyUHJveHksIGRlbGF5IHx8IDAgKTtcblx0fSxcblxuXHRfaG92ZXJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmhvdmVyYWJsZSA9IHRoaXMuaG92ZXJhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9LFxuXHRcdFx0bW91c2VsZWF2ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9mb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdGZvY3VzaW46IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRmb2N1c291dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0dmFyIHByb3AsIG9yaWcsXG5cdFx0XHRjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xuXHRcdGV2ZW50LnR5cGUgPSAoIHR5cGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggP1xuXHRcdFx0dHlwZSA6XG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0Ly8gdGhlIG9yaWdpbmFsIGV2ZW50IG1heSBjb21lIGZyb20gYW55IGVsZW1lbnRcblx0XHQvLyBzbyB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB0YXJnZXQgb24gdGhlIG5ldyBldmVudFxuXHRcdGV2ZW50LnRhcmdldCA9IHRoaXMuZWxlbWVudFsgMCBdO1xuXG5cdFx0Ly8gY29weSBvcmlnaW5hbCBldmVudCBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIG5ldyBldmVudFxuXHRcdG9yaWcgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuXHRcdGlmICggb3JpZyApIHtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0aWYgKCAhKCBwcm9wIGluIGV2ZW50ICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBldmVudCwgZGF0YSApO1xuXHRcdHJldHVybiAhKCAkLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgJiZcblx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLmVsZW1lbnRbMF0sIFsgZXZlbnQgXS5jb25jYXQoIGRhdGEgKSApID09PSBmYWxzZSB8fFxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcblx0fVxufTtcblxuJC5lYWNoKCB7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIGRlZmF1bHRFZmZlY3QgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZVsgXCJfXCIgKyBtZXRob2QgXSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZWZmZWN0OiBvcHRpb25zIH07XG5cdFx0fVxuXHRcdHZhciBoYXNPcHRpb25zLFxuXHRcdFx0ZWZmZWN0TmFtZSA9ICFvcHRpb25zID9cblx0XHRcdFx0bWV0aG9kIDpcblx0XHRcdFx0b3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdFx0ZGVmYXVsdEVmZmVjdCA6XG5cdFx0XHRcdFx0b3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZHVyYXRpb246IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0aGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3QoIG9wdGlvbnMgKTtcblx0XHRvcHRpb25zLmNvbXBsZXRlID0gY2FsbGJhY2s7XG5cdFx0aWYgKCBvcHRpb25zLmRlbGF5ICkge1xuXHRcdFx0ZWxlbWVudC5kZWxheSggb3B0aW9ucy5kZWxheSApO1xuXHRcdH1cblx0XHRpZiAoIGhhc09wdGlvbnMgJiYgJC5lZmZlY3RzICYmICQuZWZmZWN0cy5lZmZlY3RbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIG1ldGhvZCBdKCBvcHRpb25zICk7XG5cdFx0fSBlbHNlIGlmICggZWZmZWN0TmFtZSAhPT0gbWV0aG9kICYmIGVsZW1lbnRbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIGVmZmVjdE5hbWUgXSggb3B0aW9ucy5kdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQucXVldWUoZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBlbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59KTtcblxufSkoIGpRdWVyeSApO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaW1wb3J0cy1sb2FkZXI/alF1ZXJ5PWpxdWVyeSEuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9qcXVlcnktdWktMS4xMC40L2pxdWVyeS51aS53aWRnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDI2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "shim/jquery.ui.mouse":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/jquery\"),\n       __webpack_require__(\"shim/jquery.ui.widget\"),\n       __webpack_require__(266)], __WEBPACK_AMD_DEFINE_RESULT__ = function($) {\n    return $;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vanF1ZXJ5LnVpLm1vdXNlLmpzPzk5ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJzaGltL2pxdWVyeS51aS5tb3VzZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbJ2pxdWVyeScsXG4gICAgICAgJ2pxdWVyeS51aS53aWRnZXQnLFxuICAgICAgICdpbXBvcnRzP2pRdWVyeT1qcXVlcnkhY29udHJpYi9qcXVlcnktdWktMS4xMC40L2pxdWVyeS51aS5tb3VzZSddLCBmdW5jdGlvbigkKSB7XG4gICAgcmV0dXJuICQ7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvc2hpbS9qcXVlcnkudWkubW91c2UuanNcbi8vIG1vZHVsZSBpZCA9IHNoaW0vanF1ZXJ5LnVpLm1vdXNlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 266:
/***/ (function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(\"shim/jquery\");\n\n/*!\n * jQuery UI Mouse 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/mouse/\n *\n * Depends:\n *\tjquery.ui.widget.js\n */\n(function( $, undefined ) {\n\nvar mouseHandled = false;\n$( document ).mouseup( function() {\n\tmouseHandled = false;\n});\n\n$.widget(\"ui.mouse\", {\n\tversion: \"1.10.4\",\n\toptions: {\n\t\tcancel: \"input,textarea,button,select,option\",\n\t\tdistance: 1,\n\t\tdelay: 0\n\t},\n\t_mouseInit: function() {\n\t\tvar that = this;\n\n\t\tthis.element\n\t\t\t.bind(\"mousedown.\"+this.widgetName, function(event) {\n\t\t\t\treturn that._mouseDown(event);\n\t\t\t})\n\t\t\t.bind(\"click.\"+this.widgetName, function(event) {\n\t\t\t\tif (true === $.data(event.target, that.widgetName + \".preventClickEvent\")) {\n\t\t\t\t\t$.removeData(event.target, that.widgetName + \".preventClickEvent\");\n\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.started = false;\n\t},\n\n\t// TODO: make sure destroying one instance of mouse doesn't mess with\n\t// other instances of mouse\n\t_mouseDestroy: function() {\n\t\tthis.element.unbind(\".\"+this.widgetName);\n\t\tif ( this._mouseMoveDelegate ) {\n\t\t\t$(document)\n\t\t\t\t.unbind(\"mousemove.\"+this.widgetName, this._mouseMoveDelegate)\n\t\t\t\t.unbind(\"mouseup.\"+this.widgetName, this._mouseUpDelegate);\n\t\t}\n\t},\n\n\t_mouseDown: function(event) {\n\t\t// don't let more than one widget handle mouseStart\n\t\tif( mouseHandled ) { return; }\n\n\t\t// we may have missed mouseup (out of window)\n\t\t(this._mouseStarted && this._mouseUp(event));\n\n\t\tthis._mouseDownEvent = event;\n\n\t\tvar that = this,\n\t\t\tbtnIsLeft = (event.which === 1),\n\t\t\t// event.target.nodeName works around a bug in IE 8 with\n\t\t\t// disabled inputs (#7620)\n\t\t\telIsCancel = (typeof this.options.cancel === \"string\" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\n\t\tif (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tthis.mouseDelayMet = !this.options.delay;\n\t\tif (!this.mouseDelayMet) {\n\t\t\tthis._mouseDelayTimer = setTimeout(function() {\n\t\t\t\tthat.mouseDelayMet = true;\n\t\t\t}, this.options.delay);\n\t\t}\n\n\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\tthis._mouseStarted = (this._mouseStart(event) !== false);\n\t\t\tif (!this._mouseStarted) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Click event may never have fired (Gecko & Opera)\n\t\tif (true === $.data(event.target, this.widgetName + \".preventClickEvent\")) {\n\t\t\t$.removeData(event.target, this.widgetName + \".preventClickEvent\");\n\t\t}\n\n\t\t// these delegates are required to keep context\n\t\tthis._mouseMoveDelegate = function(event) {\n\t\t\treturn that._mouseMove(event);\n\t\t};\n\t\tthis._mouseUpDelegate = function(event) {\n\t\t\treturn that._mouseUp(event);\n\t\t};\n\t\t$(document)\n\t\t\t.bind(\"mousemove.\"+this.widgetName, this._mouseMoveDelegate)\n\t\t\t.bind(\"mouseup.\"+this.widgetName, this._mouseUpDelegate);\n\n\t\tevent.preventDefault();\n\n\t\tmouseHandled = true;\n\t\treturn true;\n\t},\n\n\t_mouseMove: function(event) {\n\t\t// IE mouseup check - mouseup happened when mouse was out of window\n\t\tif ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {\n\t\t\treturn this._mouseUp(event);\n\t\t}\n\n\t\tif (this._mouseStarted) {\n\t\t\tthis._mouseDrag(event);\n\t\t\treturn event.preventDefault();\n\t\t}\n\n\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\tthis._mouseStarted =\n\t\t\t\t(this._mouseStart(this._mouseDownEvent, event) !== false);\n\t\t\t(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\n\t\t}\n\n\t\treturn !this._mouseStarted;\n\t},\n\n\t_mouseUp: function(event) {\n\t\t$(document)\n\t\t\t.unbind(\"mousemove.\"+this.widgetName, this._mouseMoveDelegate)\n\t\t\t.unbind(\"mouseup.\"+this.widgetName, this._mouseUpDelegate);\n\n\t\tif (this._mouseStarted) {\n\t\t\tthis._mouseStarted = false;\n\n\t\t\tif (event.target === this._mouseDownEvent.target) {\n\t\t\t\t$.data(event.target, this.widgetName + \".preventClickEvent\", true);\n\t\t\t}\n\n\t\t\tthis._mouseStop(event);\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_mouseDistanceMet: function(event) {\n\t\treturn (Math.max(\n\t\t\t\tMath.abs(this._mouseDownEvent.pageX - event.pageX),\n\t\t\t\tMath.abs(this._mouseDownEvent.pageY - event.pageY)\n\t\t\t) >= this.options.distance\n\t\t);\n\t},\n\n\t_mouseDelayMet: function(/* event */) {\n\t\treturn this.mouseDelayMet;\n\t},\n\n\t// These are placeholder methods, to be overriden by extending plugin\n\t_mouseStart: function(/* event */) {},\n\t_mouseDrag: function(/* event */) {},\n\t_mouseStop: function(/* event */) {},\n\t_mouseCapture: function(/* event */) { return true; }\n});\n\n})(jQuery);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvanF1ZXJ5LXVpLTEuMTAuNC9qcXVlcnkudWkubW91c2UuanM/ZGVjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyx1Q0FBdUMsYUFBYTtBQUNwRCxDQUFDOztBQUVELENBQUMiLCJmaWxlIjoiMjY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG5cbi8qIVxuICogalF1ZXJ5IFVJIE1vdXNlIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9tb3VzZS9cbiAqXG4gKiBEZXBlbmRzOlxuICpcdGpxdWVyeS51aS53aWRnZXQuanNcbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciBtb3VzZUhhbmRsZWQgPSBmYWxzZTtcbiQoIGRvY3VtZW50ICkubW91c2V1cCggZnVuY3Rpb24oKSB7XG5cdG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xufSk7XG5cbiQud2lkZ2V0KFwidWkubW91c2VcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuNFwiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y2FuY2VsOiBcImlucHV0LHRleHRhcmVhLGJ1dHRvbixzZWxlY3Qsb3B0aW9uXCIsXG5cdFx0ZGlzdGFuY2U6IDEsXG5cdFx0ZGVsYXk6IDBcblx0fSxcblx0X21vdXNlSW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuYmluZChcIm1vdXNlZG93bi5cIit0aGlzLndpZGdldE5hbWUsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZURvd24oZXZlbnQpO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKFwiY2xpY2suXCIrdGhpcy53aWRnZXROYW1lLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRpZiAodHJ1ZSA9PT0gJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIikpIHtcblx0XHRcdFx0XHQkLnJlbW92ZURhdGEoZXZlbnQudGFyZ2V0LCB0aGF0LndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKTtcblx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5zdGFydGVkID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gVE9ETzogbWFrZSBzdXJlIGRlc3Ryb3lpbmcgb25lIGluc3RhbmNlIG9mIG1vdXNlIGRvZXNuJ3QgbWVzcyB3aXRoXG5cdC8vIG90aGVyIGluc3RhbmNlcyBvZiBtb3VzZVxuXHRfbW91c2VEZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQudW5iaW5kKFwiLlwiK3RoaXMud2lkZ2V0TmFtZSk7XG5cdFx0aWYgKCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSApIHtcblx0XHRcdCQoZG9jdW1lbnQpXG5cdFx0XHRcdC51bmJpbmQoXCJtb3VzZW1vdmUuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSlcblx0XHRcdFx0LnVuYmluZChcIm1vdXNldXAuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfbW91c2VEb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIGRvbid0IGxldCBtb3JlIHRoYW4gb25lIHdpZGdldCBoYW5kbGUgbW91c2VTdGFydFxuXHRcdGlmKCBtb3VzZUhhbmRsZWQgKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gd2UgbWF5IGhhdmUgbWlzc2VkIG1vdXNldXAgKG91dCBvZiB3aW5kb3cpXG5cdFx0KHRoaXMuX21vdXNlU3RhcnRlZCAmJiB0aGlzLl9tb3VzZVVwKGV2ZW50KSk7XG5cblx0XHR0aGlzLl9tb3VzZURvd25FdmVudCA9IGV2ZW50O1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0YnRuSXNMZWZ0ID0gKGV2ZW50LndoaWNoID09PSAxKSxcblx0XHRcdC8vIGV2ZW50LnRhcmdldC5ub2RlTmFtZSB3b3JrcyBhcm91bmQgYSBidWcgaW4gSUUgOCB3aXRoXG5cdFx0XHQvLyBkaXNhYmxlZCBpbnB1dHMgKCM3NjIwKVxuXHRcdFx0ZWxJc0NhbmNlbCA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLmNhbmNlbCA9PT0gXCJzdHJpbmdcIiAmJiBldmVudC50YXJnZXQubm9kZU5hbWUgPyAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdCh0aGlzLm9wdGlvbnMuY2FuY2VsKS5sZW5ndGggOiBmYWxzZSk7XG5cdFx0aWYgKCFidG5Jc0xlZnQgfHwgZWxJc0NhbmNlbCB8fCAhdGhpcy5fbW91c2VDYXB0dXJlKGV2ZW50KSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb3VzZURlbGF5TWV0ID0gIXRoaXMub3B0aW9ucy5kZWxheTtcblx0XHRpZiAoIXRoaXMubW91c2VEZWxheU1ldCkge1xuXHRcdFx0dGhpcy5fbW91c2VEZWxheVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5tb3VzZURlbGF5TWV0ID0gdHJ1ZTtcblx0XHRcdH0sIHRoaXMub3B0aW9ucy5kZWxheSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSAodGhpcy5fbW91c2VTdGFydChldmVudCkgIT09IGZhbHNlKTtcblx0XHRcdGlmICghdGhpcy5fbW91c2VTdGFydGVkKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENsaWNrIGV2ZW50IG1heSBuZXZlciBoYXZlIGZpcmVkIChHZWNrbyAmIE9wZXJhKVxuXHRcdGlmICh0cnVlID09PSAkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKSkge1xuXHRcdFx0JC5yZW1vdmVEYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIik7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlc2UgZGVsZWdhdGVzIGFyZSByZXF1aXJlZCB0byBrZWVwIGNvbnRleHRcblx0XHR0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdGhhdC5fbW91c2VNb3ZlKGV2ZW50KTtcblx0XHR9O1xuXHRcdHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdGhhdC5fbW91c2VVcChldmVudCk7XG5cdFx0fTtcblx0XHQkKGRvY3VtZW50KVxuXHRcdFx0LmJpbmQoXCJtb3VzZW1vdmUuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSlcblx0XHRcdC5iaW5kKFwibW91c2V1cC5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0bW91c2VIYW5kbGVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VNb3ZlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIElFIG1vdXNldXAgY2hlY2sgLSBtb3VzZXVwIGhhcHBlbmVkIHdoZW4gbW91c2Ugd2FzIG91dCBvZiB3aW5kb3dcblx0XHRpZiAoJC51aS5pZSAmJiAoICFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgOSApICYmICFldmVudC5idXR0b24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9tb3VzZVVwKGV2ZW50KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VTdGFydGVkKSB7XG5cdFx0XHR0aGlzLl9tb3VzZURyYWcoZXZlbnQpO1xuXHRcdFx0cmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPVxuXHRcdFx0XHQodGhpcy5fbW91c2VTdGFydCh0aGlzLl9tb3VzZURvd25FdmVudCwgZXZlbnQpICE9PSBmYWxzZSk7XG5cdFx0XHQodGhpcy5fbW91c2VTdGFydGVkID8gdGhpcy5fbW91c2VEcmFnKGV2ZW50KSA6IHRoaXMuX21vdXNlVXAoZXZlbnQpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gIXRoaXMuX21vdXNlU3RhcnRlZDtcblx0fSxcblxuXHRfbW91c2VVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQkKGRvY3VtZW50KVxuXHRcdFx0LnVuYmluZChcIm1vdXNlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0LnVuYmluZChcIm1vdXNldXAuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xuXG5cdFx0aWYgKHRoaXMuX21vdXNlU3RhcnRlZCkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID0gZmFsc2U7XG5cblx0XHRcdGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuX21vdXNlRG93bkV2ZW50LnRhcmdldCkge1xuXHRcdFx0XHQkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbW91c2VTdG9wKGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlRGlzdGFuY2VNZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIChNYXRoLm1heChcblx0XHRcdFx0TWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVggLSBldmVudC5wYWdlWCksXG5cdFx0XHRcdE1hdGguYWJzKHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VZIC0gZXZlbnQucGFnZVkpXG5cdFx0XHQpID49IHRoaXMub3B0aW9ucy5kaXN0YW5jZVxuXHRcdCk7XG5cdH0sXG5cblx0X21vdXNlRGVsYXlNZXQ6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VEZWxheU1ldDtcblx0fSxcblxuXHQvLyBUaGVzZSBhcmUgcGxhY2Vob2xkZXIgbWV0aG9kcywgdG8gYmUgb3ZlcnJpZGVuIGJ5IGV4dGVuZGluZyBwbHVnaW5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7fSxcblx0X21vdXNlRHJhZzogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHt9LFxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbigvKiBldmVudCAqLykge30sXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7IHJldHVybiB0cnVlOyB9XG59KTtcblxufSkoalF1ZXJ5KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ltcG9ydHMtbG9hZGVyP2pRdWVyeT1qcXVlcnkhLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvanF1ZXJ5LXVpLTEuMTAuNC9qcXVlcnkudWkubW91c2UuanNcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 267:
/***/ (function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(\"shim/jquery\");\n(function() {\n\n/*!\n * jQuery resize event - v1.1 - 3/14/2010\n * http://benalman.com/projects/jquery-resize-plugin/\n * \n * Copyright (c) 2010 \"Cowboy\" Ben Alman\n * Dual licensed under the MIT and GPL licenses.\n * http://benalman.com/about/license/\n */\n\n// Script: jQuery resize event\n//\n// *Version: 1.1, Last updated: 3/14/2010*\n// \n// Project Home - http://benalman.com/projects/jquery-resize-plugin/\n// GitHub       - http://github.com/cowboy/jquery-resize/\n// Source       - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.js\n// (Minified)   - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.min.js (1.0kb)\n// \n// About: License\n// \n// Copyright (c) 2010 \"Cowboy\" Ben Alman,\n// Dual licensed under the MIT and GPL licenses.\n// http://benalman.com/about/license/\n// \n// About: Examples\n// \n// This working example, complete with fully commented code, illustrates a few\n// ways in which this plugin can be used.\n// \n// resize event - http://benalman.com/code/projects/jquery-resize/examples/resize/\n// \n// About: Support and Testing\n// \n// Information about what version or versions of jQuery this plugin has been\n// tested with, what browsers it has been tested in, and where the unit tests\n// reside (so you can test it yourself).\n// \n// jQuery Versions - 1.3.2, 1.4.1, 1.4.2\n// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome, Opera 9.6-10.1.\n// Unit Tests      - http://benalman.com/code/projects/jquery-resize/unit/\n// \n// About: Release History\n// \n// 1.1 - (3/14/2010) Fixed a minor bug that was causing the event to trigger\n//       immediately after bind in some circumstances. Also changed $.fn.data\n//       to $.data to improve performance.\n// 1.0 - (2/10/2010) Initial release\n\n(function($,window,undefined){\n  '$:nomunge'; // Used by YUI compressor.\n  \n  // A jQuery object containing all non-window elements to which the resize\n  // event is bound.\n  var elems = $([]),\n    \n    // Extend $.resize if it already exists, otherwise create it.\n    jq_resize = $.resize = $.extend( $.resize, {} ),\n    \n    timeout_id,\n    \n    // Reused strings.\n    str_setTimeout = 'setTimeout',\n    str_resize = 'elementResize',\n    str_data = str_resize + '-special-event',\n    str_delay = 'delay',\n    str_throttle = 'throttleWindow';\n  \n  // Property: jQuery.resize.delay\n  // \n  // The numeric interval (in milliseconds) at which the resize event polling\n  // loop executes. Defaults to 250.\n  \n  jq_resize[ str_delay ] = 250;\n  \n  // Property: jQuery.resize.throttleWindow\n  // \n  // Throttle the native window object resize event to fire no more than once\n  // every <jQuery.resize.delay> milliseconds. Defaults to true.\n  // \n  // Because the window object has its own resize event, it doesn't need to be\n  // provided by this plugin, and its execution can be left entirely up to the\n  // browser. However, since certain browsers fire the resize event continuously\n  // while others do not, enabling this will throttle the window resize event,\n  // making event behavior consistent across all elements in all browsers.\n  // \n  // While setting this property to false will disable window object resize\n  // event throttling, please note that this property must be changed before any\n  // window object resize event callbacks are bound.\n  \n  jq_resize[ str_throttle ] = true;\n  \n  // Event: resize event\n  // \n  // Fired when an element's width or height changes. Because browsers only\n  // provide this event for the window element, for other elements a polling\n  // loop is initialized, running every <jQuery.resize.delay> milliseconds\n  // to see if elements' dimensions have changed. You may bind with either\n  // .resize( fn ) or .bind( \"resize\", fn ), and unbind with .unbind( \"resize\" ).\n  // \n  // Usage:\n  // \n  // > jQuery('selector').bind( 'resize', function(e) {\n  // >   // element's width or height has changed!\n  // >   ...\n  // > });\n  // \n  // Additional Notes:\n  // \n  // * The polling loop is not created until at least one callback is actually\n  //   bound to the 'resize' event, and this single polling loop is shared\n  //   across all elements.\n  // \n  // Double firing issue in jQuery 1.3.2:\n  // \n  // While this plugin works in jQuery 1.3.2, if an element's event callbacks\n  // are manually triggered via .trigger( 'resize' ) or .resize() those\n  // callbacks may double-fire, due to limitations in the jQuery 1.3.2 special\n  // events system. This is not an issue when using jQuery 1.4+.\n  // \n  // > // While this works in jQuery 1.4+\n  // > $(elem).css({ width: new_w, height: new_h }).resize();\n  // > \n  // > // In jQuery 1.3.2, you need to do this:\n  // > var elem = $(elem);\n  // > elem.css({ width: new_w, height: new_h });\n  // > elem.data( 'resize-special-event', { width: elem.width(), height: elem.height() } );\n  // > elem.resize();\n\n  $.event.special[ str_resize ] = {\n    \n    // Called only when the first 'resize' event callback is bound per element.\n    setup: function() {\n      // Since window has its own native 'resize' event, return false so that\n      // jQuery will bind the event using DOM methods. Since only 'window'\n      // objects have a .setTimeout method, this should be a sufficient test.\n      // Unless, of course, we're throttling the 'resize' event for window.\n      if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }\n      \n      var elem = $(this);\n      \n      // Add this element to the list of internal elements to monitor.\n      elems = elems.add( elem );\n      \n      // Initialize data store on the element.\n      $.data( this, str_data, { w: elem.width(), h: elem.height() } );\n      \n      // If this is the first element added, start the polling loop.\n      if ( elems.length === 1 ) {\n        loopy();\n      }\n    },\n    \n    // Called only when the last 'resize' event callback is unbound per element.\n    teardown: function() {\n      // Since window has its own native 'resize' event, return false so that\n      // jQuery will unbind the event using DOM methods. Since only 'window'\n      // objects have a .setTimeout method, this should be a sufficient test.\n      // Unless, of course, we're throttling the 'resize' event for window.\n      if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }\n      \n      var elem = $(this);\n      \n      // Remove this element from the list of internal elements to monitor.\n      elems = elems.not( elem );\n      \n      // Remove any data stored on the element.\n      elem.removeData( str_data );\n      \n      // If this is the last element removed, stop the polling loop.\n      if ( !elems.length ) {\n        clearTimeout( timeout_id );\n      }\n    },\n    \n    // Called every time a 'resize' event callback is bound per element (new in\n    // jQuery 1.4).\n    add: function( handleObj ) {\n      // Since window has its own native 'resize' event, return false so that\n      // jQuery doesn't modify the event object. Unless, of course, we're\n      // throttling the 'resize' event for window.\n      if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }\n      \n      var old_handler;\n      \n      // The new_handler function is executed every time the event is triggered.\n      // This is used to update the internal element data store with the width\n      // and height when the event is triggered manually, to avoid double-firing\n      // of the event callback. See the \"Double firing issue in jQuery 1.3.2\"\n      // comments above for more information.\n      \n      function new_handler( e, w, h ) {\n        var elem = $(this),\n          data = $.data( this, str_data );\n        \n        // If called from the polling loop, w and h will be passed in as\n        // arguments. If called manually, via .trigger( 'resize' ) or .resize(),\n        // those values will need to be computed.\n        data.w = w !== undefined ? w : elem.width();\n        data.h = h !== undefined ? h : elem.height();\n        \n        old_handler.apply( this, arguments );\n      };\n      \n      // This may seem a little complicated, but it normalizes the special event\n      // .add method between jQuery 1.4/1.4.1 and 1.4.2+\n      if ( $.isFunction( handleObj ) ) {\n        // 1.4, 1.4.1\n        old_handler = handleObj;\n        return new_handler;\n      } else {\n        // 1.4.2+\n        old_handler = handleObj.handler;\n        handleObj.handler = new_handler;\n      }\n    }\n    \n  };\n  \n  function loopy() {\n    \n    // Start the polling loop, asynchronously.\n    timeout_id = window[ str_setTimeout ](function(){\n      \n      // Iterate over all elements to which the 'resize' event is bound.\n      elems.each(function(){\n        var elem = $(this),\n          width = elem.width(),\n          height = elem.height(),\n          data = $.data( this, str_data );\n        \n        // If element size has changed since the last time, update the element\n        // data store and trigger the 'resize' event.\n        if ( width !== data.w || height !== data.h ) {\n          elem.trigger( str_resize, [ data.w = width, data.h = height ] );\n        }\n        \n      });\n      \n      // Loop.\n      loopy();\n      \n    }, jq_resize[ str_delay ] );\n    \n  };\n  \n})(jQuery,this);\n}.call(window));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvanF1ZXJ5LXJlc2l6ZS5qcz8wMzBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDs7QUFFakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DLDJDQUEyQyw2Q0FBNkM7QUFDeEY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGNBQWM7O0FBRWpGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isb0NBQW9DOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGNBQWM7O0FBRWpGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGNBQWM7O0FBRWpGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLENBQUM7QUFDRCxDQUFDIiwiZmlsZSI6IjI2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xuKGZ1bmN0aW9uKCkge1xuXG4vKiFcbiAqIGpRdWVyeSByZXNpemUgZXZlbnQgLSB2MS4xIC0gMy8xNC8yMDEwXG4gKiBodHRwOi8vYmVuYWxtYW4uY29tL3Byb2plY3RzL2pxdWVyeS1yZXNpemUtcGx1Z2luL1xuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgXCJDb3dib3lcIiBCZW4gQWxtYW5cbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzLlxuICogaHR0cDovL2JlbmFsbWFuLmNvbS9hYm91dC9saWNlbnNlL1xuICovXG5cbi8vIFNjcmlwdDogalF1ZXJ5IHJlc2l6ZSBldmVudFxuLy9cbi8vICpWZXJzaW9uOiAxLjEsIExhc3QgdXBkYXRlZDogMy8xNC8yMDEwKlxuLy8gXG4vLyBQcm9qZWN0IEhvbWUgLSBodHRwOi8vYmVuYWxtYW4uY29tL3Byb2plY3RzL2pxdWVyeS1yZXNpemUtcGx1Z2luL1xuLy8gR2l0SHViICAgICAgIC0gaHR0cDovL2dpdGh1Yi5jb20vY293Ym95L2pxdWVyeS1yZXNpemUvXG4vLyBTb3VyY2UgICAgICAgLSBodHRwOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LXJlc2l6ZS9yYXcvbWFzdGVyL2pxdWVyeS5iYS1yZXNpemUuanNcbi8vIChNaW5pZmllZCkgICAtIGh0dHA6Ly9naXRodWIuY29tL2Nvd2JveS9qcXVlcnktcmVzaXplL3Jhdy9tYXN0ZXIvanF1ZXJ5LmJhLXJlc2l6ZS5taW4uanMgKDEuMGtiKVxuLy8gXG4vLyBBYm91dDogTGljZW5zZVxuLy8gXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTAgXCJDb3dib3lcIiBCZW4gQWxtYW4sXG4vLyBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cbi8vIGh0dHA6Ly9iZW5hbG1hbi5jb20vYWJvdXQvbGljZW5zZS9cbi8vIFxuLy8gQWJvdXQ6IEV4YW1wbGVzXG4vLyBcbi8vIFRoaXMgd29ya2luZyBleGFtcGxlLCBjb21wbGV0ZSB3aXRoIGZ1bGx5IGNvbW1lbnRlZCBjb2RlLCBpbGx1c3RyYXRlcyBhIGZld1xuLy8gd2F5cyBpbiB3aGljaCB0aGlzIHBsdWdpbiBjYW4gYmUgdXNlZC5cbi8vIFxuLy8gcmVzaXplIGV2ZW50IC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS1yZXNpemUvZXhhbXBsZXMvcmVzaXplL1xuLy8gXG4vLyBBYm91dDogU3VwcG9ydCBhbmQgVGVzdGluZ1xuLy8gXG4vLyBJbmZvcm1hdGlvbiBhYm91dCB3aGF0IHZlcnNpb24gb3IgdmVyc2lvbnMgb2YgalF1ZXJ5IHRoaXMgcGx1Z2luIGhhcyBiZWVuXG4vLyB0ZXN0ZWQgd2l0aCwgd2hhdCBicm93c2VycyBpdCBoYXMgYmVlbiB0ZXN0ZWQgaW4sIGFuZCB3aGVyZSB0aGUgdW5pdCB0ZXN0c1xuLy8gcmVzaWRlIChzbyB5b3UgY2FuIHRlc3QgaXQgeW91cnNlbGYpLlxuLy8gXG4vLyBqUXVlcnkgVmVyc2lvbnMgLSAxLjMuMiwgMS40LjEsIDEuNC4yXG4vLyBCcm93c2VycyBUZXN0ZWQgLSBJbnRlcm5ldCBFeHBsb3JlciA2LTgsIEZpcmVmb3ggMi0zLjYsIFNhZmFyaSAzLTQsIENocm9tZSwgT3BlcmEgOS42LTEwLjEuXG4vLyBVbml0IFRlc3RzICAgICAgLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LXJlc2l6ZS91bml0L1xuLy8gXG4vLyBBYm91dDogUmVsZWFzZSBIaXN0b3J5XG4vLyBcbi8vIDEuMSAtICgzLzE0LzIwMTApIEZpeGVkIGEgbWlub3IgYnVnIHRoYXQgd2FzIGNhdXNpbmcgdGhlIGV2ZW50IHRvIHRyaWdnZXJcbi8vICAgICAgIGltbWVkaWF0ZWx5IGFmdGVyIGJpbmQgaW4gc29tZSBjaXJjdW1zdGFuY2VzLiBBbHNvIGNoYW5nZWQgJC5mbi5kYXRhXG4vLyAgICAgICB0byAkLmRhdGEgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbi8vIDEuMCAtICgyLzEwLzIwMTApIEluaXRpYWwgcmVsZWFzZVxuXG4oZnVuY3Rpb24oJCx3aW5kb3csdW5kZWZpbmVkKXtcbiAgJyQ6bm9tdW5nZSc7IC8vIFVzZWQgYnkgWVVJIGNvbXByZXNzb3IuXG4gIFxuICAvLyBBIGpRdWVyeSBvYmplY3QgY29udGFpbmluZyBhbGwgbm9uLXdpbmRvdyBlbGVtZW50cyB0byB3aGljaCB0aGUgcmVzaXplXG4gIC8vIGV2ZW50IGlzIGJvdW5kLlxuICB2YXIgZWxlbXMgPSAkKFtdKSxcbiAgICBcbiAgICAvLyBFeHRlbmQgJC5yZXNpemUgaWYgaXQgYWxyZWFkeSBleGlzdHMsIG90aGVyd2lzZSBjcmVhdGUgaXQuXG4gICAganFfcmVzaXplID0gJC5yZXNpemUgPSAkLmV4dGVuZCggJC5yZXNpemUsIHt9ICksXG4gICAgXG4gICAgdGltZW91dF9pZCxcbiAgICBcbiAgICAvLyBSZXVzZWQgc3RyaW5ncy5cbiAgICBzdHJfc2V0VGltZW91dCA9ICdzZXRUaW1lb3V0JyxcbiAgICBzdHJfcmVzaXplID0gJ2VsZW1lbnRSZXNpemUnLFxuICAgIHN0cl9kYXRhID0gc3RyX3Jlc2l6ZSArICctc3BlY2lhbC1ldmVudCcsXG4gICAgc3RyX2RlbGF5ID0gJ2RlbGF5JyxcbiAgICBzdHJfdGhyb3R0bGUgPSAndGhyb3R0bGVXaW5kb3cnO1xuICBcbiAgLy8gUHJvcGVydHk6IGpRdWVyeS5yZXNpemUuZGVsYXlcbiAgLy8gXG4gIC8vIFRoZSBudW1lcmljIGludGVydmFsIChpbiBtaWxsaXNlY29uZHMpIGF0IHdoaWNoIHRoZSByZXNpemUgZXZlbnQgcG9sbGluZ1xuICAvLyBsb29wIGV4ZWN1dGVzLiBEZWZhdWx0cyB0byAyNTAuXG4gIFxuICBqcV9yZXNpemVbIHN0cl9kZWxheSBdID0gMjUwO1xuICBcbiAgLy8gUHJvcGVydHk6IGpRdWVyeS5yZXNpemUudGhyb3R0bGVXaW5kb3dcbiAgLy8gXG4gIC8vIFRocm90dGxlIHRoZSBuYXRpdmUgd2luZG93IG9iamVjdCByZXNpemUgZXZlbnQgdG8gZmlyZSBubyBtb3JlIHRoYW4gb25jZVxuICAvLyBldmVyeSA8alF1ZXJ5LnJlc2l6ZS5kZWxheT4gbWlsbGlzZWNvbmRzLiBEZWZhdWx0cyB0byB0cnVlLlxuICAvLyBcbiAgLy8gQmVjYXVzZSB0aGUgd2luZG93IG9iamVjdCBoYXMgaXRzIG93biByZXNpemUgZXZlbnQsIGl0IGRvZXNuJ3QgbmVlZCB0byBiZVxuICAvLyBwcm92aWRlZCBieSB0aGlzIHBsdWdpbiwgYW5kIGl0cyBleGVjdXRpb24gY2FuIGJlIGxlZnQgZW50aXJlbHkgdXAgdG8gdGhlXG4gIC8vIGJyb3dzZXIuIEhvd2V2ZXIsIHNpbmNlIGNlcnRhaW4gYnJvd3NlcnMgZmlyZSB0aGUgcmVzaXplIGV2ZW50IGNvbnRpbnVvdXNseVxuICAvLyB3aGlsZSBvdGhlcnMgZG8gbm90LCBlbmFibGluZyB0aGlzIHdpbGwgdGhyb3R0bGUgdGhlIHdpbmRvdyByZXNpemUgZXZlbnQsXG4gIC8vIG1ha2luZyBldmVudCBiZWhhdmlvciBjb25zaXN0ZW50IGFjcm9zcyBhbGwgZWxlbWVudHMgaW4gYWxsIGJyb3dzZXJzLlxuICAvLyBcbiAgLy8gV2hpbGUgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIHdpbGwgZGlzYWJsZSB3aW5kb3cgb2JqZWN0IHJlc2l6ZVxuICAvLyBldmVudCB0aHJvdHRsaW5nLCBwbGVhc2Ugbm90ZSB0aGF0IHRoaXMgcHJvcGVydHkgbXVzdCBiZSBjaGFuZ2VkIGJlZm9yZSBhbnlcbiAgLy8gd2luZG93IG9iamVjdCByZXNpemUgZXZlbnQgY2FsbGJhY2tzIGFyZSBib3VuZC5cbiAgXG4gIGpxX3Jlc2l6ZVsgc3RyX3Rocm90dGxlIF0gPSB0cnVlO1xuICBcbiAgLy8gRXZlbnQ6IHJlc2l6ZSBldmVudFxuICAvLyBcbiAgLy8gRmlyZWQgd2hlbiBhbiBlbGVtZW50J3Mgd2lkdGggb3IgaGVpZ2h0IGNoYW5nZXMuIEJlY2F1c2UgYnJvd3NlcnMgb25seVxuICAvLyBwcm92aWRlIHRoaXMgZXZlbnQgZm9yIHRoZSB3aW5kb3cgZWxlbWVudCwgZm9yIG90aGVyIGVsZW1lbnRzIGEgcG9sbGluZ1xuICAvLyBsb29wIGlzIGluaXRpYWxpemVkLCBydW5uaW5nIGV2ZXJ5IDxqUXVlcnkucmVzaXplLmRlbGF5PiBtaWxsaXNlY29uZHNcbiAgLy8gdG8gc2VlIGlmIGVsZW1lbnRzJyBkaW1lbnNpb25zIGhhdmUgY2hhbmdlZC4gWW91IG1heSBiaW5kIHdpdGggZWl0aGVyXG4gIC8vIC5yZXNpemUoIGZuICkgb3IgLmJpbmQoIFwicmVzaXplXCIsIGZuICksIGFuZCB1bmJpbmQgd2l0aCAudW5iaW5kKCBcInJlc2l6ZVwiICkuXG4gIC8vIFxuICAvLyBVc2FnZTpcbiAgLy8gXG4gIC8vID4galF1ZXJ5KCdzZWxlY3RvcicpLmJpbmQoICdyZXNpemUnLCBmdW5jdGlvbihlKSB7XG4gIC8vID4gICAvLyBlbGVtZW50J3Mgd2lkdGggb3IgaGVpZ2h0IGhhcyBjaGFuZ2VkIVxuICAvLyA+ICAgLi4uXG4gIC8vID4gfSk7XG4gIC8vIFxuICAvLyBBZGRpdGlvbmFsIE5vdGVzOlxuICAvLyBcbiAgLy8gKiBUaGUgcG9sbGluZyBsb29wIGlzIG5vdCBjcmVhdGVkIHVudGlsIGF0IGxlYXN0IG9uZSBjYWxsYmFjayBpcyBhY3R1YWxseVxuICAvLyAgIGJvdW5kIHRvIHRoZSAncmVzaXplJyBldmVudCwgYW5kIHRoaXMgc2luZ2xlIHBvbGxpbmcgbG9vcCBpcyBzaGFyZWRcbiAgLy8gICBhY3Jvc3MgYWxsIGVsZW1lbnRzLlxuICAvLyBcbiAgLy8gRG91YmxlIGZpcmluZyBpc3N1ZSBpbiBqUXVlcnkgMS4zLjI6XG4gIC8vIFxuICAvLyBXaGlsZSB0aGlzIHBsdWdpbiB3b3JrcyBpbiBqUXVlcnkgMS4zLjIsIGlmIGFuIGVsZW1lbnQncyBldmVudCBjYWxsYmFja3NcbiAgLy8gYXJlIG1hbnVhbGx5IHRyaWdnZXJlZCB2aWEgLnRyaWdnZXIoICdyZXNpemUnICkgb3IgLnJlc2l6ZSgpIHRob3NlXG4gIC8vIGNhbGxiYWNrcyBtYXkgZG91YmxlLWZpcmUsIGR1ZSB0byBsaW1pdGF0aW9ucyBpbiB0aGUgalF1ZXJ5IDEuMy4yIHNwZWNpYWxcbiAgLy8gZXZlbnRzIHN5c3RlbS4gVGhpcyBpcyBub3QgYW4gaXNzdWUgd2hlbiB1c2luZyBqUXVlcnkgMS40Ky5cbiAgLy8gXG4gIC8vID4gLy8gV2hpbGUgdGhpcyB3b3JrcyBpbiBqUXVlcnkgMS40K1xuICAvLyA+ICQoZWxlbSkuY3NzKHsgd2lkdGg6IG5ld193LCBoZWlnaHQ6IG5ld19oIH0pLnJlc2l6ZSgpO1xuICAvLyA+IFxuICAvLyA+IC8vIEluIGpRdWVyeSAxLjMuMiwgeW91IG5lZWQgdG8gZG8gdGhpczpcbiAgLy8gPiB2YXIgZWxlbSA9ICQoZWxlbSk7XG4gIC8vID4gZWxlbS5jc3MoeyB3aWR0aDogbmV3X3csIGhlaWdodDogbmV3X2ggfSk7XG4gIC8vID4gZWxlbS5kYXRhKCAncmVzaXplLXNwZWNpYWwtZXZlbnQnLCB7IHdpZHRoOiBlbGVtLndpZHRoKCksIGhlaWdodDogZWxlbS5oZWlnaHQoKSB9ICk7XG4gIC8vID4gZWxlbS5yZXNpemUoKTtcblxuICAkLmV2ZW50LnNwZWNpYWxbIHN0cl9yZXNpemUgXSA9IHtcbiAgICBcbiAgICAvLyBDYWxsZWQgb25seSB3aGVuIHRoZSBmaXJzdCAncmVzaXplJyBldmVudCBjYWxsYmFjayBpcyBib3VuZCBwZXIgZWxlbWVudC5cbiAgICBzZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBTaW5jZSB3aW5kb3cgaGFzIGl0cyBvd24gbmF0aXZlICdyZXNpemUnIGV2ZW50LCByZXR1cm4gZmFsc2Ugc28gdGhhdFxuICAgICAgLy8galF1ZXJ5IHdpbGwgYmluZCB0aGUgZXZlbnQgdXNpbmcgRE9NIG1ldGhvZHMuIFNpbmNlIG9ubHkgJ3dpbmRvdydcbiAgICAgIC8vIG9iamVjdHMgaGF2ZSBhIC5zZXRUaW1lb3V0IG1ldGhvZCwgdGhpcyBzaG91bGQgYmUgYSBzdWZmaWNpZW50IHRlc3QuXG4gICAgICAvLyBVbmxlc3MsIG9mIGNvdXJzZSwgd2UncmUgdGhyb3R0bGluZyB0aGUgJ3Jlc2l6ZScgZXZlbnQgZm9yIHdpbmRvdy5cbiAgICAgIGlmICggIWpxX3Jlc2l6ZVsgc3RyX3Rocm90dGxlIF0gJiYgdGhpc1sgc3RyX3NldFRpbWVvdXQgXSApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBcbiAgICAgIHZhciBlbGVtID0gJCh0aGlzKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHRoaXMgZWxlbWVudCB0byB0aGUgbGlzdCBvZiBpbnRlcm5hbCBlbGVtZW50cyB0byBtb25pdG9yLlxuICAgICAgZWxlbXMgPSBlbGVtcy5hZGQoIGVsZW0gKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBkYXRhIHN0b3JlIG9uIHRoZSBlbGVtZW50LlxuICAgICAgJC5kYXRhKCB0aGlzLCBzdHJfZGF0YSwgeyB3OiBlbGVtLndpZHRoKCksIGg6IGVsZW0uaGVpZ2h0KCkgfSApO1xuICAgICAgXG4gICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBlbGVtZW50IGFkZGVkLCBzdGFydCB0aGUgcG9sbGluZyBsb29wLlxuICAgICAgaWYgKCBlbGVtcy5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgIGxvb3B5KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICAvLyBDYWxsZWQgb25seSB3aGVuIHRoZSBsYXN0ICdyZXNpemUnIGV2ZW50IGNhbGxiYWNrIGlzIHVuYm91bmQgcGVyIGVsZW1lbnQuXG4gICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gU2luY2Ugd2luZG93IGhhcyBpdHMgb3duIG5hdGl2ZSAncmVzaXplJyBldmVudCwgcmV0dXJuIGZhbHNlIHNvIHRoYXRcbiAgICAgIC8vIGpRdWVyeSB3aWxsIHVuYmluZCB0aGUgZXZlbnQgdXNpbmcgRE9NIG1ldGhvZHMuIFNpbmNlIG9ubHkgJ3dpbmRvdydcbiAgICAgIC8vIG9iamVjdHMgaGF2ZSBhIC5zZXRUaW1lb3V0IG1ldGhvZCwgdGhpcyBzaG91bGQgYmUgYSBzdWZmaWNpZW50IHRlc3QuXG4gICAgICAvLyBVbmxlc3MsIG9mIGNvdXJzZSwgd2UncmUgdGhyb3R0bGluZyB0aGUgJ3Jlc2l6ZScgZXZlbnQgZm9yIHdpbmRvdy5cbiAgICAgIGlmICggIWpxX3Jlc2l6ZVsgc3RyX3Rocm90dGxlIF0gJiYgdGhpc1sgc3RyX3NldFRpbWVvdXQgXSApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBcbiAgICAgIHZhciBlbGVtID0gJCh0aGlzKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIHRoaXMgZWxlbWVudCBmcm9tIHRoZSBsaXN0IG9mIGludGVybmFsIGVsZW1lbnRzIHRvIG1vbml0b3IuXG4gICAgICBlbGVtcyA9IGVsZW1zLm5vdCggZWxlbSApO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LlxuICAgICAgZWxlbS5yZW1vdmVEYXRhKCBzdHJfZGF0YSApO1xuICAgICAgXG4gICAgICAvLyBJZiB0aGlzIGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVtb3ZlZCwgc3RvcCB0aGUgcG9sbGluZyBsb29wLlxuICAgICAgaWYgKCAhZWxlbXMubGVuZ3RoICkge1xuICAgICAgICBjbGVhclRpbWVvdXQoIHRpbWVvdXRfaWQgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIC8vIENhbGxlZCBldmVyeSB0aW1lIGEgJ3Jlc2l6ZScgZXZlbnQgY2FsbGJhY2sgaXMgYm91bmQgcGVyIGVsZW1lbnQgKG5ldyBpblxuICAgIC8vIGpRdWVyeSAxLjQpLlxuICAgIGFkZDogZnVuY3Rpb24oIGhhbmRsZU9iaiApIHtcbiAgICAgIC8vIFNpbmNlIHdpbmRvdyBoYXMgaXRzIG93biBuYXRpdmUgJ3Jlc2l6ZScgZXZlbnQsIHJldHVybiBmYWxzZSBzbyB0aGF0XG4gICAgICAvLyBqUXVlcnkgZG9lc24ndCBtb2RpZnkgdGhlIGV2ZW50IG9iamVjdC4gVW5sZXNzLCBvZiBjb3Vyc2UsIHdlJ3JlXG4gICAgICAvLyB0aHJvdHRsaW5nIHRoZSAncmVzaXplJyBldmVudCBmb3Igd2luZG93LlxuICAgICAgaWYgKCAhanFfcmVzaXplWyBzdHJfdGhyb3R0bGUgXSAmJiB0aGlzWyBzdHJfc2V0VGltZW91dCBdICkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIFxuICAgICAgdmFyIG9sZF9oYW5kbGVyO1xuICAgICAgXG4gICAgICAvLyBUaGUgbmV3X2hhbmRsZXIgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZXZlcnkgdGltZSB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWwgZWxlbWVudCBkYXRhIHN0b3JlIHdpdGggdGhlIHdpZHRoXG4gICAgICAvLyBhbmQgaGVpZ2h0IHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCBtYW51YWxseSwgdG8gYXZvaWQgZG91YmxlLWZpcmluZ1xuICAgICAgLy8gb2YgdGhlIGV2ZW50IGNhbGxiYWNrLiBTZWUgdGhlIFwiRG91YmxlIGZpcmluZyBpc3N1ZSBpbiBqUXVlcnkgMS4zLjJcIlxuICAgICAgLy8gY29tbWVudHMgYWJvdmUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIG5ld19oYW5kbGVyKCBlLCB3LCBoICkge1xuICAgICAgICB2YXIgZWxlbSA9ICQodGhpcyksXG4gICAgICAgICAgZGF0YSA9ICQuZGF0YSggdGhpcywgc3RyX2RhdGEgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIGNhbGxlZCBmcm9tIHRoZSBwb2xsaW5nIGxvb3AsIHcgYW5kIGggd2lsbCBiZSBwYXNzZWQgaW4gYXNcbiAgICAgICAgLy8gYXJndW1lbnRzLiBJZiBjYWxsZWQgbWFudWFsbHksIHZpYSAudHJpZ2dlciggJ3Jlc2l6ZScgKSBvciAucmVzaXplKCksXG4gICAgICAgIC8vIHRob3NlIHZhbHVlcyB3aWxsIG5lZWQgdG8gYmUgY29tcHV0ZWQuXG4gICAgICAgIGRhdGEudyA9IHcgIT09IHVuZGVmaW5lZCA/IHcgOiBlbGVtLndpZHRoKCk7XG4gICAgICAgIGRhdGEuaCA9IGggIT09IHVuZGVmaW5lZCA/IGggOiBlbGVtLmhlaWdodCgpO1xuICAgICAgICBcbiAgICAgICAgb2xkX2hhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gVGhpcyBtYXkgc2VlbSBhIGxpdHRsZSBjb21wbGljYXRlZCwgYnV0IGl0IG5vcm1hbGl6ZXMgdGhlIHNwZWNpYWwgZXZlbnRcbiAgICAgIC8vIC5hZGQgbWV0aG9kIGJldHdlZW4galF1ZXJ5IDEuNC8xLjQuMSBhbmQgMS40LjIrXG4gICAgICBpZiAoICQuaXNGdW5jdGlvbiggaGFuZGxlT2JqICkgKSB7XG4gICAgICAgIC8vIDEuNCwgMS40LjFcbiAgICAgICAgb2xkX2hhbmRsZXIgPSBoYW5kbGVPYmo7XG4gICAgICAgIHJldHVybiBuZXdfaGFuZGxlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuNC4yK1xuICAgICAgICBvbGRfaGFuZGxlciA9IGhhbmRsZU9iai5oYW5kbGVyO1xuICAgICAgICBoYW5kbGVPYmouaGFuZGxlciA9IG5ld19oYW5kbGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIGxvb3B5KCkge1xuICAgIFxuICAgIC8vIFN0YXJ0IHRoZSBwb2xsaW5nIGxvb3AsIGFzeW5jaHJvbm91c2x5LlxuICAgIHRpbWVvdXRfaWQgPSB3aW5kb3dbIHN0cl9zZXRUaW1lb3V0IF0oZnVuY3Rpb24oKXtcbiAgICAgIFxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlbGVtZW50cyB0byB3aGljaCB0aGUgJ3Jlc2l6ZScgZXZlbnQgaXMgYm91bmQuXG4gICAgICBlbGVtcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBlbGVtID0gJCh0aGlzKSxcbiAgICAgICAgICB3aWR0aCA9IGVsZW0ud2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQgPSBlbGVtLmhlaWdodCgpLFxuICAgICAgICAgIGRhdGEgPSAkLmRhdGEoIHRoaXMsIHN0cl9kYXRhICk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBlbGVtZW50IHNpemUgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSwgdXBkYXRlIHRoZSBlbGVtZW50XG4gICAgICAgIC8vIGRhdGEgc3RvcmUgYW5kIHRyaWdnZXIgdGhlICdyZXNpemUnIGV2ZW50LlxuICAgICAgICBpZiAoIHdpZHRoICE9PSBkYXRhLncgfHwgaGVpZ2h0ICE9PSBkYXRhLmggKSB7XG4gICAgICAgICAgZWxlbS50cmlnZ2VyKCBzdHJfcmVzaXplLCBbIGRhdGEudyA9IHdpZHRoLCBkYXRhLmggPSBoZWlnaHQgXSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIExvb3AuXG4gICAgICBsb29weSgpO1xuICAgICAgXG4gICAgfSwganFfcmVzaXplWyBzdHJfZGVsYXkgXSApO1xuICAgIFxuICB9O1xuICBcbn0pKGpRdWVyeSx0aGlzKTtcbn0uY2FsbCh3aW5kb3cpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaW1wb3J0cy1sb2FkZXI/alF1ZXJ5PWpxdWVyeSx0aGlzPT53aW5kb3chLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvanF1ZXJ5LXJlc2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "views/shared/singlevalue/Sparkline":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\"),\n        module,\n        __webpack_require__(\"views/Base\"),\n        __webpack_require__(\"shim/splunk.util\"),\n        __webpack_require__(\"util/svg\"),\n        __webpack_require__(\"util/general_utils\"),\n        __webpack_require__(\"util/math_utils\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n        $,\n        _,\n        module,\n        BaseView,\n        splunkUtil,\n        svgUtil,\n        generalUtil,\n        mathUtil\n    ) {\n\n        return BaseView.extend({\n            moduleId: module.id,\n            className: \"single-value-sparkline\",\n            el: function() {\n                return svgUtil.createElement('g').attr('class', 'single-value-sparkline');\n            },\n            SPARKLINE_WIDTH: 150,\n            SPARKLINE_HEIGHT: 14,\n            SPARKLINE_Y: 77,\n            DEFAULT_SPARKLINE_COLOR: '#000000',\n            initialize: function(options) {\n                BaseView.prototype.initialize.apply(this, arguments);\n\n                this.sparklineColor = this.model.presentation.get('sparklineColor');\n                this.activate();\n            },\n            drawSparkline: function() {\n                var opacity = this.model.presentation.get('sparklineOpacity') || 1,\n                    counter = 1, // X-axis values do not matter as long as they are uniform in distance from one another\n                    rawData = this.model.results.get('sparklineData'),\n                    deltaBacktrack = this.model.results.get('deltaBacktrack');\n\n                // clear previous render\n                this.$el.empty();\n\n                // bail if no data or less than two data points\n                if (!rawData || (rawData.length < 2)) {\n                    return;\n                }\n\n                // convert data to points and compute x/y ranges\n                var points = [];\n                var minX = Infinity;\n                var maxX = -Infinity;\n                var minY = Infinity;\n                var maxY = -Infinity;\n                _.each(rawData, function(d) {\n                    var x = counter++;\n                    var y = parseFloat(d) || 0;\n                    minX = Math.min(x, minX);\n                    maxX = Math.max(x, maxX);\n                    minY = Math.min(y, minY);\n                    maxY = Math.max(y, maxY);\n                    points.push({ x: x, y: y });\n                });\n\n                // scale points to width/height\n                var width = this.SPARKLINE_WIDTH;\n                var height = this.SPARKLINE_HEIGHT;\n                _.each(points, function(d, i) {\n                    d.x = (width * ((d.x - minX) / Math.max(maxX - minX, 1)));\n                    d.y = (height * (1 - (d.y - minY) / Math.max(maxY - minY, 1)));\n                });\n\n                // draw sparkline with delta range\n                if ((deltaBacktrack > 0) && this.displayDeltaRange()) {\n                    var endIndex = points.length - 1;\n                    var startIndex = Math.max(endIndex - deltaBacktrack, 0);\n\n                    // draw thin path segment\n                    svgUtil.createElement('path')\n                        .attr('class', 'sparkline')\n                        .attr('d', this.pointsToPath(points.slice(0, startIndex + 1)))\n                        .attr('fill', 'none')\n                        .attr('stroke', this.sparklineColor)\n                        .attr('opacity', opacity * 0.6)\n                        .attr('stroke-width', '1px')\n                        .attr('stroke-linecap', 'round')\n                        .attr('stroke-linejoin', 'round')\n                        .appendTo(this.$el);\n\n                    // draw thick path segment\n                    svgUtil.createElement('path')\n                        .attr('class', 'sparkline-delta')\n                        .attr('d', this.pointsToPath(points.slice(startIndex, endIndex + 1)))\n                        .attr('fill', 'none')\n                        .attr('stroke', this.sparklineColor)\n                        .attr('opacity', opacity)\n                        .attr('stroke-width', '1.5px')\n                        .attr('stroke-linecap', 'round')\n                        .attr('stroke-linejoin', 'round')\n                        .appendTo(this.$el);\n\n                    // draw start point\n                    var startPoint = points[startIndex];\n                    svgUtil.createElement('circle')\n                        .attr('class', 'sparkline-point')\n                        .attr('cx', startPoint.x)\n                        .attr('cy', startPoint.y)\n                        .attr('r', 2)\n                        .attr('fill', this.sparklineColor)\n                        .attr('stroke', 'none')\n                        .attr('opacity', opacity)\n                        .appendTo(this.$el);\n\n                // draw normal sparkline\n                } else {\n                    svgUtil.createElement('path')\n                        .attr('class', 'sparkline')\n                        .attr('d', this.pointsToPath(points))\n                        .attr('fill', 'none')\n                        .attr('stroke', this.sparklineColor)\n                        .attr('opacity', opacity)\n                        .attr('stroke-width', '1.5px')\n                        .attr('stroke-linecap', 'round')\n                        .attr('stroke-linejoin', 'round')\n                        .appendTo(this.$el);\n                }\n\n                // draw end point\n                var endPoint = points[points.length - 1];\n                svgUtil.createElement('circle')\n                    .attr('class', 'sparkline-point')\n                    .attr('cx', endPoint.x)\n                    .attr('cy', endPoint.y)\n                    .attr('r', 2)\n                    .attr('fill', this.sparklineColor)\n                    .attr('stroke', 'none')\n                    .attr('opacity', opacity)\n                    .appendTo(this.$el);\n            },\n            positionAndScaleSparkline: function() {\n                // Position sparkline in middle of SVG container\n                var shiftWidth = mathUtil.roundToDecimal(((this.svgWidth / 2 - this.sparklineWidth / 2) / this.scaleRatio), -2),\n                    shiftHeight = this.SPARKLINE_Y,\n                    edgePadding = this.model.presentation.get('edgePadding'),\n                    availableWidth = this.svgWidth - (edgePadding * 2),\n                    originalHeight,\n                    maxHeight,\n                    maxWidthRatio,\n                    maxShiftWidth,\n                    maxShiftHeight;\n                if (this.sparklineWidth < availableWidth) {\n                    // Only scale up sparkline if there is horizontal space to do so\n                    if (generalUtil.valuesAreNumericAndFinite([this.scaleRatio, shiftWidth, shiftHeight])) {\n                        this.$el.attr({\n                            transform: \"scale(\" + this.scaleRatio + \")translate(\" + shiftWidth + \",\" + shiftHeight + \")\"\n                        });\n                    }\n                } else {\n                    maxWidthRatio = mathUtil.roundToDecimal((availableWidth / this.SPARKLINE_WIDTH), -2);\n                    maxShiftWidth = mathUtil.roundToDecimal((edgePadding / maxWidthRatio), -2);\n                    originalHeight = mathUtil.roundToDecimal((this.svgHeight / this.scaleRatio), -2);\n                    // Due to width constraint, Sparkline cannot scale beyond this max height\n                    maxHeight = originalHeight * maxWidthRatio;\n                    // Because Sparkline is scaled only by the constant maxWidthRatio and not by the actual viz height's scaleRatio,\n                    // the Sparkline vertical translate amount must be increased by the viz height increase in addition to the usual shiftHeight\n                    maxShiftHeight = mathUtil.roundToDecimal(shiftHeight + ((this.svgHeight - maxHeight) / maxWidthRatio), -2);\n                    if (generalUtil.valuesAreNumericAndFinite([maxWidthRatio, maxShiftWidth, maxShiftHeight])) {\n                        this.$el.attr({\n                            transform: \"scale(\" + maxWidthRatio + \")translate(\" + maxShiftWidth + \",\" + maxShiftHeight + \")\"\n                        });\n                    }\n                }\n            },\n            pointsToPath: function(points) {\n                var path = \"\";\n                var point;\n                for (var i = 0, l = points.length; i < l; i++) {\n                    point = points[i];\n                    path += (i === 0) ? \"M\" : \"L\";\n                    path += point.x + \",\" + point.y;\n                }\n                return path;\n            },\n            displayDeltaRange: function() {\n                var showDeltaValue = splunkUtil.normalizeBoolean(this.model.state.get('display.visualizations.singlevalue.showTrendIndicator')),\n                deltaValue = this.model.results.get('deltaValue');\n                return (showDeltaValue !== false) && (deltaValue != null);\n            },\n            reflow: function() {\n                this.updateContainerDimensions();\n                this.positionAndScaleSparkline();\n            },\n            updateContainerDimensions: function() {\n                this.svgWidth = this.model.presentation.get('svgWidth');\n                this.svgHeight = this.model.presentation.get('svgHeight');\n                this.scaleRatio = this.model.presentation.get('scaleRatio');\n\n                // Scale sparkline dimensions to fill new available SVG height\n                this.sparklineWidth = this.SPARKLINE_WIDTH * this.scaleRatio;\n            },\n            render: function() {\n                this.drawSparkline();\n                return this;\n            }\n        });\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9TcGFya2xpbmUuanM/ZDUwMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUEsaUNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QyxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9KQUNBIiwiZmlsZSI6InZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9TcGFya2xpbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoXG4gICAgW1xuICAgICAgICAnanF1ZXJ5JyxcbiAgICAgICAgJ3VuZGVyc2NvcmUnLFxuICAgICAgICAnbW9kdWxlJyxcbiAgICAgICAgJ3ZpZXdzL0Jhc2UnLFxuICAgICAgICAnc3BsdW5rLnV0aWwnLFxuICAgICAgICAndXRpbC9zdmcnLFxuICAgICAgICAndXRpbC9nZW5lcmFsX3V0aWxzJyxcbiAgICAgICAgJ3V0aWwvbWF0aF91dGlscydcbiAgICBdLFxuICAgIGZ1bmN0aW9uKFxuICAgICAgICAkLFxuICAgICAgICBfLFxuICAgICAgICBtb2R1bGUsXG4gICAgICAgIEJhc2VWaWV3LFxuICAgICAgICBzcGx1bmtVdGlsLFxuICAgICAgICBzdmdVdGlsLFxuICAgICAgICBnZW5lcmFsVXRpbCxcbiAgICAgICAgbWF0aFV0aWxcbiAgICApIHtcblxuICAgICAgICByZXR1cm4gQmFzZVZpZXcuZXh0ZW5kKHtcbiAgICAgICAgICAgIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic2luZ2xlLXZhbHVlLXNwYXJrbGluZVwiLFxuICAgICAgICAgICAgZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdmdVdGlsLmNyZWF0ZUVsZW1lbnQoJ2cnKS5hdHRyKCdjbGFzcycsICdzaW5nbGUtdmFsdWUtc3BhcmtsaW5lJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU1BBUktMSU5FX1dJRFRIOiAxNTAsXG4gICAgICAgICAgICBTUEFSS0xJTkVfSEVJR0hUOiAxNCxcbiAgICAgICAgICAgIFNQQVJLTElORV9ZOiA3NyxcbiAgICAgICAgICAgIERFRkFVTFRfU1BBUktMSU5FX0NPTE9SOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgQmFzZVZpZXcucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc3BhcmtsaW5lQ29sb3IgPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ3NwYXJrbGluZUNvbG9yJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyYXdTcGFya2xpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uZ2V0KCdzcGFya2xpbmVPcGFjaXR5JykgfHwgMSxcbiAgICAgICAgICAgICAgICAgICAgY291bnRlciA9IDEsIC8vIFgtYXhpcyB2YWx1ZXMgZG8gbm90IG1hdHRlciBhcyBsb25nIGFzIHRoZXkgYXJlIHVuaWZvcm0gaW4gZGlzdGFuY2UgZnJvbSBvbmUgYW5vdGhlclxuICAgICAgICAgICAgICAgICAgICByYXdEYXRhID0gdGhpcy5tb2RlbC5yZXN1bHRzLmdldCgnc3BhcmtsaW5lRGF0YScpLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YUJhY2t0cmFjayA9IHRoaXMubW9kZWwucmVzdWx0cy5nZXQoJ2RlbHRhQmFja3RyYWNrJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjbGVhciBwcmV2aW91cyByZW5kZXJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBpZiBubyBkYXRhIG9yIGxlc3MgdGhhbiB0d28gZGF0YSBwb2ludHNcbiAgICAgICAgICAgICAgICBpZiAoIXJhd0RhdGEgfHwgKHJhd0RhdGEubGVuZ3RoIDwgMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgZGF0YSB0byBwb2ludHMgYW5kIGNvbXB1dGUgeC95IHJhbmdlc1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHJhd0RhdGEsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBjb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChkKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBtaW5YID0gTWF0aC5taW4oeCwgbWluWCk7XG4gICAgICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heCh4LCBtYXhYKTtcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKHksIG1pblkpO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgoeSwgbWF4WSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeDogeCwgeTogeSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHNjYWxlIHBvaW50cyB0byB3aWR0aC9oZWlnaHRcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLlNQQVJLTElORV9XSURUSDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5TUEFSS0xJTkVfSEVJR0hUO1xuICAgICAgICAgICAgICAgIF8uZWFjaChwb2ludHMsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZC54ID0gKHdpZHRoICogKChkLnggLSBtaW5YKSAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSkpO1xuICAgICAgICAgICAgICAgICAgICBkLnkgPSAoaGVpZ2h0ICogKDEgLSAoZC55IC0gbWluWSkgLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSkpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGRyYXcgc3BhcmtsaW5lIHdpdGggZGVsdGEgcmFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoKGRlbHRhQmFja3RyYWNrID4gMCkgJiYgdGhpcy5kaXNwbGF5RGVsdGFSYW5nZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IE1hdGgubWF4KGVuZEluZGV4IC0gZGVsdGFCYWNrdHJhY2ssIDApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhpbiBwYXRoIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCdwYXRoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdzcGFya2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCB0aGlzLnBvaW50c1RvUGF0aChwb2ludHMuc2xpY2UoMCwgc3RhcnRJbmRleCArIDEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHRoaXMuc3BhcmtsaW5lQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIG9wYWNpdHkgKiAwLjYpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgJzFweCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1saW5lam9pbicsICdyb3VuZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8odGhpcy4kZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhpY2sgcGF0aCBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIHN2Z1V0aWwuY3JlYXRlRWxlbWVudCgncGF0aCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnc3BhcmtsaW5lLWRlbHRhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgdGhpcy5wb2ludHNUb1BhdGgocG9pbnRzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4ICsgMSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgdGhpcy5zcGFya2xpbmVDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5Jywgb3BhY2l0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAnMS41cHgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1saW5lY2FwJywgJ3JvdW5kJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtbGluZWpvaW4nLCAncm91bmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGVsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gcG9pbnRzW3N0YXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBzdmdVdGlsLmNyZWF0ZUVsZW1lbnQoJ2NpcmNsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnc3BhcmtsaW5lLXBvaW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHN0YXJ0UG9pbnQueClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHN0YXJ0UG9pbnQueSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgdGhpcy5zcGFya2xpbmVDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnbm9uZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIG9wYWNpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8odGhpcy4kZWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gZHJhdyBub3JtYWwgc3BhcmtsaW5lXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCdwYXRoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdzcGFya2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCB0aGlzLnBvaW50c1RvUGF0aChwb2ludHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgdGhpcy5zcGFya2xpbmVDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5Jywgb3BhY2l0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAnMS41cHgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1saW5lY2FwJywgJ3JvdW5kJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtbGluZWpvaW4nLCAncm91bmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkcmF3IGVuZCBwb2ludFxuICAgICAgICAgICAgICAgIHZhciBlbmRQb2ludCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCdjaXJjbGUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnc3BhcmtsaW5lLXBvaW50JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZW5kUG9pbnQueClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZW5kUG9pbnQueSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIHRoaXMuc3BhcmtsaW5lQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnbm9uZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5Jywgb3BhY2l0eSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbkFuZFNjYWxlU3BhcmtsaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiBzcGFya2xpbmUgaW4gbWlkZGxlIG9mIFNWRyBjb250YWluZXJcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnRXaWR0aCA9IG1hdGhVdGlsLnJvdW5kVG9EZWNpbWFsKCgodGhpcy5zdmdXaWR0aCAvIDIgLSB0aGlzLnNwYXJrbGluZVdpZHRoIC8gMikgLyB0aGlzLnNjYWxlUmF0aW8pLCAtMiksXG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0SGVpZ2h0ID0gdGhpcy5TUEFSS0xJTkVfWSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZVBhZGRpbmcgPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ2VkZ2VQYWRkaW5nJyksXG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoID0gdGhpcy5zdmdXaWR0aCAtIChlZGdlUGFkZGluZyAqIDIpLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICBtYXhTaGlmdFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBtYXhTaGlmdEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGFya2xpbmVXaWR0aCA8IGF2YWlsYWJsZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc2NhbGUgdXAgc3BhcmtsaW5lIGlmIHRoZXJlIGlzIGhvcml6b250YWwgc3BhY2UgdG8gZG8gc29cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYWxVdGlsLnZhbHVlc0FyZU51bWVyaWNBbmRGaW5pdGUoW3RoaXMuc2NhbGVSYXRpbywgc2hpZnRXaWR0aCwgc2hpZnRIZWlnaHRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKFwiICsgdGhpcy5zY2FsZVJhdGlvICsgXCIpdHJhbnNsYXRlKFwiICsgc2hpZnRXaWR0aCArIFwiLFwiICsgc2hpZnRIZWlnaHQgKyBcIilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aFJhdGlvID0gbWF0aFV0aWwucm91bmRUb0RlY2ltYWwoKGF2YWlsYWJsZVdpZHRoIC8gdGhpcy5TUEFSS0xJTkVfV0lEVEgpLCAtMik7XG4gICAgICAgICAgICAgICAgICAgIG1heFNoaWZ0V2lkdGggPSBtYXRoVXRpbC5yb3VuZFRvRGVjaW1hbCgoZWRnZVBhZGRpbmcgLyBtYXhXaWR0aFJhdGlvKSwgLTIpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEhlaWdodCA9IG1hdGhVdGlsLnJvdW5kVG9EZWNpbWFsKCh0aGlzLnN2Z0hlaWdodCAvIHRoaXMuc2NhbGVSYXRpbyksIC0yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHVlIHRvIHdpZHRoIGNvbnN0cmFpbnQsIFNwYXJrbGluZSBjYW5ub3Qgc2NhbGUgYmV5b25kIHRoaXMgbWF4IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBvcmlnaW5hbEhlaWdodCAqIG1heFdpZHRoUmF0aW87XG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgU3BhcmtsaW5lIGlzIHNjYWxlZCBvbmx5IGJ5IHRoZSBjb25zdGFudCBtYXhXaWR0aFJhdGlvIGFuZCBub3QgYnkgdGhlIGFjdHVhbCB2aXogaGVpZ2h0J3Mgc2NhbGVSYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIFNwYXJrbGluZSB2ZXJ0aWNhbCB0cmFuc2xhdGUgYW1vdW50IG11c3QgYmUgaW5jcmVhc2VkIGJ5IHRoZSB2aXogaGVpZ2h0IGluY3JlYXNlIGluIGFkZGl0aW9uIHRvIHRoZSB1c3VhbCBzaGlmdEhlaWdodFxuICAgICAgICAgICAgICAgICAgICBtYXhTaGlmdEhlaWdodCA9IG1hdGhVdGlsLnJvdW5kVG9EZWNpbWFsKHNoaWZ0SGVpZ2h0ICsgKCh0aGlzLnN2Z0hlaWdodCAtIG1heEhlaWdodCkgLyBtYXhXaWR0aFJhdGlvKSwgLTIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhbFV0aWwudmFsdWVzQXJlTnVtZXJpY0FuZEZpbml0ZShbbWF4V2lkdGhSYXRpbywgbWF4U2hpZnRXaWR0aCwgbWF4U2hpZnRIZWlnaHRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKFwiICsgbWF4V2lkdGhSYXRpbyArIFwiKXRyYW5zbGF0ZShcIiArIG1heFNoaWZ0V2lkdGggKyBcIixcIiArIG1heFNoaWZ0SGVpZ2h0ICsgXCIpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvaW50c1RvUGF0aDogZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gKGkgPT09IDApID8gXCJNXCIgOiBcIkxcIjtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBwb2ludC54ICsgXCIsXCIgKyBwb2ludC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwbGF5RGVsdGFSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3dEZWx0YVZhbHVlID0gc3BsdW5rVXRpbC5ub3JtYWxpemVCb29sZWFuKHRoaXMubW9kZWwuc3RhdGUuZ2V0KCdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLnNob3dUcmVuZEluZGljYXRvcicpKSxcbiAgICAgICAgICAgICAgICBkZWx0YVZhbHVlID0gdGhpcy5tb2RlbC5yZXN1bHRzLmdldCgnZGVsdGFWYWx1ZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2hvd0RlbHRhVmFsdWUgIT09IGZhbHNlKSAmJiAoZGVsdGFWYWx1ZSAhPSBudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVyRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25BbmRTY2FsZVNwYXJrbGluZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUNvbnRhaW5lckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ZnV2lkdGggPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ3N2Z1dpZHRoJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdmdIZWlnaHQgPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ3N2Z0hlaWdodCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVSYXRpbyA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnc2NhbGVSYXRpbycpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgc3BhcmtsaW5lIGRpbWVuc2lvbnMgdG8gZmlsbCBuZXcgYXZhaWxhYmxlIFNWRyBoZWlnaHRcbiAgICAgICAgICAgICAgICB0aGlzLnNwYXJrbGluZVdpZHRoID0gdGhpcy5TUEFSS0xJTkVfV0lEVEggKiB0aGlzLnNjYWxlUmF0aW87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTcGFya2xpbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy92aWV3cy9zaGFyZWQvc2luZ2xldmFsdWUvU3BhcmtsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSB2aWV3cy9zaGFyZWQvc2luZ2xldmFsdWUvU3BhcmtsaW5lXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "util/svg":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n        $,\n        _\n    ) {\n        var SVG_NS = 'http://www.w3.org/2000/svg';\n\n        var modifyClass = function($el, cls, add) {\n            var currentClasses = $el.attr('class') || '',\n                paddedClasses = ' ' + currentClasses + ' ',\n                clsTrim = $.trim(cls),\n                paddedCls = ' ' + clsTrim + ' ';\n\n            if (add && paddedClasses.indexOf(paddedCls) === -1) {\n                $el.attr('class', currentClasses + ' ' + clsTrim);\n            } else if (!add && paddedClasses.indexOf(paddedCls) !== -1) {\n                $el.attr('class', $.trim(paddedClasses.replace(paddedCls,'')));\n            }\n        };\n\n        return {\n            createElement: function(type) {\n                return $(document.createElementNS(SVG_NS, type));\n            },\n\n            getBBox: function($el) {\n                var getBBox = $el[0].getBBox,\n                    bbox;\n\n                // getBBox will not exist in Chrome and IE if\n                // the svg element is not yet rendered.\n                if (!_.isFunction(getBBox)) {\n                    return {};\n                }\n\n                // This call will fail in firefox if the svg is\n                // not rendered yet.\n                try {\n                    bbox = getBBox.apply($el[0]);\n                } catch(e) {\n                    return {\n                        height: 0,\n                        width: 0,\n                        cx: 0,\n                        cy: 0,\n                        x2: 0,\n                        y2: 0\n                    };\n                }\n\n                return $.extend(bbox, {\n                    cx: bbox.x + Math.floor(bbox.width / 2),\n                    cy: bbox.y + Math.floor(bbox.height / 2),\n                    x2: bbox.x + bbox.width,\n                    y2: bbox.y + bbox.height\n                });\n            },\n\n            addClass: function($el, cls) {\n               modifyClass($el, cls, true);\n            },\n\n            removeClass: function($el, cls) {\n                modifyClass($el, cls, false);\n            },\n\n            isSvgEl: function($el) {\n                return ($el[0] && $el[0] instanceof SVGElement);\n            }\n        };\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvc3ZnLmpzPzkwMDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBLGlDQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSkFDQSIsImZpbGUiOiJ1dGlsL3N2Zy5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShcbiAgICBbXG4gICAgICAgICdqcXVlcnknLFxuICAgICAgICAndW5kZXJzY29yZSdcbiAgICBdLFxuICAgIGZ1bmN0aW9uKFxuICAgICAgICAkLFxuICAgICAgICBfXG4gICAgKSB7XG4gICAgICAgIHZhciBTVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG4gICAgICAgIHZhciBtb2RpZnlDbGFzcyA9IGZ1bmN0aW9uKCRlbCwgY2xzLCBhZGQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2xhc3NlcyA9ICRlbC5hdHRyKCdjbGFzcycpIHx8ICcnLFxuICAgICAgICAgICAgICAgIHBhZGRlZENsYXNzZXMgPSAnICcgKyBjdXJyZW50Q2xhc3NlcyArICcgJyxcbiAgICAgICAgICAgICAgICBjbHNUcmltID0gJC50cmltKGNscyksXG4gICAgICAgICAgICAgICAgcGFkZGVkQ2xzID0gJyAnICsgY2xzVHJpbSArICcgJztcblxuICAgICAgICAgICAgaWYgKGFkZCAmJiBwYWRkZWRDbGFzc2VzLmluZGV4T2YocGFkZGVkQ2xzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAkZWwuYXR0cignY2xhc3MnLCBjdXJyZW50Q2xhc3NlcyArICcgJyArIGNsc1RyaW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYWRkICYmIHBhZGRlZENsYXNzZXMuaW5kZXhPZihwYWRkZWRDbHMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICRlbC5hdHRyKCdjbGFzcycsICQudHJpbShwYWRkZWRDbGFzc2VzLnJlcGxhY2UocGFkZGVkQ2xzLCcnKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgdHlwZSkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0QkJveDogZnVuY3Rpb24oJGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdldEJCb3ggPSAkZWxbMF0uZ2V0QkJveCxcbiAgICAgICAgICAgICAgICAgICAgYmJveDtcblxuICAgICAgICAgICAgICAgIC8vIGdldEJCb3ggd2lsbCBub3QgZXhpc3QgaW4gQ2hyb21lIGFuZCBJRSBpZlxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdmcgZWxlbWVudCBpcyBub3QgeWV0IHJlbmRlcmVkLlxuICAgICAgICAgICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKGdldEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbGwgd2lsbCBmYWlsIGluIGZpcmVmb3ggaWYgdGhlIHN2ZyBpc1xuICAgICAgICAgICAgICAgIC8vIG5vdCByZW5kZXJlZCB5ZXQuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYmJveCA9IGdldEJCb3guYXBwbHkoJGVsWzBdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJC5leHRlbmQoYmJveCwge1xuICAgICAgICAgICAgICAgICAgICBjeDogYmJveC54ICsgTWF0aC5mbG9vcihiYm94LndpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgICAgIGN5OiBiYm94LnkgKyBNYXRoLmZsb29yKGJib3guaGVpZ2h0IC8gMiksXG4gICAgICAgICAgICAgICAgICAgIHgyOiBiYm94LnggKyBiYm94LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB5MjogYmJveC55ICsgYmJveC5oZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbigkZWwsIGNscykge1xuICAgICAgICAgICAgICAgbW9kaWZ5Q2xhc3MoJGVsLCBjbHMsIHRydWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCRlbCwgY2xzKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZ5Q2xhc3MoJGVsLCBjbHMsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzU3ZnRWw6IGZ1bmN0aW9uKCRlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoJGVsWzBdICYmICRlbFswXSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvc3ZnLmpzXG4vLyBtb2R1bGUgaWQgPSB1dGlsL3N2Z1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "views/shared/singlevalue/MainBody":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\"),\n        module,\n        __webpack_require__(\"views/Base\"),\n        __webpack_require__(\"views/shared/singlevalue/Labels\"),\n        __webpack_require__(\"views/shared/singlevalue/Delta\"),\n        __webpack_require__(\"models/Base\"),\n        __webpack_require__(\"shim/splunk.util\"),\n        __webpack_require__(\"util/svg\"),\n        __webpack_require__(\"util/general_utils\"),\n        __webpack_require__(\"util/math_utils\")\n\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n        $,\n        _,\n        module,\n        BaseView,\n        LabelsView,\n        DeltaView,\n        BaseModel,\n        splunkUtil,\n        svgUtil,\n        generalUtil,\n        mathUtil\n        ) {\n        return BaseView.extend({\n            moduleId: module.id,\n            className: 'single-value-main-body',\n            el: function() {\n                return svgUtil.createElement('g').attr('class', 'single-value-main-body');\n            },\n            DELTA_PADDING: 10,\n            initialize: function(options) {\n                BaseView.prototype.initialize.apply(this, arguments);\n                this.model.presentation.set('deltaPadding', this.DELTA_PADDING);\n            },\n\n            reflow: function() {\n                var mainLabelsRightX,\n                    deltaWidth,\n                    labelWidth,\n                    maxDeltaWidth,\n                    maxLabelsWidth,\n                    $rightmostLabel,\n                    rightLabelWidth,\n                    rightLabelLeftX,\n                    edgePadding = this.model.presentation.get('edgePadding'),\n                    svgWidth = this.model.presentation.get('svgWidth') - edgePadding * 2,\n                    scaleRatio = this.model.presentation.get('scaleRatio'),\n                    mainBodyPadding = this.model.presentation.get('mainBodyPadding'),\n                    scaledMainBodyPadding = mainBodyPadding * scaleRatio;\n\n\n                if (generalUtil.valuesAreNumericAndFinite([scaledMainBodyPadding])) {\n                    this.$el.attr('transform', 'translate(0,' + scaledMainBodyPadding + ')');\n                }\n                // Keep track of ratio between Labels and Delta Value\n                if (this.displayDelta()) {\n                    svgWidth -= this.DELTA_PADDING;\n                    if (!this.maxLabelProportion) {\n                        labelWidth = this.children.labels.getMainLabelsWidth();\n                        deltaWidth = this.children.delta.el.getBBox().width;\n                        this.maxLabelProportion = mathUtil.roundToDecimal(labelWidth / (labelWidth + deltaWidth), -2);\n                    }\n                    maxLabelsWidth = mathUtil.roundToDecimal(svgWidth * this.maxLabelProportion, -2);\n                    maxDeltaWidth = svgWidth - maxLabelsWidth;\n\n                    // Subtract width of delta view from the width available for the main labels\n                    this.model.presentation.set('maxLabelsWidth', maxLabelsWidth);\n                    this.model.presentation.set('maxDeltaWidth', maxDeltaWidth);\n                } else {\n                    this.model.presentation.set('maxLabelsWidth', svgWidth);\n                    this.model.presentation.set('maxDeltaWidth', 0);\n                }\n\n                // Have main labels scale to fill in the new width\n                this.children.labels.validateReflow(true);\n\n                if (this.displayDelta()) {\n                    // Have delta scale to fill in the new width\n                    // ( Note: because delta scaling and positioning happen in the same SVG transform action, the delta\n                    //   will also be positioned here, but we will reposition the delta properly later in this method. )\n                    this.children.delta.validateReflow(true);\n\n                    deltaWidth = this.children.delta.el.getBoundingClientRect().width;\n\n                    this.model.presentation.set('deltaWidth', deltaWidth);\n                } else {\n                    this.model.presentation.set('deltaWidth', 0);\n                }\n\n                this.children.labels.positionLabels();\n\n                // Now, we reposition the delta value to its final position using the new scaled label's coordinates\n                if (this.displayDelta()) {\n                    if (this.hasAfterLabel) {\n                        $rightmostLabel = this.children.labels.children.afterLabelView;\n                    } else {\n                        $rightmostLabel = this.children.labels.children.singleResultView;\n                    }\n                    // PDF requires that we read the text element's 'x' attribute to measure its position\n                    rightLabelLeftX = parseFloat($rightmostLabel.$('text').attr('x'));\n                    rightLabelWidth = $rightmostLabel.getWidth();\n                    mainLabelsRightX = rightLabelLeftX + rightLabelWidth;\n\n                    this.model.presentation.set('deltaLeft', mainLabelsRightX);\n                    this.children.delta.positionAndScaleElements();\n                }\n            },\n\n            drawLabels: function() {\n                if (this.children.labels) {\n                    this.children.labels.remove();\n                }\n\n                var unit = this.model.state.get(\"display.visualizations.singlevalue.unit\");\n                if (typeof unit === \"undefined\" || unit === \"\") {\n                    this.hasUnit = false;\n                    this.hasAfterLabel = !!this.model.state.get(\"display.visualizations.singlevalue.afterLabel\");\n                    this.hasBeforeLabel = !!this.model.state.get(\"display.visualizations.singlevalue.beforeLabel\");\n                } else {\n                    this.hasUnit = true;\n                    var unitPosition = this.model.state.get(\"display.visualizations.singlevalue.unitPosition\");\n                    if (unitPosition === \"before\") {\n                        this.unitPosition = \"before\";\n                        this.hasBeforeLabel = false;\n                        this.hasAfterLabel = false;\n                    } else {\n                        this.unitPosition = \"after\";\n                        this.hasBeforeLabel = false;\n                        this.hasAfterLabel = false;\n                    }\n                }\n                this.children.labels = new LabelsView({\n                    model: {\n                        application: this.model.application,\n                        state: this.model.state,\n                        results: this.model.results,\n                        presentation: this.model.presentation\n                    },\n                    unit: unit,\n                    unitPosition: this.unitPosition,\n                    hasUnit: this.hasUnit,\n                    hasBeforeLabel: this.hasBeforeLabel,\n                    hasAfterLabel: this.hasAfterLabel\n                });\n                this.listenTo(this.children.labels, 'singleDrilldownClicked', function(params) {\n                    this.trigger('singleDrilldownClicked', params);\n                });\n                this.listenTo(this.children.labels, 'anchorTagClicked', function(e) {\n                    this.trigger('anchorTagClicked', e);\n                });\n                this.children.labels.render().appendTo(this.$el);\n            },\n\n            drawDelta: function() {\n                if (this.children.delta) {\n                    this.children.delta.detach();\n                    this.children.delta.remove();\n                }\n\n                if (this.displayDelta()) {\n                    this.children.delta = new DeltaView({\n                        model: {\n                            state: this.model.state,\n                            presentation: this.model.presentation,\n                            results: this.model.results\n                        }\n                    });\n                    this.children.delta.render().appendTo(this.$el);\n                }\n\n            },\n\n            displayDelta: function() {\n                var showDeltaValue = splunkUtil.normalizeBoolean(this.model.state.get('display.visualizations.singlevalue.showTrendIndicator')),\n                deltaValue = this.model.results.get('deltaValue');\n                return showDeltaValue !== false && (deltaValue  || deltaValue === 0);\n            },\n\n            drawComponents: function() {\n                this.drawLabels();\n                this.drawDelta();\n            },\n\n            render: function() {\n                this.drawComponents();\n                return this;\n            }\n        });\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9NYWluQm9keS5qcz8xMjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQSxpQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9KQUNBIiwiZmlsZSI6InZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9NYWluQm9keS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShcbiAgICBbXG4gICAgICAgICdqcXVlcnknLFxuICAgICAgICAndW5kZXJzY29yZScsXG4gICAgICAgICdtb2R1bGUnLFxuICAgICAgICAndmlld3MvQmFzZScsXG4gICAgICAgICcuL0xhYmVscycsXG4gICAgICAgICcuL0RlbHRhJyxcbiAgICAgICAgJ21vZGVscy9CYXNlJyxcbiAgICAgICAgJ3NwbHVuay51dGlsJyxcbiAgICAgICAgJ3V0aWwvc3ZnJyxcbiAgICAgICAgJ3V0aWwvZ2VuZXJhbF91dGlscycsXG4gICAgICAgICd1dGlsL21hdGhfdXRpbHMnXG5cbiAgICBdLFxuICAgIGZ1bmN0aW9uKFxuICAgICAgICAkLFxuICAgICAgICBfLFxuICAgICAgICBtb2R1bGUsXG4gICAgICAgIEJhc2VWaWV3LFxuICAgICAgICBMYWJlbHNWaWV3LFxuICAgICAgICBEZWx0YVZpZXcsXG4gICAgICAgIEJhc2VNb2RlbCxcbiAgICAgICAgc3BsdW5rVXRpbCxcbiAgICAgICAgc3ZnVXRpbCxcbiAgICAgICAgZ2VuZXJhbFV0aWwsXG4gICAgICAgIG1hdGhVdGlsXG4gICAgICAgICkge1xuICAgICAgICByZXR1cm4gQmFzZVZpZXcuZXh0ZW5kKHtcbiAgICAgICAgICAgIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdzaW5nbGUtdmFsdWUtbWFpbi1ib2R5JyxcbiAgICAgICAgICAgIGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCdnJykuYXR0cignY2xhc3MnLCAnc2luZ2xlLXZhbHVlLW1haW4tYm9keScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIERFTFRBX1BBRERJTkc6IDEwLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIEJhc2VWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uc2V0KCdkZWx0YVBhZGRpbmcnLCB0aGlzLkRFTFRBX1BBRERJTkcpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVmbG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFpbkxhYmVsc1JpZ2h0WCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbWF4RGVsdGFXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbWF4TGFiZWxzV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICRyaWdodG1vc3RMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRMYWJlbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICByaWdodExhYmVsTGVmdFgsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VQYWRkaW5nID0gdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uZ2V0KCdlZGdlUGFkZGluZycpLFxuICAgICAgICAgICAgICAgICAgICBzdmdXaWR0aCA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnc3ZnV2lkdGgnKSAtIGVkZ2VQYWRkaW5nICogMixcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVSYXRpbyA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnc2NhbGVSYXRpbycpLFxuICAgICAgICAgICAgICAgICAgICBtYWluQm9keVBhZGRpbmcgPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ21haW5Cb2R5UGFkZGluZycpLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZWRNYWluQm9keVBhZGRpbmcgPSBtYWluQm9keVBhZGRpbmcgKiBzY2FsZVJhdGlvO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhbFV0aWwudmFsdWVzQXJlTnVtZXJpY0FuZEZpbml0ZShbc2NhbGVkTWFpbkJvZHlQYWRkaW5nXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBzY2FsZWRNYWluQm9keVBhZGRpbmcgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHJhdGlvIGJldHdlZW4gTGFiZWxzIGFuZCBEZWx0YSBWYWx1ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc3BsYXlEZWx0YSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN2Z1dpZHRoIC09IHRoaXMuREVMVEFfUEFERElORztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1heExhYmVsUHJvcG9ydGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxXaWR0aCA9IHRoaXMuY2hpbGRyZW4ubGFiZWxzLmdldE1haW5MYWJlbHNXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFXaWR0aCA9IHRoaXMuY2hpbGRyZW4uZGVsdGEuZWwuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhMYWJlbFByb3BvcnRpb24gPSBtYXRoVXRpbC5yb3VuZFRvRGVjaW1hbChsYWJlbFdpZHRoIC8gKGxhYmVsV2lkdGggKyBkZWx0YVdpZHRoKSwgLTIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1heExhYmVsc1dpZHRoID0gbWF0aFV0aWwucm91bmRUb0RlY2ltYWwoc3ZnV2lkdGggKiB0aGlzLm1heExhYmVsUHJvcG9ydGlvbiwgLTIpO1xuICAgICAgICAgICAgICAgICAgICBtYXhEZWx0YVdpZHRoID0gc3ZnV2lkdGggLSBtYXhMYWJlbHNXaWR0aDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCB3aWR0aCBvZiBkZWx0YSB2aWV3IGZyb20gdGhlIHdpZHRoIGF2YWlsYWJsZSBmb3IgdGhlIG1haW4gbGFiZWxzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucHJlc2VudGF0aW9uLnNldCgnbWF4TGFiZWxzV2lkdGgnLCBtYXhMYWJlbHNXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucHJlc2VudGF0aW9uLnNldCgnbWF4RGVsdGFXaWR0aCcsIG1heERlbHRhV2lkdGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucHJlc2VudGF0aW9uLnNldCgnbWF4TGFiZWxzV2lkdGgnLCBzdmdXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucHJlc2VudGF0aW9uLnNldCgnbWF4RGVsdGFXaWR0aCcsIDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhhdmUgbWFpbiBsYWJlbHMgc2NhbGUgdG8gZmlsbCBpbiB0aGUgbmV3IHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sYWJlbHMudmFsaWRhdGVSZWZsb3codHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5RGVsdGEoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYXZlIGRlbHRhIHNjYWxlIHRvIGZpbGwgaW4gdGhlIG5ldyB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAvLyAoIE5vdGU6IGJlY2F1c2UgZGVsdGEgc2NhbGluZyBhbmQgcG9zaXRpb25pbmcgaGFwcGVuIGluIHRoZSBzYW1lIFNWRyB0cmFuc2Zvcm0gYWN0aW9uLCB0aGUgZGVsdGFcbiAgICAgICAgICAgICAgICAgICAgLy8gICB3aWxsIGFsc28gYmUgcG9zaXRpb25lZCBoZXJlLCBidXQgd2Ugd2lsbCByZXBvc2l0aW9uIHRoZSBkZWx0YSBwcm9wZXJseSBsYXRlciBpbiB0aGlzIG1ldGhvZC4gKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmRlbHRhLnZhbGlkYXRlUmVmbG93KHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhV2lkdGggPSB0aGlzLmNoaWxkcmVuLmRlbHRhLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucHJlc2VudGF0aW9uLnNldCgnZGVsdGFXaWR0aCcsIGRlbHRhV2lkdGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucHJlc2VudGF0aW9uLnNldCgnZGVsdGFXaWR0aCcsIDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGFiZWxzLnBvc2l0aW9uTGFiZWxzKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3csIHdlIHJlcG9zaXRpb24gdGhlIGRlbHRhIHZhbHVlIHRvIGl0cyBmaW5hbCBwb3NpdGlvbiB1c2luZyB0aGUgbmV3IHNjYWxlZCBsYWJlbCdzIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheURlbHRhKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQWZ0ZXJMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJpZ2h0bW9zdExhYmVsID0gdGhpcy5jaGlsZHJlbi5sYWJlbHMuY2hpbGRyZW4uYWZ0ZXJMYWJlbFZpZXc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcmlnaHRtb3N0TGFiZWwgPSB0aGlzLmNoaWxkcmVuLmxhYmVscy5jaGlsZHJlbi5zaW5nbGVSZXN1bHRWaWV3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBERiByZXF1aXJlcyB0aGF0IHdlIHJlYWQgdGhlIHRleHQgZWxlbWVudCdzICd4JyBhdHRyaWJ1dGUgdG8gbWVhc3VyZSBpdHMgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmlnaHRMYWJlbExlZnRYID0gcGFyc2VGbG9hdCgkcmlnaHRtb3N0TGFiZWwuJCgndGV4dCcpLmF0dHIoJ3gnKSk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0TGFiZWxXaWR0aCA9ICRyaWdodG1vc3RMYWJlbC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICBtYWluTGFiZWxzUmlnaHRYID0gcmlnaHRMYWJlbExlZnRYICsgcmlnaHRMYWJlbFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucHJlc2VudGF0aW9uLnNldCgnZGVsdGFMZWZ0JywgbWFpbkxhYmVsc1JpZ2h0WCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZGVsdGEucG9zaXRpb25BbmRTY2FsZUVsZW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZHJhd0xhYmVsczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGFiZWxzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gdGhpcy5tb2RlbC5zdGF0ZS5nZXQoXCJkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLnVuaXRcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1bml0ID09PSBcInVuZGVmaW5lZFwiIHx8IHVuaXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNVbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzQWZ0ZXJMYWJlbCA9ICEhdGhpcy5tb2RlbC5zdGF0ZS5nZXQoXCJkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLmFmdGVyTGFiZWxcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVmb3JlTGFiZWwgPSAhIXRoaXMubW9kZWwuc3RhdGUuZ2V0KFwiZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS5iZWZvcmVMYWJlbFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1VuaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pdFBvc2l0aW9uID0gdGhpcy5tb2RlbC5zdGF0ZS5nZXQoXCJkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLnVuaXRQb3NpdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuaXRQb3NpdGlvbiA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bml0UG9zaXRpb24gPSBcImJlZm9yZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNCZWZvcmVMYWJlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNBZnRlckxhYmVsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaXRQb3NpdGlvbiA9IFwiYWZ0ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVmb3JlTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzQWZ0ZXJMYWJlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGFiZWxzID0gbmV3IExhYmVsc1ZpZXcoe1xuICAgICAgICAgICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb246IHRoaXMubW9kZWwuYXBwbGljYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5tb2RlbC5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IHRoaXMubW9kZWwucmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRhdGlvbjogdGhpcy5tb2RlbC5wcmVzZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgICAgICAgICAgdW5pdFBvc2l0aW9uOiB0aGlzLnVuaXRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5pdDogdGhpcy5oYXNVbml0LFxuICAgICAgICAgICAgICAgICAgICBoYXNCZWZvcmVMYWJlbDogdGhpcy5oYXNCZWZvcmVMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgaGFzQWZ0ZXJMYWJlbDogdGhpcy5oYXNBZnRlckxhYmVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNoaWxkcmVuLmxhYmVscywgJ3NpbmdsZURyaWxsZG93bkNsaWNrZWQnLCBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzaW5nbGVEcmlsbGRvd25DbGlja2VkJywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY2hpbGRyZW4ubGFiZWxzLCAnYW5jaG9yVGFnQ2xpY2tlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdhbmNob3JUYWdDbGlja2VkJywgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sYWJlbHMucmVuZGVyKCkuYXBwZW5kVG8odGhpcy4kZWwpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZHJhd0RlbHRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5kZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmRlbHRhLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmRlbHRhLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc3BsYXlEZWx0YSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZGVsdGEgPSBuZXcgRGVsdGFWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMubW9kZWwuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGF0aW9uOiB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiB0aGlzLm1vZGVsLnJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZGVsdGEucmVuZGVyKCkuYXBwZW5kVG8odGhpcy4kZWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGlzcGxheURlbHRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hvd0RlbHRhVmFsdWUgPSBzcGx1bmtVdGlsLm5vcm1hbGl6ZUJvb2xlYW4odGhpcy5tb2RlbC5zdGF0ZS5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUuc2hvd1RyZW5kSW5kaWNhdG9yJykpLFxuICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSB0aGlzLm1vZGVsLnJlc3VsdHMuZ2V0KCdkZWx0YVZhbHVlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3dEZWx0YVZhbHVlICE9PSBmYWxzZSAmJiAoZGVsdGFWYWx1ZSAgfHwgZGVsdGFWYWx1ZSA9PT0gMCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkcmF3Q29tcG9uZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGFiZWxzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3RGVsdGEoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9uZW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9NYWluQm9keS5qc1xuLy8gbW9kdWxlIGlkID0gdmlld3Mvc2hhcmVkL3NpbmdsZXZhbHVlL01haW5Cb2R5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "models/Base":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(\"shim/jquery\"),\n    __webpack_require__(\"require/underscore\"),\n    __webpack_require__(\"require/backbone\"),\n    __webpack_require__(\"mixins/modelcollection\"),\n    __webpack_require__(\"util/general_utils\"),\n    __webpack_require__(\"util/splunkd_utils\"),\n    __webpack_require__(\"validation/ValidationMixin\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n    $,\n    _,\n    Backbone,\n    modelcollectionMixin,\n    generalUtils,\n    splunkDUtils,\n    ValidationMixin\n){\n   /**\n    * @namespace models\n    */\n   /**\n    * @consturctor\n    * @memberOf models\n    * @class\n    * @name Base\n    * @description Base Model class for all our models.\n    * Events:\n    *\n    *      attributeValidate:attributeName - triggered when validation has been performed on the attributeName\n    *          isValid - true if the attribute has passed validation\n    *          attributeName - name of the attribute being validated\n    *          errorMessage - if isValid is false, then this holds the error message. Otherwise, it is empty\n    *\n    *      serverValidated - triggered when we get messages from the server\n    *          isValid - true if the model has no server errors\n    *          model - a reference to the model itself\n    *          messages - a list of message objects, each containing the message content and type\n    *\n    * @extends {Backbone.Model}\n    * @mixes validation\n    */\n   var BaseModel = Backbone.Model.extend(/** @lends models.Base.prototype */{\n       /**\n        * @param {Object} attributes\n        * @param {Object} options\n        */\n        initialize: function(attributes, options) {\n            Backbone.Model.prototype.initialize.apply(this, arguments);\n\n            this.error = new Backbone.Model();\n            this.fetchData = (options && options.fetchData) ? options.fetchData : new Backbone.Model();\n            this.associated = this.associated || {};\n            this.associated.error = this.error;\n\n            this.fetchData.on('change', _.debounce(function() { this.safeFetch(); }, 0), this);\n            this.on('sync', this._onsync, this);\n            this.on('error', this._onerror, this);\n            this.on('validated', this._rebroadcastValidation, this);\n        },\n        /**\n        * @param {Object} options\n        * Merges options into the model\n        */\n        fetch: function(options) {\n            // merge the contents of the fetchData model into options.data\n            var mergedOptions = $.extend(true, {}, {data: this.fetchData.toJSON()}, options);\n            this.fetchXhr = Backbone.Model.prototype.fetch.call(this, mergedOptions);\n            // on successful fetch, handle any calls to safeFetch that came in while we were in-flight\n            var that = this;\n            this.fetchXhr.done(function() {\n                if (that.touched) {\n                    that.safeFetch.apply(that, that.touched);\n                }\n            });\n            return this.fetchXhr;\n        },\n        /**\n         * Helper function to allow the caller to use both the deferred returned by the fetch and to pass in success\n         * and error handlers. In addition, the returned Deferred only resolves, it doesn't reject. Instead, it passes\n         * a boolean attribute to the Deferred's resolve handler indicating whether the request succeeded (true) or\n         * failed (false).\n         *\n         * @param {object} options The options passed to the fetch, including success and error handlers\n         * @returns {Deferred} A Deferred that normalizes the response from the fetch.\n        */\n        binaryPromiseFetch: function(options) {\n            options || (options={});\n            var deferred = $.Deferred(),\n                success = options.success,\n                error = options.error;\n            options.success = function() {\n                deferred.resolve(true);\n                if (success) {\n                    success.apply(this, arguments);\n                }\n            };\n            options.error = function() {\n                deferred.resolve(false);\n                if (error) {\n                    error.apply(this, arguments);\n                }\n            };\n            this.fetch(options);\n            return deferred;\n        },\n        /**\n        * @param {Object} options\n        */\n        clear: function(options) {\n            options = options || {};\n            \n            _.each(this.associated, function(value){\n                if (value instanceof Backbone.Model){\n                    value.clear(options);\n                } else if (value instanceof Backbone.Collection) {\n                    value.reset(null, options);\n                }\n            });\n            \n            this.error.clear(options);\n            Backbone.Model.prototype.clear.call(this, options);\n            \n            if (options.setDefaults) {\n                var defaults = _.result(this, 'defaults');\n                if (defaults) {\n                    this.set(defaults, options);\n                }\n            }\n            \n            return this;\n        },\n        clone: function(){\n            var clonedModel = Backbone.Model.prototype.clone.call(this);\n            _.each(this.associated, function(value, key) {\n                if (value instanceof Backbone.Model) {\n                    var clonedAsscModel = value.clone();\n                    clonedModel[key] = clonedAsscModel;\n                    clonedModel.associated[key] = clonedAsscModel;\n                } else if (value instanceof Backbone.Collection) {\n                    var clonedAsscCollection = new value.constructor(\n                        value.map(function(model) {\n                            return model.clone();\n                        })\n                    );\n                    clonedModel[key] = clonedAsscCollection;\n                    clonedModel.associated[key] = clonedAsscCollection;\n                }\n            });\n            return clonedModel;\n        },\n        associatedOff: function(events, callback, context) {\n            _(this.associated).each(function(associated) {\n                associated.off(events, callback, context);\n                if (_.isFunction(associated.associatedOff)) {\n                    associated.associatedOff(events, callback, context);\n                }\n            }, this);\n            // fetchData is not part of the associated container, but should still be unbound\n            this.fetchData.off(events, callback, context);\n        },\n        /**\n         * Use this to announce to any listeners that the model is in a valid state. This is useful in cases where the\n         * model is attached to a ControlGroup and you want that ControlGroup to no longer be in the error state.\n         * Note that the next time you attempt to validate the model, it will still run through its validation rules.\n         */\n        clearErrors: function() {\n            this.trigger('serverValidated', true, this, []);\n            this.trigger('validated', true, this, []);\n        },\n\n       /**\n        * Returns true if the message contains an error\n        * @param message\n        * @returns {boolean}\n        */\n        messageHasError: function(message) {\n            return (message.type === splunkDUtils.ERROR || message.type === splunkDUtils.FATAL);\n        },\n\n       /**\n        * Returns true if the response contains an error. As an optimization, we take an array of messages parsed\n        * from the response so that we don't have to parse the response twice.\n        * @param response - parsed response object from the model sync\n        * @param messages - array of message objects\n        * @returns {*}\n        */\n        responseHasErrors: function(response, messages) {\n            return _(messages).any(function (message) {\n                return this.messageHasError(message);\n            }, this);\n        },\n\n        _rebroadcastValidation: function(validated, model, error_payload) {\n            // doing this union will handle the case where a previously-undefined attribute is being set with an invalid value\n            var allKeys = _.union(_.keys(this.attributes), _.keys(error_payload));\n            _(allKeys).each(function(k){\n                this.trigger('attributeValidated:' + k, !_.has(error_payload, k), k, error_payload[k]);\n            },this);\n        },\n        _onerror: function(model, response, options) {\n            model.error.clear();\n            var messages = splunkDUtils.xhrErrorResponseParser(response, this.id);\n            this.trigger('serverValidated', false, this, messages);\n            model.error.set(\"messages\", messages);\n        },\n        _onsync: function(model, response, options) {\n            model.error.clear();\n            var messages = this.parseSplunkDMessages(response);\n            var hasErrors = this.responseHasErrors(response, messages);\n\n            this.trigger('serverValidated', !hasErrors, this, messages);\n            \n            if (hasErrors) {\n                model.error.set(\"messages\", messages);\n            }\n        },\n        parseSplunkDMessages: function(response) {\n            if(!response) {\n                return [];\n            }\n            return splunkDUtils.parseMessagesObject(response.messages);\n        },\n        filterByKeys: function(keys, options, fetchOptions /* optional */) {\n            options = options || {};\n\n            var attrs = {},\n                strip = _.isString(options.strip) ? options.strip : '',\n                allowEmpty = !!options.allowEmpty;\n\n            _.each(this.toJSON(fetchOptions), function(value, key) {\n                if(_.indexOf(keys, key) != -1) {\n                    if (!_.isUndefined(value)){\n                        if (!(value === \"\") || allowEmpty){\n                            attrs[key.replace(strip, '')] = value;\n                        }\n                    }\n                }\n            }, this);\n            return attrs;\n        },\n        filterByWildcards: function(wildcards, options, fetchOptions /* optional */) {\n            return generalUtils.filterObjectByRegexes(this.toJSON(fetchOptions), wildcards, options);\n        },\n        filterChangedByWildcards: function(wildcards, options) {\n            return generalUtils.filterObjectByRegexes(this.changedAttributes() || {}, wildcards, options);\n        },\n        toObject: function(attr) {\n            var value = this.get(attr);\n            try {\n                value = JSON.parse(value);\n            } catch (e) {}\n            return value;\n        },\n        replace: function(attributes, options) {\n            this.clear({silent: true});\n            this.set(attributes, options);\n        },\n        /**\n         * Restore the model to its default attributes.\n         * CAVEAT EMPTOR: often fires two change events, both globally and per-attribute\n         * CAVEAT EMPTOR: this has not been well tested yet\n         * @param {Object} options\n         */\n        restoreDefaults: function(options) {\n            var defaults = _.isFunction(this.defaults) ? this.defaults() : this.defaults;\n            this.clear(options);\n            this.set(defaults, options);\n        }\n\n    });\n    _.extend(BaseModel.prototype, ValidationMixin);\n    _.extend(BaseModel.prototype, modelcollectionMixin);\n   \n   return BaseModel;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL21vZGVscy9CYXNlLmpzP2U4MDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQStELGtCQUFrQixFQUFFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEdBQUcsOEJBQThCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0ZBQW9GO0FBQ3BGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiJtb2RlbHMvQmFzZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXG4gICAgJ2pxdWVyeScsXG4gICAgJ3VuZGVyc2NvcmUnLFxuICAgICdiYWNrYm9uZScsXG4gICAgJ21peGlucy9tb2RlbGNvbGxlY3Rpb24nLFxuICAgICd1dGlsL2dlbmVyYWxfdXRpbHMnLFxuICAgICd1dGlsL3NwbHVua2RfdXRpbHMnLFxuICAgICd2YWxpZGF0aW9uL1ZhbGlkYXRpb25NaXhpbidcbl0sXG5mdW5jdGlvbihcbiAgICAkLFxuICAgIF8sXG4gICAgQmFja2JvbmUsXG4gICAgbW9kZWxjb2xsZWN0aW9uTWl4aW4sXG4gICAgZ2VuZXJhbFV0aWxzLFxuICAgIHNwbHVua0RVdGlscyxcbiAgICBWYWxpZGF0aW9uTWl4aW5cbil7XG4gICAvKipcbiAgICAqIEBuYW1lc3BhY2UgbW9kZWxzXG4gICAgKi9cbiAgIC8qKlxuICAgICogQGNvbnN0dXJjdG9yXG4gICAgKiBAbWVtYmVyT2YgbW9kZWxzXG4gICAgKiBAY2xhc3NcbiAgICAqIEBuYW1lIEJhc2VcbiAgICAqIEBkZXNjcmlwdGlvbiBCYXNlIE1vZGVsIGNsYXNzIGZvciBhbGwgb3VyIG1vZGVscy5cbiAgICAqIEV2ZW50czpcbiAgICAqXG4gICAgKiAgICAgIGF0dHJpYnV0ZVZhbGlkYXRlOmF0dHJpYnV0ZU5hbWUgLSB0cmlnZ2VyZWQgd2hlbiB2YWxpZGF0aW9uIGhhcyBiZWVuIHBlcmZvcm1lZCBvbiB0aGUgYXR0cmlidXRlTmFtZVxuICAgICogICAgICAgICAgaXNWYWxpZCAtIHRydWUgaWYgdGhlIGF0dHJpYnV0ZSBoYXMgcGFzc2VkIHZhbGlkYXRpb25cbiAgICAqICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgLSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgYmVpbmcgdmFsaWRhdGVkXG4gICAgKiAgICAgICAgICBlcnJvck1lc3NhZ2UgLSBpZiBpc1ZhbGlkIGlzIGZhbHNlLCB0aGVuIHRoaXMgaG9sZHMgdGhlIGVycm9yIG1lc3NhZ2UuIE90aGVyd2lzZSwgaXQgaXMgZW1wdHlcbiAgICAqXG4gICAgKiAgICAgIHNlcnZlclZhbGlkYXRlZCAtIHRyaWdnZXJlZCB3aGVuIHdlIGdldCBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAqICAgICAgICAgIGlzVmFsaWQgLSB0cnVlIGlmIHRoZSBtb2RlbCBoYXMgbm8gc2VydmVyIGVycm9yc1xuICAgICogICAgICAgICAgbW9kZWwgLSBhIHJlZmVyZW5jZSB0byB0aGUgbW9kZWwgaXRzZWxmXG4gICAgKiAgICAgICAgICBtZXNzYWdlcyAtIGEgbGlzdCBvZiBtZXNzYWdlIG9iamVjdHMsIGVhY2ggY29udGFpbmluZyB0aGUgbWVzc2FnZSBjb250ZW50IGFuZCB0eXBlXG4gICAgKlxuICAgICogQGV4dGVuZHMge0JhY2tib25lLk1vZGVsfVxuICAgICogQG1peGVzIHZhbGlkYXRpb25cbiAgICAqL1xuICAgdmFyIEJhc2VNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCgvKiogQGxlbmRzIG1vZGVscy5CYXNlLnByb3RvdHlwZSAqL3tcbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgQmFja2JvbmUuTW9kZWwoKTtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hEYXRhID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5mZXRjaERhdGEpID8gb3B0aW9ucy5mZXRjaERhdGEgOiBuZXcgQmFja2JvbmUuTW9kZWwoKTtcbiAgICAgICAgICAgIHRoaXMuYXNzb2NpYXRlZCA9IHRoaXMuYXNzb2NpYXRlZCB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuYXNzb2NpYXRlZC5lcnJvciA9IHRoaXMuZXJyb3I7XG5cbiAgICAgICAgICAgIHRoaXMuZmV0Y2hEYXRhLm9uKCdjaGFuZ2UnLCBfLmRlYm91bmNlKGZ1bmN0aW9uKCkgeyB0aGlzLnNhZmVGZXRjaCgpOyB9LCAwKSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCdzeW5jJywgdGhpcy5fb25zeW5jLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2Vycm9yJywgdGhpcy5fb25lcnJvciwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCd2YWxpZGF0ZWQnLCB0aGlzLl9yZWJyb2FkY2FzdFZhbGlkYXRpb24sIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAqIE1lcmdlcyBvcHRpb25zIGludG8gdGhlIG1vZGVsXG4gICAgICAgICovXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSB0aGUgY29udGVudHMgb2YgdGhlIGZldGNoRGF0YSBtb2RlbCBpbnRvIG9wdGlvbnMuZGF0YVxuICAgICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwge2RhdGE6IHRoaXMuZmV0Y2hEYXRhLnRvSlNPTigpfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmZldGNoWGhyID0gQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBvbiBzdWNjZXNzZnVsIGZldGNoLCBoYW5kbGUgYW55IGNhbGxzIHRvIHNhZmVGZXRjaCB0aGF0IGNhbWUgaW4gd2hpbGUgd2Ugd2VyZSBpbi1mbGlnaHRcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hYaHIuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC50b3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2FmZUZldGNoLmFwcGx5KHRoYXQsIHRoYXQudG91Y2hlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFhocjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBhbGxvdyB0aGUgY2FsbGVyIHRvIHVzZSBib3RoIHRoZSBkZWZlcnJlZCByZXR1cm5lZCBieSB0aGUgZmV0Y2ggYW5kIHRvIHBhc3MgaW4gc3VjY2Vzc1xuICAgICAgICAgKiBhbmQgZXJyb3IgaGFuZGxlcnMuIEluIGFkZGl0aW9uLCB0aGUgcmV0dXJuZWQgRGVmZXJyZWQgb25seSByZXNvbHZlcywgaXQgZG9lc24ndCByZWplY3QuIEluc3RlYWQsIGl0IHBhc3Nlc1xuICAgICAgICAgKiBhIGJvb2xlYW4gYXR0cmlidXRlIHRvIHRoZSBEZWZlcnJlZCdzIHJlc29sdmUgaGFuZGxlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJlcXVlc3Qgc3VjY2VlZGVkICh0cnVlKSBvclxuICAgICAgICAgKiBmYWlsZWQgKGZhbHNlKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBmZXRjaCwgaW5jbHVkaW5nIHN1Y2Nlc3MgYW5kIGVycm9yIGhhbmRsZXJzXG4gICAgICAgICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gQSBEZWZlcnJlZCB0aGF0IG5vcm1hbGl6ZXMgdGhlIHJlc3BvbnNlIGZyb20gdGhlIGZldGNoLlxuICAgICAgICAqL1xuICAgICAgICBiaW5hcnlQcm9taXNlRmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnM9e30pO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5mZXRjaChvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBfLmVhY2godGhpcy5hc3NvY2lhdGVkLCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmFja2JvbmUuTW9kZWwpe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jbGVhcihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZXNldChudWxsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5lcnJvci5jbGVhcihvcHRpb25zKTtcbiAgICAgICAgICAgIEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZXREZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpO1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgY2xvbmVkTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmFzc29jaWF0ZWQsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvbmVkQXNzY01vZGVsID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTW9kZWxba2V5XSA9IGNsb25lZEFzc2NNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTW9kZWwuYXNzb2NpYXRlZFtrZXldID0gY2xvbmVkQXNzY01vZGVsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCYWNrYm9uZS5Db2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZWRBc3NjQ29sbGVjdGlvbiA9IG5ldyB2YWx1ZS5jb25zdHJ1Y3RvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm1hcChmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTW9kZWxba2V5XSA9IGNsb25lZEFzc2NDb2xsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWRNb2RlbC5hc3NvY2lhdGVkW2tleV0gPSBjbG9uZWRBc3NjQ29sbGVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWRNb2RlbDtcbiAgICAgICAgfSxcbiAgICAgICAgYXNzb2NpYXRlZE9mZjogZnVuY3Rpb24oZXZlbnRzLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICAgICAgXyh0aGlzLmFzc29jaWF0ZWQpLmVhY2goZnVuY3Rpb24oYXNzb2NpYXRlZCkge1xuICAgICAgICAgICAgICAgIGFzc29jaWF0ZWQub2ZmKGV2ZW50cywgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oYXNzb2NpYXRlZC5hc3NvY2lhdGVkT2ZmKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGVkLmFzc29jaWF0ZWRPZmYoZXZlbnRzLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAvLyBmZXRjaERhdGEgaXMgbm90IHBhcnQgb2YgdGhlIGFzc29jaWF0ZWQgY29udGFpbmVyLCBidXQgc2hvdWxkIHN0aWxsIGJlIHVuYm91bmRcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hEYXRhLm9mZihldmVudHMsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB0aGlzIHRvIGFubm91bmNlIHRvIGFueSBsaXN0ZW5lcnMgdGhhdCB0aGUgbW9kZWwgaXMgaW4gYSB2YWxpZCBzdGF0ZS4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgdGhlXG4gICAgICAgICAqIG1vZGVsIGlzIGF0dGFjaGVkIHRvIGEgQ29udHJvbEdyb3VwIGFuZCB5b3Ugd2FudCB0aGF0IENvbnRyb2xHcm91cCB0byBubyBsb25nZXIgYmUgaW4gdGhlIGVycm9yIHN0YXRlLlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIG5leHQgdGltZSB5b3UgYXR0ZW1wdCB0byB2YWxpZGF0ZSB0aGUgbW9kZWwsIGl0IHdpbGwgc3RpbGwgcnVuIHRocm91Z2ggaXRzIHZhbGlkYXRpb24gcnVsZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckVycm9yczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlcnZlclZhbGlkYXRlZCcsIHRydWUsIHRoaXMsIFtdKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndmFsaWRhdGVkJywgdHJ1ZSwgdGhpcywgW10pO1xuICAgICAgICB9LFxuXG4gICAgICAgLyoqXG4gICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtZXNzYWdlIGNvbnRhaW5zIGFuIGVycm9yXG4gICAgICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgKi9cbiAgICAgICAgbWVzc2FnZUhhc0Vycm9yOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG1lc3NhZ2UudHlwZSA9PT0gc3BsdW5rRFV0aWxzLkVSUk9SIHx8IG1lc3NhZ2UudHlwZSA9PT0gc3BsdW5rRFV0aWxzLkZBVEFMKTtcbiAgICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgY29udGFpbnMgYW4gZXJyb3IuIEFzIGFuIG9wdGltaXphdGlvbiwgd2UgdGFrZSBhbiBhcnJheSBvZiBtZXNzYWdlcyBwYXJzZWRcbiAgICAgICAgKiBmcm9tIHRoZSByZXNwb25zZSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gcGFyc2UgdGhlIHJlc3BvbnNlIHR3aWNlLlxuICAgICAgICAqIEBwYXJhbSByZXNwb25zZSAtIHBhcnNlZCByZXNwb25zZSBvYmplY3QgZnJvbSB0aGUgbW9kZWwgc3luY1xuICAgICAgICAqIEBwYXJhbSBtZXNzYWdlcyAtIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0c1xuICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAqL1xuICAgICAgICByZXNwb25zZUhhc0Vycm9yczogZnVuY3Rpb24ocmVzcG9uc2UsIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gXyhtZXNzYWdlcykuYW55KGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhc0Vycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlYnJvYWRjYXN0VmFsaWRhdGlvbjogZnVuY3Rpb24odmFsaWRhdGVkLCBtb2RlbCwgZXJyb3JfcGF5bG9hZCkge1xuICAgICAgICAgICAgLy8gZG9pbmcgdGhpcyB1bmlvbiB3aWxsIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhIHByZXZpb3VzbHktdW5kZWZpbmVkIGF0dHJpYnV0ZSBpcyBiZWluZyBzZXQgd2l0aCBhbiBpbnZhbGlkIHZhbHVlXG4gICAgICAgICAgICB2YXIgYWxsS2V5cyA9IF8udW5pb24oXy5rZXlzKHRoaXMuYXR0cmlidXRlcyksIF8ua2V5cyhlcnJvcl9wYXlsb2FkKSk7XG4gICAgICAgICAgICBfKGFsbEtleXMpLmVhY2goZnVuY3Rpb24oayl7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdhdHRyaWJ1dGVWYWxpZGF0ZWQ6JyArIGssICFfLmhhcyhlcnJvcl9wYXlsb2FkLCBrKSwgaywgZXJyb3JfcGF5bG9hZFtrXSk7XG4gICAgICAgICAgICB9LHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBfb25lcnJvcjogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBtb2RlbC5lcnJvci5jbGVhcigpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gc3BsdW5rRFV0aWxzLnhockVycm9yUmVzcG9uc2VQYXJzZXIocmVzcG9uc2UsIHRoaXMuaWQpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzZXJ2ZXJWYWxpZGF0ZWQnLCBmYWxzZSwgdGhpcywgbWVzc2FnZXMpO1xuICAgICAgICAgICAgbW9kZWwuZXJyb3Iuc2V0KFwibWVzc2FnZXNcIiwgbWVzc2FnZXMpO1xuICAgICAgICB9LFxuICAgICAgICBfb25zeW5jOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG1vZGVsLmVycm9yLmNsZWFyKCk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSB0aGlzLnBhcnNlU3BsdW5rRE1lc3NhZ2VzKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHZhciBoYXNFcnJvcnMgPSB0aGlzLnJlc3BvbnNlSGFzRXJyb3JzKHJlc3BvbnNlLCBtZXNzYWdlcyk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc2VydmVyVmFsaWRhdGVkJywgIWhhc0Vycm9ycywgdGhpcywgbWVzc2FnZXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuZXJyb3Iuc2V0KFwibWVzc2FnZXNcIiwgbWVzc2FnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXJzZVNwbHVua0RNZXNzYWdlczogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzcGx1bmtEVXRpbHMucGFyc2VNZXNzYWdlc09iamVjdChyZXNwb25zZS5tZXNzYWdlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlckJ5S2V5czogZnVuY3Rpb24oa2V5cywgb3B0aW9ucywgZmV0Y2hPcHRpb25zIC8qIG9wdGlvbmFsICovKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIGF0dHJzID0ge30sXG4gICAgICAgICAgICAgICAgc3RyaXAgPSBfLmlzU3RyaW5nKG9wdGlvbnMuc3RyaXApID8gb3B0aW9ucy5zdHJpcCA6ICcnLFxuICAgICAgICAgICAgICAgIGFsbG93RW1wdHkgPSAhIW9wdGlvbnMuYWxsb3dFbXB0eTtcblxuICAgICAgICAgICAgXy5lYWNoKHRoaXMudG9KU09OKGZldGNoT3B0aW9ucyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZihfLmluZGV4T2Yoa2V5cywga2V5KSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlID09PSBcIlwiKSB8fCBhbGxvd0VtcHR5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXkucmVwbGFjZShzdHJpcCwgJycpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlckJ5V2lsZGNhcmRzOiBmdW5jdGlvbih3aWxkY2FyZHMsIG9wdGlvbnMsIGZldGNoT3B0aW9ucyAvKiBvcHRpb25hbCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYWxVdGlscy5maWx0ZXJPYmplY3RCeVJlZ2V4ZXModGhpcy50b0pTT04oZmV0Y2hPcHRpb25zKSwgd2lsZGNhcmRzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyQ2hhbmdlZEJ5V2lsZGNhcmRzOiBmdW5jdGlvbih3aWxkY2FyZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmFsVXRpbHMuZmlsdGVyT2JqZWN0QnlSZWdleGVzKHRoaXMuY2hhbmdlZEF0dHJpYnV0ZXMoKSB8fCB7fSwgd2lsZGNhcmRzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGF0dHIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jbGVhcih7c2lsZW50OiB0cnVlfSk7XG4gICAgICAgICAgICB0aGlzLnNldChhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3RvcmUgdGhlIG1vZGVsIHRvIGl0cyBkZWZhdWx0IGF0dHJpYnV0ZXMuXG4gICAgICAgICAqIENBVkVBVCBFTVBUT1I6IG9mdGVuIGZpcmVzIHR3byBjaGFuZ2UgZXZlbnRzLCBib3RoIGdsb2JhbGx5IGFuZCBwZXItYXR0cmlidXRlXG4gICAgICAgICAqIENBVkVBVCBFTVBUT1I6IHRoaXMgaGFzIG5vdCBiZWVuIHdlbGwgdGVzdGVkIHlldFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgcmVzdG9yZURlZmF1bHRzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBfLmlzRnVuY3Rpb24odGhpcy5kZWZhdWx0cykgPyB0aGlzLmRlZmF1bHRzKCkgOiB0aGlzLmRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5jbGVhcihvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2V0KGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG4gICAgXy5leHRlbmQoQmFzZU1vZGVsLnByb3RvdHlwZSwgVmFsaWRhdGlvbk1peGluKTtcbiAgICBfLmV4dGVuZChCYXNlTW9kZWwucHJvdG90eXBlLCBtb2RlbGNvbGxlY3Rpb25NaXhpbik7XG4gICBcbiAgIHJldHVybiBCYXNlTW9kZWw7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9tb2RlbHMvQmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gbW9kZWxzL0Jhc2Vcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "mixins/modelcollection":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"require/underscore\"), __webpack_require__(\"util/Ticker\"), __webpack_require__(\"helpers/Session\")], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, Ticker, Session) {\n    /**\n     * @mixin modelcollection\n     */\n    return {\n        safeFetch: function() {\n            if (this.isFetching()) {\n                this.touched = arguments;\n                return;\n            }\n            delete this.touched;\n            this.fetch.apply(this, arguments);\n        },\n        isFetching: function() {\n            return this.fetchXhr && this.fetchXhr.state && this.fetchXhr.state()==='pending';\n        },\n        fetchAbort: function() {\n            if (this.isFetching()) {\n                delete this.touched;//fetch data will leak memory\n                if(_.isFunction(this.fetchXhr.abort)) {\n                    this.fetchXhr.abort();\n                }\n            }\n        },\n        deepOff: function() {\n            this.fetchAbort();\n            _(this.associated).each(function(associated) {\n                if (_.isFunction(associated.deepOff)) {\n                    associated.deepOff();\n                }\n            }, this);\n            if (_.isFunction(this.fetchData.deepOff)) {\n                this.fetchData.deepOff();\n            } else {\n                this.fetchData.off();\n            }\n            this.off();\n        },\n\n        DEFAULT_POLLING_DELAY: 1000,\n        ticker: null,\n        /**\n         * Start polling the model/collection.\n         * @param {Object} options\n         *     @param {Number} options.delay time to wait after each fetch before fetching again, in milliseconds, default is 1000\n         *     @param {Object} options.data the data that will be sent with each fetch\n         *     @param {Boolean} options.stopOnError stop polling if an error occurs on the model/collection, defaults to true\n         *     @param {Boolean} options.uiInactivity stop polling if a session timeout event occurs, defaults to false\n         *     @param {Function} options.condition callback to test if polling should continue\n         *                           will be passed the model/collection and should return boolean indicating whether polling should continue\n         *                           default behavior is to continue polling until cancelled for other reasons\n         * @memberOf modelcollection\n         */\n        startPolling: function(options) {\n            options = options || {};\n            if(this.ticker) {\n                throw new Error('startPolling cannot be called while already polling');\n            }\n\n            this.ticker = new Ticker({interval: options.delay || this.DEFAULT_POLLING_DELAY});\n            this.ticker.on('tick', function() {\n                if(options.condition && !options.condition(this)) {\n                    this.stopPolling();\n                }\n                else {\n                    this.safeFetch({ data: options.data });\n                }\n            }, this);\n\n            if(options.stopOnError !== false) {\n                this.on('error', this.stopPolling, this);\n            }\n\n            if(options.uiInactivity) {\n                Session.on('timeout', this.stopPolling, this);\n            }\n\n            this.ticker.start(true);\n        },\n        stopPolling: function() {\n            if(this.ticker) {\n                this.ticker.stop();\n                this.ticker.off();\n            }\n            this.off('error', this.stopPolling, this);\n            Session.off('timeout', this.stopPolling, this);\n            this.ticker = null;\n        }\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL21peGlucy9tb2RlbGNvbGxlY3Rpb24uanM/NDlmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsdUJBQXVCLE9BQU87QUFDOUIsdUJBQXVCLE9BQU87QUFDOUIsdUJBQXVCLFFBQVE7QUFDL0IsdUJBQXVCLFFBQVE7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxzREFBc0Q7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Im1peGlucy9tb2RlbGNvbGxlY3Rpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWyd1bmRlcnNjb3JlJywgJ3V0aWwvVGlja2VyJywgJ2hlbHBlcnMvU2Vzc2lvbiddLCBmdW5jdGlvbihfLCBUaWNrZXIsIFNlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBAbWl4aW4gbW9kZWxjb2xsZWN0aW9uXG4gICAgICovXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2FmZUZldGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmV0Y2hpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hlZCA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy50b3VjaGVkO1xuICAgICAgICAgICAgdGhpcy5mZXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICBpc0ZldGNoaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoWGhyICYmIHRoaXMuZmV0Y2hYaHIuc3RhdGUgJiYgdGhpcy5mZXRjaFhoci5zdGF0ZSgpPT09J3BlbmRpbmcnO1xuICAgICAgICB9LFxuICAgICAgICBmZXRjaEFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmV0Y2hpbmcoKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRvdWNoZWQ7Ly9mZXRjaCBkYXRhIHdpbGwgbGVhayBtZW1vcnlcbiAgICAgICAgICAgICAgICBpZihfLmlzRnVuY3Rpb24odGhpcy5mZXRjaFhoci5hYm9ydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZXRjaFhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVlcE9mZjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoQWJvcnQoKTtcbiAgICAgICAgICAgIF8odGhpcy5hc3NvY2lhdGVkKS5lYWNoKGZ1bmN0aW9uKGFzc29jaWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGFzc29jaWF0ZWQuZGVlcE9mZikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRlZC5kZWVwT2ZmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuZmV0Y2hEYXRhLmRlZXBPZmYpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaERhdGEuZGVlcE9mZigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZldGNoRGF0YS5vZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2ZmKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgREVGQVVMVF9QT0xMSU5HX0RFTEFZOiAxMDAwLFxuICAgICAgICB0aWNrZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydCBwb2xsaW5nIHRoZSBtb2RlbC9jb2xsZWN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiAgICAgQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXkgdGltZSB0byB3YWl0IGFmdGVyIGVhY2ggZmV0Y2ggYmVmb3JlIGZldGNoaW5nIGFnYWluLCBpbiBtaWxsaXNlY29uZHMsIGRlZmF1bHQgaXMgMTAwMFxuICAgICAgICAgKiAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGF0YSB0aGUgZGF0YSB0aGF0IHdpbGwgYmUgc2VudCB3aXRoIGVhY2ggZmV0Y2hcbiAgICAgICAgICogICAgIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zdG9wT25FcnJvciBzdG9wIHBvbGxpbmcgaWYgYW4gZXJyb3Igb2NjdXJzIG9uIHRoZSBtb2RlbC9jb2xsZWN0aW9uLCBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAqICAgICBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMudWlJbmFjdGl2aXR5IHN0b3AgcG9sbGluZyBpZiBhIHNlc3Npb24gdGltZW91dCBldmVudCBvY2N1cnMsIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAgICAgICAqICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNvbmRpdGlvbiBjYWxsYmFjayB0byB0ZXN0IGlmIHBvbGxpbmcgc2hvdWxkIGNvbnRpbnVlXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIG1vZGVsL2NvbGxlY3Rpb24gYW5kIHNob3VsZCByZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgcG9sbGluZyBzaG91bGQgY29udGludWVcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNvbnRpbnVlIHBvbGxpbmcgdW50aWwgY2FuY2VsbGVkIGZvciBvdGhlciByZWFzb25zXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2RlbGNvbGxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0UG9sbGluZzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICBpZih0aGlzLnRpY2tlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnRQb2xsaW5nIGNhbm5vdCBiZSBjYWxsZWQgd2hpbGUgYWxyZWFkeSBwb2xsaW5nJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGlja2VyID0gbmV3IFRpY2tlcih7aW50ZXJ2YWw6IG9wdGlvbnMuZGVsYXkgfHwgdGhpcy5ERUZBVUxUX1BPTExJTkdfREVMQVl9KTtcbiAgICAgICAgICAgIHRoaXMudGlja2VyLm9uKCd0aWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYob3B0aW9ucy5jb25kaXRpb24gJiYgIW9wdGlvbnMuY29uZGl0aW9uKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FmZUZldGNoKHsgZGF0YTogb3B0aW9ucy5kYXRhIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBpZihvcHRpb25zLnN0b3BPbkVycm9yICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub24oJ2Vycm9yJywgdGhpcy5zdG9wUG9sbGluZywgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKG9wdGlvbnMudWlJbmFjdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgU2Vzc2lvbi5vbigndGltZW91dCcsIHRoaXMuc3RvcFBvbGxpbmcsIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRpY2tlci5zdGFydCh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcFBvbGxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy50aWNrZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpY2tlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrZXIub2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9mZignZXJyb3InLCB0aGlzLnN0b3BQb2xsaW5nLCB0aGlzKTtcbiAgICAgICAgICAgIFNlc3Npb24ub2ZmKCd0aW1lb3V0JywgdGhpcy5zdG9wUG9sbGluZywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRpY2tlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvbWl4aW5zL21vZGVsY29sbGVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gbWl4aW5zL21vZGVsY29sbGVjdGlvblxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "util/Ticker":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"require/underscore\"), __webpack_require__(\"require/backbone\")], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, Backbone) {\n    var Ticker = function(options) {\n        options || (options = {});\n        this.interval = options.interval || 1000;\n        this.cid = _.uniqueId('ticker');\n        if (options.params) {\n            this.params = options.params;\n        }\n        if (options.tick) {\n            this.tick();\n        }\n        if (options.start) {\n            this.start();\n        }\n    };\n    _.extend(Ticker.prototype, Backbone.Events, {\n        start: function(tick) {\n            if (this._intervalId) {\n                return false;\n            }\n            if (tick) {\n                this.tick();\n            }\n            this._intervalId = setInterval(\n                _.bind(this.tick, this),\n                this.interval\n            );\n            return true;\n        },\n        stop: function(tick) {\n            if (this._intervalId) {\n                if (tick) {\n                    this.tick();\n                }\n                clearInterval(this._intervalId);\n                delete this._intervalId;\n                return true;\n            }\n            return false;\n        },\n        restart: function(options) {\n            options || (options = {});\n            this.stop();\n            if (options.interval) {\n                this.interval = options.interval;\n            }\n            if (options.params) {\n                this.params = options.params;\n            }\n            this.start(options.tick);\n        },\n        tick: function(params) {\n            params || (params=this.params);\n            var args = _.isArray(params) ? params : [params];\n            this.trigger.apply(this, ['tick'].concat(args));\n        }\n    });\n    return Ticker;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvVGlja2VyLmpzPzg3MDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsImZpbGUiOiJ1dGlsL1RpY2tlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbJ3VuZGVyc2NvcmUnLCAnYmFja2JvbmUnXSwgZnVuY3Rpb24oXywgQmFja2JvbmUpIHtcbiAgICB2YXIgVGlja2VyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICB0aGlzLmludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbCB8fCAxMDAwO1xuICAgICAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQoJ3RpY2tlcicpO1xuICAgICAgICBpZiAob3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudGljaykge1xuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXy5leHRlbmQoVGlja2VyLnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCB7XG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbih0aWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMudGljaywgdGhpcyksXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbih0aWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbnRlcnZhbElkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICByZXN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhcnQob3B0aW9ucy50aWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGljazogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgfHwgKHBhcmFtcz10aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICB2YXIgYXJncyA9IF8uaXNBcnJheShwYXJhbXMpID8gcGFyYW1zIDogW3BhcmFtc107XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgWyd0aWNrJ10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBUaWNrZXI7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvdXRpbC9UaWNrZXIuanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvVGlja2VyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "helpers/Session":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/backbone\"),\n        __webpack_require__(\"require/underscore\"),\n        __webpack_require__(\"shim/splunk.session\"),\n        __webpack_require__(\"util/console\"),\n        __webpack_require__(\"shim/splunk.util\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, _, SplunkSession, console, splunkUtil){\n    \n    var Session = function() {\n        this._session = SplunkSession.getInstance();\n        this.cid = _.uniqueId();\n        this.timeout = 'SessionTimeout.' + this.cid;\n        this.start = 'SessionStart.' + this.cid;\n        this.restart = 'HaltOnRestart.' + this.cid; //Stop all the pollers when restart is initiated from the UI\n\n        $(document).on(this.timeout, function() {\n            console.log(\"ui_inactivity_timeout occurred, current limit is: \" + splunkUtil.getConfigValue(\"UI_INACTIVITY_TIMEOUT\", this._session.UI_INACTIVITY_TIMEOUT) + ' minute(s)');\n            this.trigger('timeout');\n        }.bind(this));\n        $(document).on(this.start, function() {\n            this.trigger('start');\n        }.bind(this));\n        $(document).on(this.restart, function() {\n            this.trigger('restart');\n        }.bind(this));\n    };\n\n    _.extend(Session.prototype, Backbone.Events, {\n        dispose: function() {\n            $(document).off(this.timeout);\n            $(document).off(this.start);\n            $(document).off(this.restart);\n        }\n    });\n    \n    return new Session;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2hlbHBlcnMvU2Vzc2lvbi5qcz9jZTg4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQSxpQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUMiLCJmaWxlIjoiaGVscGVycy9TZXNzaW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFxuICAgIFtcbiAgICAgICAgJ2pxdWVyeScsXG4gICAgICAgICdiYWNrYm9uZScsXG4gICAgICAgICd1bmRlcnNjb3JlJyxcbiAgICAgICAgJ3NwbHVuay5zZXNzaW9uJyxcbiAgICAgICAgJ3V0aWwvY29uc29sZScsXG4gICAgICAgICdzcGx1bmsudXRpbCdcbiAgICBdLCBmdW5jdGlvbigkLCBCYWNrYm9uZSwgXywgU3BsdW5rU2Vzc2lvbiwgY29uc29sZSwgc3BsdW5rVXRpbCl7XG4gICAgXG4gICAgdmFyIFNlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbiA9IFNwbHVua1Nlc3Npb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9ICdTZXNzaW9uVGltZW91dC4nICsgdGhpcy5jaWQ7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAnU2Vzc2lvblN0YXJ0LicgKyB0aGlzLmNpZDtcbiAgICAgICAgdGhpcy5yZXN0YXJ0ID0gJ0hhbHRPblJlc3RhcnQuJyArIHRoaXMuY2lkOyAvL1N0b3AgYWxsIHRoZSBwb2xsZXJzIHdoZW4gcmVzdGFydCBpcyBpbml0aWF0ZWQgZnJvbSB0aGUgVUlcblxuICAgICAgICAkKGRvY3VtZW50KS5vbih0aGlzLnRpbWVvdXQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1aV9pbmFjdGl2aXR5X3RpbWVvdXQgb2NjdXJyZWQsIGN1cnJlbnQgbGltaXQgaXM6IFwiICsgc3BsdW5rVXRpbC5nZXRDb25maWdWYWx1ZShcIlVJX0lOQUNUSVZJVFlfVElNRU9VVFwiLCB0aGlzLl9zZXNzaW9uLlVJX0lOQUNUSVZJVFlfVElNRU9VVCkgKyAnIG1pbnV0ZShzKScpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0aW1lb3V0Jyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICQoZG9jdW1lbnQpLm9uKHRoaXMuc3RhcnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzdGFydCcpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAkKGRvY3VtZW50KS5vbih0aGlzLnJlc3RhcnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdyZXN0YXJ0Jyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfTtcblxuICAgIF8uZXh0ZW5kKFNlc3Npb24ucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIHtcbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vZmYodGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZih0aGlzLnN0YXJ0KTtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZih0aGlzLnJlc3RhcnQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvaGVscGVycy9TZXNzaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSBoZWxwZXJzL1Nlc3Npb25cbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "shim/splunk.session":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"shim/splunk\"),\n       __webpack_require__(\"shim/jquery\"),\n       __webpack_require__(\"shim/lowpro\"),\n       __webpack_require__(\"shim/splunk.logger\"),\n       __webpack_require__(\"shim/splunk.util\"),\n       __webpack_require__(268)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Splunk) {\n    return Splunk.Session;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vc3BsdW5rLnNlc3Npb24uanM/NDg3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InNoaW0vc3BsdW5rLnNlc3Npb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydzcGx1bmsnLFxuICAgICAgICdqcXVlcnknLFxuICAgICAgICdsb3dwcm8nLFxuICAgICAgICdzcGx1bmsubG9nZ2VyJyxcbiAgICAgICAnc3BsdW5rLnV0aWwnLFxuICAgICAgICdpbXBvcnRzPyQ9anF1ZXJ5IXNlc3Npb24nXSwgZnVuY3Rpb24oU3BsdW5rKSB7XG4gICAgcmV0dXJuIFNwbHVuay5TZXNzaW9uO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vc3BsdW5rLnNlc3Npb24uanNcbi8vIG1vZHVsZSBpZCA9IHNoaW0vc3BsdW5rLnNlc3Npb25cbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 268:
/***/ (function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar $ = __webpack_require__(\"shim/jquery\");\n\nSplunk.namespace(\"Splunk.Session\");\n/**\n * A simple class that dispatches jQuery document events Splunk.Session.TIMEOUT_EVENT and Splunk.Session.START_EVENT.\n * Events triggered on UI activity/no-activity configuration setting POLLER_TIMEOUT_INTERVAL.\n */\nSplunk.Session = $.klass({\n    EVENT_BUFFER_TIMEOUT: 1000,//Never operate on many DOM events without a governor (ie., 1000ms governor cancels >30 scroll events).\n    UI_INACTIVITY_TIMEOUT: 60,\n    START_EVENT: \"SessionStart\",\n    TIMEOUT_EVENT: \"SessionTimeout\",\n    RESTART_EVENT: \"HaltOnRestart\", //Stop all the pollers when restart is initiated from the UI\n    UI_EVENT_TYPES: [\"click\", \"keydown\", \"mouseover\", \"scroll\"],\n    /**\n     * Initializes Session.\n     */\n    initialize: function(){\n        this.logger = Splunk.Logger.getLogger(\"session.js\");\n        this.eventBuffer = [];\n        this.timeoutDelay = Splunk.util.getConfigValue(\"UI_INACTIVITY_TIMEOUT\", this.UI_INACTIVITY_TIMEOUT);\n        this.timeoutDelay *= 60000;\n\n        // SPL-82672 if timeoutDelay is > 2147483647 they are most likely treating it as milliseconds.\n        if(this.timeoutDelay > 2147483647) {\n            this.logger.warn(\"ui_inactivity_timeout must be treated as minutes not milliseconds. Defaulting to 60 min\");\n            this.timeoutDelay = 3600000;\n        }\n\n        this.timeoutID = null;\n        $(document).bind(this.START_EVENT, this.onSessionStart.bind(this));\n        if(!this.timeoutDelay<1){\n            $(document).bind(this.TIMEOUT_EVENT, this.onSessionTimeout.bind(this));\n            $(document).bind(this.UI_EVENT_TYPES.join(\" \"), this.onUIEvent.bind(this));\n            this.startTimeout();\n        }\n        $(document).trigger(this.START_EVENT, new Date());\n    },\n    /**\n     * Top level UI event listener and dispatcher, triggers Splunk.Session.START_EVENT if timeoutID is null, resets the \n     * timer if timeoutID not null.\n     *\n     * @param {Object} event A DOM event.\n     */\n    onUIEvent: function(event){\n        if(this.timeoutID){\n            this.eventBuffer.push(\"\");\n            if(this.eventBuffer.length===1){\n                this.resetTimeout();\n                setTimeout(\n                    function(){\n                        this.eventBuffer = [];\n                    }.bind(this),\n                    this.EVENT_BUFFER_TIMEOUT\n                );\n            }\n        }else{\n            this.startTimeout();\n            $(document).trigger(this.START_EVENT, new Date());\n        }\n    },\n    /**\n     * Start of new UI activity/session.\n     * \n     * @param {Object) event The jQuery passed event.\n     * @param {Date} date The time the event was fired.\n     */\n    onSessionStart: function(event, date){},\n    /**\n     * End of UI activity/session.\n     * \n     * @param {Object) event The jQuery passed event.\n     * @param {Date} date The time the event was fired.\n     */\n    onSessionTimeout: function(event, date){},\n    /**\n     * Reset timeout, stop and start again.\n     */\n    resetTimeout: function(){\n        this.stopTimeout();\n        this.startTimeout();\n    },\n    /**\n     * Inform subscribers of server restart started\n     */\n    signalRestart: function(){\n        $(document).trigger(this.RESTART_EVENT);\n    },\n    /**\n     * Start timeout, set timeoutID.\n     */\n    startTimeout: function(){\n        this.timeoutID = window.setTimeout(this.timeoutHandler.bind(this), this.timeoutDelay);\n    },\n    /**\n     * Stop timeout, if timeoutID exists clear the previous delay and set timeoutID back to null.\n     * \n     * Note: Passing an invalid ID to clearTimeout does not have any effect (and doesn't throw an exception).\n     */\n    stopTimeout: function(){\n        if(this.timeoutID){\n            window.clearTimeout(this.timeoutID);\n            this.timeoutID = null;\n        }\n    },\n    /**\n     * Handler for successful timeout, set timeoutID back to null, trigger Splunk.Session.TIMEOUT_EVENT.\n     */\n    timeoutHandler: function(){\n        this.stopTimeout();\n        $(document).trigger(this.TIMEOUT_EVENT, new Date());\n    }\n});\nSplunk.Session.instance = null;\n/**\n * Singleton reference to Session object.\n *\n * @return A reference to a shared Session object.\n * @type Object\n */\nSplunk.Session.getInstance = function(){\n    if(!Splunk.Session.instance){\n        Splunk.Session.instance = new Splunk.Session();\n    }\n    return Splunk.Session.instance;\n};\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3Nlc3Npb24uanM/NjI5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlLEtBQUs7QUFDcEI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWUsS0FBSztBQUNwQjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI2OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcblxuU3BsdW5rLm5hbWVzcGFjZShcIlNwbHVuay5TZXNzaW9uXCIpO1xuLyoqXG4gKiBBIHNpbXBsZSBjbGFzcyB0aGF0IGRpc3BhdGNoZXMgalF1ZXJ5IGRvY3VtZW50IGV2ZW50cyBTcGx1bmsuU2Vzc2lvbi5USU1FT1VUX0VWRU5UIGFuZCBTcGx1bmsuU2Vzc2lvbi5TVEFSVF9FVkVOVC5cbiAqIEV2ZW50cyB0cmlnZ2VyZWQgb24gVUkgYWN0aXZpdHkvbm8tYWN0aXZpdHkgY29uZmlndXJhdGlvbiBzZXR0aW5nIFBPTExFUl9USU1FT1VUX0lOVEVSVkFMLlxuICovXG5TcGx1bmsuU2Vzc2lvbiA9ICQua2xhc3Moe1xuICAgIEVWRU5UX0JVRkZFUl9USU1FT1VUOiAxMDAwLC8vTmV2ZXIgb3BlcmF0ZSBvbiBtYW55IERPTSBldmVudHMgd2l0aG91dCBhIGdvdmVybm9yIChpZS4sIDEwMDBtcyBnb3Zlcm5vciBjYW5jZWxzID4zMCBzY3JvbGwgZXZlbnRzKS5cbiAgICBVSV9JTkFDVElWSVRZX1RJTUVPVVQ6IDYwLFxuICAgIFNUQVJUX0VWRU5UOiBcIlNlc3Npb25TdGFydFwiLFxuICAgIFRJTUVPVVRfRVZFTlQ6IFwiU2Vzc2lvblRpbWVvdXRcIixcbiAgICBSRVNUQVJUX0VWRU5UOiBcIkhhbHRPblJlc3RhcnRcIiwgLy9TdG9wIGFsbCB0aGUgcG9sbGVycyB3aGVuIHJlc3RhcnQgaXMgaW5pdGlhdGVkIGZyb20gdGhlIFVJXG4gICAgVUlfRVZFTlRfVFlQRVM6IFtcImNsaWNrXCIsIFwia2V5ZG93blwiLCBcIm1vdXNlb3ZlclwiLCBcInNjcm9sbFwiXSxcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBTZXNzaW9uLlxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gU3BsdW5rLkxvZ2dlci5nZXRMb2dnZXIoXCJzZXNzaW9uLmpzXCIpO1xuICAgICAgICB0aGlzLmV2ZW50QnVmZmVyID0gW107XG4gICAgICAgIHRoaXMudGltZW91dERlbGF5ID0gU3BsdW5rLnV0aWwuZ2V0Q29uZmlnVmFsdWUoXCJVSV9JTkFDVElWSVRZX1RJTUVPVVRcIiwgdGhpcy5VSV9JTkFDVElWSVRZX1RJTUVPVVQpO1xuICAgICAgICB0aGlzLnRpbWVvdXREZWxheSAqPSA2MDAwMDtcblxuICAgICAgICAvLyBTUEwtODI2NzIgaWYgdGltZW91dERlbGF5IGlzID4gMjE0NzQ4MzY0NyB0aGV5IGFyZSBtb3N0IGxpa2VseSB0cmVhdGluZyBpdCBhcyBtaWxsaXNlY29uZHMuXG4gICAgICAgIGlmKHRoaXMudGltZW91dERlbGF5ID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInVpX2luYWN0aXZpdHlfdGltZW91dCBtdXN0IGJlIHRyZWF0ZWQgYXMgbWludXRlcyBub3QgbWlsbGlzZWNvbmRzLiBEZWZhdWx0aW5nIHRvIDYwIG1pblwiKTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dERlbGF5ID0gMzYwMDAwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZW91dElEID0gbnVsbDtcbiAgICAgICAgJChkb2N1bWVudCkuYmluZCh0aGlzLlNUQVJUX0VWRU5ULCB0aGlzLm9uU2Vzc2lvblN0YXJ0LmJpbmQodGhpcykpO1xuICAgICAgICBpZighdGhpcy50aW1lb3V0RGVsYXk8MSl7XG4gICAgICAgICAgICAkKGRvY3VtZW50KS5iaW5kKHRoaXMuVElNRU9VVF9FVkVOVCwgdGhpcy5vblNlc3Npb25UaW1lb3V0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgJChkb2N1bWVudCkuYmluZCh0aGlzLlVJX0VWRU5UX1RZUEVTLmpvaW4oXCIgXCIpLCB0aGlzLm9uVUlFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgJChkb2N1bWVudCkudHJpZ2dlcih0aGlzLlNUQVJUX0VWRU5ULCBuZXcgRGF0ZSgpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRvcCBsZXZlbCBVSSBldmVudCBsaXN0ZW5lciBhbmQgZGlzcGF0Y2hlciwgdHJpZ2dlcnMgU3BsdW5rLlNlc3Npb24uU1RBUlRfRVZFTlQgaWYgdGltZW91dElEIGlzIG51bGwsIHJlc2V0cyB0aGUgXG4gICAgICogdGltZXIgaWYgdGltZW91dElEIG5vdCBudWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEEgRE9NIGV2ZW50LlxuICAgICAqL1xuICAgIG9uVUlFdmVudDogZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICBpZih0aGlzLnRpbWVvdXRJRCl7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVmZmVyLnB1c2goXCJcIik7XG4gICAgICAgICAgICBpZih0aGlzLmV2ZW50QnVmZmVyLmxlbmd0aD09PTEpe1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkVWRU5UX0JVRkZFUl9USU1FT1VUXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZW91dCgpO1xuICAgICAgICAgICAgJChkb2N1bWVudCkudHJpZ2dlcih0aGlzLlNUQVJUX0VWRU5ULCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogU3RhcnQgb2YgbmV3IFVJIGFjdGl2aXR5L3Nlc3Npb24uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtPYmplY3QpIGV2ZW50IFRoZSBqUXVlcnkgcGFzc2VkIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBUaGUgdGltZSB0aGUgZXZlbnQgd2FzIGZpcmVkLlxuICAgICAqL1xuICAgIG9uU2Vzc2lvblN0YXJ0OiBmdW5jdGlvbihldmVudCwgZGF0ZSl7fSxcbiAgICAvKipcbiAgICAgKiBFbmQgb2YgVUkgYWN0aXZpdHkvc2Vzc2lvbi5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge09iamVjdCkgZXZlbnQgVGhlIGpRdWVyeSBwYXNzZWQgZXZlbnQuXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlIFRoZSB0aW1lIHRoZSBldmVudCB3YXMgZmlyZWQuXG4gICAgICovXG4gICAgb25TZXNzaW9uVGltZW91dDogZnVuY3Rpb24oZXZlbnQsIGRhdGUpe30sXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGltZW91dCwgc3RvcCBhbmQgc3RhcnQgYWdhaW4uXG4gICAgICovXG4gICAgcmVzZXRUaW1lb3V0OiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnN0b3BUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbmZvcm0gc3Vic2NyaWJlcnMgb2Ygc2VydmVyIHJlc3RhcnQgc3RhcnRlZFxuICAgICAqL1xuICAgIHNpZ25hbFJlc3RhcnQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIodGhpcy5SRVNUQVJUX0VWRU5UKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRpbWVvdXQsIHNldCB0aW1lb3V0SUQuXG4gICAgICovXG4gICAgc3RhcnRUaW1lb3V0OiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnRpbWVvdXRJRCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMudGltZW91dEhhbmRsZXIuYmluZCh0aGlzKSwgdGhpcy50aW1lb3V0RGVsYXkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU3RvcCB0aW1lb3V0LCBpZiB0aW1lb3V0SUQgZXhpc3RzIGNsZWFyIHRoZSBwcmV2aW91cyBkZWxheSBhbmQgc2V0IHRpbWVvdXRJRCBiYWNrIHRvIG51bGwuXG4gICAgICogXG4gICAgICogTm90ZTogUGFzc2luZyBhbiBpbnZhbGlkIElEIHRvIGNsZWFyVGltZW91dCBkb2VzIG5vdCBoYXZlIGFueSBlZmZlY3QgKGFuZCBkb2Vzbid0IHRocm93IGFuIGV4Y2VwdGlvbikuXG4gICAgICovXG4gICAgc3RvcFRpbWVvdXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRoaXMudGltZW91dElEKXtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SUQpO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0SUQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciBzdWNjZXNzZnVsIHRpbWVvdXQsIHNldCB0aW1lb3V0SUQgYmFjayB0byBudWxsLCB0cmlnZ2VyIFNwbHVuay5TZXNzaW9uLlRJTUVPVVRfRVZFTlQuXG4gICAgICovXG4gICAgdGltZW91dEhhbmRsZXI6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuc3RvcFRpbWVvdXQoKTtcbiAgICAgICAgJChkb2N1bWVudCkudHJpZ2dlcih0aGlzLlRJTUVPVVRfRVZFTlQsIG5ldyBEYXRlKCkpO1xuICAgIH1cbn0pO1xuU3BsdW5rLlNlc3Npb24uaW5zdGFuY2UgPSBudWxsO1xuLyoqXG4gKiBTaW5nbGV0b24gcmVmZXJlbmNlIHRvIFNlc3Npb24gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gQSByZWZlcmVuY2UgdG8gYSBzaGFyZWQgU2Vzc2lvbiBvYmplY3QuXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xuU3BsdW5rLlNlc3Npb24uZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbigpe1xuICAgIGlmKCFTcGx1bmsuU2Vzc2lvbi5pbnN0YW5jZSl7XG4gICAgICAgIFNwbHVuay5TZXNzaW9uLmluc3RhbmNlID0gbmV3IFNwbHVuay5TZXNzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBTcGx1bmsuU2Vzc2lvbi5pbnN0YW5jZTtcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pbXBvcnRzLWxvYWRlcj8kPWpxdWVyeSEuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvc2Vzc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "validation/ValidationMixin":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(\"require/underscore\"),\n    __webpack_require__(\"require/backbone\"),\n    __webpack_require__(\"contrib/backbone-validation-amd\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n        _,\n        Backbone\n        // backbone-validation\n        ){\n        /**\n         * Custom Validator Example:\n         *\n         *     _.extend(Backbone.Validation.validators, {\n         *         myValidator: function(value, attr, customValue, model) {\n         *             if(value !== customValue){\n         *                 return 'error';\n         *             }\n         *         }\n         *     });\n         *\n         *  Custom Patterns Example:\n         *\n         *     _.extend(Backbone.Validation.patterns, {\n         *         myPattern: /my-pattern/,\n         *         email: /my-much-better-email-regex/\n         *     });\n         *      \n         * Custom Messages\n         * Replace the existing error messages with ones that use the\n         * ControlGroup's label as the placeholder instead of the model attribute name\n         * @mixin validation\n         */\n        _.extend(Backbone.Validation.messages, {\n            required: '{label} is required',\n            acceptance: '{label} must be accepted',\n            min: '{label} must be greater than or equal to {1}',\n            max: '{label} must be less than or equal to {1}',\n            range: '{label} must be between {1} and {2}',\n            length: '{label} must be {1} characters',\n            minLength: '{label} must be at least {1} characters',\n            maxLength: '{label} must be at most {1} characters',\n            rangeLength: '{label} must be between {1} and {2} characters',\n            oneOf: '{label} must be one of: {1}',\n            equalTo: '{label} must be the same as {1}',\n            pattern: '{label} must be a valid {1}'\n        });\n\n        return Backbone.Validation.mixin;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZhbGlkYXRpb24vVmFsaWRhdGlvbk1peGluLmpzPzI5MGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QiwwQkFBMEIsTUFBTTtBQUNoQyxtQkFBbUIsTUFBTSxtQ0FBbUMsRUFBRTtBQUM5RCxtQkFBbUIsTUFBTSxnQ0FBZ0MsRUFBRTtBQUMzRCxxQkFBcUIsTUFBTSxrQkFBa0IsRUFBRSxNQUFNLEVBQUU7QUFDdkQsc0JBQXNCLE1BQU0sVUFBVSxFQUFFO0FBQ3hDLHlCQUF5QixNQUFNLG1CQUFtQixFQUFFO0FBQ3BELHlCQUF5QixNQUFNLGtCQUFrQixFQUFFO0FBQ25ELDJCQUEyQixNQUFNLGtCQUFrQixFQUFFLE1BQU0sRUFBRTtBQUM3RCxxQkFBcUIsTUFBTSxrQkFBa0IsRUFBRTtBQUMvQyx1QkFBdUIsTUFBTSxzQkFBc0IsRUFBRTtBQUNyRCx1QkFBdUIsTUFBTSxrQkFBa0IsRUFBRTtBQUNqRCxTQUFTOztBQUVUO0FBQ0EsQ0FBQyIsImZpbGUiOiJ2YWxpZGF0aW9uL1ZhbGlkYXRpb25NaXhpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXG4gICAgJ3VuZGVyc2NvcmUnLFxuICAgICdiYWNrYm9uZScsXG4gICAgJ2JhY2tib25lX3ZhbGlkYXRpb24nXG5dLFxuICAgIGZ1bmN0aW9uKFxuICAgICAgICBfLFxuICAgICAgICBCYWNrYm9uZVxuICAgICAgICAvLyBiYWNrYm9uZS12YWxpZGF0aW9uXG4gICAgICAgICl7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXN0b20gVmFsaWRhdG9yIEV4YW1wbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBfLmV4dGVuZChCYWNrYm9uZS5WYWxpZGF0aW9uLnZhbGlkYXRvcnMsIHtcbiAgICAgICAgICogICAgICAgICBteVZhbGlkYXRvcjogZnVuY3Rpb24odmFsdWUsIGF0dHIsIGN1c3RvbVZhbHVlLCBtb2RlbCkge1xuICAgICAgICAgKiAgICAgICAgICAgICBpZih2YWx1ZSAhPT0gY3VzdG9tVmFsdWUpe1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgcmV0dXJuICdlcnJvcic7XG4gICAgICAgICAqICAgICAgICAgICAgIH1cbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogIEN1c3RvbSBQYXR0ZXJucyBFeGFtcGxlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgXy5leHRlbmQoQmFja2JvbmUuVmFsaWRhdGlvbi5wYXR0ZXJucywge1xuICAgICAgICAgKiAgICAgICAgIG15UGF0dGVybjogL215LXBhdHRlcm4vLFxuICAgICAgICAgKiAgICAgICAgIGVtYWlsOiAvbXktbXVjaC1iZXR0ZXItZW1haWwtcmVnZXgvXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICogICAgICBcbiAgICAgICAgICogQ3VzdG9tIE1lc3NhZ2VzXG4gICAgICAgICAqIFJlcGxhY2UgdGhlIGV4aXN0aW5nIGVycm9yIG1lc3NhZ2VzIHdpdGggb25lcyB0aGF0IHVzZSB0aGVcbiAgICAgICAgICogQ29udHJvbEdyb3VwJ3MgbGFiZWwgYXMgdGhlIHBsYWNlaG9sZGVyIGluc3RlYWQgb2YgdGhlIG1vZGVsIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAqIEBtaXhpbiB2YWxpZGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBfLmV4dGVuZChCYWNrYm9uZS5WYWxpZGF0aW9uLm1lc3NhZ2VzLCB7XG4gICAgICAgICAgICByZXF1aXJlZDogJ3tsYWJlbH0gaXMgcmVxdWlyZWQnLFxuICAgICAgICAgICAgYWNjZXB0YW5jZTogJ3tsYWJlbH0gbXVzdCBiZSBhY2NlcHRlZCcsXG4gICAgICAgICAgICBtaW46ICd7bGFiZWx9IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHsxfScsXG4gICAgICAgICAgICBtYXg6ICd7bGFiZWx9IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHsxfScsXG4gICAgICAgICAgICByYW5nZTogJ3tsYWJlbH0gbXVzdCBiZSBiZXR3ZWVuIHsxfSBhbmQgezJ9JyxcbiAgICAgICAgICAgIGxlbmd0aDogJ3tsYWJlbH0gbXVzdCBiZSB7MX0gY2hhcmFjdGVycycsXG4gICAgICAgICAgICBtaW5MZW5ndGg6ICd7bGFiZWx9IG11c3QgYmUgYXQgbGVhc3QgezF9IGNoYXJhY3RlcnMnLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiAne2xhYmVsfSBtdXN0IGJlIGF0IG1vc3QgezF9IGNoYXJhY3RlcnMnLFxuICAgICAgICAgICAgcmFuZ2VMZW5ndGg6ICd7bGFiZWx9IG11c3QgYmUgYmV0d2VlbiB7MX0gYW5kIHsyfSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgICAgIG9uZU9mOiAne2xhYmVsfSBtdXN0IGJlIG9uZSBvZjogezF9JyxcbiAgICAgICAgICAgIGVxdWFsVG86ICd7bGFiZWx9IG11c3QgYmUgdGhlIHNhbWUgYXMgezF9JyxcbiAgICAgICAgICAgIHBhdHRlcm46ICd7bGFiZWx9IG11c3QgYmUgYSB2YWxpZCB7MX0nXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBCYWNrYm9uZS5WYWxpZGF0aW9uLm1peGluO1xufSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy92YWxpZGF0aW9uL1ZhbGlkYXRpb25NaXhpbi5qc1xuLy8gbW9kdWxlIGlkID0gdmFsaWRhdGlvbi9WYWxpZGF0aW9uTWl4aW5cbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/backbone-validation-amd":
/***/ (function(module, exports, __webpack_require__) {

	eval("// Backbone.Validation v0.9.1\n//\n// Copyright (c) 2011-2014 Thomas Pedersen\n// Distributed under MIT License\n//\n// Documentation and full license available at:\n// http://thedersen.com/projects/backbone-validation\n(function (factory) {\n  if (true) {\n    module.exports = factory(__webpack_require__(\"require/backbone\"), __webpack_require__(\"require/underscore\"));\n  } else if (typeof define === 'function' && define.amd) {\n    define(['backbone', 'underscore'], factory);\n  }\n}(function (Backbone, _) {\n  Backbone.Validation = (function(_){\n    'use strict';\n  \n    // Default options\n    // ---------------\n  \n    var defaultOptions = {\n      forceUpdate: false,\n      selector: 'name',\n      labelFormatter: 'sentenceCase',\n      valid: Function.prototype,\n      invalid: Function.prototype\n    };\n  \n  \n    // Helper functions\n    // ----------------\n  \n    // Formatting functions used for formatting error messages\n    var formatFunctions = {\n      // Uses the configured label formatter to format the attribute name\n      // to make it more readable for the user\n      formatLabel: function(attrName, model) {\n        return defaultLabelFormatters[defaultOptions.labelFormatter](attrName, model);\n      },\n  \n      // Replaces nummeric placeholders like {0} in a string with arguments\n      // passed to the function\n      format: function() {\n        var args = Array.prototype.slice.call(arguments),\n            text = args.shift();\n        return text.replace(/\\{(\\d+)\\}/g, function(match, number) {\n          return typeof args[number] !== 'undefined' ? args[number] : match;\n        });\n      }\n    };\n  \n    // Flattens an object\n    // eg:\n    //\n    //     var o = {\n    //       address: {\n    //         street: 'Street',\n    //         zip: 1234\n    //       }\n    //     };\n    //\n    // becomes:\n    //\n    //     var o = {\n    //       'address.street': 'Street',\n    //       'address.zip': 1234\n    //     };\n    var flatten = function (obj, into, prefix) {\n      into = into || {};\n      prefix = prefix || '';\n  \n      _.each(obj, function(val, key) {\n        if(obj.hasOwnProperty(key)) {\n          if (val && typeof val === 'object' && !(\n            val instanceof Array ||\n            val instanceof Date ||\n            val instanceof RegExp ||\n            val instanceof Backbone.Model ||\n            val instanceof Backbone.Collection)\n          ) {\n            flatten(val, into, prefix + key + '.');\n          }\n          else {\n            into[prefix + key] = val;\n          }\n        }\n      });\n  \n      return into;\n    };\n  \n    // Validation\n    // ----------\n  \n    var Validation = (function(){\n  \n      // Returns an object with undefined properties for all\n      // attributes on the model that has defined one or more\n      // validation rules.\n      var getValidatedAttrs = function(model) {\n        return _.reduce(_.keys(_.result(model, 'validation') || {}), function(memo, key) {\n          memo[key] = void 0;\n          return memo;\n        }, {});\n      };\n  \n      // Looks on the model for validations for a specified\n      // attribute. Returns an array of any validators defined,\n      // or an empty array if none is defined.\n      var getValidators = function(model, attr) {\n        var attrValidationSet = model.validation ? _.result(model, 'validation')[attr] || {} : {};\n  \n        // If the validator is a function or a string, wrap it in a function validator\n        if (_.isFunction(attrValidationSet) || _.isString(attrValidationSet)) {\n          attrValidationSet = {\n            fn: attrValidationSet\n          };\n        }\n  \n        // Stick the validator object into an array\n        if(!_.isArray(attrValidationSet)) {\n          attrValidationSet = [attrValidationSet];\n        }\n  \n        // Reduces the array of validators into a new array with objects\n        // with a validation method to call, the value to validate against\n        // and the specified error message, if any\n        return _.reduce(attrValidationSet, function(memo, attrValidation) {\n          _.each(_.without(_.keys(attrValidation), 'msg'), function(validator) {\n            memo.push({\n              fn: defaultValidators[validator],\n              val: attrValidation[validator],\n              msg: attrValidation.msg\n            });\n          });\n          return memo;\n        }, []);\n      };\n  \n      // Validates an attribute against all validators defined\n      // for that attribute. If one or more errors are found,\n      // the first error message is returned.\n      // If the attribute is valid, an empty string is returned.\n      var validateAttr = function(model, attr, value, computed) {\n        // Reduces the array of validators to an error message by\n        // applying all the validators and returning the first error\n        // message, if any.\n        return _.reduce(getValidators(model, attr), function(memo, validator){\n          // Pass the format functions plus the default\n          // validators as the context to the validator\n          var ctx = _.extend({}, formatFunctions, defaultValidators),\n              result = validator.fn.call(ctx, value, attr, validator.val, model, computed);\n  \n          if(result === false || memo === false) {\n            return false;\n          }\n          if (result && !memo) {\n            return _.result(validator, 'msg') || result;\n          }\n          return memo;\n        }, '');\n      };\n  \n      // Loops through the model's attributes and validates them all.\n      // Returns and object containing names of invalid attributes\n      // as well as error messages.\n      var validateModel = function(model, attrs) {\n        var error,\n            invalidAttrs = {},\n            isValid = true,\n            computed = _.clone(attrs),\n            flattened = flatten(attrs);\n  \n        _.each(flattened, function(val, attr) {\n          error = validateAttr(model, attr, val, computed);\n          if (error) {\n            invalidAttrs[attr] = error;\n            isValid = false;\n          }\n        });\n  \n        return {\n          invalidAttrs: invalidAttrs,\n          isValid: isValid\n        };\n      };\n  \n      // Contains the methods that are mixed in on the model when binding\n      var mixin = function(view, options) {\n        return {\n  \n          // Check whether or not a value, or a hash of values\n          // passes validation without updating the model\n          preValidate: function(attr, value) {\n            var self = this,\n                result = {},\n                error;\n  \n            if(_.isObject(attr)){\n              _.each(attr, function(value, key) {\n                error = self.preValidate(key, value);\n                if(error){\n                  result[key] = error;\n                }\n              });\n  \n              return _.isEmpty(result) ? undefined : result;\n            }\n            else {\n              return validateAttr(this, attr, value, _.extend({}, this.attributes));\n            }\n          },\n  \n          // Check to see if an attribute, an array of attributes or the\n          // entire model is valid. Passing true will force a validation\n          // of the model.\n          isValid: function(option) {\n            var flattened = flatten(this.attributes);\n  \n            if(_.isString(option)){\n              return !validateAttr(this, option, flattened[option], _.extend({}, this.attributes));\n            }\n            if(_.isArray(option)){\n              return _.reduce(option, function(memo, attr) {\n                return memo && !validateAttr(this, attr, flattened[attr], _.extend({}, this.attributes));\n              }, true, this);\n            }\n            if(option === true) {\n              this.validate();\n            }\n            return this.validation ? this._isValid : true;\n          },\n  \n          // This is called by Backbone when it needs to perform validation.\n          // You can call it manually without any parameters to validate the\n          // entire model.\n          validate: function(attrs, setOptions){\n            var model = this,\n                validateAll = !attrs,\n                opt = _.extend({}, options, setOptions),\n                validatedAttrs = getValidatedAttrs(model),\n                allAttrs = _.extend({}, validatedAttrs, model.attributes, attrs),\n                changedAttrs = flatten(attrs || allAttrs),\n  \n                result = validateModel(model, allAttrs);\n  \n            model._isValid = result.isValid;\n  \n            // After validation is performed, loop through all validated attributes\n            // and call the valid callbacks so the view is updated.\n            _.each(validatedAttrs, function(val, attr){\n              var invalid = result.invalidAttrs.hasOwnProperty(attr);\n              if(!invalid){\n                opt.valid(view, attr, opt.selector);\n              }\n            });\n  \n            // After validation is performed, loop through all validated and changed attributes\n            // and call the invalid callback so the view is updated.\n            _.each(validatedAttrs, function(val, attr){\n              var invalid = result.invalidAttrs.hasOwnProperty(attr),\n                  changed = changedAttrs.hasOwnProperty(attr);\n  \n              if(invalid && (changed || validateAll)){\n                opt.invalid(view, attr, result.invalidAttrs[attr], opt.selector);\n              }\n            });\n  \n            // Trigger validated events.\n            // Need to defer this so the model is actually updated before\n            // the event is triggered.\n            _.defer(function() {\n              model.trigger('validated', model._isValid, model, result.invalidAttrs);\n              model.trigger('validated:' + (model._isValid ? 'valid' : 'invalid'), model, result.invalidAttrs);\n            });\n  \n            // Return any error messages to Backbone, unless the forceUpdate flag is set.\n            // Then we do not return anything and fools Backbone to believe the validation was\n            // a success. That way Backbone will update the model regardless.\n            if (!opt.forceUpdate && _.intersection(_.keys(result.invalidAttrs), _.keys(changedAttrs)).length > 0) {\n              return result.invalidAttrs;\n            }\n          }\n        };\n      };\n  \n      // Helper to mix in validation on a model\n      var bindModel = function(view, model, options) {\n        _.extend(model, mixin(view, options));\n      };\n  \n      // Removes the methods added to a model\n      var unbindModel = function(model) {\n        delete model.validate;\n        delete model.preValidate;\n        delete model.isValid;\n      };\n  \n      // Mix in validation on a model whenever a model is\n      // added to a collection\n      var collectionAdd = function(model) {\n        bindModel(this.view, model, this.options);\n      };\n  \n      // Remove validation from a model whenever a model is\n      // removed from a collection\n      var collectionRemove = function(model) {\n        unbindModel(model);\n      };\n  \n      // Returns the public methods on Backbone.Validation\n      return {\n  \n        // Current version of the library\n        version: '0.9.1',\n  \n        // Called to configure the default options\n        configure: function(options) {\n          _.extend(defaultOptions, options);\n        },\n  \n        // Hooks up validation on a view with a model\n        // or collection\n        bind: function(view, options) {\n          options = _.extend({}, defaultOptions, defaultCallbacks, options);\n  \n          var model = options.model || view.model,\n              collection = options.collection || view.collection;\n  \n          if(typeof model === 'undefined' && typeof collection === 'undefined'){\n            throw 'Before you execute the binding your view must have a model or a collection.\\n' +\n                  'See http://thedersen.com/projects/backbone-validation/#using-form-model-validation for more information.';\n          }\n  \n          if(model) {\n            bindModel(view, model, options);\n          }\n          else if(collection) {\n            collection.each(function(model){\n              bindModel(view, model, options);\n            });\n            collection.bind('add', collectionAdd, {view: view, options: options});\n            collection.bind('remove', collectionRemove);\n          }\n        },\n  \n        // Removes validation from a view with a model\n        // or collection\n        unbind: function(view, options) {\n          options = _.extend({}, options);\n          var model = options.model || view.model,\n              collection = options.collection || view.collection;\n  \n          if(model) {\n            unbindModel(model);\n          }\n          else if(collection) {\n            collection.each(function(model){\n              unbindModel(model);\n            });\n            collection.unbind('add', collectionAdd);\n            collection.unbind('remove', collectionRemove);\n          }\n        },\n  \n        // Used to extend the Backbone.Model.prototype\n        // with validation\n        mixin: mixin(null, defaultOptions)\n      };\n    }());\n  \n  \n    // Callbacks\n    // ---------\n  \n    var defaultCallbacks = Validation.callbacks = {\n  \n      // Gets called when a previously invalid field in the\n      // view becomes valid. Removes any error message.\n      // Should be overridden with custom functionality.\n      valid: function(view, attr, selector) {\n        view.$('[' + selector + '~=\"' + attr + '\"]')\n            .removeClass('invalid')\n            .removeAttr('data-error');\n      },\n  \n      // Gets called when a field in the view becomes invalid.\n      // Adds a error message.\n      // Should be overridden with custom functionality.\n      invalid: function(view, attr, error, selector) {\n        view.$('[' + selector + '~=\"' + attr + '\"]')\n            .addClass('invalid')\n            .attr('data-error', error);\n      }\n    };\n  \n  \n    // Patterns\n    // --------\n  \n    var defaultPatterns = Validation.patterns = {\n      // Matches any digit(s) (i.e. 0-9)\n      digits: /^\\d+$/,\n  \n      // Matches any number (e.g. 100.000)\n      number: /^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)(?:\\.\\d+)?$/,\n  \n      // Matches a valid email address (e.g. mail@example.com)\n      email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n  \n      // Mathes any valid url (e.g. http://www.xample.com)\n      url: /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i\n    };\n  \n  \n    // Error messages\n    // --------------\n  \n    // Error message for the build in validators.\n    // {x} gets swapped out with arguments form the validator.\n    var defaultMessages = Validation.messages = {\n      required: '{0} is required',\n      acceptance: '{0} must be accepted',\n      min: '{0} must be greater than or equal to {1}',\n      max: '{0} must be less than or equal to {1}',\n      range: '{0} must be between {1} and {2}',\n      length: '{0} must be {1} characters',\n      minLength: '{0} must be at least {1} characters',\n      maxLength: '{0} must be at most {1} characters',\n      rangeLength: '{0} must be between {1} and {2} characters',\n      oneOf: '{0} must be one of: {1}',\n      equalTo: '{0} must be the same as {1}',\n      digits: '{0} must only contain digits',\n      number: '{0} must be a number',\n      email: '{0} must be a valid email',\n      url: '{0} must be a valid url',\n      inlinePattern: '{0} is invalid'\n    };\n  \n    // Label formatters\n    // ----------------\n  \n    // Label formatters are used to convert the attribute name\n    // to a more human friendly label when using the built in\n    // error messages.\n    // Configure which one to use with a call to\n    //\n    //     Backbone.Validation.configure({\n    //       labelFormatter: 'label'\n    //     });\n    var defaultLabelFormatters = Validation.labelFormatters = {\n  \n      // Returns the attribute name with applying any formatting\n      none: function(attrName) {\n        return attrName;\n      },\n  \n      // Converts attributeName or attribute_name to Attribute name\n      sentenceCase: function(attrName) {\n        return attrName.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function(match, index) {\n          return index === 0 ? match.toUpperCase() : ' ' + match.toLowerCase();\n        }).replace(/_/g, ' ');\n      },\n  \n      // Looks for a label configured on the model and returns it\n      //\n      //      var Model = Backbone.Model.extend({\n      //        validation: {\n      //          someAttribute: {\n      //            required: true\n      //          }\n      //        },\n      //\n      //        labels: {\n      //          someAttribute: 'Custom label'\n      //        }\n      //      });\n      label: function(attrName, model) {\n        return (model.labels && model.labels[attrName]) || defaultLabelFormatters.sentenceCase(attrName, model);\n      }\n    };\n  \n  \n    // Built in validators\n    // -------------------\n  \n    var defaultValidators = Validation.validators = (function(){\n      // Use native trim when defined\n      var trim = String.prototype.trim ?\n        function(text) {\n          return text === null ? '' : String.prototype.trim.call(text);\n        } :\n        function(text) {\n          var trimLeft = /^\\s+/,\n              trimRight = /\\s+$/;\n  \n          return text === null ? '' : text.toString().replace(trimLeft, '').replace(trimRight, '');\n        };\n  \n      // Determines whether or not a value is a number\n      var isNumber = function(value){\n        return _.isNumber(value) || (_.isString(value) && value.match(defaultPatterns.number));\n      };\n  \n      // Determines whether or not a value is empty\n      var hasValue = function(value) {\n        return !(_.isNull(value) || _.isUndefined(value) || (_.isString(value) && trim(value) === '') || (_.isArray(value) && _.isEmpty(value)));\n      };\n  \n      return {\n        // Function validator\n        // Lets you implement a custom function used for validation\n        fn: function(value, attr, fn, model, computed) {\n          if(_.isString(fn)){\n            fn = model[fn];\n          }\n          return fn.call(model, value, attr, computed);\n        },\n  \n        // Required validator\n        // Validates if the attribute is required or not\n        // This can be specified as either a boolean value or a function that returns a boolean value\n        required: function(value, attr, required, model, computed) {\n          var isRequired = _.isFunction(required) ? required.call(model, value, attr, computed) : required;\n          if(!isRequired && !hasValue(value)) {\n            return false; // overrides all other validators\n          }\n          if (isRequired && !hasValue(value)) {\n            return this.format(defaultMessages.required, this.formatLabel(attr, model));\n          }\n        },\n  \n        // Acceptance validator\n        // Validates that something has to be accepted, e.g. terms of use\n        // `true` or 'true' are valid\n        acceptance: function(value, attr, accept, model) {\n          if(value !== 'true' && (!_.isBoolean(value) || value === false)) {\n            return this.format(defaultMessages.acceptance, this.formatLabel(attr, model));\n          }\n        },\n  \n        // Min validator\n        // Validates that the value has to be a number and equal to or greater than\n        // the min value specified\n        min: function(value, attr, minValue, model) {\n          if (!isNumber(value) || value < minValue) {\n            return this.format(defaultMessages.min, this.formatLabel(attr, model), minValue);\n          }\n        },\n  \n        // Max validator\n        // Validates that the value has to be a number and equal to or less than\n        // the max value specified\n        max: function(value, attr, maxValue, model) {\n          if (!isNumber(value) || value > maxValue) {\n            return this.format(defaultMessages.max, this.formatLabel(attr, model), maxValue);\n          }\n        },\n  \n        // Range validator\n        // Validates that the value has to be a number and equal to or between\n        // the two numbers specified\n        range: function(value, attr, range, model) {\n          if(!isNumber(value) || value < range[0] || value > range[1]) {\n            return this.format(defaultMessages.range, this.formatLabel(attr, model), range[0], range[1]);\n          }\n        },\n  \n        // Length validator\n        // Validates that the value has to be a string with length equal to\n        // the length value specified\n        length: function(value, attr, length, model) {\n          if (!_.isString(value) || value.length !== length) {\n            return this.format(defaultMessages.length, this.formatLabel(attr, model), length);\n          }\n        },\n  \n        // Min length validator\n        // Validates that the value has to be a string with length equal to or greater than\n        // the min length value specified\n        minLength: function(value, attr, minLength, model) {\n          if (!_.isString(value) || value.length < minLength) {\n            return this.format(defaultMessages.minLength, this.formatLabel(attr, model), minLength);\n          }\n        },\n  \n        // Max length validator\n        // Validates that the value has to be a string with length equal to or less than\n        // the max length value specified\n        maxLength: function(value, attr, maxLength, model) {\n          if (!_.isString(value) || value.length > maxLength) {\n            return this.format(defaultMessages.maxLength, this.formatLabel(attr, model), maxLength);\n          }\n        },\n  \n        // Range length validator\n        // Validates that the value has to be a string and equal to or between\n        // the two numbers specified\n        rangeLength: function(value, attr, range, model) {\n          if (!_.isString(value) || value.length < range[0] || value.length > range[1]) {\n            return this.format(defaultMessages.rangeLength, this.formatLabel(attr, model), range[0], range[1]);\n          }\n        },\n  \n        // One of validator\n        // Validates that the value has to be equal to one of the elements in\n        // the specified array. Case sensitive matching\n        oneOf: function(value, attr, values, model) {\n          if(!_.include(values, value)){\n            return this.format(defaultMessages.oneOf, this.formatLabel(attr, model), values.join(', '));\n          }\n        },\n  \n        // Equal to validator\n        // Validates that the value has to be equal to the value of the attribute\n        // with the name specified\n        equalTo: function(value, attr, equalTo, model, computed) {\n          if(value !== computed[equalTo]) {\n            return this.format(defaultMessages.equalTo, this.formatLabel(attr, model), this.formatLabel(equalTo, model));\n          }\n        },\n  \n        // Pattern validator\n        // Validates that the value has to match the pattern specified.\n        // Can be a regular expression or the name of one of the built in patterns\n        pattern: function(value, attr, pattern, model) {\n          if (!hasValue(value) || !value.toString().match(defaultPatterns[pattern] || pattern)) {\n            return this.format(defaultMessages[pattern] || defaultMessages.inlinePattern, this.formatLabel(attr, model), pattern);\n          }\n        }\n      };\n    }());\n  \n    // Set the correct context for all validators\n    // when used from within a method validator\n    _.each(defaultValidators, function(validator, key){\n      defaultValidators[key] = _.bind(defaultValidators[key], _.extend({}, formatFunctions, defaultValidators));\n    });\n  \n    return Validation;\n  }(_));\n  return Backbone.Validation;\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvYmFja2JvbmUtdmFsaWRhdGlvbi1hbWQuanM/MTA1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckYsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixtREFBbUQsNkJBQTZCO0FBQ2hGO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixJQUFJLE9BQU8sRUFBRTs7QUFFekM7QUFDQSxtREFBbUQsR0FBRyxtRkFBbUYsR0FBRzs7QUFFNUk7QUFDQSx5R0FBeUcsRUFBRSxrQkFBa0Isa3JCQUFrckIsRUFBRSxrQkFBa0Isb0ZBQW9GLEVBQUUsa0JBQWtCLDJGQUEyRixFQUFFLGtCQUFrQiw4R0FBOEcsRUFBRSxrQkFBa0I7QUFDNXBDOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxFQUFFO0FBQ1Y7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQixvQkFBb0IsRUFBRTtBQUN0QixhQUFhLEVBQUUsbUNBQW1DLEVBQUU7QUFDcEQsYUFBYSxFQUFFLGdDQUFnQyxFQUFFO0FBQ2pELGVBQWUsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLEVBQUU7QUFDN0MsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFO0FBQzlCLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFO0FBQzFDLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFO0FBQ3pDLHFCQUFxQixFQUFFLGtCQUFrQixFQUFFLE1BQU0sRUFBRTtBQUNuRCxlQUFlLEVBQUUsa0JBQWtCLEVBQUU7QUFDckMsaUJBQWlCLEVBQUUsc0JBQXNCLEVBQUU7QUFDM0MsZ0JBQWdCLEVBQUU7QUFDbEIsZ0JBQWdCLEVBQUU7QUFDbEIsZUFBZSxFQUFFO0FBQ2pCLGFBQWEsRUFBRTtBQUNmLHVCQUF1QixFQUFFO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekUsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMiLCJmaWxlIjoiY29udHJpYi9iYWNrYm9uZS12YWxpZGF0aW9uLWFtZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEJhY2tib25lLlZhbGlkYXRpb24gdjAuOS4xXG4vL1xuLy8gQ29weXJpZ2h0IChjKSAyMDExLTIwMTQgVGhvbWFzIFBlZGVyc2VuXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZVxuLy9cbi8vIERvY3VtZW50YXRpb24gYW5kIGZ1bGwgbGljZW5zZSBhdmFpbGFibGUgYXQ6XG4vLyBodHRwOi8vdGhlZGVyc2VuLmNvbS9wcm9qZWN0cy9iYWNrYm9uZS12YWxpZGF0aW9uXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdiYWNrYm9uZScpLCByZXF1aXJlKCd1bmRlcnNjb3JlJykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2JhY2tib25lJywgJ3VuZGVyc2NvcmUnXSwgZmFjdG9yeSk7XG4gIH1cbn0oZnVuY3Rpb24gKEJhY2tib25lLCBfKSB7XG4gIEJhY2tib25lLlZhbGlkYXRpb24gPSAoZnVuY3Rpb24oXyl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICBcbiAgICAvLyBEZWZhdWx0IG9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZm9yY2VVcGRhdGU6IGZhbHNlLFxuICAgICAgc2VsZWN0b3I6ICduYW1lJyxcbiAgICAgIGxhYmVsRm9ybWF0dGVyOiAnc2VudGVuY2VDYXNlJyxcbiAgICAgIHZhbGlkOiBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICBpbnZhbGlkOiBGdW5jdGlvbi5wcm90b3R5cGVcbiAgICB9O1xuICBcbiAgXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgLy8gRm9ybWF0dGluZyBmdW5jdGlvbnMgdXNlZCBmb3IgZm9ybWF0dGluZyBlcnJvciBtZXNzYWdlc1xuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7XG4gICAgICAvLyBVc2VzIHRoZSBjb25maWd1cmVkIGxhYmVsIGZvcm1hdHRlciB0byBmb3JtYXQgdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAvLyB0byBtYWtlIGl0IG1vcmUgcmVhZGFibGUgZm9yIHRoZSB1c2VyXG4gICAgICBmb3JtYXRMYWJlbDogZnVuY3Rpb24oYXR0ck5hbWUsIG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TGFiZWxGb3JtYXR0ZXJzW2RlZmF1bHRPcHRpb25zLmxhYmVsRm9ybWF0dGVyXShhdHRyTmFtZSwgbW9kZWwpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBSZXBsYWNlcyBudW1tZXJpYyBwbGFjZWhvbGRlcnMgbGlrZSB7MH0gaW4gYSBzdHJpbmcgd2l0aCBhcmd1bWVudHNcbiAgICAgIC8vIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cbiAgICAgIGZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHRleHQgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xceyhcXGQrKVxcfS9nLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmdzW251bWJlcl0gIT09ICd1bmRlZmluZWQnID8gYXJnc1tudW1iZXJdIDogbWF0Y2g7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIC8vIEZsYXR0ZW5zIGFuIG9iamVjdFxuICAgIC8vIGVnOlxuICAgIC8vXG4gICAgLy8gICAgIHZhciBvID0ge1xuICAgIC8vICAgICAgIGFkZHJlc3M6IHtcbiAgICAvLyAgICAgICAgIHN0cmVldDogJ1N0cmVldCcsXG4gICAgLy8gICAgICAgICB6aXA6IDEyMzRcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIH07XG4gICAgLy9cbiAgICAvLyBiZWNvbWVzOlxuICAgIC8vXG4gICAgLy8gICAgIHZhciBvID0ge1xuICAgIC8vICAgICAgICdhZGRyZXNzLnN0cmVldCc6ICdTdHJlZXQnLFxuICAgIC8vICAgICAgICdhZGRyZXNzLnppcCc6IDEyMzRcbiAgICAvLyAgICAgfTtcbiAgICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uIChvYmosIGludG8sIHByZWZpeCkge1xuICAgICAgaW50byA9IGludG8gfHwge307XG4gICAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG4gIFxuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICEoXG4gICAgICAgICAgICB2YWwgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgdmFsIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgdmFsIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICB2YWwgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCB8fFxuICAgICAgICAgICAgdmFsIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZsYXR0ZW4odmFsLCBpbnRvLCBwcmVmaXggKyBrZXkgKyAnLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGludG9bcHJlZml4ICsga2V5XSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICBcbiAgICAgIHJldHVybiBpbnRvO1xuICAgIH07XG4gIFxuICAgIC8vIFZhbGlkYXRpb25cbiAgICAvLyAtLS0tLS0tLS0tXG4gIFxuICAgIHZhciBWYWxpZGF0aW9uID0gKGZ1bmN0aW9uKCl7XG4gIFxuICAgICAgLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1bmRlZmluZWQgcHJvcGVydGllcyBmb3IgYWxsXG4gICAgICAvLyBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCB0aGF0IGhhcyBkZWZpbmVkIG9uZSBvciBtb3JlXG4gICAgICAvLyB2YWxpZGF0aW9uIHJ1bGVzLlxuICAgICAgdmFyIGdldFZhbGlkYXRlZEF0dHJzID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIF8ucmVkdWNlKF8ua2V5cyhfLnJlc3VsdChtb2RlbCwgJ3ZhbGlkYXRpb24nKSB8fCB7fSksIGZ1bmN0aW9uKG1lbW8sIGtleSkge1xuICAgICAgICAgIG1lbW9ba2V5XSA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfSwge30pO1xuICAgICAgfTtcbiAgXG4gICAgICAvLyBMb29rcyBvbiB0aGUgbW9kZWwgZm9yIHZhbGlkYXRpb25zIGZvciBhIHNwZWNpZmllZFxuICAgICAgLy8gYXR0cmlidXRlLiBSZXR1cm5zIGFuIGFycmF5IG9mIGFueSB2YWxpZGF0b3JzIGRlZmluZWQsXG4gICAgICAvLyBvciBhbiBlbXB0eSBhcnJheSBpZiBub25lIGlzIGRlZmluZWQuXG4gICAgICB2YXIgZ2V0VmFsaWRhdG9ycyA9IGZ1bmN0aW9uKG1vZGVsLCBhdHRyKSB7XG4gICAgICAgIHZhciBhdHRyVmFsaWRhdGlvblNldCA9IG1vZGVsLnZhbGlkYXRpb24gPyBfLnJlc3VsdChtb2RlbCwgJ3ZhbGlkYXRpb24nKVthdHRyXSB8fCB7fSA6IHt9O1xuICBcbiAgICAgICAgLy8gSWYgdGhlIHZhbGlkYXRvciBpcyBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLCB3cmFwIGl0IGluIGEgZnVuY3Rpb24gdmFsaWRhdG9yXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oYXR0clZhbGlkYXRpb25TZXQpIHx8IF8uaXNTdHJpbmcoYXR0clZhbGlkYXRpb25TZXQpKSB7XG4gICAgICAgICAgYXR0clZhbGlkYXRpb25TZXQgPSB7XG4gICAgICAgICAgICBmbjogYXR0clZhbGlkYXRpb25TZXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBTdGljayB0aGUgdmFsaWRhdG9yIG9iamVjdCBpbnRvIGFuIGFycmF5XG4gICAgICAgIGlmKCFfLmlzQXJyYXkoYXR0clZhbGlkYXRpb25TZXQpKSB7XG4gICAgICAgICAgYXR0clZhbGlkYXRpb25TZXQgPSBbYXR0clZhbGlkYXRpb25TZXRdO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBSZWR1Y2VzIHRoZSBhcnJheSBvZiB2YWxpZGF0b3JzIGludG8gYSBuZXcgYXJyYXkgd2l0aCBvYmplY3RzXG4gICAgICAgIC8vIHdpdGggYSB2YWxpZGF0aW9uIG1ldGhvZCB0byBjYWxsLCB0aGUgdmFsdWUgdG8gdmFsaWRhdGUgYWdhaW5zdFxuICAgICAgICAvLyBhbmQgdGhlIHNwZWNpZmllZCBlcnJvciBtZXNzYWdlLCBpZiBhbnlcbiAgICAgICAgcmV0dXJuIF8ucmVkdWNlKGF0dHJWYWxpZGF0aW9uU2V0LCBmdW5jdGlvbihtZW1vLCBhdHRyVmFsaWRhdGlvbikge1xuICAgICAgICAgIF8uZWFjaChfLndpdGhvdXQoXy5rZXlzKGF0dHJWYWxpZGF0aW9uKSwgJ21zZycpLCBmdW5jdGlvbih2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIG1lbW8ucHVzaCh7XG4gICAgICAgICAgICAgIGZuOiBkZWZhdWx0VmFsaWRhdG9yc1t2YWxpZGF0b3JdLFxuICAgICAgICAgICAgICB2YWw6IGF0dHJWYWxpZGF0aW9uW3ZhbGlkYXRvcl0sXG4gICAgICAgICAgICAgIG1zZzogYXR0clZhbGlkYXRpb24ubXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfSwgW10pO1xuICAgICAgfTtcbiAgXG4gICAgICAvLyBWYWxpZGF0ZXMgYW4gYXR0cmlidXRlIGFnYWluc3QgYWxsIHZhbGlkYXRvcnMgZGVmaW5lZFxuICAgICAgLy8gZm9yIHRoYXQgYXR0cmlidXRlLiBJZiBvbmUgb3IgbW9yZSBlcnJvcnMgYXJlIGZvdW5kLFxuICAgICAgLy8gdGhlIGZpcnN0IGVycm9yIG1lc3NhZ2UgaXMgcmV0dXJuZWQuXG4gICAgICAvLyBJZiB0aGUgYXR0cmlidXRlIGlzIHZhbGlkLCBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gICAgICB2YXIgdmFsaWRhdGVBdHRyID0gZnVuY3Rpb24obW9kZWwsIGF0dHIsIHZhbHVlLCBjb21wdXRlZCkge1xuICAgICAgICAvLyBSZWR1Y2VzIHRoZSBhcnJheSBvZiB2YWxpZGF0b3JzIHRvIGFuIGVycm9yIG1lc3NhZ2UgYnlcbiAgICAgICAgLy8gYXBwbHlpbmcgYWxsIHRoZSB2YWxpZGF0b3JzIGFuZCByZXR1cm5pbmcgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgIC8vIG1lc3NhZ2UsIGlmIGFueS5cbiAgICAgICAgcmV0dXJuIF8ucmVkdWNlKGdldFZhbGlkYXRvcnMobW9kZWwsIGF0dHIpLCBmdW5jdGlvbihtZW1vLCB2YWxpZGF0b3Ipe1xuICAgICAgICAgIC8vIFBhc3MgdGhlIGZvcm1hdCBmdW5jdGlvbnMgcGx1cyB0aGUgZGVmYXVsdFxuICAgICAgICAgIC8vIHZhbGlkYXRvcnMgYXMgdGhlIGNvbnRleHQgdG8gdGhlIHZhbGlkYXRvclxuICAgICAgICAgIHZhciBjdHggPSBfLmV4dGVuZCh7fSwgZm9ybWF0RnVuY3Rpb25zLCBkZWZhdWx0VmFsaWRhdG9ycyksXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbGlkYXRvci5mbi5jYWxsKGN0eCwgdmFsdWUsIGF0dHIsIHZhbGlkYXRvci52YWwsIG1vZGVsLCBjb21wdXRlZCk7XG4gIFxuICAgICAgICAgIGlmKHJlc3VsdCA9PT0gZmFsc2UgfHwgbWVtbyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCAmJiAhbWVtbykge1xuICAgICAgICAgICAgcmV0dXJuIF8ucmVzdWx0KHZhbGlkYXRvciwgJ21zZycpIHx8IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sICcnKTtcbiAgICAgIH07XG4gIFxuICAgICAgLy8gTG9vcHMgdGhyb3VnaCB0aGUgbW9kZWwncyBhdHRyaWJ1dGVzIGFuZCB2YWxpZGF0ZXMgdGhlbSBhbGwuXG4gICAgICAvLyBSZXR1cm5zIGFuZCBvYmplY3QgY29udGFpbmluZyBuYW1lcyBvZiBpbnZhbGlkIGF0dHJpYnV0ZXNcbiAgICAgIC8vIGFzIHdlbGwgYXMgZXJyb3IgbWVzc2FnZXMuXG4gICAgICB2YXIgdmFsaWRhdGVNb2RlbCA9IGZ1bmN0aW9uKG1vZGVsLCBhdHRycykge1xuICAgICAgICB2YXIgZXJyb3IsXG4gICAgICAgICAgICBpbnZhbGlkQXR0cnMgPSB7fSxcbiAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBfLmNsb25lKGF0dHJzKSxcbiAgICAgICAgICAgIGZsYXR0ZW5lZCA9IGZsYXR0ZW4oYXR0cnMpO1xuICBcbiAgICAgICAgXy5lYWNoKGZsYXR0ZW5lZCwgZnVuY3Rpb24odmFsLCBhdHRyKSB7XG4gICAgICAgICAgZXJyb3IgPSB2YWxpZGF0ZUF0dHIobW9kZWwsIGF0dHIsIHZhbCwgY29tcHV0ZWQpO1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaW52YWxpZEF0dHJzW2F0dHJdID0gZXJyb3I7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW52YWxpZEF0dHJzOiBpbnZhbGlkQXR0cnMsXG4gICAgICAgICAgaXNWYWxpZDogaXNWYWxpZFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgXG4gICAgICAvLyBDb250YWlucyB0aGUgbWV0aG9kcyB0aGF0IGFyZSBtaXhlZCBpbiBvbiB0aGUgbW9kZWwgd2hlbiBiaW5kaW5nXG4gICAgICB2YXIgbWl4aW4gPSBmdW5jdGlvbih2aWV3LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gIFxuICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUsIG9yIGEgaGFzaCBvZiB2YWx1ZXNcbiAgICAgICAgICAvLyBwYXNzZXMgdmFsaWRhdGlvbiB3aXRob3V0IHVwZGF0aW5nIHRoZSBtb2RlbFxuICAgICAgICAgIHByZVZhbGlkYXRlOiBmdW5jdGlvbihhdHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAgICAgIGVycm9yO1xuICBcbiAgICAgICAgICAgIGlmKF8uaXNPYmplY3QoYXR0cikpe1xuICAgICAgICAgICAgICBfLmVhY2goYXR0ciwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gc2VsZi5wcmVWYWxpZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZihlcnJvcil7XG4gICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgICAgICByZXR1cm4gXy5pc0VtcHR5KHJlc3VsdCkgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlQXR0cih0aGlzLCBhdHRyLCB2YWx1ZSwgXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gIFxuICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBhbiBhdHRyaWJ1dGUsIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgb3IgdGhlXG4gICAgICAgICAgLy8gZW50aXJlIG1vZGVsIGlzIHZhbGlkLiBQYXNzaW5nIHRydWUgd2lsbCBmb3JjZSBhIHZhbGlkYXRpb25cbiAgICAgICAgICAvLyBvZiB0aGUgbW9kZWwuXG4gICAgICAgICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZmxhdHRlbmVkID0gZmxhdHRlbih0aGlzLmF0dHJpYnV0ZXMpO1xuICBcbiAgICAgICAgICAgIGlmKF8uaXNTdHJpbmcob3B0aW9uKSl7XG4gICAgICAgICAgICAgIHJldHVybiAhdmFsaWRhdGVBdHRyKHRoaXMsIG9wdGlvbiwgZmxhdHRlbmVkW29wdGlvbl0sIF8uZXh0ZW5kKHt9LCB0aGlzLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKF8uaXNBcnJheShvcHRpb24pKXtcbiAgICAgICAgICAgICAgcmV0dXJuIF8ucmVkdWNlKG9wdGlvbiwgZnVuY3Rpb24obWVtbywgYXR0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1vICYmICF2YWxpZGF0ZUF0dHIodGhpcywgYXR0ciwgZmxhdHRlbmVkW2F0dHJdLCBfLmV4dGVuZCh7fSwgdGhpcy5hdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICAgIH0sIHRydWUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob3B0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRpb24gPyB0aGlzLl9pc1ZhbGlkIDogdHJ1ZTtcbiAgICAgICAgICB9LFxuICBcbiAgICAgICAgICAvLyBUaGlzIGlzIGNhbGxlZCBieSBCYWNrYm9uZSB3aGVuIGl0IG5lZWRzIHRvIHBlcmZvcm0gdmFsaWRhdGlvbi5cbiAgICAgICAgICAvLyBZb3UgY2FuIGNhbGwgaXQgbWFudWFsbHkgd2l0aG91dCBhbnkgcGFyYW1ldGVycyB0byB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAvLyBlbnRpcmUgbW9kZWwuXG4gICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBzZXRPcHRpb25zKXtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVBbGwgPSAhYXR0cnMsXG4gICAgICAgICAgICAgICAgb3B0ID0gXy5leHRlbmQoe30sIG9wdGlvbnMsIHNldE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRlZEF0dHJzID0gZ2V0VmFsaWRhdGVkQXR0cnMobW9kZWwpLFxuICAgICAgICAgICAgICAgIGFsbEF0dHJzID0gXy5leHRlbmQoe30sIHZhbGlkYXRlZEF0dHJzLCBtb2RlbC5hdHRyaWJ1dGVzLCBhdHRycyksXG4gICAgICAgICAgICAgICAgY2hhbmdlZEF0dHJzID0gZmxhdHRlbihhdHRycyB8fCBhbGxBdHRycyksXG4gIFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbGlkYXRlTW9kZWwobW9kZWwsIGFsbEF0dHJzKTtcbiAgXG4gICAgICAgICAgICBtb2RlbC5faXNWYWxpZCA9IHJlc3VsdC5pc1ZhbGlkO1xuICBcbiAgICAgICAgICAgIC8vIEFmdGVyIHZhbGlkYXRpb24gaXMgcGVyZm9ybWVkLCBsb29wIHRocm91Z2ggYWxsIHZhbGlkYXRlZCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBhbmQgY2FsbCB0aGUgdmFsaWQgY2FsbGJhY2tzIHNvIHRoZSB2aWV3IGlzIHVwZGF0ZWQuXG4gICAgICAgICAgICBfLmVhY2godmFsaWRhdGVkQXR0cnMsIGZ1bmN0aW9uKHZhbCwgYXR0cil7XG4gICAgICAgICAgICAgIHZhciBpbnZhbGlkID0gcmVzdWx0LmludmFsaWRBdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKTtcbiAgICAgICAgICAgICAgaWYoIWludmFsaWQpe1xuICAgICAgICAgICAgICAgIG9wdC52YWxpZCh2aWV3LCBhdHRyLCBvcHQuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgICAvLyBBZnRlciB2YWxpZGF0aW9uIGlzIHBlcmZvcm1lZCwgbG9vcCB0aHJvdWdoIGFsbCB2YWxpZGF0ZWQgYW5kIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gYW5kIGNhbGwgdGhlIGludmFsaWQgY2FsbGJhY2sgc28gdGhlIHZpZXcgaXMgdXBkYXRlZC5cbiAgICAgICAgICAgIF8uZWFjaCh2YWxpZGF0ZWRBdHRycywgZnVuY3Rpb24odmFsLCBhdHRyKXtcbiAgICAgICAgICAgICAgdmFyIGludmFsaWQgPSByZXN1bHQuaW52YWxpZEF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpLFxuICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWRBdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKTtcbiAgXG4gICAgICAgICAgICAgIGlmKGludmFsaWQgJiYgKGNoYW5nZWQgfHwgdmFsaWRhdGVBbGwpKXtcbiAgICAgICAgICAgICAgICBvcHQuaW52YWxpZCh2aWV3LCBhdHRyLCByZXN1bHQuaW52YWxpZEF0dHJzW2F0dHJdLCBvcHQuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHZhbGlkYXRlZCBldmVudHMuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGRlZmVyIHRoaXMgc28gdGhlIG1vZGVsIGlzIGFjdHVhbGx5IHVwZGF0ZWQgYmVmb3JlXG4gICAgICAgICAgICAvLyB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgXy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcigndmFsaWRhdGVkJywgbW9kZWwuX2lzVmFsaWQsIG1vZGVsLCByZXN1bHQuaW52YWxpZEF0dHJzKTtcbiAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcigndmFsaWRhdGVkOicgKyAobW9kZWwuX2lzVmFsaWQgPyAndmFsaWQnIDogJ2ludmFsaWQnKSwgbW9kZWwsIHJlc3VsdC5pbnZhbGlkQXR0cnMpO1xuICAgICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgICAgLy8gUmV0dXJuIGFueSBlcnJvciBtZXNzYWdlcyB0byBCYWNrYm9uZSwgdW5sZXNzIHRoZSBmb3JjZVVwZGF0ZSBmbGFnIGlzIHNldC5cbiAgICAgICAgICAgIC8vIFRoZW4gd2UgZG8gbm90IHJldHVybiBhbnl0aGluZyBhbmQgZm9vbHMgQmFja2JvbmUgdG8gYmVsaWV2ZSB0aGUgdmFsaWRhdGlvbiB3YXNcbiAgICAgICAgICAgIC8vIGEgc3VjY2Vzcy4gVGhhdCB3YXkgQmFja2JvbmUgd2lsbCB1cGRhdGUgdGhlIG1vZGVsIHJlZ2FyZGxlc3MuXG4gICAgICAgICAgICBpZiAoIW9wdC5mb3JjZVVwZGF0ZSAmJiBfLmludGVyc2VjdGlvbihfLmtleXMocmVzdWx0LmludmFsaWRBdHRycyksIF8ua2V5cyhjaGFuZ2VkQXR0cnMpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQuaW52YWxpZEF0dHJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gIFxuICAgICAgLy8gSGVscGVyIHRvIG1peCBpbiB2YWxpZGF0aW9uIG9uIGEgbW9kZWxcbiAgICAgIHZhciBiaW5kTW9kZWwgPSBmdW5jdGlvbih2aWV3LCBtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICBfLmV4dGVuZChtb2RlbCwgbWl4aW4odmlldywgb3B0aW9ucykpO1xuICAgICAgfTtcbiAgXG4gICAgICAvLyBSZW1vdmVzIHRoZSBtZXRob2RzIGFkZGVkIHRvIGEgbW9kZWxcbiAgICAgIHZhciB1bmJpbmRNb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIGRlbGV0ZSBtb2RlbC52YWxpZGF0ZTtcbiAgICAgICAgZGVsZXRlIG1vZGVsLnByZVZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgbW9kZWwuaXNWYWxpZDtcbiAgICAgIH07XG4gIFxuICAgICAgLy8gTWl4IGluIHZhbGlkYXRpb24gb24gYSBtb2RlbCB3aGVuZXZlciBhIG1vZGVsIGlzXG4gICAgICAvLyBhZGRlZCB0byBhIGNvbGxlY3Rpb25cbiAgICAgIHZhciBjb2xsZWN0aW9uQWRkID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgYmluZE1vZGVsKHRoaXMudmlldywgbW9kZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9O1xuICBcbiAgICAgIC8vIFJlbW92ZSB2YWxpZGF0aW9uIGZyb20gYSBtb2RlbCB3aGVuZXZlciBhIG1vZGVsIGlzXG4gICAgICAvLyByZW1vdmVkIGZyb20gYSBjb2xsZWN0aW9uXG4gICAgICB2YXIgY29sbGVjdGlvblJlbW92ZSA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHVuYmluZE1vZGVsKG1vZGVsKTtcbiAgICAgIH07XG4gIFxuICAgICAgLy8gUmV0dXJucyB0aGUgcHVibGljIG1ldGhvZHMgb24gQmFja2JvbmUuVmFsaWRhdGlvblxuICAgICAgcmV0dXJuIHtcbiAgXG4gICAgICAgIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeVxuICAgICAgICB2ZXJzaW9uOiAnMC45LjEnLFxuICBcbiAgICAgICAgLy8gQ2FsbGVkIHRvIGNvbmZpZ3VyZSB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIF8uZXh0ZW5kKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIEhvb2tzIHVwIHZhbGlkYXRpb24gb24gYSB2aWV3IHdpdGggYSBtb2RlbFxuICAgICAgICAvLyBvciBjb2xsZWN0aW9uXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKHZpZXcsIG9wdGlvbnMpIHtcbiAgICAgICAgICBvcHRpb25zID0gXy5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBkZWZhdWx0Q2FsbGJhY2tzLCBvcHRpb25zKTtcbiAgXG4gICAgICAgICAgdmFyIG1vZGVsID0gb3B0aW9ucy5tb2RlbCB8fCB2aWV3Lm1vZGVsLFxuICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uIHx8IHZpZXcuY29sbGVjdGlvbjtcbiAgXG4gICAgICAgICAgaWYodHlwZW9mIG1vZGVsID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29sbGVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgdGhyb3cgJ0JlZm9yZSB5b3UgZXhlY3V0ZSB0aGUgYmluZGluZyB5b3VyIHZpZXcgbXVzdCBoYXZlIGEgbW9kZWwgb3IgYSBjb2xsZWN0aW9uLlxcbicgK1xuICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vdGhlZGVyc2VuLmNvbS9wcm9qZWN0cy9iYWNrYm9uZS12YWxpZGF0aW9uLyN1c2luZy1mb3JtLW1vZGVsLXZhbGlkYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmKG1vZGVsKSB7XG4gICAgICAgICAgICBiaW5kTW9kZWwodmlldywgbW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbihtb2RlbCl7XG4gICAgICAgICAgICAgIGJpbmRNb2RlbCh2aWV3LCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uYmluZCgnYWRkJywgY29sbGVjdGlvbkFkZCwge3ZpZXc6IHZpZXcsIG9wdGlvbnM6IG9wdGlvbnN9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uYmluZCgncmVtb3ZlJywgY29sbGVjdGlvblJlbW92ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gUmVtb3ZlcyB2YWxpZGF0aW9uIGZyb20gYSB2aWV3IHdpdGggYSBtb2RlbFxuICAgICAgICAvLyBvciBjb2xsZWN0aW9uXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24odmlldywgb3B0aW9ucykge1xuICAgICAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG1vZGVsID0gb3B0aW9ucy5tb2RlbCB8fCB2aWV3Lm1vZGVsLFxuICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uIHx8IHZpZXcuY29sbGVjdGlvbjtcbiAgXG4gICAgICAgICAgaWYobW9kZWwpIHtcbiAgICAgICAgICAgIHVuYmluZE1vZGVsKG1vZGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZihjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24obW9kZWwpe1xuICAgICAgICAgICAgICB1bmJpbmRNb2RlbChtb2RlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24udW5iaW5kKCdhZGQnLCBjb2xsZWN0aW9uQWRkKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24udW5iaW5kKCdyZW1vdmUnLCBjb2xsZWN0aW9uUmVtb3ZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gIFxuICAgICAgICAvLyBVc2VkIHRvIGV4dGVuZCB0aGUgQmFja2JvbmUuTW9kZWwucHJvdG90eXBlXG4gICAgICAgIC8vIHdpdGggdmFsaWRhdGlvblxuICAgICAgICBtaXhpbjogbWl4aW4obnVsbCwgZGVmYXVsdE9wdGlvbnMpXG4gICAgICB9O1xuICAgIH0oKSk7XG4gIFxuICBcbiAgICAvLyBDYWxsYmFja3NcbiAgICAvLyAtLS0tLS0tLS1cbiAgXG4gICAgdmFyIGRlZmF1bHRDYWxsYmFja3MgPSBWYWxpZGF0aW9uLmNhbGxiYWNrcyA9IHtcbiAgXG4gICAgICAvLyBHZXRzIGNhbGxlZCB3aGVuIGEgcHJldmlvdXNseSBpbnZhbGlkIGZpZWxkIGluIHRoZVxuICAgICAgLy8gdmlldyBiZWNvbWVzIHZhbGlkLiBSZW1vdmVzIGFueSBlcnJvciBtZXNzYWdlLlxuICAgICAgLy8gU2hvdWxkIGJlIG92ZXJyaWRkZW4gd2l0aCBjdXN0b20gZnVuY3Rpb25hbGl0eS5cbiAgICAgIHZhbGlkOiBmdW5jdGlvbih2aWV3LCBhdHRyLCBzZWxlY3Rvcikge1xuICAgICAgICB2aWV3LiQoJ1snICsgc2VsZWN0b3IgKyAnfj1cIicgKyBhdHRyICsgJ1wiXScpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2ludmFsaWQnKVxuICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtZXJyb3InKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gR2V0cyBjYWxsZWQgd2hlbiBhIGZpZWxkIGluIHRoZSB2aWV3IGJlY29tZXMgaW52YWxpZC5cbiAgICAgIC8vIEFkZHMgYSBlcnJvciBtZXNzYWdlLlxuICAgICAgLy8gU2hvdWxkIGJlIG92ZXJyaWRkZW4gd2l0aCBjdXN0b20gZnVuY3Rpb25hbGl0eS5cbiAgICAgIGludmFsaWQ6IGZ1bmN0aW9uKHZpZXcsIGF0dHIsIGVycm9yLCBzZWxlY3Rvcikge1xuICAgICAgICB2aWV3LiQoJ1snICsgc2VsZWN0b3IgKyAnfj1cIicgKyBhdHRyICsgJ1wiXScpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2ludmFsaWQnKVxuICAgICAgICAgICAgLmF0dHIoJ2RhdGEtZXJyb3InLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgXG4gIFxuICAgIC8vIFBhdHRlcm5zXG4gICAgLy8gLS0tLS0tLS1cbiAgXG4gICAgdmFyIGRlZmF1bHRQYXR0ZXJucyA9IFZhbGlkYXRpb24ucGF0dGVybnMgPSB7XG4gICAgICAvLyBNYXRjaGVzIGFueSBkaWdpdChzKSAoaS5lLiAwLTkpXG4gICAgICBkaWdpdHM6IC9eXFxkKyQvLFxuICBcbiAgICAgIC8vIE1hdGNoZXMgYW55IG51bWJlciAoZS5nLiAxMDAuMDAwKVxuICAgICAgbnVtYmVyOiAvXi0/KD86XFxkK3xcXGR7MSwzfSg/OixcXGR7M30pKykoPzpcXC5cXGQrKT8kLyxcbiAgXG4gICAgICAvLyBNYXRjaGVzIGEgdmFsaWQgZW1haWwgYWRkcmVzcyAoZS5nLiBtYWlsQGV4YW1wbGUuY29tKVxuICAgICAgZW1haWw6IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaSxcbiAgXG4gICAgICAvLyBNYXRoZXMgYW55IHZhbGlkIHVybCAoZS5nLiBodHRwOi8vd3d3LnhhbXBsZS5jb20pXG4gICAgICB1cmw6IC9eKGh0dHBzP3xmdHApOlxcL1xcLygoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6KSpAKT8oKChcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSkpfCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLj8pKDpcXGQqKT8pKFxcLygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkrKFxcLygoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSopKik/KT8oXFw/KCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxbXFx1RTAwMC1cXHVGOEZGXXxcXC98XFw/KSopPyhcXCMoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFxcL3xcXD8pKik/JC9pXG4gICAgfTtcbiAgXG4gIFxuICAgIC8vIEVycm9yIG1lc3NhZ2VzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgLy8gRXJyb3IgbWVzc2FnZSBmb3IgdGhlIGJ1aWxkIGluIHZhbGlkYXRvcnMuXG4gICAgLy8ge3h9IGdldHMgc3dhcHBlZCBvdXQgd2l0aCBhcmd1bWVudHMgZm9ybSB0aGUgdmFsaWRhdG9yLlxuICAgIHZhciBkZWZhdWx0TWVzc2FnZXMgPSBWYWxpZGF0aW9uLm1lc3NhZ2VzID0ge1xuICAgICAgcmVxdWlyZWQ6ICd7MH0gaXMgcmVxdWlyZWQnLFxuICAgICAgYWNjZXB0YW5jZTogJ3swfSBtdXN0IGJlIGFjY2VwdGVkJyxcbiAgICAgIG1pbjogJ3swfSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7MX0nLFxuICAgICAgbWF4OiAnezB9IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHsxfScsXG4gICAgICByYW5nZTogJ3swfSBtdXN0IGJlIGJldHdlZW4gezF9IGFuZCB7Mn0nLFxuICAgICAgbGVuZ3RoOiAnezB9IG11c3QgYmUgezF9IGNoYXJhY3RlcnMnLFxuICAgICAgbWluTGVuZ3RoOiAnezB9IG11c3QgYmUgYXQgbGVhc3QgezF9IGNoYXJhY3RlcnMnLFxuICAgICAgbWF4TGVuZ3RoOiAnezB9IG11c3QgYmUgYXQgbW9zdCB7MX0gY2hhcmFjdGVycycsXG4gICAgICByYW5nZUxlbmd0aDogJ3swfSBtdXN0IGJlIGJldHdlZW4gezF9IGFuZCB7Mn0gY2hhcmFjdGVycycsXG4gICAgICBvbmVPZjogJ3swfSBtdXN0IGJlIG9uZSBvZjogezF9JyxcbiAgICAgIGVxdWFsVG86ICd7MH0gbXVzdCBiZSB0aGUgc2FtZSBhcyB7MX0nLFxuICAgICAgZGlnaXRzOiAnezB9IG11c3Qgb25seSBjb250YWluIGRpZ2l0cycsXG4gICAgICBudW1iZXI6ICd7MH0gbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICBlbWFpbDogJ3swfSBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxuICAgICAgdXJsOiAnezB9IG11c3QgYmUgYSB2YWxpZCB1cmwnLFxuICAgICAgaW5saW5lUGF0dGVybjogJ3swfSBpcyBpbnZhbGlkJ1xuICAgIH07XG4gIFxuICAgIC8vIExhYmVsIGZvcm1hdHRlcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIC8vIExhYmVsIGZvcm1hdHRlcnMgYXJlIHVzZWQgdG8gY29udmVydCB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAvLyB0byBhIG1vcmUgaHVtYW4gZnJpZW5kbHkgbGFiZWwgd2hlbiB1c2luZyB0aGUgYnVpbHQgaW5cbiAgICAvLyBlcnJvciBtZXNzYWdlcy5cbiAgICAvLyBDb25maWd1cmUgd2hpY2ggb25lIHRvIHVzZSB3aXRoIGEgY2FsbCB0b1xuICAgIC8vXG4gICAgLy8gICAgIEJhY2tib25lLlZhbGlkYXRpb24uY29uZmlndXJlKHtcbiAgICAvLyAgICAgICBsYWJlbEZvcm1hdHRlcjogJ2xhYmVsJ1xuICAgIC8vICAgICB9KTtcbiAgICB2YXIgZGVmYXVsdExhYmVsRm9ybWF0dGVycyA9IFZhbGlkYXRpb24ubGFiZWxGb3JtYXR0ZXJzID0ge1xuICBcbiAgICAgIC8vIFJldHVybnMgdGhlIGF0dHJpYnV0ZSBuYW1lIHdpdGggYXBwbHlpbmcgYW55IGZvcm1hdHRpbmdcbiAgICAgIG5vbmU6IGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG4gICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gQ29udmVydHMgYXR0cmlidXRlTmFtZSBvciBhdHRyaWJ1dGVfbmFtZSB0byBBdHRyaWJ1dGUgbmFtZVxuICAgICAgc2VudGVuY2VDYXNlOiBmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gYXR0ck5hbWUucmVwbGFjZSgvKD86Xlxcd3xbQS1aXXxcXGJcXHcpL2csIGZ1bmN0aW9uKG1hdGNoLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gMCA/IG1hdGNoLnRvVXBwZXJDYXNlKCkgOiAnICcgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KS5yZXBsYWNlKC9fL2csICcgJyk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIExvb2tzIGZvciBhIGxhYmVsIGNvbmZpZ3VyZWQgb24gdGhlIG1vZGVsIGFuZCByZXR1cm5zIGl0XG4gICAgICAvL1xuICAgICAgLy8gICAgICB2YXIgTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgICAgLy8gICAgICAgIHZhbGlkYXRpb246IHtcbiAgICAgIC8vICAgICAgICAgIHNvbWVBdHRyaWJ1dGU6IHtcbiAgICAgIC8vICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgIC8vICAgICAgICAgIH1cbiAgICAgIC8vICAgICAgICB9LFxuICAgICAgLy9cbiAgICAgIC8vICAgICAgICBsYWJlbHM6IHtcbiAgICAgIC8vICAgICAgICAgIHNvbWVBdHRyaWJ1dGU6ICdDdXN0b20gbGFiZWwnXG4gICAgICAvLyAgICAgICAgfVxuICAgICAgLy8gICAgICB9KTtcbiAgICAgIGxhYmVsOiBmdW5jdGlvbihhdHRyTmFtZSwgbW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlbC5sYWJlbHMgJiYgbW9kZWwubGFiZWxzW2F0dHJOYW1lXSkgfHwgZGVmYXVsdExhYmVsRm9ybWF0dGVycy5zZW50ZW5jZUNhc2UoYXR0ck5hbWUsIG1vZGVsKTtcbiAgICAgIH1cbiAgICB9O1xuICBcbiAgXG4gICAgLy8gQnVpbHQgaW4gdmFsaWRhdG9yc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgdmFyIGRlZmF1bHRWYWxpZGF0b3JzID0gVmFsaWRhdGlvbi52YWxpZGF0b3JzID0gKGZ1bmN0aW9uKCl7XG4gICAgICAvLyBVc2UgbmF0aXZlIHRyaW0gd2hlbiBkZWZpbmVkXG4gICAgICB2YXIgdHJpbSA9IFN0cmluZy5wcm90b3R5cGUudHJpbSA/XG4gICAgICAgIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dCA9PT0gbnVsbCA/ICcnIDogU3RyaW5nLnByb3RvdHlwZS50cmltLmNhbGwodGV4dCk7XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgdmFyIHRyaW1MZWZ0ID0gL15cXHMrLyxcbiAgICAgICAgICAgICAgdHJpbVJpZ2h0ID0gL1xccyskLztcbiAgXG4gICAgICAgICAgcmV0dXJuIHRleHQgPT09IG51bGwgPyAnJyA6IHRleHQudG9TdHJpbmcoKS5yZXBsYWNlKHRyaW1MZWZ0LCAnJykucmVwbGFjZSh0cmltUmlnaHQsICcnKTtcbiAgICAgICAgfTtcbiAgXG4gICAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBudW1iZXJcbiAgICAgIHZhciBpc051bWJlciA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIF8uaXNOdW1iZXIodmFsdWUpIHx8IChfLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5tYXRjaChkZWZhdWx0UGF0dGVybnMubnVtYmVyKSk7XG4gICAgICB9O1xuICBcbiAgICAgIC8vIERldGVybWluZXMgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBlbXB0eVxuICAgICAgdmFyIGhhc1ZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEoXy5pc051bGwodmFsdWUpIHx8IF8uaXNVbmRlZmluZWQodmFsdWUpIHx8IChfLmlzU3RyaW5nKHZhbHVlKSAmJiB0cmltKHZhbHVlKSA9PT0gJycpIHx8IChfLmlzQXJyYXkodmFsdWUpICYmIF8uaXNFbXB0eSh2YWx1ZSkpKTtcbiAgICAgIH07XG4gIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRnVuY3Rpb24gdmFsaWRhdG9yXG4gICAgICAgIC8vIExldHMgeW91IGltcGxlbWVudCBhIGN1c3RvbSBmdW5jdGlvbiB1c2VkIGZvciB2YWxpZGF0aW9uXG4gICAgICAgIGZuOiBmdW5jdGlvbih2YWx1ZSwgYXR0ciwgZm4sIG1vZGVsLCBjb21wdXRlZCkge1xuICAgICAgICAgIGlmKF8uaXNTdHJpbmcoZm4pKXtcbiAgICAgICAgICAgIGZuID0gbW9kZWxbZm5dO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm4uY2FsbChtb2RlbCwgdmFsdWUsIGF0dHIsIGNvbXB1dGVkKTtcbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIFJlcXVpcmVkIHZhbGlkYXRvclxuICAgICAgICAvLyBWYWxpZGF0ZXMgaWYgdGhlIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvciBub3RcbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhIGJvb2xlYW4gdmFsdWUgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBib29sZWFuIHZhbHVlXG4gICAgICAgIHJlcXVpcmVkOiBmdW5jdGlvbih2YWx1ZSwgYXR0ciwgcmVxdWlyZWQsIG1vZGVsLCBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBpc1JlcXVpcmVkID0gXy5pc0Z1bmN0aW9uKHJlcXVpcmVkKSA/IHJlcXVpcmVkLmNhbGwobW9kZWwsIHZhbHVlLCBhdHRyLCBjb21wdXRlZCkgOiByZXF1aXJlZDtcbiAgICAgICAgICBpZighaXNSZXF1aXJlZCAmJiAhaGFzVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG92ZXJyaWRlcyBhbGwgb3RoZXIgdmFsaWRhdG9yc1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNSZXF1aXJlZCAmJiAhaGFzVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZGVmYXVsdE1lc3NhZ2VzLnJlcXVpcmVkLCB0aGlzLmZvcm1hdExhYmVsKGF0dHIsIG1vZGVsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gQWNjZXB0YW5jZSB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgc29tZXRoaW5nIGhhcyB0byBiZSBhY2NlcHRlZCwgZS5nLiB0ZXJtcyBvZiB1c2VcbiAgICAgICAgLy8gYHRydWVgIG9yICd0cnVlJyBhcmUgdmFsaWRcbiAgICAgICAgYWNjZXB0YW5jZTogZnVuY3Rpb24odmFsdWUsIGF0dHIsIGFjY2VwdCwgbW9kZWwpIHtcbiAgICAgICAgICBpZih2YWx1ZSAhPT0gJ3RydWUnICYmICghXy5pc0Jvb2xlYW4odmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMuYWNjZXB0YW5jZSwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIE1pbiB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBhIG51bWJlciBhbmQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXG4gICAgICAgIC8vIHRoZSBtaW4gdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgIG1pbjogZnVuY3Rpb24odmFsdWUsIGF0dHIsIG1pblZhbHVlLCBtb2RlbCkge1xuICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpIHx8IHZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMubWluLCB0aGlzLmZvcm1hdExhYmVsKGF0dHIsIG1vZGVsKSwgbWluVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIE1heCB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBhIG51bWJlciBhbmQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXG4gICAgICAgIC8vIHRoZSBtYXggdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgIG1heDogZnVuY3Rpb24odmFsdWUsIGF0dHIsIG1heFZhbHVlLCBtb2RlbCkge1xuICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpIHx8IHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMubWF4LCB0aGlzLmZvcm1hdExhYmVsKGF0dHIsIG1vZGVsKSwgbWF4VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIFJhbmdlIHZhbGlkYXRvclxuICAgICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaGFzIHRvIGJlIGEgbnVtYmVyIGFuZCBlcXVhbCB0byBvciBiZXR3ZWVuXG4gICAgICAgIC8vIHRoZSB0d28gbnVtYmVycyBzcGVjaWZpZWRcbiAgICAgICAgcmFuZ2U6IGZ1bmN0aW9uKHZhbHVlLCBhdHRyLCByYW5nZSwgbW9kZWwpIHtcbiAgICAgICAgICBpZighaXNOdW1iZXIodmFsdWUpIHx8IHZhbHVlIDwgcmFuZ2VbMF0gfHwgdmFsdWUgPiByYW5nZVsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZmF1bHRNZXNzYWdlcy5yYW5nZSwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCksIHJhbmdlWzBdLCByYW5nZVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gTGVuZ3RoIHZhbGlkYXRvclxuICAgICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaGFzIHRvIGJlIGEgc3RyaW5nIHdpdGggbGVuZ3RoIGVxdWFsIHRvXG4gICAgICAgIC8vIHRoZSBsZW5ndGggdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgIGxlbmd0aDogZnVuY3Rpb24odmFsdWUsIGF0dHIsIGxlbmd0aCwgbW9kZWwpIHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZGVmYXVsdE1lc3NhZ2VzLmxlbmd0aCwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCksIGxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gTWluIGxlbmd0aCB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBhIHN0cmluZyB3aXRoIGxlbmd0aCBlcXVhbCB0byBvciBncmVhdGVyIHRoYW5cbiAgICAgICAgLy8gdGhlIG1pbiBsZW5ndGggdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgIG1pbkxlbmd0aDogZnVuY3Rpb24odmFsdWUsIGF0dHIsIG1pbkxlbmd0aCwgbW9kZWwpIHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZmF1bHRNZXNzYWdlcy5taW5MZW5ndGgsIHRoaXMuZm9ybWF0TGFiZWwoYXR0ciwgbW9kZWwpLCBtaW5MZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIE1heCBsZW5ndGggdmFsaWRhdG9yXG4gICAgICAgIC8vIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBoYXMgdG8gYmUgYSBzdHJpbmcgd2l0aCBsZW5ndGggZXF1YWwgdG8gb3IgbGVzcyB0aGFuXG4gICAgICAgIC8vIHRoZSBtYXggbGVuZ3RoIHZhbHVlIHNwZWNpZmllZFxuICAgICAgICBtYXhMZW5ndGg6IGZ1bmN0aW9uKHZhbHVlLCBhdHRyLCBtYXhMZW5ndGgsIG1vZGVsKSB7XG4gICAgICAgICAgaWYgKCFfLmlzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMubWF4TGVuZ3RoLCB0aGlzLmZvcm1hdExhYmVsKGF0dHIsIG1vZGVsKSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gIFxuICAgICAgICAvLyBSYW5nZSBsZW5ndGggdmFsaWRhdG9yXG4gICAgICAgIC8vIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBoYXMgdG8gYmUgYSBzdHJpbmcgYW5kIGVxdWFsIHRvIG9yIGJldHdlZW5cbiAgICAgICAgLy8gdGhlIHR3byBudW1iZXJzIHNwZWNpZmllZFxuICAgICAgICByYW5nZUxlbmd0aDogZnVuY3Rpb24odmFsdWUsIGF0dHIsIHJhbmdlLCBtb2RlbCkge1xuICAgICAgICAgIGlmICghXy5pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoIDwgcmFuZ2VbMF0gfHwgdmFsdWUubGVuZ3RoID4gcmFuZ2VbMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMucmFuZ2VMZW5ndGgsIHRoaXMuZm9ybWF0TGFiZWwoYXR0ciwgbW9kZWwpLCByYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIE9uZSBvZiB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGVsZW1lbnRzIGluXG4gICAgICAgIC8vIHRoZSBzcGVjaWZpZWQgYXJyYXkuIENhc2Ugc2Vuc2l0aXZlIG1hdGNoaW5nXG4gICAgICAgIG9uZU9mOiBmdW5jdGlvbih2YWx1ZSwgYXR0ciwgdmFsdWVzLCBtb2RlbCkge1xuICAgICAgICAgIGlmKCFfLmluY2x1ZGUodmFsdWVzLCB2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZmF1bHRNZXNzYWdlcy5vbmVPZiwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCksIHZhbHVlcy5qb2luKCcsICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gIFxuICAgICAgICAvLyBFcXVhbCB0byB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBlcXVhbCB0byB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAvLyB3aXRoIHRoZSBuYW1lIHNwZWNpZmllZFxuICAgICAgICBlcXVhbFRvOiBmdW5jdGlvbih2YWx1ZSwgYXR0ciwgZXF1YWxUbywgbW9kZWwsIGNvbXB1dGVkKSB7XG4gICAgICAgICAgaWYodmFsdWUgIT09IGNvbXB1dGVkW2VxdWFsVG9dKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZGVmYXVsdE1lc3NhZ2VzLmVxdWFsVG8sIHRoaXMuZm9ybWF0TGFiZWwoYXR0ciwgbW9kZWwpLCB0aGlzLmZvcm1hdExhYmVsKGVxdWFsVG8sIG1vZGVsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gUGF0dGVybiB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBtYXRjaCB0aGUgcGF0dGVybiBzcGVjaWZpZWQuXG4gICAgICAgIC8vIENhbiBiZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciB0aGUgbmFtZSBvZiBvbmUgb2YgdGhlIGJ1aWx0IGluIHBhdHRlcm5zXG4gICAgICAgIHBhdHRlcm46IGZ1bmN0aW9uKHZhbHVlLCBhdHRyLCBwYXR0ZXJuLCBtb2RlbCkge1xuICAgICAgICAgIGlmICghaGFzVmFsdWUodmFsdWUpIHx8ICF2YWx1ZS50b1N0cmluZygpLm1hdGNoKGRlZmF1bHRQYXR0ZXJuc1twYXR0ZXJuXSB8fCBwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZmF1bHRNZXNzYWdlc1twYXR0ZXJuXSB8fCBkZWZhdWx0TWVzc2FnZXMuaW5saW5lUGF0dGVybiwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCksIHBhdHRlcm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KCkpO1xuICBcbiAgICAvLyBTZXQgdGhlIGNvcnJlY3QgY29udGV4dCBmb3IgYWxsIHZhbGlkYXRvcnNcbiAgICAvLyB3aGVuIHVzZWQgZnJvbSB3aXRoaW4gYSBtZXRob2QgdmFsaWRhdG9yXG4gICAgXy5lYWNoKGRlZmF1bHRWYWxpZGF0b3JzLCBmdW5jdGlvbih2YWxpZGF0b3IsIGtleSl7XG4gICAgICBkZWZhdWx0VmFsaWRhdG9yc1trZXldID0gXy5iaW5kKGRlZmF1bHRWYWxpZGF0b3JzW2tleV0sIF8uZXh0ZW5kKHt9LCBmb3JtYXRGdW5jdGlvbnMsIGRlZmF1bHRWYWxpZGF0b3JzKSk7XG4gICAgfSk7XG4gIFxuICAgIHJldHVybiBWYWxpZGF0aW9uO1xuICB9KF8pKTtcbiAgcmV0dXJuIEJhY2tib25lLlZhbGlkYXRpb247XG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvYmFja2JvbmUtdmFsaWRhdGlvbi1hbWQuanNcbi8vIG1vZHVsZSBpZCA9IGNvbnRyaWIvYmFja2JvbmUtdmFsaWRhdGlvbi1hbWRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "views/shared/singlevalue/Labels":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\"),\n        module,\n        __webpack_require__(\"views/Base\"),\n        __webpack_require__(\"views/shared/singlevalue/Label\"),\n        __webpack_require__(\"models/Base\"),\n        __webpack_require__(\"shim/splunk.util\"),\n        __webpack_require__(\"util/svg\"),\n        __webpack_require__(\"util/math_utils\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n        $,\n        _,\n        module,\n        BaseView,\n        LabelView,\n        BaseModel,\n        splunkUtil,\n        svgUtil,\n        mathUtil\n        ) {\n\n        return BaseView.extend({\n            moduleId: module.id,\n            className: \"single-value-labels\",\n            el: function() {\n                return svgUtil.createElement('g').attr('class', 'single-value-labels');\n            },\n            LABEL_SIDE_PADDING: 5,\n\n            initialize: function(options) {\n                BaseView.prototype.initialize.apply(this, arguments);\n                this.activate();\n                this.unit = options.unit;\n                this.unitPosition = options.unitPosition;\n                this.hasUnit = options.hasUnit;\n                this.hasAfterLabel = options.hasAfterLabel;\n                this.hasBeforeLabel = options.hasBeforeLabel;\n                this.originalSingleValueFontSize = this.model.presentation.get('singleValueFontSize');\n                this.originalSideLabelFontSize = this.model.presentation.get('sideLabelFontSize');\n                this.updateContainerDimensions();\n            },\n\n            reflow: function() {\n                this.updateContainerDimensions();\n                this.scaleLabels();\n                // Do not call this.positionLabels() in reflow because positionLabels is called manually by the parent view (MainBody.js) later,\n                // after the delta value scaling and measuring routines have run, in order to use the latest deltaWidth dimension.\n            },\n\n            updateContainerDimensions: function() {\n                // Scale font size to fill new available SVG height\n                this.scaleRatio = this.model.presentation.get('scaleRatio');\n                this.singleValueFontSize = this.originalSingleValueFontSize * this.scaleRatio;\n                this.labelFontSize = this.originalSideLabelFontSize * this.scaleRatio;\n            },\n\n            constructMainLabelData: function() {\n                var labelData,\n                    fontColor = this.model.presentation.get('fontColor'),\n                    beforeLabelConfigName = \"display.visualizations.singlevalue.beforeLabel\",\n                    afterLabelConfigName = \"display.visualizations.singlevalue.afterLabel\";\n\n                labelData = {\n                    singleResultData: {\n                        labelFontSize: this.originalSingleValueFontSize,\n                        labelFontColor: fontColor,\n                        labelGroupClass: 'single-result-group',\n                        labelClass: 'single-result',\n                        linkField: 'result',\n                        configName: 'display.visualizations.singlevalue.singleResult',\n                        useResultField: true,\n                        fontWeight: 'bold',\n                        unit: this.unit,\n                        unitPosition: this.unitPosition,\n                        hasUnit: this.hasUnit,\n                        exportMode: !!this.model.state.get('exportMode')\n                    }\n                };\n\n                if (this.hasBeforeLabel) {\n                    labelData.beforeLabelData = {\n                        labelFontSize: this.originalSideLabelFontSize,\n                        labelFontColor: fontColor,\n                        labelGroupClass: 'before-label-group',\n                        labelClass: 'before-label',\n                        linkField: 'beforelabel',\n                        configName: beforeLabelConfigName,\n                        useResultField: false,\n                        fontWeight: 'normal'\n                    };\n                }\n\n                if (this.hasAfterLabel) {\n                    labelData.afterLabelData = {\n                        labelFontSize: this.originalSideLabelFontSize,\n                        labelFontColor: fontColor,\n                        labelGroupClass: 'after-label-group',\n                        labelClass: 'after-label',\n                        linkField: 'afterlabel',\n                        configName: afterLabelConfigName,\n                        useResultField: false,\n                        fontWeight: 'normal'\n                    };\n                }\n\n                return labelData;\n            },\n\n            getMainLabelsWidth: function() {\n                var mainLabelsWidth = 0;\n                if (this.hasBeforeLabel) {\n                    mainLabelsWidth += this.children.beforeLabelView.getWidth();\n                    mainLabelsWidth += this.LABEL_SIDE_PADDING;\n                }\n                if (this.hasAfterLabel) {\n                    mainLabelsWidth += this.children.afterLabelView.getWidth();\n                    mainLabelsWidth += this.LABEL_SIDE_PADDING;\n                }\n                mainLabelsWidth += this.children.singleResultView.getWidth();\n\n                return mainLabelsWidth;\n            },\n\n            positionLabels: function() {\n                var shiftWidth = 0,\n                    beforeLabel,\n                    afterLabel,\n                    singleValue = this.children.singleResultView.getLabelElement(),\n                    beforeLabelX = shiftWidth,\n                    singleValueX = shiftWidth,\n                    afterLabelX = 0,\n                    beforeLabelWidth,\n                    singleValueWidth = this.children.singleResultView.getWidth(),\n                    mainLabelsWidth = this.getMainLabelsWidth(),\n                    deltaWidth = this.model.presentation.get('deltaWidth') || 0,\n                    svgWidth = this.model.presentation.get('svgWidth');\n\n                if (deltaWidth > 0) {\n                    deltaWidth += this.model.presentation.get('deltaPadding');\n                }\n                // Center labels within SVG container\n                shiftWidth = mathUtil.roundToDecimal((svgWidth / 2) - ((mainLabelsWidth + deltaWidth) / 2), -2); // round to 2 d.p.\n\n                // Now, actually reposition the labels\n                if (this.hasBeforeLabel) {\n                    beforeLabelWidth = this.children.beforeLabelView.getWidth();\n                    beforeLabel = this.children.beforeLabelView.getLabelElement();\n                    beforeLabelX = shiftWidth;\n                    singleValueX = beforeLabelWidth + beforeLabelX + this.LABEL_SIDE_PADDING;\n                    beforeLabel.attr('x', beforeLabelX);\n                } else {\n                    singleValueX = shiftWidth;\n                }\n                singleValue.attr('x', singleValueX);\n\n                if (this.hasAfterLabel) {\n                    afterLabel = this.children.afterLabelView.getLabelElement();\n                    afterLabelX = singleValueX + singleValueWidth + this.LABEL_SIDE_PADDING;\n                    afterLabel.attr('x', afterLabelX);\n                }\n            },\n\n            scaleLabels: function() {\n                var beforeLabel,\n                    singleValue = this.children.singleResultView.getLabelElement(),\n                    afterLabel,\n                    mainLabelsWidth,\n                    maxLabelWidth = this.model.presentation.get('maxLabelsWidth'),\n                    maxLabelRatio;\n\n                if (!this.defaultMainLabelsWidth) {\n                    this.defaultMainLabelsWidth = this.getMainLabelsWidth();\n                }\n\n                // Reset all adjusted attributes to position and scale from the same place every time\n                singleValue.css('font-size', this.singleValueFontSize);\n\n                // Width will always be 0 in PDF so skip this step\n                if (!this.model.state.get('exportMode')) {\n                    if (this.children.singleResultView.getWidth() === 0) {\n                        // The labels are not yet in the DOM - not point of adjusting positions/scales\n                        // Bail and wait until next pass through when labels are in DOM\n                        return;\n                    }\n                }\n\n                if (this.hasBeforeLabel) {\n                    beforeLabel = this.children.beforeLabelView.getLabelElement();\n                    beforeLabel.css('font-size', this.labelFontSize);\n                }\n\n                if (this.hasAfterLabel) {\n                    afterLabel = this.children.afterLabelView.getLabelElement();\n                    afterLabel.css('font-size', this.labelFontSize);\n                }\n\n                mainLabelsWidth = this.getMainLabelsWidth();\n\n                // don't rescale labels in displayMode simple as it would affect the final font size\n                if (mainLabelsWidth > maxLabelWidth && this.model.presentation.get('displayMode') !== 'simple') {\n                    maxLabelRatio = mathUtil.roundToDecimal(maxLabelWidth / this.defaultMainLabelsWidth, -4);\n                    this.singleValueFontSize = mathUtil.roundToDecimal(this.originalSingleValueFontSize * maxLabelRatio, -4);\n                    this.labelFontSize = mathUtil.roundToDecimal(this.originalSideLabelFontSize * maxLabelRatio, -4);\n\n                    singleValue.css('font-size', this.singleValueFontSize);\n                    if (this.hasBeforeLabel) {\n                        beforeLabel = this.children.beforeLabelView.getLabelElement();\n                        beforeLabel.css('font-size', this.labelFontSize);\n                    }\n\n                    if (this.hasAfterLabel) {\n                        afterLabel = this.children.afterLabelView.getLabelElement();\n                        afterLabel.css('font-size', this.labelFontSize);\n                    }\n                }\n            },\n\n            createLabel: function(mainGroup, mainLabelData, modelOptions, viewName, dataName) {\n                if (this.children[viewName]) {\n                    this.children[viewName].detach();\n                    this.children[viewName].remove();\n                }\n                this.children[viewName] = new LabelView(_.extend(modelOptions, mainLabelData[dataName]));\n                this.children[viewName].render().appendTo(mainGroup);\n\n                this.listenTo(this.children[viewName], 'singleDrilldownClicked', function(params) {\n                    this.trigger('singleDrilldownClicked', params);\n                });\n                this.listenTo(this.children[viewName], 'anchorTagClicked', function(e) {\n                    this.trigger('anchorTagClicked', e);\n                });\n            },\n\n            render: function() {\n                var mainGroup = this.$el.find('.main-label-group'),\n                    mainLabelData = this.constructMainLabelData(),\n                    modelOptions = {\n                        model: {\n                            state: this.model.state,\n                            results: this.model.results,\n                            presentation: this.model.presentation,\n                            application: this.model.application\n                        }\n                    };\n                if (mainGroup.length > 0) {\n                    mainGroup.remove();\n                }\n                // Create group to contain BeforeLabel, SingleValue, and AfterLabel\n                mainGroup = svgUtil.createElement('g')\n                    .attr('class', 'main-label-group');\n                this.$el.append(mainGroup);\n\n                if (this.hasBeforeLabel) {\n                    this.createLabel(mainGroup, mainLabelData, modelOptions, 'beforeLabelView', 'beforeLabelData');\n                }\n\n                this.createLabel(mainGroup, mainLabelData, modelOptions, 'singleResultView', 'singleResultData');\n\n                if (this.hasAfterLabel) {\n                    this.createLabel(mainGroup, mainLabelData, modelOptions, 'afterLabelView', 'afterLabelData');\n                }\n                return this;\n            }\n        });\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9MYWJlbHMuanM/MDFiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUEsaUNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDs7QUFFaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvSkFDQSIsImZpbGUiOiJ2aWV3cy9zaGFyZWQvc2luZ2xldmFsdWUvTGFiZWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFxuICAgIFtcbiAgICAgICAgJ2pxdWVyeScsXG4gICAgICAgICd1bmRlcnNjb3JlJyxcbiAgICAgICAgJ21vZHVsZScsXG4gICAgICAgICd2aWV3cy9CYXNlJyxcbiAgICAgICAgJy4vTGFiZWwnLFxuICAgICAgICAnbW9kZWxzL0Jhc2UnLFxuICAgICAgICAnc3BsdW5rLnV0aWwnLFxuICAgICAgICAndXRpbC9zdmcnLFxuICAgICAgICAndXRpbC9tYXRoX3V0aWxzJ1xuICAgIF0sXG4gICAgZnVuY3Rpb24oXG4gICAgICAgICQsXG4gICAgICAgIF8sXG4gICAgICAgIG1vZHVsZSxcbiAgICAgICAgQmFzZVZpZXcsXG4gICAgICAgIExhYmVsVmlldyxcbiAgICAgICAgQmFzZU1vZGVsLFxuICAgICAgICBzcGx1bmtVdGlsLFxuICAgICAgICBzdmdVdGlsLFxuICAgICAgICBtYXRoVXRpbFxuICAgICAgICApIHtcblxuICAgICAgICByZXR1cm4gQmFzZVZpZXcuZXh0ZW5kKHtcbiAgICAgICAgICAgIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic2luZ2xlLXZhbHVlLWxhYmVsc1wiLFxuICAgICAgICAgICAgZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdmdVdGlsLmNyZWF0ZUVsZW1lbnQoJ2cnKS5hdHRyKCdjbGFzcycsICdzaW5nbGUtdmFsdWUtbGFiZWxzJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTEFCRUxfU0lERV9QQURESU5HOiA1LFxuXG4gICAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgQmFzZVZpZXcucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51bml0ID0gb3B0aW9ucy51bml0O1xuICAgICAgICAgICAgICAgIHRoaXMudW5pdFBvc2l0aW9uID0gb3B0aW9ucy51bml0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNVbml0ID0gb3B0aW9ucy5oYXNVbml0O1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQWZ0ZXJMYWJlbCA9IG9wdGlvbnMuaGFzQWZ0ZXJMYWJlbDtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0JlZm9yZUxhYmVsID0gb3B0aW9ucy5oYXNCZWZvcmVMYWJlbDtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsU2luZ2xlVmFsdWVGb250U2l6ZSA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnc2luZ2xlVmFsdWVGb250U2l6ZScpO1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxTaWRlTGFiZWxGb250U2l6ZSA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnc2lkZUxhYmVsRm9udFNpemUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lckRpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlZmxvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb250YWluZXJEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZUxhYmVscygpO1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBjYWxsIHRoaXMucG9zaXRpb25MYWJlbHMoKSBpbiByZWZsb3cgYmVjYXVzZSBwb3NpdGlvbkxhYmVscyBpcyBjYWxsZWQgbWFudWFsbHkgYnkgdGhlIHBhcmVudCB2aWV3IChNYWluQm9keS5qcykgbGF0ZXIsXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIGRlbHRhIHZhbHVlIHNjYWxpbmcgYW5kIG1lYXN1cmluZyByb3V0aW5lcyBoYXZlIHJ1biwgaW4gb3JkZXIgdG8gdXNlIHRoZSBsYXRlc3QgZGVsdGFXaWR0aCBkaW1lbnNpb24uXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1cGRhdGVDb250YWluZXJEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSBmb250IHNpemUgdG8gZmlsbCBuZXcgYXZhaWxhYmxlIFNWRyBoZWlnaHRcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlUmF0aW8gPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ3NjYWxlUmF0aW8nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpbmdsZVZhbHVlRm9udFNpemUgPSB0aGlzLm9yaWdpbmFsU2luZ2xlVmFsdWVGb250U2l6ZSAqIHRoaXMuc2NhbGVSYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsRm9udFNpemUgPSB0aGlzLm9yaWdpbmFsU2lkZUxhYmVsRm9udFNpemUgKiB0aGlzLnNjYWxlUmF0aW87XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb25zdHJ1Y3RNYWluTGFiZWxEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxEYXRhLFxuICAgICAgICAgICAgICAgICAgICBmb250Q29sb3IgPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ2ZvbnRDb2xvcicpLFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVMYWJlbENvbmZpZ05hbWUgPSBcImRpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUuYmVmb3JlTGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYWJlbENvbmZpZ05hbWUgPSBcImRpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUuYWZ0ZXJMYWJlbFwiO1xuXG4gICAgICAgICAgICAgICAgbGFiZWxEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVSZXN1bHREYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEZvbnRTaXplOiB0aGlzLm9yaWdpbmFsU2luZ2xlVmFsdWVGb250U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRm9udENvbG9yOiBmb250Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEdyb3VwQ2xhc3M6ICdzaW5nbGUtcmVzdWx0LWdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQ2xhc3M6ICdzaW5nbGUtcmVzdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtGaWVsZDogJ3Jlc3VsdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdOYW1lOiAnZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS5zaW5nbGVSZXN1bHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlUmVzdWx0RmllbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bml0UG9zaXRpb246IHRoaXMudW5pdFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzVW5pdDogdGhpcy5oYXNVbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0TW9kZTogISF0aGlzLm1vZGVsLnN0YXRlLmdldCgnZXhwb3J0TW9kZScpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQmVmb3JlTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhLmJlZm9yZUxhYmVsRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRm9udFNpemU6IHRoaXMub3JpZ2luYWxTaWRlTGFiZWxGb250U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRm9udENvbG9yOiBmb250Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEdyb3VwQ2xhc3M6ICdiZWZvcmUtbGFiZWwtZ3JvdXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxDbGFzczogJ2JlZm9yZS1sYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rRmllbGQ6ICdiZWZvcmVsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdOYW1lOiBiZWZvcmVMYWJlbENvbmZpZ05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VSZXN1bHRGaWVsZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0FmdGVyTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhLmFmdGVyTGFiZWxEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxGb250U2l6ZTogdGhpcy5vcmlnaW5hbFNpZGVMYWJlbEZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxGb250Q29sb3I6IGZvbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsR3JvdXBDbGFzczogJ2FmdGVyLWxhYmVsLWdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQ2xhc3M6ICdhZnRlci1sYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rRmllbGQ6ICdhZnRlcmxhYmVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ05hbWU6IGFmdGVyTGFiZWxDb25maWdOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlUmVzdWx0RmllbGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxEYXRhO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0TWFpbkxhYmVsc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFpbkxhYmVsc1dpZHRoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNCZWZvcmVMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluTGFiZWxzV2lkdGggKz0gdGhpcy5jaGlsZHJlbi5iZWZvcmVMYWJlbFZpZXcuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbkxhYmVsc1dpZHRoICs9IHRoaXMuTEFCRUxfU0lERV9QQURESU5HO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNBZnRlckxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5MYWJlbHNXaWR0aCArPSB0aGlzLmNoaWxkcmVuLmFmdGVyTGFiZWxWaWV3LmdldFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5MYWJlbHNXaWR0aCArPSB0aGlzLkxBQkVMX1NJREVfUEFERElORztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFpbkxhYmVsc1dpZHRoICs9IHRoaXMuY2hpbGRyZW4uc2luZ2xlUmVzdWx0Vmlldy5nZXRXaWR0aCgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW5MYWJlbHNXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBvc2l0aW9uTGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnRXaWR0aCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBhZnRlckxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVWYWx1ZSA9IHRoaXMuY2hpbGRyZW4uc2luZ2xlUmVzdWx0Vmlldy5nZXRMYWJlbEVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlTGFiZWxYID0gc2hpZnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlVmFsdWVYID0gc2hpZnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYWJlbFggPSAwLFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVMYWJlbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVWYWx1ZVdpZHRoID0gdGhpcy5jaGlsZHJlbi5zaW5nbGVSZXN1bHRWaWV3LmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIG1haW5MYWJlbHNXaWR0aCA9IHRoaXMuZ2V0TWFpbkxhYmVsc1dpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhV2lkdGggPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ2RlbHRhV2lkdGgnKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBzdmdXaWR0aCA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnc3ZnV2lkdGgnKTtcblxuICAgICAgICAgICAgICAgIGlmIChkZWx0YVdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVdpZHRoICs9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnZGVsdGFQYWRkaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENlbnRlciBsYWJlbHMgd2l0aGluIFNWRyBjb250YWluZXJcbiAgICAgICAgICAgICAgICBzaGlmdFdpZHRoID0gbWF0aFV0aWwucm91bmRUb0RlY2ltYWwoKHN2Z1dpZHRoIC8gMikgLSAoKG1haW5MYWJlbHNXaWR0aCArIGRlbHRhV2lkdGgpIC8gMiksIC0yKTsgLy8gcm91bmQgdG8gMiBkLnAuXG5cbiAgICAgICAgICAgICAgICAvLyBOb3csIGFjdHVhbGx5IHJlcG9zaXRpb24gdGhlIGxhYmVsc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0JlZm9yZUxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUxhYmVsV2lkdGggPSB0aGlzLmNoaWxkcmVuLmJlZm9yZUxhYmVsVmlldy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVMYWJlbCA9IHRoaXMuY2hpbGRyZW4uYmVmb3JlTGFiZWxWaWV3LmdldExhYmVsRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVMYWJlbFggPSBzaGlmdFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVWYWx1ZVggPSBiZWZvcmVMYWJlbFdpZHRoICsgYmVmb3JlTGFiZWxYICsgdGhpcy5MQUJFTF9TSURFX1BBRERJTkc7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUxhYmVsLmF0dHIoJ3gnLCBiZWZvcmVMYWJlbFgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVZhbHVlWCA9IHNoaWZ0V2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpbmdsZVZhbHVlLmF0dHIoJ3gnLCBzaW5nbGVWYWx1ZVgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQWZ0ZXJMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBhZnRlckxhYmVsID0gdGhpcy5jaGlsZHJlbi5hZnRlckxhYmVsVmlldy5nZXRMYWJlbEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYWJlbFggPSBzaW5nbGVWYWx1ZVggKyBzaW5nbGVWYWx1ZVdpZHRoICsgdGhpcy5MQUJFTF9TSURFX1BBRERJTkc7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyTGFiZWwuYXR0cigneCcsIGFmdGVyTGFiZWxYKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzY2FsZUxhYmVsczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZUxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVWYWx1ZSA9IHRoaXMuY2hpbGRyZW4uc2luZ2xlUmVzdWx0Vmlldy5nZXRMYWJlbEVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgbWFpbkxhYmVsc1dpZHRoLFxuICAgICAgICAgICAgICAgICAgICBtYXhMYWJlbFdpZHRoID0gdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uZ2V0KCdtYXhMYWJlbHNXaWR0aCcpLFxuICAgICAgICAgICAgICAgICAgICBtYXhMYWJlbFJhdGlvO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRNYWluTGFiZWxzV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0TWFpbkxhYmVsc1dpZHRoID0gdGhpcy5nZXRNYWluTGFiZWxzV2lkdGgoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgYWRqdXN0ZWQgYXR0cmlidXRlcyB0byBwb3NpdGlvbiBhbmQgc2NhbGUgZnJvbSB0aGUgc2FtZSBwbGFjZSBldmVyeSB0aW1lXG4gICAgICAgICAgICAgICAgc2luZ2xlVmFsdWUuY3NzKCdmb250LXNpemUnLCB0aGlzLnNpbmdsZVZhbHVlRm9udFNpemUpO1xuXG4gICAgICAgICAgICAgICAgLy8gV2lkdGggd2lsbCBhbHdheXMgYmUgMCBpbiBQREYgc28gc2tpcCB0aGlzIHN0ZXBcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW9kZWwuc3RhdGUuZ2V0KCdleHBvcnRNb2RlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uc2luZ2xlUmVzdWx0Vmlldy5nZXRXaWR0aCgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGFiZWxzIGFyZSBub3QgeWV0IGluIHRoZSBET00gLSBub3QgcG9pbnQgb2YgYWRqdXN0aW5nIHBvc2l0aW9ucy9zY2FsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhaWwgYW5kIHdhaXQgdW50aWwgbmV4dCBwYXNzIHRocm91Z2ggd2hlbiBsYWJlbHMgYXJlIGluIERPTVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQmVmb3JlTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlTGFiZWwgPSB0aGlzLmNoaWxkcmVuLmJlZm9yZUxhYmVsVmlldy5nZXRMYWJlbEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlTGFiZWwuY3NzKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0FmdGVyTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYWJlbCA9IHRoaXMuY2hpbGRyZW4uYWZ0ZXJMYWJlbFZpZXcuZ2V0TGFiZWxFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyTGFiZWwuY3NzKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1haW5MYWJlbHNXaWR0aCA9IHRoaXMuZ2V0TWFpbkxhYmVsc1dpZHRoKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCByZXNjYWxlIGxhYmVscyBpbiBkaXNwbGF5TW9kZSBzaW1wbGUgYXMgaXQgd291bGQgYWZmZWN0IHRoZSBmaW5hbCBmb250IHNpemVcbiAgICAgICAgICAgICAgICBpZiAobWFpbkxhYmVsc1dpZHRoID4gbWF4TGFiZWxXaWR0aCAmJiB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ2Rpc3BsYXlNb2RlJykgIT09ICdzaW1wbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heExhYmVsUmF0aW8gPSBtYXRoVXRpbC5yb3VuZFRvRGVjaW1hbChtYXhMYWJlbFdpZHRoIC8gdGhpcy5kZWZhdWx0TWFpbkxhYmVsc1dpZHRoLCAtNCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2luZ2xlVmFsdWVGb250U2l6ZSA9IG1hdGhVdGlsLnJvdW5kVG9EZWNpbWFsKHRoaXMub3JpZ2luYWxTaW5nbGVWYWx1ZUZvbnRTaXplICogbWF4TGFiZWxSYXRpbywgLTQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsRm9udFNpemUgPSBtYXRoVXRpbC5yb3VuZFRvRGVjaW1hbCh0aGlzLm9yaWdpbmFsU2lkZUxhYmVsRm9udFNpemUgKiBtYXhMYWJlbFJhdGlvLCAtNCk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlVmFsdWUuY3NzKCdmb250LXNpemUnLCB0aGlzLnNpbmdsZVZhbHVlRm9udFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNCZWZvcmVMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlTGFiZWwgPSB0aGlzLmNoaWxkcmVuLmJlZm9yZUxhYmVsVmlldy5nZXRMYWJlbEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUxhYmVsLmNzcygnZm9udC1zaXplJywgdGhpcy5sYWJlbEZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0FmdGVyTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGFiZWwgPSB0aGlzLmNoaWxkcmVuLmFmdGVyTGFiZWxWaWV3LmdldExhYmVsRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYWJlbC5jc3MoJ2ZvbnQtc2l6ZScsIHRoaXMubGFiZWxGb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjcmVhdGVMYWJlbDogZnVuY3Rpb24obWFpbkdyb3VwLCBtYWluTGFiZWxEYXRhLCBtb2RlbE9wdGlvbnMsIHZpZXdOYW1lLCBkYXRhTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW3ZpZXdOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW3ZpZXdOYW1lXS5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblt2aWV3TmFtZV0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bdmlld05hbWVdID0gbmV3IExhYmVsVmlldyhfLmV4dGVuZChtb2RlbE9wdGlvbnMsIG1haW5MYWJlbERhdGFbZGF0YU5hbWVdKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblt2aWV3TmFtZV0ucmVuZGVyKCkuYXBwZW5kVG8obWFpbkdyb3VwKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jaGlsZHJlblt2aWV3TmFtZV0sICdzaW5nbGVEcmlsbGRvd25DbGlja2VkJywgZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc2luZ2xlRHJpbGxkb3duQ2xpY2tlZCcsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNoaWxkcmVuW3ZpZXdOYW1lXSwgJ2FuY2hvclRhZ0NsaWNrZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYW5jaG9yVGFnQ2xpY2tlZCcsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFpbkdyb3VwID0gdGhpcy4kZWwuZmluZCgnLm1haW4tbGFiZWwtZ3JvdXAnKSxcbiAgICAgICAgICAgICAgICAgICAgbWFpbkxhYmVsRGF0YSA9IHRoaXMuY29uc3RydWN0TWFpbkxhYmVsRGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLm1vZGVsLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IHRoaXMubW9kZWwucmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50YXRpb246IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uOiB0aGlzLm1vZGVsLmFwcGxpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG1haW5Hcm91cC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5Hcm91cC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGdyb3VwIHRvIGNvbnRhaW4gQmVmb3JlTGFiZWwsIFNpbmdsZVZhbHVlLCBhbmQgQWZ0ZXJMYWJlbFxuICAgICAgICAgICAgICAgIG1haW5Hcm91cCA9IHN2Z1V0aWwuY3JlYXRlRWxlbWVudCgnZycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdtYWluLWxhYmVsLWdyb3VwJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuYXBwZW5kKG1haW5Hcm91cCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNCZWZvcmVMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUxhYmVsKG1haW5Hcm91cCwgbWFpbkxhYmVsRGF0YSwgbW9kZWxPcHRpb25zLCAnYmVmb3JlTGFiZWxWaWV3JywgJ2JlZm9yZUxhYmVsRGF0YScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlTGFiZWwobWFpbkdyb3VwLCBtYWluTGFiZWxEYXRhLCBtb2RlbE9wdGlvbnMsICdzaW5nbGVSZXN1bHRWaWV3JywgJ3NpbmdsZVJlc3VsdERhdGEnKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0FmdGVyTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVMYWJlbChtYWluR3JvdXAsIG1haW5MYWJlbERhdGEsIG1vZGVsT3B0aW9ucywgJ2FmdGVyTGFiZWxWaWV3JywgJ2FmdGVyTGFiZWxEYXRhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9MYWJlbHMuanNcbi8vIG1vZHVsZSBpZCA9IHZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9MYWJlbHNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "views/shared/singlevalue/Label":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\"),\n        module,\n        __webpack_require__(\"views/Base\"),\n        __webpack_require__(\"models/Base\"),\n        __webpack_require__(\"shim/splunk.util\"),\n        __webpack_require__(\"util/svg\"),\n        __webpack_require__(\"util/general_utils\"),\n        __webpack_require__(\"uri/route\"),\n        __webpack_require__(\"util/numeral\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n        $,\n        _,\n        module,\n        BaseView,\n        BaseModel,\n        splunkUtil,\n        svgUtil,\n        generalUtil,\n        route,\n        numeral\n        ) {\n\n        var getStringRepresentation = function(label, formatted) {\n            if (_.isFunction(label)) {\n                try {\n                    label = label(formatted);\n                } catch (e) {\n                    return '';\n                }\n            }\n            return label;\n        };\n\n        return BaseView.extend({\n            moduleId: module.id,\n            className: \"single-value-label\",\n            el: function() {\n                return svgUtil.createElement('g').attr({\n                    'class': 'single-value-label',\n                    'data-name': this.options.configName\n                });\n            },\n\n            initialize: function(options) {\n                BaseView.prototype.initialize.apply(this, arguments);\n                this.activate();\n                this.LABEL_FONT_SIZE = this.options.labelFontSize;\n                this.labelFontColor = this.options.labelFontColor;\n                this.labelGroupClass = this.options.labelGroupClass;\n                this.labelClass = this.options.labelClass;\n                this.linkField = this.options.linkField;\n                this.resultFieldValue = this.model.results.get('resultFieldValue');\n                this.configName = this.options.configName;\n                this.unit = this.options.unit;\n                this.unitPosition = this.options.unitPosition;\n                this.hasUnit = this.options.hasUnit;\n                this.isNumericLabelValue = false;\n                if (this.options.useResultField) {\n                    if (!isNaN(this.resultFieldValue)) {\n                        // Single Result Label - needs formatting\n                        var formatPattern = this.model.presentation.get('formatPattern');\n                        this.labelValue = numeral(this.resultFieldValue).format(formatPattern);\n                        this.isNumericLabelValue = true;\n                    } else {\n                        this.labelValue = this.resultFieldValue;\n                    }\n                } else {\n                    this.labelValue = getStringRepresentation(this.model.state.get(this.configName) || \"\", this.resultFieldValue);\n                }\n                this.fontWeight = this.options.fontWeight;\n                this.labelOpacity = this.options.labelOpacity;\n                this.exportMode = this.options.exportMode;\n            },\n\n            events: {\n                'click a.single-drilldown': function(e) {\n                    e.preventDefault();\n                    var target = $(e.currentTarget);\n                    var resModel = this.model.results.get('searchResultsColumn'),\n                        names = resModel.get('fields');\n\n                    // Fields can either be a list of strings or a list of dictionaries each with a 'name' entry\n                    // depending on whether 'show_metadata' is enabled\n                    if (_.isObject(names[0])) {\n                        names = _(names).pluck('name');\n                    }\n\n                    var rowContext = _.object(\n                        _(names).map(function(f) { return 'row.' + f; }),\n                        _(resModel.get('columns')).map(function(col) { return _(col).last(); })\n                    );\n\n                    var drilldownInfo = {\n                        name: target.data('field'),\n                        value: target.data('value'),\n                        rowContext: rowContext,\n                        originalEvent: e,\n                        type: 'cell'\n                    };\n\n                    // If the results model has sparkline data, we want to narrow the drilldown time range\n                    // to the last time bucket, since that is what is used to display the label.\n                    if (this.model.results.has('sparklineData')) {\n                        var timeFieldIndex = _(names).indexOf('_time'),\n                            spanFieldIndex = _(names).indexOf('_span'),\n                            columns = resModel.get('columns'),\n                            lastTimestamp = splunkUtil.getEpochTimeFromISO(_(columns[timeFieldIndex]).last()),\n                            lastTimespan = parseFloat(_(columns[spanFieldIndex]).last());\n\n                        // Time range drilldown has to be done with `name` and `value`, re-map the current values\n                        // there to `name2` and `value2` so that consumers still have access to them.\n                        drilldownInfo.name2 = drilldownInfo.name;\n                        drilldownInfo.value2 = drilldownInfo.value;\n                        drilldownInfo.name = '_time';\n                        drilldownInfo.value = lastTimestamp;\n                        drilldownInfo._span = lastTimespan;\n                        drilldownInfo.rowContext['row._time'] = lastTimestamp;\n                        drilldownInfo.rowContext['row._span'] = lastTimespan;\n                    }\n\n                    var specificEventNames = _(target.children('text').attr('class').split(' ')).map(function(cls) {\n                        return 'click:' + cls;\n                    }).join(' ');\n                    this.trigger('singleDrilldownClicked', { specificEventNames: 'click drilldown ' + specificEventNames, drilldownInfo: drilldownInfo });\n                },\n                'click a.link-drilldown': function(e) {\n                    e.preventDefault();\n                    this.trigger('anchorTagClicked', e);\n                }\n            },\n\n            constructLabelData: function() {\n                var labelData,\n                    severityColor = this.model.presentation.get('severityColor');\n\n                labelData = {\n                    name: this.labelClass,\n                    linkField: this.linkField,\n                    value: this.labelValue,\n                    fontSize: this.LABEL_FONT_SIZE + 'px',\n                    fontWeight: this.fontWeight,\n                    fontColor: this.labelFontColor,\n                    opacity: this.labelOpacity || 1\n                };\n\n                return labelData;\n            },\n\n            drawLabel: function(container, labelData) {\n                var labelGroup,\n                    labelText,\n                    labelAnchor;\n\n                labelGroup = svgUtil.createElement('g')\n                    .attr('class', 'svg-label');\n\n                labelText = svgUtil.createElement('text')\n                    .attr({\n                        x: labelData.x,\n                        y: labelData.y,\n                        'class': labelData.name\n                    })\n                    .css({\n                        'letter-spacing': this.isNumericLabelValue ? '-0.02em' : 'normal',\n                        'font-size' : labelData.fontSize,\n                        'font-weight' : labelData.fontWeight,\n                        'fill' : labelData.fontColor,\n                        'opacity': labelData.opacity\n                    });\n\n                var labelValue = (\"\" + labelData.value);\n\n                if (this.hasUnit && (this.unitPosition === \"before\")) {\n                    if ((/^\\-\\d/).test(labelValue)) {\n                        labelText.append(document.createTextNode('-'));\n                        labelValue = labelValue.substring(1);\n                    }\n\n                    if (this.exportMode) {\n                        // The export renderer does not support <tspan> elements,\n                        // work around it by prepending the unit directly to the main label.\n                        labelValue = \"\" + this.unit + labelValue;\n                    } else {\n                        var beforeSpan = svgUtil.createElement('tspan')\n                            .attr({\n                                'class': labelData.name + \"-unit\"\n                            })\n                            .css({\n                                'letter-spacing': 'normal'\n                            })\n                            .text(\"\" + this.unit);\n\n                        labelText.append(beforeSpan);\n                    }\n                }\n\n                labelText.append(document.createTextNode(labelValue));\n\n                if (this.hasUnit && (this.unitPosition === \"after\")) {\n                    if (this.exportMode) {\n                        // The export renderer does not support <tspan> elements,\n                        // work around it by appending the unit directly to the main label.\n                        labelText.append(document.createTextNode('\\u2009' + this.unit));  // u2009 = thin space\n                    } else {\n                        var afterSpan = svgUtil.createElement('tspan')\n                            .attr({\n                                'class': labelData.name + \"-unit\"\n                            })\n                            .css({\n                                'letter-spacing': 'normal'\n                            })\n                            .text('\\u2009' + this.unit);  // u2009 = thin space\n\n                        labelText.append(afterSpan);\n                    }\n                }\n\n                if (labelData.link) {\n                    labelAnchor = svgUtil.createElement('a')\n                        .attr({\n                            href: labelData.link.attr('href'),\n                            'class': labelData.link.attr('class')\n                        })\n                        .css({\n                            'text-decoration': 'none' // only style the <text> element itself, so that there is only 1 underline on hover\n                        });\n                    labelAnchor.data('value', labelData.value);\n                    labelAnchor.data('field', labelData.linkField);\n\n                    labelAnchor.append(labelText);\n                    labelGroup.append(labelAnchor);\n\n                    // IE requires that hover underline anchor styles are applied directly to the <text> element and not the surrounding anchor tag.\n                    // We must therefore dynamically apply a hover styling event handler as\n                    // we have no stylesheet for Single Value in which to use :hover pseudoselector for SVG\n                    labelText.hover(function(e) {\n                        labelText.css({ 'text-decoration': e.type === \"mouseenter\" ? 'underline' : 'none' });\n                    });\n                } else {\n                    labelGroup.append(labelText);\n                }\n                container.append(labelGroup);\n\n                this.labelElement = this.getLabelElement();\n            },\n\n            getWidth: function() {\n                return this.getBBox(this.labelElement).width;\n            },\n\n            getLeftX: function($label) {\n                return parseInt($label.attr('x'), 10);\n            },\n\n            getBBox: function($label) {\n                var bbox;\n                try {\n                    bbox = $label[0].getBBox();\n                } catch (e) {\n                    // FF throws blocking error if element is not yet in DOM and getBBox is called, so return dummy BBox.\n                    bbox = {\n                        x: 0,\n                        y: 0,\n                        width: 0,\n                        height: 0\n                    };\n                }\n                return bbox;\n            },\n\n            getRightX: function($label) {\n                return this.getLeftX($label) + this.getWidth($label);\n            },\n\n            getClientRect: function($label) {\n                return $label[0].getBoundingClientRect();\n            },\n\n            getLabelElement: function() {\n                var label = this.$('.' + this.labelClass);\n                if (label.length > 0) {\n                    return label;\n                }\n            },\n\n            wrapLinks: function(field, value) {\n                if (!this.model.application) {\n                    return;\n                }\n                var linkFields = this.model.state.get('display.visualizations.singlevalue.linkFields');\n                linkFields = linkFields ? $.trim(linkFields).split(/\\s*,\\s*/) : [];\n                var linkView = this.model.state.get('display.visualizations.singlevalue.linkView');\n                var linkSearch = this.model.state.get('display.visualizations.singlevalue.linkSearch');\n                var drilldown = this.model.state.get('display.visualizations.singlevalue.drilldown') || 'none';\n                var app = this.model.application.toJSON();\n\n                var link;\n                if ((linkView !== 'search' && linkFields.length) || linkSearch) {\n                    var url;\n                    if (linkView) {\n                        var params = linkSearch ? { q: linkSearch } : undefined;\n                        if (linkView.charAt(0) === '/') {\n                            url = splunkUtil.make_full_url(linkView, params);\n                        } else {\n                            url = route.page(app.root, app.locale, app.app, linkView, { data: params });\n                        }\n                    } else {\n                        url = route.search(app.root, app.locale, app.app, { data: { q: linkSearch }});\n                    }\n                    link = $('<a class=\"link-drilldown\" />').attr('href', url);\n                } else if (drilldown !== 'none') {\n                    link = $('<a class=\"single-drilldown\" href=\"#\"></a>');\n                    if (!_(linkFields).contains('result')) {\n                        linkFields.push('result');\n                    }\n                }\n\n                if (link) {\n                    link.data({\n                        field: field,\n                        value: value\n                    });\n                    return { linkFields: linkFields, link: link };\n                }\n            },\n\n            render: function() {\n                var labelGroup,\n                    labelData = this.constructLabelData(),\n                    resultFieldValue = this.model.results.get('resultFieldValue'),\n                    linkArray = this.wrapLinks(this.model.results.get('resultField'), resultFieldValue);\n\n                if (linkArray) {\n                    _.each(linkArray.linkFields, function(linkField) {\n                        if (this.linkField === linkField) {\n                            labelData.link = linkArray.link;\n                        }\n                    }, this);\n                }\n                labelGroup = this.$el.find('.' + this.labelGroupClass);\n                if (labelGroup.length > 0) {\n                    labelGroup.remove();\n                }\n                labelGroup = svgUtil.createElement('g')\n                    .attr('class', this.labelGroupClass);\n                this.$el.append(labelGroup);\n                this.drawLabel(labelGroup, labelData);\n                return this;\n            }\n        });\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9MYWJlbC5qcz84ZWQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQSxpQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsbUJBQW1CLEVBQUU7QUFDdkUsc0VBQXNFLHNCQUFzQixFQUFFO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw0REFBNEQsNEZBQTRGO0FBQ3hKLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEYscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0VBQW9FO0FBQzNHLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVGQUF1RixlQUFlO0FBQ3RHO0FBQ0EscUJBQXFCO0FBQ3JCLDJFQUEyRSxRQUFRLGlCQUFpQjtBQUNwRztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsNEJBQTRCO0FBQzVCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvSkFDQSIsImZpbGUiOiJ2aWV3cy9zaGFyZWQvc2luZ2xldmFsdWUvTGFiZWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoXG4gICAgW1xuICAgICAgICAnanF1ZXJ5JyxcbiAgICAgICAgJ3VuZGVyc2NvcmUnLFxuICAgICAgICAnbW9kdWxlJyxcbiAgICAgICAgJ3ZpZXdzL0Jhc2UnLFxuICAgICAgICAnbW9kZWxzL0Jhc2UnLFxuICAgICAgICAnc3BsdW5rLnV0aWwnLFxuICAgICAgICAndXRpbC9zdmcnLFxuICAgICAgICAndXRpbC9nZW5lcmFsX3V0aWxzJyxcbiAgICAgICAgJ3VyaS9yb3V0ZScsXG4gICAgICAgICd1dGlsL251bWVyYWwnXG4gICAgXSxcbiAgICBmdW5jdGlvbihcbiAgICAgICAgJCxcbiAgICAgICAgXyxcbiAgICAgICAgbW9kdWxlLFxuICAgICAgICBCYXNlVmlldyxcbiAgICAgICAgQmFzZU1vZGVsLFxuICAgICAgICBzcGx1bmtVdGlsLFxuICAgICAgICBzdmdVdGlsLFxuICAgICAgICBnZW5lcmFsVXRpbCxcbiAgICAgICAgcm91dGUsXG4gICAgICAgIG51bWVyYWxcbiAgICAgICAgKSB7XG5cbiAgICAgICAgdmFyIGdldFN0cmluZ1JlcHJlc2VudGF0aW9uID0gZnVuY3Rpb24obGFiZWwsIGZvcm1hdHRlZCkge1xuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsKGZvcm1hdHRlZCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBCYXNlVmlldy5leHRlbmQoe1xuICAgICAgICAgICAgbW9kdWxlSWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzaW5nbGUtdmFsdWUtbGFiZWxcIixcbiAgICAgICAgICAgIGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCdnJykuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdzaW5nbGUtdmFsdWUtbGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICAnZGF0YS1uYW1lJzogdGhpcy5vcHRpb25zLmNvbmZpZ05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBCYXNlVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLkxBQkVMX0ZPTlRfU0laRSA9IHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplO1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxGb250Q29sb3IgPSB0aGlzLm9wdGlvbnMubGFiZWxGb250Q29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbEdyb3VwQ2xhc3MgPSB0aGlzLm9wdGlvbnMubGFiZWxHcm91cENsYXNzO1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxDbGFzcyA9IHRoaXMub3B0aW9ucy5sYWJlbENsYXNzO1xuICAgICAgICAgICAgICAgIHRoaXMubGlua0ZpZWxkID0gdGhpcy5vcHRpb25zLmxpbmtGaWVsZDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdEZpZWxkVmFsdWUgPSB0aGlzLm1vZGVsLnJlc3VsdHMuZ2V0KCdyZXN1bHRGaWVsZFZhbHVlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdOYW1lID0gdGhpcy5vcHRpb25zLmNvbmZpZ05hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy51bml0ID0gdGhpcy5vcHRpb25zLnVuaXQ7XG4gICAgICAgICAgICAgICAgdGhpcy51bml0UG9zaXRpb24gPSB0aGlzLm9wdGlvbnMudW5pdFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzVW5pdCA9IHRoaXMub3B0aW9ucy5oYXNVbml0O1xuICAgICAgICAgICAgICAgIHRoaXMuaXNOdW1lcmljTGFiZWxWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlUmVzdWx0RmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTih0aGlzLnJlc3VsdEZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUgUmVzdWx0IExhYmVsIC0gbmVlZHMgZm9ybWF0dGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdFBhdHRlcm4gPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ2Zvcm1hdFBhdHRlcm4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWxWYWx1ZSA9IG51bWVyYWwodGhpcy5yZXN1bHRGaWVsZFZhbHVlKS5mb3JtYXQoZm9ybWF0UGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTnVtZXJpY0xhYmVsVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbFZhbHVlID0gdGhpcy5yZXN1bHRGaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbFZhbHVlID0gZ2V0U3RyaW5nUmVwcmVzZW50YXRpb24odGhpcy5tb2RlbC5zdGF0ZS5nZXQodGhpcy5jb25maWdOYW1lKSB8fCBcIlwiLCB0aGlzLnJlc3VsdEZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSB0aGlzLm9wdGlvbnMuZm9udFdlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsT3BhY2l0eSA9IHRoaXMub3B0aW9ucy5sYWJlbE9wYWNpdHk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBvcnRNb2RlID0gdGhpcy5vcHRpb25zLmV4cG9ydE1vZGU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgICAgICAnY2xpY2sgYS5zaW5nbGUtZHJpbGxkb3duJzogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNNb2RlbCA9IHRoaXMubW9kZWwucmVzdWx0cy5nZXQoJ3NlYXJjaFJlc3VsdHNDb2x1bW4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzID0gcmVzTW9kZWwuZ2V0KCdmaWVsZHMnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaWVsZHMgY2FuIGVpdGhlciBiZSBhIGxpc3Qgb2Ygc3RyaW5ncyBvciBhIGxpc3Qgb2YgZGljdGlvbmFyaWVzIGVhY2ggd2l0aCBhICduYW1lJyBlbnRyeVxuICAgICAgICAgICAgICAgICAgICAvLyBkZXBlbmRpbmcgb24gd2hldGhlciAnc2hvd19tZXRhZGF0YScgaXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc09iamVjdChuYW1lc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzID0gXyhuYW1lcykucGx1Y2soJ25hbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dDb250ZXh0ID0gXy5vYmplY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBfKG5hbWVzKS5tYXAoZnVuY3Rpb24oZikgeyByZXR1cm4gJ3Jvdy4nICsgZjsgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfKHJlc01vZGVsLmdldCgnY29sdW1ucycpKS5tYXAoZnVuY3Rpb24oY29sKSB7IHJldHVybiBfKGNvbCkubGFzdCgpOyB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmlsbGRvd25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGFyZ2V0LmRhdGEoJ2ZpZWxkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0LmRhdGEoJ3ZhbHVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZXh0OiByb3dDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjZWxsJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXN1bHRzIG1vZGVsIGhhcyBzcGFya2xpbmUgZGF0YSwgd2Ugd2FudCB0byBuYXJyb3cgdGhlIGRyaWxsZG93biB0aW1lIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBsYXN0IHRpbWUgYnVja2V0LCBzaW5jZSB0aGF0IGlzIHdoYXQgaXMgdXNlZCB0byBkaXNwbGF5IHRoZSBsYWJlbC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwucmVzdWx0cy5oYXMoJ3NwYXJrbGluZURhdGEnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVGaWVsZEluZGV4ID0gXyhuYW1lcykuaW5kZXhPZignX3RpbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuRmllbGRJbmRleCA9IF8obmFtZXMpLmluZGV4T2YoJ19zcGFuJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucyA9IHJlc01vZGVsLmdldCgnY29sdW1ucycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lc3RhbXAgPSBzcGx1bmtVdGlsLmdldEVwb2NoVGltZUZyb21JU08oXyhjb2x1bW5zW3RpbWVGaWVsZEluZGV4XSkubGFzdCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VGltZXNwYW4gPSBwYXJzZUZsb2F0KF8oY29sdW1uc1tzcGFuRmllbGRJbmRleF0pLmxhc3QoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRpbWUgcmFuZ2UgZHJpbGxkb3duIGhhcyB0byBiZSBkb25lIHdpdGggYG5hbWVgIGFuZCBgdmFsdWVgLCByZS1tYXAgdGhlIGN1cnJlbnQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSB0byBgbmFtZTJgIGFuZCBgdmFsdWUyYCBzbyB0aGF0IGNvbnN1bWVycyBzdGlsbCBoYXZlIGFjY2VzcyB0byB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgZHJpbGxkb3duSW5mby5uYW1lMiA9IGRyaWxsZG93bkluZm8ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyaWxsZG93bkluZm8udmFsdWUyID0gZHJpbGxkb3duSW5mby52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyaWxsZG93bkluZm8ubmFtZSA9ICdfdGltZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmlsbGRvd25JbmZvLnZhbHVlID0gbGFzdFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyaWxsZG93bkluZm8uX3NwYW4gPSBsYXN0VGltZXNwYW47XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmlsbGRvd25JbmZvLnJvd0NvbnRleHRbJ3Jvdy5fdGltZSddID0gbGFzdFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyaWxsZG93bkluZm8ucm93Q29udGV4dFsncm93Ll9zcGFuJ10gPSBsYXN0VGltZXNwYW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BlY2lmaWNFdmVudE5hbWVzID0gXyh0YXJnZXQuY2hpbGRyZW4oJ3RleHQnKS5hdHRyKCdjbGFzcycpLnNwbGl0KCcgJykpLm1hcChmdW5jdGlvbihjbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnY2xpY2s6JyArIGNscztcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3NpbmdsZURyaWxsZG93bkNsaWNrZWQnLCB7IHNwZWNpZmljRXZlbnROYW1lczogJ2NsaWNrIGRyaWxsZG93biAnICsgc3BlY2lmaWNFdmVudE5hbWVzLCBkcmlsbGRvd25JbmZvOiBkcmlsbGRvd25JbmZvIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2NsaWNrIGEubGluay1kcmlsbGRvd24nOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdhbmNob3JUYWdDbGlja2VkJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY29uc3RydWN0TGFiZWxEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxEYXRhLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eUNvbG9yID0gdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uZ2V0KCdzZXZlcml0eUNvbG9yJyk7XG5cbiAgICAgICAgICAgICAgICBsYWJlbERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubGFiZWxDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgbGlua0ZpZWxkOiB0aGlzLmxpbmtGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMubGFiZWxWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHRoaXMuTEFCRUxfRk9OVF9TSVpFICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogdGhpcy5mb250V2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBmb250Q29sb3I6IHRoaXMubGFiZWxGb250Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMubGFiZWxPcGFjaXR5IHx8IDFcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsRGF0YTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRyYXdMYWJlbDogZnVuY3Rpb24oY29udGFpbmVyLCBsYWJlbERhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxUZXh0LFxuICAgICAgICAgICAgICAgICAgICBsYWJlbEFuY2hvcjtcblxuICAgICAgICAgICAgICAgIGxhYmVsR3JvdXAgPSBzdmdVdGlsLmNyZWF0ZUVsZW1lbnQoJ2cnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnc3ZnLWxhYmVsJyk7XG5cbiAgICAgICAgICAgICAgICBsYWJlbFRleHQgPSBzdmdVdGlsLmNyZWF0ZUVsZW1lbnQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBsYWJlbERhdGEueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGxhYmVsRGF0YS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogbGFiZWxEYXRhLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbGV0dGVyLXNwYWNpbmcnOiB0aGlzLmlzTnVtZXJpY0xhYmVsVmFsdWUgPyAnLTAuMDJlbScgOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250LXNpemUnIDogbGFiZWxEYXRhLmZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JyA6IGxhYmVsRGF0YS5mb250V2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGwnIDogbGFiZWxEYXRhLmZvbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGFjaXR5JzogbGFiZWxEYXRhLm9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxWYWx1ZSA9IChcIlwiICsgbGFiZWxEYXRhLnZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1VuaXQgJiYgKHRoaXMudW5pdFBvc2l0aW9uID09PSBcImJlZm9yZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKC9eXFwtXFxkLykudGVzdChsYWJlbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxUZXh0LmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsVmFsdWUgPSBsYWJlbFZhbHVlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4cG9ydE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBleHBvcnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCA8dHNwYW4+IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgaXQgYnkgcHJlcGVuZGluZyB0aGUgdW5pdCBkaXJlY3RseSB0byB0aGUgbWFpbiBsYWJlbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsVmFsdWUgPSBcIlwiICsgdGhpcy51bml0ICsgbGFiZWxWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmVTcGFuID0gc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCd0c3BhbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBsYWJlbERhdGEubmFtZSArIFwiLXVuaXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZXR0ZXItc3BhY2luZyc6ICdub3JtYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGV4dChcIlwiICsgdGhpcy51bml0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxUZXh0LmFwcGVuZChiZWZvcmVTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWxWYWx1ZSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzVW5pdCAmJiAodGhpcy51bml0UG9zaXRpb24gPT09IFwiYWZ0ZXJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhwb3J0TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4cG9ydCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IDx0c3Bhbj4gZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBpdCBieSBhcHBlbmRpbmcgdGhlIHVuaXQgZGlyZWN0bHkgdG8gdGhlIG1haW4gbGFiZWwuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFRleHQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUyMDA5JyArIHRoaXMudW5pdCkpOyAgLy8gdTIwMDkgPSB0aGluIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJTcGFuID0gc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCd0c3BhbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBsYWJlbERhdGEubmFtZSArIFwiLXVuaXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZXR0ZXItc3BhY2luZyc6ICdub3JtYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGV4dCgnXFx1MjAwOScgKyB0aGlzLnVuaXQpOyAgLy8gdTIwMDkgPSB0aGluIHNwYWNlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dC5hcHBlbmQoYWZ0ZXJTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGEubGluaykge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbEFuY2hvciA9IHN2Z1V0aWwuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogbGFiZWxEYXRhLmxpbmsuYXR0cignaHJlZicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IGxhYmVsRGF0YS5saW5rLmF0dHIoJ2NsYXNzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnIC8vIG9ubHkgc3R5bGUgdGhlIDx0ZXh0PiBlbGVtZW50IGl0c2VsZiwgc28gdGhhdCB0aGVyZSBpcyBvbmx5IDEgdW5kZXJsaW5lIG9uIGhvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxBbmNob3IuZGF0YSgndmFsdWUnLCBsYWJlbERhdGEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbEFuY2hvci5kYXRhKCdmaWVsZCcsIGxhYmVsRGF0YS5saW5rRmllbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsQW5jaG9yLmFwcGVuZChsYWJlbFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbEdyb3VwLmFwcGVuZChsYWJlbEFuY2hvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgcmVxdWlyZXMgdGhhdCBob3ZlciB1bmRlcmxpbmUgYW5jaG9yIHN0eWxlcyBhcmUgYXBwbGllZCBkaXJlY3RseSB0byB0aGUgPHRleHQ+IGVsZW1lbnQgYW5kIG5vdCB0aGUgc3Vycm91bmRpbmcgYW5jaG9yIHRhZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbXVzdCB0aGVyZWZvcmUgZHluYW1pY2FsbHkgYXBwbHkgYSBob3ZlciBzdHlsaW5nIGV2ZW50IGhhbmRsZXIgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBubyBzdHlsZXNoZWV0IGZvciBTaW5nbGUgVmFsdWUgaW4gd2hpY2ggdG8gdXNlIDpob3ZlciBwc2V1ZG9zZWxlY3RvciBmb3IgU1ZHXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dC5ob3ZlcihmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFRleHQuY3NzKHsgJ3RleHQtZGVjb3JhdGlvbic6IGUudHlwZSA9PT0gXCJtb3VzZWVudGVyXCIgPyAndW5kZXJsaW5lJyA6ICdub25lJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxHcm91cC5hcHBlbmQobGFiZWxUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZChsYWJlbEdyb3VwKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxFbGVtZW50ID0gdGhpcy5nZXRMYWJlbEVsZW1lbnQoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCQm94KHRoaXMubGFiZWxFbGVtZW50KS53aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldExlZnRYOiBmdW5jdGlvbigkbGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoJGxhYmVsLmF0dHIoJ3gnKSwgMTApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0QkJveDogZnVuY3Rpb24oJGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJib3g7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYmJveCA9ICRsYWJlbFswXS5nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGRiB0aHJvd3MgYmxvY2tpbmcgZXJyb3IgaWYgZWxlbWVudCBpcyBub3QgeWV0IGluIERPTSBhbmQgZ2V0QkJveCBpcyBjYWxsZWQsIHNvIHJldHVybiBkdW1teSBCQm94LlxuICAgICAgICAgICAgICAgICAgICBiYm94ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJpZ2h0WDogZnVuY3Rpb24oJGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGVmdFgoJGxhYmVsKSArIHRoaXMuZ2V0V2lkdGgoJGxhYmVsKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENsaWVudFJlY3Q6IGZ1bmN0aW9uKCRsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbGFiZWxbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRMYWJlbEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuJCgnLicgKyB0aGlzLmxhYmVsQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB3cmFwTGlua3M6IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tb2RlbC5hcHBsaWNhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5rRmllbGRzID0gdGhpcy5tb2RlbC5zdGF0ZS5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUubGlua0ZpZWxkcycpO1xuICAgICAgICAgICAgICAgIGxpbmtGaWVsZHMgPSBsaW5rRmllbGRzID8gJC50cmltKGxpbmtGaWVsZHMpLnNwbGl0KC9cXHMqLFxccyovKSA6IFtdO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rVmlldyA9IHRoaXMubW9kZWwuc3RhdGUuZ2V0KCdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLmxpbmtWaWV3Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtTZWFyY2ggPSB0aGlzLm1vZGVsLnN0YXRlLmdldCgnZGlzcGxheS52aXN1YWxpemF0aW9ucy5zaW5nbGV2YWx1ZS5saW5rU2VhcmNoJyk7XG4gICAgICAgICAgICAgICAgdmFyIGRyaWxsZG93biA9IHRoaXMubW9kZWwuc3RhdGUuZ2V0KCdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLmRyaWxsZG93bicpIHx8ICdub25lJztcbiAgICAgICAgICAgICAgICB2YXIgYXBwID0gdGhpcy5tb2RlbC5hcHBsaWNhdGlvbi50b0pTT04oKTtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5rO1xuICAgICAgICAgICAgICAgIGlmICgobGlua1ZpZXcgIT09ICdzZWFyY2gnICYmIGxpbmtGaWVsZHMubGVuZ3RoKSB8fCBsaW5rU2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rVmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGxpbmtTZWFyY2ggPyB7IHE6IGxpbmtTZWFyY2ggfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5rVmlldy5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHNwbHVua1V0aWwubWFrZV9mdWxsX3VybChsaW5rVmlldywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gcm91dGUucGFnZShhcHAucm9vdCwgYXBwLmxvY2FsZSwgYXBwLmFwcCwgbGlua1ZpZXcsIHsgZGF0YTogcGFyYW1zIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gcm91dGUuc2VhcmNoKGFwcC5yb290LCBhcHAubG9jYWxlLCBhcHAuYXBwLCB7IGRhdGE6IHsgcTogbGlua1NlYXJjaCB9fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluayA9ICQoJzxhIGNsYXNzPVwibGluay1kcmlsbGRvd25cIiAvPicpLmF0dHIoJ2hyZWYnLCB1cmwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZHJpbGxkb3duICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluayA9ICQoJzxhIGNsYXNzPVwic2luZ2xlLWRyaWxsZG93blwiIGhyZWY9XCIjXCI+PC9hPicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV8obGlua0ZpZWxkcykuY29udGFpbnMoJ3Jlc3VsdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rRmllbGRzLnB1c2goJ3Jlc3VsdCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluay5kYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua0ZpZWxkczogbGlua0ZpZWxkcywgbGluazogbGluayB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YSA9IHRoaXMuY29uc3RydWN0TGFiZWxEYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEZpZWxkVmFsdWUgPSB0aGlzLm1vZGVsLnJlc3VsdHMuZ2V0KCdyZXN1bHRGaWVsZFZhbHVlJyksXG4gICAgICAgICAgICAgICAgICAgIGxpbmtBcnJheSA9IHRoaXMud3JhcExpbmtzKHRoaXMubW9kZWwucmVzdWx0cy5nZXQoJ3Jlc3VsdEZpZWxkJyksIHJlc3VsdEZpZWxkVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmtBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2gobGlua0FycmF5LmxpbmtGaWVsZHMsIGZ1bmN0aW9uKGxpbmtGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlua0ZpZWxkID09PSBsaW5rRmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGEubGluayA9IGxpbmtBcnJheS5saW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFiZWxHcm91cCA9IHRoaXMuJGVsLmZpbmQoJy4nICsgdGhpcy5sYWJlbEdyb3VwQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbEdyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxHcm91cC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFiZWxHcm91cCA9IHN2Z1V0aWwuY3JlYXRlRWxlbWVudCgnZycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIHRoaXMubGFiZWxHcm91cENsYXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5hcHBlbmQobGFiZWxHcm91cCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGFiZWwobGFiZWxHcm91cCwgbGFiZWxEYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy92aWV3cy9zaGFyZWQvc2luZ2xldmFsdWUvTGFiZWwuanNcbi8vIG1vZHVsZSBpZCA9IHZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9MYWJlbFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "util/numeral":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"stubs/i18n\"), __webpack_require__(\"shim/numeral\")], __WEBPACK_AMD_DEFINE_RESULT__ = function(i18n, numeral){\n    var initFn = i18n.numeral_install,\n        localeMap = {\n            'de_DE': 'de',\n            'en_DEBUG': 'en-debug',\n            'en_GB': 'en-gb',\n            'en_US': 'en-us',\n            'it_IT': 'it',\n            'ko_KR': 'ko',\n            'zh_CN': 'chs',\n            'zh_TW': 'chs-traditional'\n        };\n    if(typeof initFn === 'function') {\n        initFn(numeral);\n        numeral.language(localeMap[i18n.locale_name()]);\n    }\n    return numeral;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvbnVtZXJhbC5qcz9kZjdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJ1dGlsL251bWVyYWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydzcGx1bmsuaTE4bicsICdudW1lcmFsJ10sZnVuY3Rpb24oaTE4biwgbnVtZXJhbCl7XG4gICAgdmFyIGluaXRGbiA9IGkxOG4ubnVtZXJhbF9pbnN0YWxsLFxuICAgICAgICBsb2NhbGVNYXAgPSB7XG4gICAgICAgICAgICAnZGVfREUnOiAnZGUnLFxuICAgICAgICAgICAgJ2VuX0RFQlVHJzogJ2VuLWRlYnVnJyxcbiAgICAgICAgICAgICdlbl9HQic6ICdlbi1nYicsXG4gICAgICAgICAgICAnZW5fVVMnOiAnZW4tdXMnLFxuICAgICAgICAgICAgJ2l0X0lUJzogJ2l0JyxcbiAgICAgICAgICAgICdrb19LUic6ICdrbycsXG4gICAgICAgICAgICAnemhfQ04nOiAnY2hzJyxcbiAgICAgICAgICAgICd6aF9UVyc6ICdjaHMtdHJhZGl0aW9uYWwnXG4gICAgICAgIH07XG4gICAgaWYodHlwZW9mIGluaXRGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbml0Rm4obnVtZXJhbCk7XG4gICAgICAgIG51bWVyYWwubGFuZ3VhZ2UobG9jYWxlTWFwW2kxOG4ubG9jYWxlX25hbWUoKV0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVtZXJhbDtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy91dGlsL251bWVyYWwuanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvbnVtZXJhbFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "shim/numeral":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(269)], __WEBPACK_AMD_DEFINE_RESULT__ = function(numeral) {\n    // This shim is only needed for backwards compatibility. It makes numeral a\n    // global on the window object to support the language files in:\n    // web/search_mrsparkle/exposed/js/contrib/numeral/lang\n    // These language files are injected into i18n.js in the\n    // `write_numeral_translation` function of\n    // /Users/dstreit/splunk/source/main/python-site/splunk/appserver/mrsparkle/lib/i18n.py\n    return numeral;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NoaW0vbnVtZXJhbC5qcz9hNWZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJzaGltL251bWVyYWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydpbXBvcnRzP3RoaXM9PndpbmRvdyFjb250cmliL251bWVyYWwnXSwgZnVuY3Rpb24obnVtZXJhbCkge1xuICAgIC8vIFRoaXMgc2hpbSBpcyBvbmx5IG5lZWRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IG1ha2VzIG51bWVyYWwgYVxuICAgIC8vIGdsb2JhbCBvbiB0aGUgd2luZG93IG9iamVjdCB0byBzdXBwb3J0IHRoZSBsYW5ndWFnZSBmaWxlcyBpbjpcbiAgICAvLyB3ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbnVtZXJhbC9sYW5nXG4gICAgLy8gVGhlc2UgbGFuZ3VhZ2UgZmlsZXMgYXJlIGluamVjdGVkIGludG8gaTE4bi5qcyBpbiB0aGVcbiAgICAvLyBgd3JpdGVfbnVtZXJhbF90cmFuc2xhdGlvbmAgZnVuY3Rpb24gb2ZcbiAgICAvLyAvVXNlcnMvZHN0cmVpdC9zcGx1bmsvc291cmNlL21haW4vcHl0aG9uLXNpdGUvc3BsdW5rL2FwcHNlcnZlci9tcnNwYXJrbGUvbGliL2kxOG4ucHlcbiAgICByZXR1cm4gbnVtZXJhbDtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zaGltL251bWVyYWwuanNcbi8vIG1vZHVsZSBpZCA9IHNoaW0vbnVtZXJhbFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 269:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n/*!\n * numeral.js\n * version : 1.5.3\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n\n(function () {\n\n    /************************************\n        Constants\n    ************************************/\n\n    var numeral,\n        VERSION = '1.5.3',\n        // internal storage for language config files\n        languages = {},\n        currentLanguage = 'en',\n        zeroFormat = null,\n        defaultFormat = '0,0',\n        // check for nodeJS\n        hasModule = (typeof module !== 'undefined' && module.exports);\n\n\n    /************************************\n        Constructors\n    ************************************/\n\n\n    // Numeral prototype object\n    function Numeral (number) {\n        this._value = number;\n    }\n\n    /**\n     * Implementation of toFixed() that treats floats more like decimals\n     *\n     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n     * problems for accounting- and finance-related software.\n     */\n    function toFixed (value, precision, roundingFunction, optionals) {\n        var power = Math.pow(10, precision),\n            optionalsRegExp,\n            output;\n            \n        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);\n        // Multiply up by precision, round accurately, then divide and use native toFixed():\n        output = (roundingFunction(value * power) / power).toFixed(precision);\n\n        if (optionals) {\n            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');\n            output = output.replace(optionalsRegExp, '');\n        }\n\n        return output;\n    }\n\n    /************************************\n        Formatting\n    ************************************/\n\n    // determine what type of formatting we need to do\n    function formatNumeral (n, format, roundingFunction) {\n        var output;\n\n        // figure out what kind of format we are dealing with\n        if (format.indexOf('$') > -1) { // currency!!!!!\n            output = formatCurrency(n, format, roundingFunction);\n        } else if (format.indexOf('%') > -1) { // percentage\n            output = formatPercentage(n, format, roundingFunction);\n        } else if (format.indexOf(':') > -1) { // time\n            output = formatTime(n, format);\n        } else { // plain ol' numbers or bytes\n            output = formatNumber(n._value, format, roundingFunction);\n        }\n\n        // return string\n        return output;\n    }\n\n    // revert to number\n    function unformatNumeral (n, string) {\n        var stringOriginal = string,\n            thousandRegExp,\n            millionRegExp,\n            billionRegExp,\n            trillionRegExp,\n            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n            bytesMultiplier = false,\n            power;\n\n        if (string.indexOf(':') > -1) {\n            n._value = unformatTime(string);\n        } else {\n            if (string === zeroFormat) {\n                n._value = 0;\n            } else {\n                if (languages[currentLanguage].delimiters.decimal !== '.') {\n                    string = string.replace(/\\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');\n                }\n\n                // see if abbreviations are there so that we can multiply to the correct number\n                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\\\)|(\\\\' + languages[currentLanguage].currency.symbol + ')?(?:\\\\))?)?$');\n\n                // see if bytes are there so that we can multiply to the correct number\n                for (power = 0; power <= suffixes.length; power++) {\n                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;\n\n                    if (bytesMultiplier) {\n                        break;\n                    }\n                }\n\n                // do some math to create our number\n                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\\.]+/g, ''));\n\n                // round if we are talking about bytes\n                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;\n            }\n        }\n        return n._value;\n    }\n\n    function formatCurrency (n, format, roundingFunction) {\n        var symbolIndex = format.indexOf('$'),\n            openParenIndex = format.indexOf('('),\n            minusSignIndex = format.indexOf('-'),\n            space = '',\n            spliceIndex,\n            output;\n\n        // check for space before or after currency\n        if (format.indexOf(' $') > -1) {\n            space = ' ';\n            format = format.replace(' $', '');\n        } else if (format.indexOf('$ ') > -1) {\n            space = ' ';\n            format = format.replace('$ ', '');\n        } else {\n            format = format.replace('$', '');\n        }\n\n        // format the number\n        output = formatNumber(n._value, format, roundingFunction);\n\n        // position the symbol\n        if (symbolIndex <= 1) {\n            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {\n                output = output.split('');\n                spliceIndex = 1;\n                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){\n                    // the symbol appears before the \"(\" or \"-\"\n                    spliceIndex = 0;\n                }\n                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);\n                output = output.join('');\n            } else {\n                output = languages[currentLanguage].currency.symbol + space + output;\n            }\n        } else {\n            if (output.indexOf(')') > -1) {\n                output = output.split('');\n                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);\n                output = output.join('');\n            } else {\n                output = output + space + languages[currentLanguage].currency.symbol;\n            }\n        }\n\n        return output;\n    }\n\n    function formatPercentage (n, format, roundingFunction) {\n        var space = '',\n            output,\n            value = n._value * 100;\n\n        // check for space before %\n        if (format.indexOf(' %') > -1) {\n            space = ' ';\n            format = format.replace(' %', '');\n        } else {\n            format = format.replace('%', '');\n        }\n\n        output = formatNumber(value, format, roundingFunction);\n        \n        if (output.indexOf(')') > -1 ) {\n            output = output.split('');\n            output.splice(-1, 0, space + '%');\n            output = output.join('');\n        } else {\n            output = output + space + '%';\n        }\n\n        return output;\n    }\n\n    function formatTime (n) {\n        var hours = Math.floor(n._value/60/60),\n            minutes = Math.floor((n._value - (hours * 60 * 60))/60),\n            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));\n        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);\n    }\n\n    function unformatTime (string) {\n        var timeArray = string.split(':'),\n            seconds = 0;\n        // turn hours and minutes into seconds and add them all up\n        if (timeArray.length === 3) {\n            // hours\n            seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n            // minutes\n            seconds = seconds + (Number(timeArray[1]) * 60);\n            // seconds\n            seconds = seconds + Number(timeArray[2]);\n        } else if (timeArray.length === 2) {\n            // minutes\n            seconds = seconds + (Number(timeArray[0]) * 60);\n            // seconds\n            seconds = seconds + Number(timeArray[1]);\n        }\n        return Number(seconds);\n    }\n\n    function formatNumber (value, format, roundingFunction) {\n        var negP = false,\n            signed = false,\n            optDec = false,\n            abbr = '',\n            abbrK = false, // force abbreviation to thousands\n            abbrM = false, // force abbreviation to millions\n            abbrB = false, // force abbreviation to billions\n            abbrT = false, // force abbreviation to trillions\n            abbrForce = false, // force abbreviation\n            bytes = '',\n            ord = '',\n            abs = Math.abs(value),\n            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n            min,\n            max,\n            power,\n            w,\n            precision,\n            thousands,\n            d = '',\n            neg = false;\n\n        // check if number is zero and a custom zero format has been set\n        if (value === 0 && zeroFormat !== null) {\n            return zeroFormat;\n        } else {\n            // see if we should use parentheses for negative number or if we should prefix with a sign\n            // if both are present we default to parentheses\n            if (format.indexOf('(') > -1) {\n                negP = true;\n                format = format.slice(1, -1);\n            } else if (format.indexOf('+') > -1) {\n                signed = true;\n                format = format.replace(/\\+/g, '');\n            }\n\n            // see if abbreviation is wanted\n            if (format.indexOf('a') > -1) {\n                // check if abbreviation is specified\n                abbrK = format.indexOf('aK') >= 0;\n                abbrM = format.indexOf('aM') >= 0;\n                abbrB = format.indexOf('aB') >= 0;\n                abbrT = format.indexOf('aT') >= 0;\n                abbrForce = abbrK || abbrM || abbrB || abbrT;\n\n                // check for space before abbreviation\n                if (format.indexOf(' a') > -1) {\n                    abbr = ' ';\n                    format = format.replace(' a', '');\n                } else {\n                    format = format.replace('a', '');\n                }\n\n                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {\n                    // trillion\n                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;\n                    value = value / Math.pow(10, 12);\n                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {\n                    // billion\n                    abbr = abbr + languages[currentLanguage].abbreviations.billion;\n                    value = value / Math.pow(10, 9);\n                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {\n                    // million\n                    abbr = abbr + languages[currentLanguage].abbreviations.million;\n                    value = value / Math.pow(10, 6);\n                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {\n                    // thousand\n                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;\n                    value = value / Math.pow(10, 3);\n                }\n            }\n\n            // see if we are formatting bytes\n            if (format.indexOf('b') > -1) {\n                // check for space before\n                if (format.indexOf(' b') > -1) {\n                    bytes = ' ';\n                    format = format.replace(' b', '');\n                } else {\n                    format = format.replace('b', '');\n                }\n\n                for (power = 0; power <= suffixes.length; power++) {\n                    min = Math.pow(1024, power);\n                    max = Math.pow(1024, power+1);\n\n                    if (value >= min && value < max) {\n                        bytes = bytes + suffixes[power];\n                        if (min > 0) {\n                            value = value / min;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            // see if ordinal is wanted\n            if (format.indexOf('o') > -1) {\n                // check for space before\n                if (format.indexOf(' o') > -1) {\n                    ord = ' ';\n                    format = format.replace(' o', '');\n                } else {\n                    format = format.replace('o', '');\n                }\n\n                ord = ord + languages[currentLanguage].ordinal(value);\n            }\n\n            if (format.indexOf('[.]') > -1) {\n                optDec = true;\n                format = format.replace('[.]', '.');\n            }\n\n            w = value.toString().split('.')[0];\n            precision = format.split('.')[1];\n            thousands = format.indexOf(',');\n\n            if (precision) {\n                if (precision.indexOf('[') > -1) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\n                } else {\n                    d = toFixed(value, precision.length, roundingFunction);\n                }\n\n                w = d.split('.')[0];\n\n                if (d.split('.')[1].length) {\n                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];\n                } else {\n                    d = '';\n                }\n\n                if (optDec && Number(d.slice(1)) === 0) {\n                    d = '';\n                }\n            } else {\n                w = toFixed(value, null, roundingFunction);\n            }\n\n            // format number\n            if (w.indexOf('-') > -1) {\n                w = w.slice(1);\n                neg = true;\n            }\n\n            if (thousands > -1) {\n                w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);\n            }\n\n            if (format.indexOf('.') === 0) {\n                w = '';\n            }\n\n            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');\n        }\n    }\n\n    /************************************\n        Top Level Functions\n    ************************************/\n\n    numeral = function (input) {\n        if (numeral.isNumeral(input)) {\n            input = input.value();\n        } else if (input === 0 || typeof input === 'undefined') {\n            input = 0;\n        } else if (!Number(input)) {\n            input = numeral.fn.unformat(input);\n        }\n\n        return new Numeral(Number(input));\n    };\n\n    // version number\n    numeral.version = VERSION;\n\n    // compare numeral object\n    numeral.isNumeral = function (obj) {\n        return obj instanceof Numeral;\n    };\n\n    // This function will load languages and then set the global language.  If\n    // no arguments are passed in, it will simply return the current global\n    // language key.\n    numeral.language = function (key, values) {\n        if (!key) {\n            return currentLanguage;\n        }\n\n        if (key && !values) {\n            if(!languages[key]) {\n                throw new Error('Unknown language : ' + key);\n            }\n            currentLanguage = key;\n        }\n\n        if (values || !languages[key]) {\n            loadLanguage(key, values);\n        }\n\n        return numeral;\n    };\n    \n    // This function provides access to the loaded language data.  If\n    // no arguments are passed in, it will simply return the current\n    // global language object.\n    numeral.languageData = function (key) {\n        if (!key) {\n            return languages[currentLanguage];\n        }\n        \n        if (!languages[key]) {\n            throw new Error('Unknown language : ' + key);\n        }\n        \n        return languages[key];\n    };\n\n    numeral.language('en', {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function (number) {\n            var b = number % 10;\n            return (~~ (number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$'\n        }\n    });\n\n    numeral.zeroFormat = function (format) {\n        zeroFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.defaultFormat = function (format) {\n        defaultFormat = typeof(format) === 'string' ? format : '0.0';\n    };\n\n    /************************************\n        Helpers\n    ************************************/\n\n    function loadLanguage(key, values) {\n        languages[key] = values;\n    }\n\n    /************************************\n        Floating-point helpers\n    ************************************/\n\n    // The floating-point helper functions and implementation\n    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/\n\n    /**\n     * Array.prototype.reduce for browsers that don't support it\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility\n     */\n    if ('function' !== typeof Array.prototype.reduce) {\n        Array.prototype.reduce = function (callback, opt_initialValue) {\n            'use strict';\n            \n            if (null === this || 'undefined' === typeof this) {\n                // At the moment all modern browsers, that support strict mode, have\n                // native implementation of Array.prototype.reduce. For instance, IE8\n                // does not support strict mode, so this check is actually useless.\n                throw new TypeError('Array.prototype.reduce called on null or undefined');\n            }\n            \n            if ('function' !== typeof callback) {\n                throw new TypeError(callback + ' is not a function');\n            }\n\n            var index,\n                value,\n                length = this.length >>> 0,\n                isValueSet = false;\n\n            if (1 < arguments.length) {\n                value = opt_initialValue;\n                isValueSet = true;\n            }\n\n            for (index = 0; length > index; ++index) {\n                if (this.hasOwnProperty(index)) {\n                    if (isValueSet) {\n                        value = callback(value, this[index], index, this);\n                    } else {\n                        value = this[index];\n                        isValueSet = true;\n                    }\n                }\n            }\n\n            if (!isValueSet) {\n                throw new TypeError('Reduce of empty array with no initial value');\n            }\n\n            return value;\n        };\n    }\n\n    \n    /**\n     * Computes the multiplier necessary to make x >= 1,\n     * effectively eliminating miscalculations caused by\n     * finite precision.\n     */\n    function multiplier(x) {\n        var parts = x.toString().split('.');\n        if (parts.length < 2) {\n            return 1;\n        }\n        return Math.pow(10, parts[1].length);\n    }\n\n    /**\n     * Given a variable number of arguments, returns the maximum\n     * multiplier that must be used to normalize an operation involving\n     * all of them.\n     */\n    function correctionFactor() {\n        var args = Array.prototype.slice.call(arguments);\n        return args.reduce(function (prev, next) {\n            var mp = multiplier(prev),\n                mn = multiplier(next);\n        return mp > mn ? mp : mn;\n        }, -Infinity);\n    }        \n\n\n    /************************************\n        Numeral Prototype\n    ************************************/\n\n\n    numeral.fn = Numeral.prototype = {\n\n        clone : function () {\n            return numeral(this);\n        },\n\n        format : function (inputString, roundingFunction) {\n            return formatNumeral(this, \n                  inputString ? inputString : defaultFormat, \n                  (roundingFunction !== undefined) ? roundingFunction : Math.round\n              );\n        },\n\n        unformat : function (inputString) {\n            if (Object.prototype.toString.call(inputString) === '[object Number]') { \n                return inputString; \n            }\n            return unformatNumeral(this, inputString ? inputString : defaultFormat);\n        },\n\n        value : function () {\n            return this._value;\n        },\n\n        valueOf : function () {\n            return this._value;\n        },\n\n        set : function (value) {\n            this._value = Number(value);\n            return this;\n        },\n\n        add : function (value) {\n            var corrFactor = correctionFactor.call(null, this._value, value);\n            function cback(accum, curr, currI, O) {\n                return accum + corrFactor * curr;\n            }\n            this._value = [this._value, value].reduce(cback, 0) / corrFactor;\n            return this;\n        },\n\n        subtract : function (value) {\n            var corrFactor = correctionFactor.call(null, this._value, value);\n            function cback(accum, curr, currI, O) {\n                return accum - corrFactor * curr;\n            }\n            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            \n            return this;\n        },\n\n        multiply : function (value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = correctionFactor(accum, curr);\n                return (accum * corrFactor) * (curr * corrFactor) /\n                    (corrFactor * corrFactor);\n            }\n            this._value = [this._value, value].reduce(cback, 1);\n            return this;\n        },\n\n        divide : function (value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = correctionFactor(accum, curr);\n                return (accum * corrFactor) / (curr * corrFactor);\n            }\n            this._value = [this._value, value].reduce(cback);            \n            return this;\n        },\n\n        difference : function (value) {\n            return Math.abs(numeral(this._value).subtract(value).value());\n        }\n\n    };\n\n    /************************************\n        Exposing Numeral\n    ************************************/\n\n    // CommonJS module is defined\n    if (hasModule) {\n        module.exports = numeral;\n    }\n\n    /*global ender:false */\n    if (typeof ender === 'undefined') {\n        // here, `this` means `window` in the browser, or `global` on the server\n        // add `numeral` as a global object via a string identifier,\n        // for Closure Compiler 'advanced' mode\n        this['numeral'] = numeral;\n    }\n\n    /*global define:false */\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return numeral;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n}).call(this);\n}.call(window));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbnVtZXJhbC5qcz85MGNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxvQkFBb0I7QUFDaEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELEVBQUU7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsSzs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9GO0FBQ0EsbUM7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUY7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0QsQ0FBQyIsImZpbGUiOiIyNjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG4oZnVuY3Rpb24oKSB7XG5cbi8qIVxuICogbnVtZXJhbC5qc1xuICogdmVyc2lvbiA6IDEuNS4zXG4gKiBhdXRob3IgOiBBZGFtIERyYXBlclxuICogbGljZW5zZSA6IE1JVFxuICogaHR0cDovL2FkYW13ZHJhcGVyLmdpdGh1Yi5jb20vTnVtZXJhbC1qcy9cbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdGFudHNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgbnVtZXJhbCxcbiAgICAgICAgVkVSU0lPTiA9ICcxLjUuMycsXG4gICAgICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxhbmd1YWdlIGNvbmZpZyBmaWxlc1xuICAgICAgICBsYW5ndWFnZXMgPSB7fSxcbiAgICAgICAgY3VycmVudExhbmd1YWdlID0gJ2VuJyxcbiAgICAgICAgemVyb0Zvcm1hdCA9IG51bGwsXG4gICAgICAgIGRlZmF1bHRGb3JtYXQgPSAnMCwwJyxcbiAgICAgICAgLy8gY2hlY2sgZm9yIG5vZGVKU1xuICAgICAgICBoYXNNb2R1bGUgPSAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0cnVjdG9yc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gTnVtZXJhbCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTnVtZXJhbCAobnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSB0aGF0IHRyZWF0cyBmbG9hdHMgbW9yZSBsaWtlIGRlY2ltYWxzXG4gICAgICpcbiAgICAgKiBGaXhlcyBiaW5hcnkgcm91bmRpbmcgaXNzdWVzIChlZy4gKDAuNjE1KS50b0ZpeGVkKDIpID09PSAnMC42MScpIHRoYXQgcHJlc2VudFxuICAgICAqIHByb2JsZW1zIGZvciBhY2NvdW50aW5nLSBhbmQgZmluYW5jZS1yZWxhdGVkIHNvZnR3YXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRml4ZWQgKHZhbHVlLCBwcmVjaXNpb24sIHJvdW5kaW5nRnVuY3Rpb24sIG9wdGlvbmFscykge1xuICAgICAgICB2YXIgcG93ZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKSxcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCxcbiAgICAgICAgICAgIG91dHB1dDtcbiAgICAgICAgICAgIFxuICAgICAgICAvL3JvdW5kaW5nRnVuY3Rpb24gPSAocm91bmRpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmQpO1xuICAgICAgICAvLyBNdWx0aXBseSB1cCBieSBwcmVjaXNpb24sIHJvdW5kIGFjY3VyYXRlbHksIHRoZW4gZGl2aWRlIGFuZCB1c2UgbmF0aXZlIHRvRml4ZWQoKTpcbiAgICAgICAgb3V0cHV0ID0gKHJvdW5kaW5nRnVuY3Rpb24odmFsdWUgKiBwb3dlcikgLyBwb3dlcikudG9GaXhlZChwcmVjaXNpb24pO1xuXG4gICAgICAgIGlmIChvcHRpb25hbHMpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCA9IG5ldyBSZWdFeHAoJzB7MSwnICsgb3B0aW9uYWxzICsgJ30kJyk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShvcHRpb25hbHNSZWdFeHAsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGb3JtYXR0aW5nXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoYXQgdHlwZSBvZiBmb3JtYXR0aW5nIHdlIG5lZWQgdG8gZG9cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1lcmFsIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG91dHB1dDtcblxuICAgICAgICAvLyBmaWd1cmUgb3V0IHdoYXQga2luZCBvZiBmb3JtYXQgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyQnKSA+IC0xKSB7IC8vIGN1cnJlbmN5ISEhISFcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEN1cnJlbmN5KG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJyUnKSA+IC0xKSB7IC8vIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdFBlcmNlbnRhZ2UobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignOicpID4gLTEpIHsgLy8gdGltZVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0VGltZShuLCBmb3JtYXQpO1xuICAgICAgICB9IGVsc2UgeyAvLyBwbGFpbiBvbCcgbnVtYmVycyBvciBieXRlc1xuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKG4uX3ZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHN0cmluZ1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8vIHJldmVydCB0byBudW1iZXJcbiAgICBmdW5jdGlvbiB1bmZvcm1hdE51bWVyYWwgKG4sIHN0cmluZykge1xuICAgICAgICB2YXIgc3RyaW5nT3JpZ2luYWwgPSBzdHJpbmcsXG4gICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCxcbiAgICAgICAgICAgIG1pbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBiaWxsaW9uUmVnRXhwLFxuICAgICAgICAgICAgdHJpbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBzdWZmaXhlcyA9IFsnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IGZhbHNlLFxuICAgICAgICAgICAgcG93ZXI7XG5cbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICAgICAgbi5fdmFsdWUgPSB1bmZvcm1hdFRpbWUoc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcgPT09IHplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBuLl92YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFwuL2csJycpLnJlcGxhY2UobGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsLCAnLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb25zIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRob3VzYW5kICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcbiAgICAgICAgICAgICAgICBtaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMubWlsbGlvbiArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG4gICAgICAgICAgICAgICAgYmlsbGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLmJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuICAgICAgICAgICAgICAgIHRyaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudHJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIGJ5dGVzIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IChzdHJpbmcuaW5kZXhPZihzdWZmaXhlc1twb3dlcl0pID4gLTEpID8gTWF0aC5wb3coMTAyNCwgcG93ZXIgKyAxKSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlc011bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gc29tZSBtYXRoIHRvIGNyZWF0ZSBvdXIgbnVtYmVyXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoKGJ5dGVzTXVsdGlwbGllcikgPyBieXRlc011bHRpcGxpZXIgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2godGhvdXNhbmRSZWdFeHApKSA/IE1hdGgucG93KDEwLCAzKSA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaChtaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgNikgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2goYmlsbGlvblJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDkpIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKHRyaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgMTIpIDogMSkgKiAoKHN0cmluZy5pbmRleE9mKCclJykgPiAtMSkgPyAwLjAxIDogMSkgKiAoKChzdHJpbmcuc3BsaXQoJy0nKS5sZW5ndGggKyBNYXRoLm1pbihzdHJpbmcuc3BsaXQoJygnKS5sZW5ndGgtMSwgc3RyaW5nLnNwbGl0KCcpJykubGVuZ3RoLTEpKSAlIDIpPyAxOiAtMSkgKiBOdW1iZXIoc3RyaW5nLnJlcGxhY2UoL1teMC05XFwuXSsvZywgJycpKTtcblxuICAgICAgICAgICAgICAgIC8vIHJvdW5kIGlmIHdlIGFyZSB0YWxraW5nIGFib3V0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoYnl0ZXNNdWx0aXBsaWVyKSA/IE1hdGguY2VpbChuLl92YWx1ZSkgOiBuLl92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5fdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0Q3VycmVuY3kgKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgc3ltYm9sSW5kZXggPSBmb3JtYXQuaW5kZXhPZignJCcpLFxuICAgICAgICAgICAgb3BlblBhcmVuSW5kZXggPSBmb3JtYXQuaW5kZXhPZignKCcpLFxuICAgICAgICAgICAgbWludXNTaWduSW5kZXggPSBmb3JtYXQuaW5kZXhPZignLScpLFxuICAgICAgICAgICAgc3BhY2UgPSAnJyxcbiAgICAgICAgICAgIHNwbGljZUluZGV4LFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgb3IgYWZ0ZXIgY3VycmVuY3lcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgJCcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyAkJywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCckICcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQgJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQnLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JtYXQgdGhlIG51bWJlclxuICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIobi5fdmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5bWJvbFxuICAgICAgICBpZiAoc3ltYm9sSW5kZXggPD0gMSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcoJykgPiAtMSB8fCBvdXRwdXQuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIHNwbGljZUluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sSW5kZXggPCBvcGVuUGFyZW5JbmRleCB8fCBzeW1ib2xJbmRleCA8IG1pbnVzU2lnbkluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN5bWJvbCBhcHBlYXJzIGJlZm9yZSB0aGUgXCIoXCIgb3IgXCItXCJcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKHNwbGljZUluZGV4LCAwLCBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSArIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQZXJjZW50YWdlIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHNwYWNlID0gJycsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICB2YWx1ZSA9IG4uX3ZhbHVlICogMTAwO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgJVxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyAlJykgPiAtMSkge1xuICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnICUnLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEgKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgb3V0cHV0LnNwbGljZSgtMSwgMCwgc3BhY2UgKyAnJScpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgc3BhY2UgKyAnJSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFRpbWUgKG4pIHtcbiAgICAgICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihuLl92YWx1ZS82MC82MCksXG4gICAgICAgICAgICBtaW51dGVzID0gTWF0aC5mbG9vcigobi5fdmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSkvNjApLFxuICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgucm91bmQobi5fdmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSAtIChtaW51dGVzICogNjApKTtcbiAgICAgICAgcmV0dXJuIGhvdXJzICsgJzonICsgKChtaW51dGVzIDwgMTApID8gJzAnICsgbWludXRlcyA6IG1pbnV0ZXMpICsgJzonICsgKChzZWNvbmRzIDwgMTApID8gJzAnICsgc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZm9ybWF0VGltZSAoc3RyaW5nKSB7XG4gICAgICAgIHZhciB0aW1lQXJyYXkgPSBzdHJpbmcuc3BsaXQoJzonKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSAwO1xuICAgICAgICAvLyB0dXJuIGhvdXJzIGFuZCBtaW51dGVzIGludG8gc2Vjb25kcyBhbmQgYWRkIHRoZW0gYWxsIHVwXG4gICAgICAgIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyAoTnVtYmVyKHRpbWVBcnJheVswXSkgKiA2MCAqIDYwKTtcbiAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMV0pICogNjApO1xuICAgICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzJdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwKTtcbiAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgTnVtYmVyKHRpbWVBcnJheVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcihzZWNvbmRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIgKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG5lZ1AgPSBmYWxzZSxcbiAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlLFxuICAgICAgICAgICAgb3B0RGVjID0gZmFsc2UsXG4gICAgICAgICAgICBhYmJyID0gJycsXG4gICAgICAgICAgICBhYmJySyA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gdGhvdXNhbmRzXG4gICAgICAgICAgICBhYmJyTSA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gbWlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJCID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byBiaWxsaW9uc1xuICAgICAgICAgICAgYWJiclQgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIHRyaWxsaW9uc1xuICAgICAgICAgICAgYWJickZvcmNlID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgYnl0ZXMgPSAnJyxcbiAgICAgICAgICAgIG9yZCA9ICcnLFxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnModmFsdWUpLFxuICAgICAgICAgICAgc3VmZml4ZXMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgdyxcbiAgICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAgIHRob3VzYW5kcyxcbiAgICAgICAgICAgIGQgPSAnJyxcbiAgICAgICAgICAgIG5lZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIG51bWJlciBpcyB6ZXJvIGFuZCBhIGN1c3RvbSB6ZXJvIGZvcm1hdCBoYXMgYmVlbiBzZXRcbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHplcm9Gb3JtYXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRm9ybWF0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2VlIGlmIHdlIHNob3VsZCB1c2UgcGFyZW50aGVzZXMgZm9yIG5lZ2F0aXZlIG51bWJlciBvciBpZiB3ZSBzaG91bGQgcHJlZml4IHdpdGggYSBzaWduXG4gICAgICAgICAgICAvLyBpZiBib3RoIGFyZSBwcmVzZW50IHdlIGRlZmF1bHQgdG8gcGFyZW50aGVzZXNcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignKCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBuZWdQID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignKycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXCsvZywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWUgaWYgYWJicmV2aWF0aW9uIGlzIHdhbnRlZFxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdhJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFiYnJldmlhdGlvbiBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICBhYmJySyA9IGZvcm1hdC5pbmRleE9mKCdhSycpID49IDA7XG4gICAgICAgICAgICAgICAgYWJick0gPSBmb3JtYXQuaW5kZXhPZignYU0nKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJCID0gZm9ybWF0LmluZGV4T2YoJ2FCJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyVCA9IGZvcm1hdC5pbmRleE9mKCdhVCcpID49IDA7XG4gICAgICAgICAgICAgICAgYWJickZvcmNlID0gYWJicksgfHwgYWJick0gfHwgYWJickIgfHwgYWJiclQ7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGEnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgYScsICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnYScsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWJzID49IE1hdGgucG93KDEwLCAxMikgJiYgIWFiYnJGb3JjZSB8fCBhYmJyVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudHJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgMTIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgTWF0aC5wb3coMTAsIDEyKSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDkpICYmICFhYmJyRm9yY2UgfHwgYWJickIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMuYmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA5KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDYpICYmICFhYmJyRm9yY2UgfHwgYWJick0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMubWlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA2KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDMpICYmICFhYmJyRm9yY2UgfHwgYWJickspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhvdXNhbmRcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRob3VzYW5kO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIHdlIGFyZSBmb3JtYXR0aW5nIGJ5dGVzXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ2InKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGInKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIGInLCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2InLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChwb3dlciA9IDA7IHBvd2VyIDw9IHN1ZmZpeGVzLmxlbmd0aDsgcG93ZXIrKykge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLnBvdygxMDI0LCBwb3dlcik7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgucG93KDEwMjQsIHBvd2VyKzEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMgKyBzdWZmaXhlc1twb3dlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIG9yZGluYWwgaXMgd2FudGVkXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ28nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIG8nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBvJywgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdvJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9yZCA9IG9yZCArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLm9yZGluYWwodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ1suXScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvcHREZWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdbLl0nLCAnLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpWzBdO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gZm9ybWF0LnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICB0aG91c2FuZHMgPSBmb3JtYXQuaW5kZXhPZignLCcpO1xuXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbi5pbmRleE9mKCdbJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24ucmVwbGFjZSgnXScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnNwbGl0KCdbJyk7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB0b0ZpeGVkKHZhbHVlLCAocHJlY2lzaW9uWzBdLmxlbmd0aCArIHByZWNpc2lvblsxXS5sZW5ndGgpLCByb3VuZGluZ0Z1bmN0aW9uLCBwcmVjaXNpb25bMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uLmxlbmd0aCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdyA9IGQuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChkLnNwbGl0KCcuJylbMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwgKyBkLnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHREZWMgJiYgTnVtYmVyKGQuc2xpY2UoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSB0b0ZpeGVkKHZhbHVlLCBudWxsLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9ybWF0IG51bWJlclxuICAgICAgICAgICAgaWYgKHcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB3ID0gdy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBuZWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhvdXNhbmRzID4gLTEpIHtcbiAgICAgICAgICAgICAgICB3ID0gdy50b1N0cmluZygpLnJlcGxhY2UoLyhcXGQpKD89KFxcZHszfSkrKD8hXFxkKSkvZywgJyQxJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMudGhvdXNhbmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoKG5lZ1AgJiYgbmVnKSA/ICcoJyA6ICcnKSArICgoIW5lZ1AgJiYgbmVnKSA/ICctJyA6ICcnKSArICgoIW5lZyAmJiBzaWduZWQpID8gJysnIDogJycpICsgdyArIGQgKyAoKG9yZCkgPyBvcmQgOiAnJykgKyAoKGFiYnIpID8gYWJiciA6ICcnKSArICgoYnl0ZXMpID8gYnl0ZXMgOiAnJykgKyAoKG5lZ1AgJiYgbmVnKSA/ICcpJyA6ICcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgVG9wIExldmVsIEZ1bmN0aW9uc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIG51bWVyYWwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKG51bWVyYWwuaXNOdW1lcmFsKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAwIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBudW1lcmFsLmZuLnVuZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTnVtZXJhbChOdW1iZXIoaW5wdXQpKTtcbiAgICB9O1xuXG4gICAgLy8gdmVyc2lvbiBudW1iZXJcbiAgICBudW1lcmFsLnZlcnNpb24gPSBWRVJTSU9OO1xuXG4gICAgLy8gY29tcGFyZSBudW1lcmFsIG9iamVjdFxuICAgIG51bWVyYWwuaXNOdW1lcmFsID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtZXJhbDtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbGFuZ3VhZ2VzIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxhbmd1YWdlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxhbmd1YWdlIGtleS5cbiAgICBudW1lcmFsLmxhbmd1YWdlID0gZnVuY3Rpb24gKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudExhbmd1YWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSAmJiAhdmFsdWVzKSB7XG4gICAgICAgICAgICBpZighbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgOiAnICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMYW5ndWFnZSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMgfHwgIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBsb2FkTGFuZ3VhZ2Uoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWVyYWw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgbG9hZGVkIGxhbmd1YWdlIGRhdGEuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnRcbiAgICAvLyBnbG9iYWwgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgIG51bWVyYWwubGFuZ3VhZ2VEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgOiAnICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1trZXldO1xuICAgIH07XG5cbiAgICBudW1lcmFsLmxhbmd1YWdlKCdlbicsIHtcbiAgICAgICAgZGVsaW1pdGVyczoge1xuICAgICAgICAgICAgdGhvdXNhbmRzOiAnLCcsXG4gICAgICAgICAgICBkZWNpbWFsOiAnLidcbiAgICAgICAgfSxcbiAgICAgICAgYWJicmV2aWF0aW9uczoge1xuICAgICAgICAgICAgdGhvdXNhbmQ6ICdrJyxcbiAgICAgICAgICAgIG1pbGxpb246ICdtJyxcbiAgICAgICAgICAgIGJpbGxpb246ICdiJyxcbiAgICAgICAgICAgIHRyaWxsaW9uOiAndCdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMDtcbiAgICAgICAgICAgIHJldHVybiAofn4gKG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVuY3k6IHtcbiAgICAgICAgICAgIHN5bWJvbDogJyQnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG51bWVyYWwuemVyb0Zvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgemVyb0Zvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6IG51bGw7XG4gICAgfTtcblxuICAgIG51bWVyYWwuZGVmYXVsdEZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgZGVmYXVsdEZvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6ICcwLjAnO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2Uoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgbGFuZ3VhZ2VzW2tleV0gPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGbG9hdGluZy1wb2ludCBoZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gVGhlIGZsb2F0aW5nLXBvaW50IGhlbHBlciBmdW5jdGlvbnMgYW5kIGltcGxlbWVudGF0aW9uXG4gICAgLy8gYm9ycm93cyBoZWF2aWx5IGZyb20gc2luZnVsLmpzOiBodHRwOi8vZ3VpcG4uZ2l0aHViLmlvL3NpbmZ1bC5qcy9cblxuICAgIC8qKlxuICAgICAqIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdFxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L1JlZHVjZSNDb21wYXRpYmlsaXR5XG4gICAgICovXG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRoaXMgfHwgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIG1vbWVudCBhbGwgbW9kZXJuIGJyb3dzZXJzLCB0aGF0IHN1cHBvcnQgc3RyaWN0IG1vZGUsIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZS4gRm9yIGluc3RhbmNlLCBJRThcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBzbyB0aGlzIGNoZWNrIGlzIGFjdHVhbGx5IHVzZWxlc3MuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0X2luaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGxlbmd0aCA+IGluZGV4OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlLCB0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbXVsdGlwbGllciBuZWNlc3NhcnkgdG8gbWFrZSB4ID49IDEsXG4gICAgICogZWZmZWN0aXZlbHkgZWxpbWluYXRpbmcgbWlzY2FsY3VsYXRpb25zIGNhdXNlZCBieVxuICAgICAqIGZpbml0ZSBwcmVjaXNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbGllcih4KSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCBwYXJ0c1sxXS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgcmV0dXJucyB0aGUgbWF4aW11bVxuICAgICAqIG11bHRpcGxpZXIgdGhhdCBtdXN0IGJlIHVzZWQgdG8gbm9ybWFsaXplIGFuIG9wZXJhdGlvbiBpbnZvbHZpbmdcbiAgICAgKiBhbGwgb2YgdGhlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3JyZWN0aW9uRmFjdG9yKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgICAgICAgdmFyIG1wID0gbXVsdGlwbGllcihwcmV2KSxcbiAgICAgICAgICAgICAgICBtbiA9IG11bHRpcGxpZXIobmV4dCk7XG4gICAgICAgIHJldHVybiBtcCA+IG1uID8gbXAgOiBtbjtcbiAgICAgICAgfSwgLUluZmluaXR5KTtcbiAgICB9ICAgICAgICBcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBOdW1lcmFsIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgbnVtZXJhbC5mbiA9IE51bWVyYWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0IDogZnVuY3Rpb24gKGlucHV0U3RyaW5nLCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtZXJhbCh0aGlzLCBcbiAgICAgICAgICAgICAgICAgIGlucHV0U3RyaW5nID8gaW5wdXRTdHJpbmcgOiBkZWZhdWx0Rm9ybWF0LCBcbiAgICAgICAgICAgICAgICAgIChyb3VuZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bmZvcm1hdCA6IGZ1bmN0aW9uIChpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dFN0cmluZykgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7IFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFN0cmluZzsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5mb3JtYXROdW1lcmFsKHRoaXMsIGlucHV0U3RyaW5nID8gaW5wdXRTdHJpbmcgOiBkZWZhdWx0Rm9ybWF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZU9mIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgY29yckZhY3RvciAqIGN1cnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjaywgMCkgLyBjb3JyRmFjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VidHJhY3QgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3Rvci5jYWxsKG51bGwsIHRoaXMuX3ZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gLSBjb3JyRmFjdG9yICogY3VycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3ZhbHVlXS5yZWR1Y2UoY2JhY2ssIHRoaXMuX3ZhbHVlICogY29yckZhY3RvcikgLyBjb3JyRmFjdG9yOyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbXVsdGlwbHkgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpICogKGN1cnIgKiBjb3JyRmFjdG9yKSAvXG4gICAgICAgICAgICAgICAgICAgIChjb3JyRmFjdG9yICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjaywgMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXZpZGUgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpIC8gKGN1cnIgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3RoaXMuX3ZhbHVlLCB2YWx1ZV0ucmVkdWNlKGNiYWNrKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpZmZlcmVuY2UgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhudW1lcmFsKHRoaXMuX3ZhbHVlKS5zdWJ0cmFjdCh2YWx1ZSkudmFsdWUoKSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEV4cG9zaW5nIE51bWVyYWxcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBDb21tb25KUyBtb2R1bGUgaXMgZGVmaW5lZFxuICAgIGlmIChoYXNNb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBudW1lcmFsO1xuICAgIH1cblxuICAgIC8qZ2xvYmFsIGVuZGVyOmZhbHNlICovXG4gICAgaWYgKHR5cGVvZiBlbmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gaGVyZSwgYHRoaXNgIG1lYW5zIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyXG4gICAgICAgIC8vIGFkZCBgbnVtZXJhbGAgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAgICAgICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciAnYWR2YW5jZWQnIG1vZGVcbiAgICAgICAgdGhpc1snbnVtZXJhbCddID0gbnVtZXJhbDtcbiAgICB9XG5cbiAgICAvKmdsb2JhbCBkZWZpbmU6ZmFsc2UgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWw7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG59LmNhbGwod2luZG93KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ltcG9ydHMtbG9hZGVyP3RoaXM9PndpbmRvdyEuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9udW1lcmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "views/shared/singlevalue/Delta":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\"),\n        module,\n        __webpack_require__(\"views/Base\"),\n        __webpack_require__(\"util/svg\"),\n        __webpack_require__(\"util/general_utils\"),\n        __webpack_require__(\"util/math_utils\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n        $,\n        _,\n        module,\n        BaseView,\n        svgUtil,\n        generalUtil,\n        mathUtil\n        ) {\n\n        return BaseView.extend({\n            moduleId: module.id,\n            className: \"single-value-delta\",\n            el: function() {\n                return svgUtil.createElement('g').attr('class', 'single-value-delta');\n            },\n            SVG_POINTS: {\n                decrease: {\n                    polylinePoints: '20.5,3 20.5,20.5 3,20.5',\n                    linePoints: [20.2,20.9,3.4,4]\n                },\n                increase: {\n                    polylinePoints: '20.5,21 20.5,3.5 3,3.5',\n                    linePoints: [20.2,3.3,3.4,20.2]\n                },\n                noChange: {\n                    polylinePoints: '14.8,20.2 23.8,11.2 14.8,2.2',\n                    linePoints: [0,11.2,23,11.2]\n                }\n            },\n            INDICATOR_WIDTH: 22,\n            initialize: function(options) {\n                BaseView.prototype.initialize.apply(this, arguments);\n                this.updateContainerDimensions();\n                this.activate();\n            },\n            drawComponents: function() {\n                var deltaFormat = this.model.state.get('display.visualizations.singlevalue.trendDisplayMode');\n\n                this.deltaValue = this.model.results.get('deltaValue');\n                this.formattedDeltaValue = this.model.results.get('formattedDeltaValue');\n\n                if (this.deltaValue && this.deltaValue !== 0) {\n                    if (this.deltaValue === 'percentageDecrease' || this.deltaValue < 0) {\n                        this.indicatorMode = 'decrease';\n                        this.indicatorClass = 'delta-down-indicator';\n                    } else if (this.deltaValue === 'percentageIncrease' || this.deltaValue > 0) {\n                        this.indicatorMode = 'increase';\n                        this.indicatorClass = 'delta-up-indicator';\n                    }\n                } else {\n                    this.indicatorMode = 'noChange';\n                    this.indicatorClass = 'delta-no-change-indicator';\n                }\n\n                this.indicatorColor = this.model.presentation.get('deltaColor');\n\n                if (isNaN(this.deltaValue) || this.deltaValue === Infinity || this.deltaValue === -Infinity) {\n                    this.formattedDeltaValue = \"N/A\";\n                } else {\n                    if (deltaFormat && deltaFormat.toLowerCase() === 'percent') {\n                        this.formattedDeltaValue += '%';\n                    }\n                }\n\n                this.drawLabel();\n                this.drawIndicator();\n            },\n            drawIndicator: function() {\n                var indicatorGroup = svgUtil.createElement('g')\n                        .attr({\n                            'class': 'delta-indicator ' +  this.indicatorClass\n                        }),\n                    points = this.SVG_POINTS[this.indicatorMode],\n                    polyline = svgUtil.createElement('polyline')\n                        .attr({\n                            points: points.polylinePoints,\n                            fill: 'none',\n                            stroke: this.indicatorColor,\n                            'stroke-width': '5px'\n                        }),\n                    line = svgUtil.createElement('line')\n                        .attr({\n                            x1: points.linePoints[0],\n                            y1: points.linePoints[1],\n                            x2: points.linePoints[2],\n                            y2: points.linePoints[3],\n                            fill: this.indicatorColor,\n                            stroke: this.indicatorColor,\n                            'stroke-width': '5px'\n                        });\n                indicatorGroup.append(polyline);\n                indicatorGroup.append(line);\n                this.$el.append(indicatorGroup);\n            },\n            drawLabel: function() {\n                var value = svgUtil.createElement('text')\n                    .attr({\n                        'class': 'delta-label'\n                    })\n                    .text(this.formattedDeltaValue)\n                    .css({\n                        'font-size' : this.model.presentation.get('deltaFontSize'),\n                        'fill' : this.indicatorColor,\n                        'fontWeight' : 'bold'\n                    });\n                this.$el.append(value);\n            },\n            updateContainerDimensions: function() {\n                this.scaleRatio = this.model.presentation.get('scaleRatio');\n            },\n            positionAndScaleElements: function() {\n                var $label = this.$el.find('.delta-label'),\n                    $indicator = this.$el.find('.delta-indicator'),\n                    deltaScale = this.model.presentation.get('deltaScale'),\n                    labelWidth,\n                    indicatorWidth = this.INDICATOR_WIDTH * deltaScale,\n                    deltaWidth,\n                    deltaLeft = this.model.presentation.get('deltaLeft') || 0,\n                    indicatorTranslateX,\n                    indicatorTranslateY = -45,\n                    deltaTranslateX,\n                    maxDeltaRatio,\n                    maxDeltaWidth = this.model.presentation.get('maxDeltaWidth');\n\n                if (!this.defaultDeltaWidth) {\n                    this.defaultDeltaWidth = this.getDeltaWidth();\n                }\n\n                if (!this.defaultLabelWidth) {\n                    this.defaultLabelWidth = $label[0].getBBox().width;\n                }\n\n                deltaTranslateX = (deltaLeft + 10) / this.scaleRatio;\n                labelWidth = this.defaultLabelWidth;\n\n                indicatorTranslateX = mathUtil.roundToDecimal((labelWidth / 2 - indicatorWidth / 2), -2);\n                if (generalUtil.valuesAreNumericAndFinite([this.scaleRatio, indicatorTranslateX, indicatorTranslateY, deltaTranslateX])) {\n                    $indicator.attr({\n                        transform: 'scale(' + deltaScale + ')translate(' + indicatorTranslateX + ',' + indicatorTranslateY + ')'\n                    });\n                    this.$el.attr({\n                        transform: \"scale(\" + this.scaleRatio + \")translate(\" + deltaTranslateX + \")\"\n                    });\n                }\n\n\n                deltaWidth = this.getDeltaWidth();\n                if (deltaWidth > maxDeltaWidth) {\n                    maxDeltaRatio = mathUtil.roundToDecimal(maxDeltaWidth / this.defaultDeltaWidth, -2);\n                    deltaTranslateX = (deltaLeft + 10) / maxDeltaRatio;\n                    if (generalUtil.valuesAreNumericAndFinite([maxDeltaRatio, deltaTranslateX])) {\n                        this.$el.attr({\n                            transform: \"scale(\" + maxDeltaRatio + \")translate(\" + deltaTranslateX + \")\"\n                        });\n                    }\n                }\n            },\n            getDeltaWidth: function() {\n                return this.el.getBoundingClientRect().width;\n            },\n            reflow: function() {\n                this.updateContainerDimensions();\n                this.positionAndScaleElements();\n            },\n            render: function() {\n                this.drawComponents();\n                return this;\n            }\n        });\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9EZWx0YS5qcz8zZTk5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQSxpQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9KQUNBIiwiZmlsZSI6InZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9EZWx0YS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShcbiAgICBbXG4gICAgICAgICdqcXVlcnknLFxuICAgICAgICAndW5kZXJzY29yZScsXG4gICAgICAgICdtb2R1bGUnLFxuICAgICAgICAndmlld3MvQmFzZScsXG4gICAgICAgICd1dGlsL3N2ZycsXG4gICAgICAgICd1dGlsL2dlbmVyYWxfdXRpbHMnLFxuICAgICAgICAndXRpbC9tYXRoX3V0aWxzJ1xuICAgIF0sXG4gICAgZnVuY3Rpb24oXG4gICAgICAgICQsXG4gICAgICAgIF8sXG4gICAgICAgIG1vZHVsZSxcbiAgICAgICAgQmFzZVZpZXcsXG4gICAgICAgIHN2Z1V0aWwsXG4gICAgICAgIGdlbmVyYWxVdGlsLFxuICAgICAgICBtYXRoVXRpbFxuICAgICAgICApIHtcblxuICAgICAgICByZXR1cm4gQmFzZVZpZXcuZXh0ZW5kKHtcbiAgICAgICAgICAgIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic2luZ2xlLXZhbHVlLWRlbHRhXCIsXG4gICAgICAgICAgICBlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN2Z1V0aWwuY3JlYXRlRWxlbWVudCgnZycpLmF0dHIoJ2NsYXNzJywgJ3NpbmdsZS12YWx1ZS1kZWx0YScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNWR19QT0lOVFM6IHtcbiAgICAgICAgICAgICAgICBkZWNyZWFzZToge1xuICAgICAgICAgICAgICAgICAgICBwb2x5bGluZVBvaW50czogJzIwLjUsMyAyMC41LDIwLjUgMywyMC41JyxcbiAgICAgICAgICAgICAgICAgICAgbGluZVBvaW50czogWzIwLjIsMjAuOSwzLjQsNF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluY3JlYXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lUG9pbnRzOiAnMjAuNSwyMSAyMC41LDMuNSAzLDMuNScsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVQb2ludHM6IFsyMC4yLDMuMywzLjQsMjAuMl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5vQ2hhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lUG9pbnRzOiAnMTQuOCwyMC4yIDIzLjgsMTEuMiAxNC44LDIuMicsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVQb2ludHM6IFswLDExLjIsMjMsMTEuMl1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSU5ESUNBVE9SX1dJRFRIOiAyMixcbiAgICAgICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBCYXNlVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVyRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmF3Q29tcG9uZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhRm9ybWF0ID0gdGhpcy5tb2RlbC5zdGF0ZS5nZXQoJ2Rpc3BsYXkudmlzdWFsaXphdGlvbnMuc2luZ2xldmFsdWUudHJlbmREaXNwbGF5TW9kZScpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kZWx0YVZhbHVlID0gdGhpcy5tb2RlbC5yZXN1bHRzLmdldCgnZGVsdGFWYWx1ZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkRGVsdGFWYWx1ZSA9IHRoaXMubW9kZWwucmVzdWx0cy5nZXQoJ2Zvcm1hdHRlZERlbHRhVmFsdWUnKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbHRhVmFsdWUgJiYgdGhpcy5kZWx0YVZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbHRhVmFsdWUgPT09ICdwZXJjZW50YWdlRGVjcmVhc2UnIHx8IHRoaXMuZGVsdGFWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNhdG9yTW9kZSA9ICdkZWNyZWFzZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGljYXRvckNsYXNzID0gJ2RlbHRhLWRvd24taW5kaWNhdG9yJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbHRhVmFsdWUgPT09ICdwZXJjZW50YWdlSW5jcmVhc2UnIHx8IHRoaXMuZGVsdGFWYWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNhdG9yTW9kZSA9ICdpbmNyZWFzZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGljYXRvckNsYXNzID0gJ2RlbHRhLXVwLWluZGljYXRvcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGljYXRvck1vZGUgPSAnbm9DaGFuZ2UnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGljYXRvckNsYXNzID0gJ2RlbHRhLW5vLWNoYW5nZS1pbmRpY2F0b3InO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNhdG9yQ29sb3IgPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ2RlbHRhQ29sb3InKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc05hTih0aGlzLmRlbHRhVmFsdWUpIHx8IHRoaXMuZGVsdGFWYWx1ZSA9PT0gSW5maW5pdHkgfHwgdGhpcy5kZWx0YVZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWREZWx0YVZhbHVlID0gXCJOL0FcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFGb3JtYXQgJiYgZGVsdGFGb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gJ3BlcmNlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdHRlZERlbHRhVmFsdWUgKz0gJyUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGFiZWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdJbmRpY2F0b3IoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmF3SW5kaWNhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNhdG9yR3JvdXAgPSBzdmdVdGlsLmNyZWF0ZUVsZW1lbnQoJ2cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdkZWx0YS1pbmRpY2F0b3IgJyArICB0aGlzLmluZGljYXRvckNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5TVkdfUE9JTlRTW3RoaXMuaW5kaWNhdG9yTW9kZV0sXG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCdwb2x5bGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMucG9seWxpbmVQb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5pbmRpY2F0b3JDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogJzVweCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MTogcG9pbnRzLmxpbmVQb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTE6IHBvaW50cy5saW5lUG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBwb2ludHMubGluZVBvaW50c1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MjogcG9pbnRzLmxpbmVQb2ludHNbM10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5pbmRpY2F0b3JDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuaW5kaWNhdG9yQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICc1cHgnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JHcm91cC5hcHBlbmQocG9seWxpbmUpO1xuICAgICAgICAgICAgICAgIGluZGljYXRvckdyb3VwLmFwcGVuZChsaW5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5hcHBlbmQoaW5kaWNhdG9yR3JvdXApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyYXdMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2RlbHRhLWxhYmVsJ1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGV4dCh0aGlzLmZvcm1hdHRlZERlbHRhVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZScgOiB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ2RlbHRhRm9udFNpemUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsJyA6IHRoaXMuaW5kaWNhdG9yQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9udFdlaWdodCcgOiAnYm9sZCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuYXBwZW5kKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVDb250YWluZXJEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlUmF0aW8gPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ3NjYWxlUmF0aW8nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbkFuZFNjYWxlRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkbGFiZWwgPSB0aGlzLiRlbC5maW5kKCcuZGVsdGEtbGFiZWwnKSxcbiAgICAgICAgICAgICAgICAgICAgJGluZGljYXRvciA9IHRoaXMuJGVsLmZpbmQoJy5kZWx0YS1pbmRpY2F0b3InKSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnZGVsdGFTY2FsZScpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JXaWR0aCA9IHRoaXMuSU5ESUNBVE9SX1dJRFRIICogZGVsdGFTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFMZWZ0ID0gdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uZ2V0KCdkZWx0YUxlZnQnKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JUcmFuc2xhdGVYLFxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JUcmFuc2xhdGVZID0gLTQ1LFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVRyYW5zbGF0ZVgsXG4gICAgICAgICAgICAgICAgICAgIG1heERlbHRhUmF0aW8sXG4gICAgICAgICAgICAgICAgICAgIG1heERlbHRhV2lkdGggPSB0aGlzLm1vZGVsLnByZXNlbnRhdGlvbi5nZXQoJ21heERlbHRhV2lkdGgnKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWZhdWx0RGVsdGFXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHREZWx0YVdpZHRoID0gdGhpcy5nZXREZWx0YVdpZHRoKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRMYWJlbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdExhYmVsV2lkdGggPSAkbGFiZWxbMF0uZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbHRhVHJhbnNsYXRlWCA9IChkZWx0YUxlZnQgKyAxMCkgLyB0aGlzLnNjYWxlUmF0aW87XG4gICAgICAgICAgICAgICAgbGFiZWxXaWR0aCA9IHRoaXMuZGVmYXVsdExhYmVsV2lkdGg7XG5cbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JUcmFuc2xhdGVYID0gbWF0aFV0aWwucm91bmRUb0RlY2ltYWwoKGxhYmVsV2lkdGggLyAyIC0gaW5kaWNhdG9yV2lkdGggLyAyKSwgLTIpO1xuICAgICAgICAgICAgICAgIGlmIChnZW5lcmFsVXRpbC52YWx1ZXNBcmVOdW1lcmljQW5kRmluaXRlKFt0aGlzLnNjYWxlUmF0aW8sIGluZGljYXRvclRyYW5zbGF0ZVgsIGluZGljYXRvclRyYW5zbGF0ZVksIGRlbHRhVHJhbnNsYXRlWF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICRpbmRpY2F0b3IuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgnICsgZGVsdGFTY2FsZSArICcpdHJhbnNsYXRlKCcgKyBpbmRpY2F0b3JUcmFuc2xhdGVYICsgJywnICsgaW5kaWNhdG9yVHJhbnNsYXRlWSArICcpJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoXCIgKyB0aGlzLnNjYWxlUmF0aW8gKyBcIil0cmFuc2xhdGUoXCIgKyBkZWx0YVRyYW5zbGF0ZVggKyBcIilcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGRlbHRhV2lkdGggPSB0aGlzLmdldERlbHRhV2lkdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFXaWR0aCA+IG1heERlbHRhV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RGVsdGFSYXRpbyA9IG1hdGhVdGlsLnJvdW5kVG9EZWNpbWFsKG1heERlbHRhV2lkdGggLyB0aGlzLmRlZmF1bHREZWx0YVdpZHRoLCAtMik7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVHJhbnNsYXRlWCA9IChkZWx0YUxlZnQgKyAxMCkgLyBtYXhEZWx0YVJhdGlvO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhbFV0aWwudmFsdWVzQXJlTnVtZXJpY0FuZEZpbml0ZShbbWF4RGVsdGFSYXRpbywgZGVsdGFUcmFuc2xhdGVYXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZShcIiArIG1heERlbHRhUmF0aW8gKyBcIil0cmFuc2xhdGUoXCIgKyBkZWx0YVRyYW5zbGF0ZVggKyBcIilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RGVsdGFXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmbG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lckRpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uQW5kU2NhbGVFbGVtZW50cygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9uZW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9EZWx0YS5qc1xuLy8gbW9kdWxlIGlkID0gdmlld3Mvc2hhcmVkL3NpbmdsZXZhbHVlL0RlbHRhXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "views/shared/singlevalue/UnderLabel":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"shim/jquery\"),\n        __webpack_require__(\"require/underscore\"),\n        module,\n        __webpack_require__(\"views/Base\"),\n        __webpack_require__(\"views/shared/singlevalue/Label\"),\n        __webpack_require__(\"models/Base\"),\n        __webpack_require__(\"shim/splunk.util\"),\n        __webpack_require__(\"util/svg\"),\n        __webpack_require__(\"util/general_utils\"),\n        __webpack_require__(\"util/math_utils\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n        $,\n        _,\n        module,\n        BaseView,\n        LabelView,\n        BaseModel,\n        splunkUtil,\n        svgUtil,\n        generalUtil,\n        mathUtil\n        ) {\n\n        return BaseView.extend({\n            moduleId: module.id,\n            className: 'single-value-under-label',\n            initialize: function(options) {\n                BaseView.prototype.initialize.apply(this, arguments);\n            },\n            el: function() {\n                return svgUtil.createElement('g').attr('class', 'single-value-under-label');\n            },\n            LABEL_FONT_SIZE: 12,\n\n            createUnderLabel: function() {\n                if (this.children.underLabel) {\n                    this.children.underLabel.detach();\n                    this.children.underLabel.remove();\n                }\n                this.children.underLabel = new LabelView({\n                    model: {\n                        state: this.model.state,\n                        results: this.model.results,\n                        presentation: this.model.presentation,\n                        application: this.model.application\n                    },\n                    labelFontSize: this.LABEL_FONT_SIZE,\n                    labelFontColor: this.model.presentation.get('underLabelColor'),\n                    labelGroupClass: 'under-label-group',\n                    labelClass: 'under-label',\n                    linkField: 'underlabel',\n                    configName: 'display.visualizations.singlevalue.underLabel',\n                    useResultField: false,\n                    labelOpacity: this.model.presentation.get('underLabelOpacity'),\n                    fontWeight: 'normal'\n                });\n\n                this.listenTo(this.children.underLabel, 'singleDrilldownClicked', function(params) {\n                    this.trigger('singleDrilldownClicked', params);\n                });\n                this.listenTo(this.children.underLabel, 'anchorTagClicked', function(e) {\n                    this.trigger('anchorTagClicked', e);\n                });\n            },\n\n            reflow: function() {\n                this.updateContainerDimensions();\n                this.positionAndScaleUnderLabel();\n            },\n\n            updateContainerDimensions: function() {\n                this.svgWidth = this.model.presentation.get('svgWidth');\n                this.svgHeight = this.model.presentation.get('svgHeight');\n                // Scale up the font size at a decreasing rate to keep the label relatively small\n                this.scaleRatio = this.model.presentation.get('scaleRatio');\n                this.UNDER_LABEL_WIDTH = this.children.underLabel.getWidth();\n            },\n\n            positionAndScaleUnderLabel: function() {\n                // Under label does not scale - it always stays the same size. It is just scaled vertically.\n                if (this.UNDER_LABEL_WIDTH) {\n                    // Position underlabel in correct location to bottom center of container\n                    var shiftWidth = mathUtil.roundToDecimal((this.svgWidth / 2 - this.UNDER_LABEL_WIDTH / 2), -2),\n                        shiftHeight = this.model.presentation.get('underLabelY') * this.scaleRatio;\n                    if (generalUtil.valuesAreNumericAndFinite([shiftWidth, shiftHeight])) {\n                        this.$el.attr({\n                            transform: \"translate(\" + shiftWidth + \",\" + shiftHeight + \")\"\n                        });\n                    }\n                }\n            },\n\n            render: function() {\n                this.createUnderLabel();\n                this.children.underLabel.render().appendTo(this.$el);\n                return this;\n            }\n        });\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3ZpZXdzL3NoYXJlZC9zaW5nbGV2YWx1ZS9VbmRlckxhYmVsLmpzPzk5NmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBLGlDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0pBQ0EiLCJmaWxlIjoidmlld3Mvc2hhcmVkL3NpbmdsZXZhbHVlL1VuZGVyTGFiZWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoXG4gICAgW1xuICAgICAgICAnanF1ZXJ5JyxcbiAgICAgICAgJ3VuZGVyc2NvcmUnLFxuICAgICAgICAnbW9kdWxlJyxcbiAgICAgICAgJ3ZpZXdzL0Jhc2UnLFxuICAgICAgICAnLi9MYWJlbCcsXG4gICAgICAgICdtb2RlbHMvQmFzZScsXG4gICAgICAgICdzcGx1bmsudXRpbCcsXG4gICAgICAgICd1dGlsL3N2ZycsXG4gICAgICAgICd1dGlsL2dlbmVyYWxfdXRpbHMnLFxuICAgICAgICAndXRpbC9tYXRoX3V0aWxzJ1xuICAgIF0sXG4gICAgZnVuY3Rpb24oXG4gICAgICAgICQsXG4gICAgICAgIF8sXG4gICAgICAgIG1vZHVsZSxcbiAgICAgICAgQmFzZVZpZXcsXG4gICAgICAgIExhYmVsVmlldyxcbiAgICAgICAgQmFzZU1vZGVsLFxuICAgICAgICBzcGx1bmtVdGlsLFxuICAgICAgICBzdmdVdGlsLFxuICAgICAgICBnZW5lcmFsVXRpbCxcbiAgICAgICAgbWF0aFV0aWxcbiAgICAgICAgKSB7XG5cbiAgICAgICAgcmV0dXJuIEJhc2VWaWV3LmV4dGVuZCh7XG4gICAgICAgICAgICBtb2R1bGVJZDogbW9kdWxlLmlkLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnc2luZ2xlLXZhbHVlLXVuZGVyLWxhYmVsJyxcbiAgICAgICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBCYXNlVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ZnVXRpbC5jcmVhdGVFbGVtZW50KCdnJykuYXR0cignY2xhc3MnLCAnc2luZ2xlLXZhbHVlLXVuZGVyLWxhYmVsJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTEFCRUxfRk9OVF9TSVpFOiAxMixcblxuICAgICAgICAgICAgY3JlYXRlVW5kZXJMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4udW5kZXJMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnVuZGVyTGFiZWwuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4udW5kZXJMYWJlbC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi51bmRlckxhYmVsID0gbmV3IExhYmVsVmlldyh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5tb2RlbC5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IHRoaXMubW9kZWwucmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRhdGlvbjogdGhpcy5tb2RlbC5wcmVzZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbjogdGhpcy5tb2RlbC5hcHBsaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYWJlbEZvbnRTaXplOiB0aGlzLkxBQkVMX0ZPTlRfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxGb250Q29sb3I6IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgndW5kZXJMYWJlbENvbG9yJyksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsR3JvdXBDbGFzczogJ3VuZGVyLWxhYmVsLWdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxDbGFzczogJ3VuZGVyLWxhYmVsJyxcbiAgICAgICAgICAgICAgICAgICAgbGlua0ZpZWxkOiAndW5kZXJsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ05hbWU6ICdkaXNwbGF5LnZpc3VhbGl6YXRpb25zLnNpbmdsZXZhbHVlLnVuZGVyTGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICB1c2VSZXN1bHRGaWVsZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsT3BhY2l0eTogdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uZ2V0KCd1bmRlckxhYmVsT3BhY2l0eScpLFxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNoaWxkcmVuLnVuZGVyTGFiZWwsICdzaW5nbGVEcmlsbGRvd25DbGlja2VkJywgZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc2luZ2xlRHJpbGxkb3duQ2xpY2tlZCcsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNoaWxkcmVuLnVuZGVyTGFiZWwsICdhbmNob3JUYWdDbGlja2VkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2FuY2hvclRhZ0NsaWNrZWQnLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlZmxvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb250YWluZXJEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkFuZFNjYWxlVW5kZXJMYWJlbCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdXBkYXRlQ29udGFpbmVyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdmdXaWR0aCA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnc3ZnV2lkdGgnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN2Z0hlaWdodCA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgnc3ZnSGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgdXAgdGhlIGZvbnQgc2l6ZSBhdCBhIGRlY3JlYXNpbmcgcmF0ZSB0byBrZWVwIHRoZSBsYWJlbCByZWxhdGl2ZWx5IHNtYWxsXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVJhdGlvID0gdGhpcy5tb2RlbC5wcmVzZW50YXRpb24uZ2V0KCdzY2FsZVJhdGlvJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5VTkRFUl9MQUJFTF9XSURUSCA9IHRoaXMuY2hpbGRyZW4udW5kZXJMYWJlbC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcG9zaXRpb25BbmRTY2FsZVVuZGVyTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFVuZGVyIGxhYmVsIGRvZXMgbm90IHNjYWxlIC0gaXQgYWx3YXlzIHN0YXlzIHRoZSBzYW1lIHNpemUuIEl0IGlzIGp1c3Qgc2NhbGVkIHZlcnRpY2FsbHkuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuVU5ERVJfTEFCRUxfV0lEVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb24gdW5kZXJsYWJlbCBpbiBjb3JyZWN0IGxvY2F0aW9uIHRvIGJvdHRvbSBjZW50ZXIgb2YgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGlmdFdpZHRoID0gbWF0aFV0aWwucm91bmRUb0RlY2ltYWwoKHRoaXMuc3ZnV2lkdGggLyAyIC0gdGhpcy5VTkRFUl9MQUJFTF9XSURUSCAvIDIpLCAtMiksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdEhlaWdodCA9IHRoaXMubW9kZWwucHJlc2VudGF0aW9uLmdldCgndW5kZXJMYWJlbFknKSAqIHRoaXMuc2NhbGVSYXRpbztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYWxVdGlsLnZhbHVlc0FyZU51bWVyaWNBbmRGaW5pdGUoW3NoaWZ0V2lkdGgsIHNoaWZ0SGVpZ2h0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBzaGlmdFdpZHRoICsgXCIsXCIgKyBzaGlmdEhlaWdodCArIFwiKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVVbmRlckxhYmVsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi51bmRlckxhYmVsLnJlbmRlcigpLmFwcGVuZFRvKHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy92aWV3cy9zaGFyZWQvc2luZ2xldmFsdWUvVW5kZXJMYWJlbC5qc1xuLy8gbW9kdWxlIGlkID0gdmlld3Mvc2hhcmVkL3NpbmdsZXZhbHVlL1VuZGVyTGFiZWxcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "util/drilldown":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(\"shim/jquery\"),\n            __webpack_require__(\"require/underscore\"),\n            __webpack_require__(\"models/services/search/IntentionsParser\"),\n            __webpack_require__(\"shim/splunk.util\"),\n            __webpack_require__(\"util/console\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n            $,\n            _,\n            IntentionsParser,\n            splunkUtil,\n            console\n        ) {\n\n    var appendSplitInfo = function(field, value, clickInfo) {\n        if (clickInfo.splitContext) {\n            var splitInfo = clickInfo.splitContext;\n            Object.keys(splitInfo).forEach(function (name) {\n                if (!_.contains(field, name)) {\n                    field.unshift(name);\n                    value.unshift(splitInfo[name]);\n                }\n                else {\n                    var fieldIndex = field.indexOf(name);\n                    if (value[fieldIndex] === undefined) {\n                        value[fieldIndex] = splitInfo[name];\n                    }\n                }\n            });\n        }\n    };\n\n    var computeModifierKey = function(clickInfo) {\n        var event = clickInfo.originalEvent || clickInfo;\n        return !!(event.ctrlKey || event.metaKey);\n    };\n\n    var computeAltKey = function(clickInfo) {\n        var event = clickInfo.originalEvent || clickInfo;\n        return !!event.altKey;\n    };\n\n    var convertRowDrilldownToIntentions = function(clickInfo, metadata) {\n        var rowContext = _(clickInfo.rowContext).omit('row._time'),\n            field = _(rowContext).chain().keys().map(function(f) { return f.replace('row.', ''); }).value(),\n            value;\n\n        var isGroupbyField = function(fieldName) {\n            return metadata[fieldName] && metadata[fieldName].hasOwnProperty('groupby_rank');\n        };\n\n        var isSplitbyField = function(fieldName) {\n            return _.any(metadata, function(meta) { return meta['splitby_field'] === fieldName; });\n        };\n\n        // If any field in the metadata is the result of a group-by operation, then filter arguments to the intentionsparser\n        // to only include group-by and split-by fields.\n        if (metadata && _.any(metadata, function(meta, fieldName) { return isGroupbyField(fieldName); })) {\n            field = _(field).filter(function(f) {\n                return isGroupbyField(f) || isSplitbyField(f);\n            });\n        }\n        value = _(field).map(function(f) { return rowContext['row.' + f]; });\n\n        appendSplitInfo(field, value, clickInfo);\n\n        return ({\n            action: 'fieldvalue',\n            field: field.map(function (f) { return normalizeField(f, clickInfo, metadata); }),\n            value: value\n        });\n    };\n\n    var convertCellDrilldownToIntentions = function(clickInfo, metadata) {\n        var field, value;\n        if (clickInfo.name === '_time') {\n            field = _.compact([clickInfo.name2]);\n            value = _.compact([clickInfo.value2]);\n        } else {\n            if (clickInfo.name && clickInfo.name2) {\n                field = [clickInfo.name, clickInfo.name2];\n                value = [clickInfo.value, clickInfo.value2];\n            } else if (clickInfo.name) {\n                field = [clickInfo.name];\n                value = [clickInfo.value];\n            } else {\n                field = [clickInfo.name2];\n                value = [clickInfo.value2];\n            }\n        }\n\n        appendSplitInfo(field, value, clickInfo);\n\n        return ({\n            action: 'fieldvalue',\n            field: field.map(function (f) { return normalizeField(f, clickInfo, metadata); }),\n            value: value\n        });\n    };\n\n    var convertColumnDrilldownToIntentions = function(clickInfo, metadata) {\n        if (!clickInfo.splitContext && !clickInfo.splitDataSource) {\n            return ({\n                action: 'keyword',\n                field: clickInfo.name2\n            });\n        } else {\n            var field = [],\n                value = [];\n\n            if (clickInfo.value2) {\n                field.push(clickInfo.name2);\n                value.push(clickInfo.value2);\n            }\n\n            appendSplitInfo(field, value, clickInfo);\n\n            if (!_.isEmpty(field)) {\n                return ({\n                    action: 'fieldvalue',\n                    field: field.map(function (f) { return normalizeField(f, clickInfo, metadata); }),\n                    value: value\n                });\n            } else {\n                return ({\n                    action: 'keyword',\n                    field: normalizeField(clickInfo.name2, clickInfo, metadata)\n                });\n            }\n        }\n    };\n\n    var convertAddTermDrilldownToIntentions = function(clickInfo, metadata) {\n        if (!clickInfo.splitContext && !clickInfo.splitDataSource) {\n            return ({\n                action: 'addterm',\n                value: clickInfo.name2\n            });\n        } else {\n            var field = [],\n                value = [];\n\n            if (clickInfo.value2) {\n                field.push(clickInfo.name2);\n                value.push(clickInfo.value2);\n            }\n\n            appendSplitInfo(field, value, clickInfo);\n\n            if (!_.isEmpty(field)) {\n                return ({\n                    action: 'fieldvalue',\n                    field: field.map(function (f) { return normalizeField(f, clickInfo, metadata); }),\n                    value: value\n                });\n            } else {\n                return ({\n                    action: 'addterm',\n                    value: normalizeField(clickInfo.name2, clickInfo, metadata)\n                });\n            }\n        }\n    };\n\n    // normalize data for drilldown event to handle a map click\n    var convertGeovizDrilldownToIntentions = function(clickInfo) {\n        var latLonFields, latLonValues, params,\n            DRILLDOWN_PROPERTIES = {\n                _geo_lat_field: '_geo_lat_field',\n                _geo_lon_field: '_geo_long_field',\n                _geo_bounds_south: '_geo_bounds_south',\n                _geo_bounds_west: '_geo_bounds_west',\n                _geo_bounds_north: '_geo_bounds_north',\n                _geo_bounds_east: '_geo_bounds_east'\n            };\n\n        if (!_.all(DRILLDOWN_PROPERTIES, function(srcKey) { return !!clickInfo.data[srcKey]; })) {\n            // The search results did not contain bound information for the marker. This happens when the\n            // results have not been produced by the geostats command. In this case we fall back\n            // to a 'fieldvalue' action with the first two fields, which should be latitude and longitude.\n            latLonFields = clickInfo.fields.slice(0, 2);\n            latLonValues = _(latLonFields).map(function(f) { return clickInfo.data[f]; });\n\n            appendSplitInfo(latLonFields, latLonValues, clickInfo);\n\n            return ({\n                action: 'fieldvalue',\n                field: latLonFields,\n                value: latLonValues\n            });\n        }\n        params = _(DRILLDOWN_PROPERTIES).chain().map(function(srcKey, prop) {\n            return [prop, clickInfo.data[srcKey]];\n        }).object().value();\n\n        return (_.extend({ action: 'geoviz' }, params));\n    };\n\n    var normalizeField = function(fieldName, clickInfo, metadata) {\n        if (!clickInfo\n            || !clickInfo.splitDataSource) {\n            return fieldName;\n        } else {\n            var updatedFieldName = clickInfo.splitDataSource + ': ' + fieldName;\n            if (metadata && metadata[updatedFieldName]) {\n                return updatedFieldName;\n            }\n            else {\n                return fieldName;\n            }\n        }\n    };\n\n    var Drilldown = {};\n\n    /**\n     * Calls the intentions parser which then generates a new search string and time range based on the original\n     * search string of the manager and the click information.\n     *\n     * @param clickInfo {Object} - {\n     *      name/value, name2/value2 {String}\n     *      _span {Number}\n     *      type {String}\n     *      rowContext {Object} map of all key-value pairs in the row\n     *      originalEvent {jQuery Event} the original browser event\n     *  }\n     * @param query {Object} - the properties of the current query - {\n     *     search {String} the current search string\n     *     earliest {String} the current earliest time\n     *     latest {String} the current latest time\n     * }\n     * @param metadata - the current field metadata\n     * @param applicationModel - the current application model\n     * @param options {Object} - {\n     *      negate {Boolean} - Invert the drilldown intention\n     *      stripReportsSearch {Boolean} - default true, strip of all reporting commands, drill down into events\n     *      newSearch {Boolean} - default false, drill down into all events, ignores current search string\n     *      drilldownNewTab {Boolean} - whether to open a new tab for the drilldown action,\n     *                                  default is to inspect the clickInfo for a modifier key\n     *      fields {Array} - list of additional field constraints to apply to cell drilldown\n     *      values {Array} - list of additional value constraints (1 to 1 correspondence with \"fields\" above)\n     *  }\n     *\n     * @returns A promise for the result of the intentions parser - which is an object containing the search\n     *              string (q) and the time range (earliest and latest)\n     */\n    Drilldown.applyDrilldownIntention = function(clickInfo, query, metadata, applicationModel, options) {\n        options || (options = {});\n        var search = options.newSearch ? '*' : query.search,\n            newTab = Drilldown.shouldDrilldownInNewTab(clickInfo, options),\n            intentionsParser = new IntentionsParser();\n\n        if (clickInfo.name === '_time') {\n            intentionsParser.set({\n                'dispatch.earliest_time': clickInfo.value\n            }, { silent: true });\n        }\n        if (clickInfo._span) {\n            intentionsParser.set({\n                'dispatch.latest_time': JSON.stringify(Math.round((parseFloat(clickInfo.value) + clickInfo._span) * 1000) / 1000)\n            }, { silent: true });\n        }\n\n        var intentionParams = {\n            negate: options.hasOwnProperty('negate') ? options.negate : computeAltKey(clickInfo),\n            stripReportsSearch: options.hasOwnProperty('stripReportsSearch') ? options.stripReportsSearch : true\n        };\n        if (options.fields && options.fields.length > 0) {\n            _.extend(intentionParams, { action: 'fieldvalue', field: options.fields, value: options.values });\n        }\n        else if (clickInfo.type === 'geoviz') {\n            _.extend(intentionParams, convertGeovizDrilldownToIntentions(clickInfo));\n        } else if (clickInfo.type === 'column') {\n            _.extend(intentionParams, convertColumnDrilldownToIntentions(clickInfo, metadata));\n        } else if (clickInfo.type === 'row') {\n            _.extend(intentionParams, convertRowDrilldownToIntentions(clickInfo, metadata));\n        } else if (clickInfo.type === 'addterm') {\n            _.extend(intentionParams, convertAddTermDrilldownToIntentions(clickInfo, metadata));\n        } else {\n            _.extend(intentionParams, convertCellDrilldownToIntentions(clickInfo, metadata));\n        }\n\n        console.info('Applying drilldown intention', intentionParams);\n        var dfd = $.Deferred();\n        intentionsParser.fetch({\n            data: _.extend({\n                q: search,\n                fieldMetaData: JSON.stringify(metadata),\n                app: applicationModel.get('app'),\n                owner: applicationModel.get('owner'),\n                parse_only: true\n            }, intentionParams)\n        }).done(function() {\n            dfd.resolve({\n                'q': splunkUtil.stripLeadingSearchCommand(intentionsParser.get('fullSearch')),\n                'earliest': intentionsParser.get('dispatch.earliest_time') || query.earliest || 0,\n                'latest': intentionsParser.get('dispatch.latest_time') || query.latest || ''\n            }, newTab);\n        }).fail(function() {\n            dfd.reject.apply(dfd, arguments);\n        });\n\n        return dfd.promise();\n    };\n\n    /*\n     * Returns whether or not the drilldown should be in a new tab.\n     *\n     * @param clickInfo {Object} (see applyDrilldownIntention above)\n     * @param options {Object} (see applyDrilldownIntention above)\n     */\n    Drilldown.shouldDrilldownInNewTab = function(clickInfo, options) {\n        options = options || {};\n        var modifierKey = clickInfo.hasOwnProperty('modifierKey') ? clickInfo.modifierKey : computeModifierKey(clickInfo);\n        return options.hasOwnProperty('drilldownNewTab') ? options.drilldownNewTab : modifierKey;\n    };\n\n    // we want those functions to be testable\n    Drilldown._convertRowDrilldownToIntentions = convertRowDrilldownToIntentions;\n    Drilldown._convertCellDrilldownToIntentions = convertCellDrilldownToIntentions;\n    Drilldown._convertColumnDrilldownToIntentions = convertColumnDrilldownToIntentions;\n    Drilldown._convertAddTermDrilldownToIntentions = convertAddTermDrilldownToIntentions;\n    Drilldown._convertGeovizDrilldownToIntentions = convertGeovizDrilldownToIntentions;\n    Drilldown._normalizeField = normalizeField;\n\n    return Drilldown;\n\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvZHJpbGxkb3duLmpzPzRhNTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFLDhCQUE4QixFQUFFO0FBQ2xHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCw0Q0FBNEMsRUFBRTtBQUNqRzs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FLGtDQUFrQyxFQUFFO0FBQ3ZHO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQ0FBMEMsK0JBQStCLEVBQUU7O0FBRTNFOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsK0NBQStDLEVBQUU7QUFDNUY7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLCtDQUErQyxFQUFFO0FBQzVGO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELCtDQUErQyxFQUFFO0FBQ3BHO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELCtDQUErQyxFQUFFO0FBQ3BHO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELGlDQUFpQyxFQUFFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDBCQUEwQixFQUFFOztBQUV4Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULDBCQUEwQixtQkFBbUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMsc0NBQXNDO0FBQ3RDLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsd0JBQXdCLE9BQU87QUFDL0IsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQSxxQkFBcUIsT0FBTztBQUM1QixtQkFBbUIsT0FBTztBQUMxQixxQkFBcUIsT0FBTztBQUM1QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QixvQkFBb0IsUUFBUTtBQUM1QixnQ0FBZ0MsUUFBUTtBQUN4Qyx1QkFBdUIsUUFBUTtBQUMvQiw2QkFBNkIsUUFBUTtBQUNyQztBQUNBLG9CQUFvQixNQUFNO0FBQzFCLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUcsZUFBZTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFFQUFxRTtBQUM1RztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiJ1dGlsL2RyaWxsZG93bi5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXG4gICAgICAgICAgICAnanF1ZXJ5JyxcbiAgICAgICAgICAgICd1bmRlcnNjb3JlJyxcbiAgICAgICAgICAgICdtb2RlbHMvc2VydmljZXMvc2VhcmNoL0ludGVudGlvbnNQYXJzZXInLFxuICAgICAgICAgICAgJ3NwbHVuay51dGlsJyxcbiAgICAgICAgICAgICd1dGlsL2NvbnNvbGUnXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uKFxuICAgICAgICAgICAgJCxcbiAgICAgICAgICAgIF8sXG4gICAgICAgICAgICBJbnRlbnRpb25zUGFyc2VyLFxuICAgICAgICAgICAgc3BsdW5rVXRpbCxcbiAgICAgICAgICAgIGNvbnNvbGVcbiAgICAgICAgKSB7XG5cbiAgICB2YXIgYXBwZW5kU3BsaXRJbmZvID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBjbGlja0luZm8pIHtcbiAgICAgICAgaWYgKGNsaWNrSW5mby5zcGxpdENvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdEluZm8gPSBjbGlja0luZm8uc3BsaXRDb250ZXh0O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3BsaXRJbmZvKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGZpZWxkLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC51bnNoaWZ0KG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS51bnNoaWZ0KHNwbGl0SW5mb1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRJbmRleCA9IGZpZWxkLmluZGV4T2YobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtmaWVsZEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtmaWVsZEluZGV4XSA9IHNwbGl0SW5mb1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjb21wdXRlTW9kaWZpZXJLZXkgPSBmdW5jdGlvbihjbGlja0luZm8pIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY2xpY2tJbmZvLm9yaWdpbmFsRXZlbnQgfHwgY2xpY2tJbmZvO1xuICAgICAgICByZXR1cm4gISEoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbXB1dGVBbHRLZXkgPSBmdW5jdGlvbihjbGlja0luZm8pIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY2xpY2tJbmZvLm9yaWdpbmFsRXZlbnQgfHwgY2xpY2tJbmZvO1xuICAgICAgICByZXR1cm4gISFldmVudC5hbHRLZXk7XG4gICAgfTtcblxuICAgIHZhciBjb252ZXJ0Um93RHJpbGxkb3duVG9JbnRlbnRpb25zID0gZnVuY3Rpb24oY2xpY2tJbmZvLCBtZXRhZGF0YSkge1xuICAgICAgICB2YXIgcm93Q29udGV4dCA9IF8oY2xpY2tJbmZvLnJvd0NvbnRleHQpLm9taXQoJ3Jvdy5fdGltZScpLFxuICAgICAgICAgICAgZmllbGQgPSBfKHJvd0NvbnRleHQpLmNoYWluKCkua2V5cygpLm1hcChmdW5jdGlvbihmKSB7IHJldHVybiBmLnJlcGxhY2UoJ3Jvdy4nLCAnJyk7IH0pLnZhbHVlKCksXG4gICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICB2YXIgaXNHcm91cGJ5RmllbGQgPSBmdW5jdGlvbihmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVtmaWVsZE5hbWVdICYmIG1ldGFkYXRhW2ZpZWxkTmFtZV0uaGFzT3duUHJvcGVydHkoJ2dyb3VwYnlfcmFuaycpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpc1NwbGl0YnlGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIF8uYW55KG1ldGFkYXRhLCBmdW5jdGlvbihtZXRhKSB7IHJldHVybiBtZXRhWydzcGxpdGJ5X2ZpZWxkJ10gPT09IGZpZWxkTmFtZTsgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSWYgYW55IGZpZWxkIGluIHRoZSBtZXRhZGF0YSBpcyB0aGUgcmVzdWx0IG9mIGEgZ3JvdXAtYnkgb3BlcmF0aW9uLCB0aGVuIGZpbHRlciBhcmd1bWVudHMgdG8gdGhlIGludGVudGlvbnNwYXJzZXJcbiAgICAgICAgLy8gdG8gb25seSBpbmNsdWRlIGdyb3VwLWJ5IGFuZCBzcGxpdC1ieSBmaWVsZHMuXG4gICAgICAgIGlmIChtZXRhZGF0YSAmJiBfLmFueShtZXRhZGF0YSwgZnVuY3Rpb24obWV0YSwgZmllbGROYW1lKSB7IHJldHVybiBpc0dyb3VwYnlGaWVsZChmaWVsZE5hbWUpOyB9KSkge1xuICAgICAgICAgICAgZmllbGQgPSBfKGZpZWxkKS5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0dyb3VwYnlGaWVsZChmKSB8fCBpc1NwbGl0YnlGaWVsZChmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gXyhmaWVsZCkubWFwKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIHJvd0NvbnRleHRbJ3Jvdy4nICsgZl07IH0pO1xuXG4gICAgICAgIGFwcGVuZFNwbGl0SW5mbyhmaWVsZCwgdmFsdWUsIGNsaWNrSW5mbyk7XG5cbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBhY3Rpb246ICdmaWVsZHZhbHVlJyxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZC5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG5vcm1hbGl6ZUZpZWxkKGYsIGNsaWNrSW5mbywgbWV0YWRhdGEpOyB9KSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnZlcnRDZWxsRHJpbGxkb3duVG9JbnRlbnRpb25zID0gZnVuY3Rpb24oY2xpY2tJbmZvLCBtZXRhZGF0YSkge1xuICAgICAgICB2YXIgZmllbGQsIHZhbHVlO1xuICAgICAgICBpZiAoY2xpY2tJbmZvLm5hbWUgPT09ICdfdGltZScpIHtcbiAgICAgICAgICAgIGZpZWxkID0gXy5jb21wYWN0KFtjbGlja0luZm8ubmFtZTJdKTtcbiAgICAgICAgICAgIHZhbHVlID0gXy5jb21wYWN0KFtjbGlja0luZm8udmFsdWUyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xpY2tJbmZvLm5hbWUgJiYgY2xpY2tJbmZvLm5hbWUyKSB7XG4gICAgICAgICAgICAgICAgZmllbGQgPSBbY2xpY2tJbmZvLm5hbWUsIGNsaWNrSW5mby5uYW1lMl07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbY2xpY2tJbmZvLnZhbHVlLCBjbGlja0luZm8udmFsdWUyXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xpY2tJbmZvLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBmaWVsZCA9IFtjbGlja0luZm8ubmFtZV07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbY2xpY2tJbmZvLnZhbHVlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGQgPSBbY2xpY2tJbmZvLm5hbWUyXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtjbGlja0luZm8udmFsdWUyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZFNwbGl0SW5mbyhmaWVsZCwgdmFsdWUsIGNsaWNrSW5mbyk7XG5cbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBhY3Rpb246ICdmaWVsZHZhbHVlJyxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZC5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG5vcm1hbGl6ZUZpZWxkKGYsIGNsaWNrSW5mbywgbWV0YWRhdGEpOyB9KSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnZlcnRDb2x1bW5EcmlsbGRvd25Ub0ludGVudGlvbnMgPSBmdW5jdGlvbihjbGlja0luZm8sIG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICghY2xpY2tJbmZvLnNwbGl0Q29udGV4dCAmJiAhY2xpY2tJbmZvLnNwbGl0RGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAna2V5d29yZCcsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGNsaWNrSW5mby5uYW1lMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBbXSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoY2xpY2tJbmZvLnZhbHVlMikge1xuICAgICAgICAgICAgICAgIGZpZWxkLnB1c2goY2xpY2tJbmZvLm5hbWUyKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGNsaWNrSW5mby52YWx1ZTIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcHBlbmRTcGxpdEluZm8oZmllbGQsIHZhbHVlLCBjbGlja0luZm8pO1xuXG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eShmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnZmllbGR2YWx1ZScsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZC5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG5vcm1hbGl6ZUZpZWxkKGYsIGNsaWNrSW5mbywgbWV0YWRhdGEpOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdrZXl3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IG5vcm1hbGl6ZUZpZWxkKGNsaWNrSW5mby5uYW1lMiwgY2xpY2tJbmZvLCBtZXRhZGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY29udmVydEFkZFRlcm1EcmlsbGRvd25Ub0ludGVudGlvbnMgPSBmdW5jdGlvbihjbGlja0luZm8sIG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICghY2xpY2tJbmZvLnNwbGl0Q29udGV4dCAmJiAhY2xpY2tJbmZvLnNwbGl0RGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnYWRkdGVybScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsaWNrSW5mby5uYW1lMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBbXSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoY2xpY2tJbmZvLnZhbHVlMikge1xuICAgICAgICAgICAgICAgIGZpZWxkLnB1c2goY2xpY2tJbmZvLm5hbWUyKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGNsaWNrSW5mby52YWx1ZTIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcHBlbmRTcGxpdEluZm8oZmllbGQsIHZhbHVlLCBjbGlja0luZm8pO1xuXG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eShmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnZmllbGR2YWx1ZScsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZC5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG5vcm1hbGl6ZUZpZWxkKGYsIGNsaWNrSW5mbywgbWV0YWRhdGEpOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdhZGR0ZXJtJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZUZpZWxkKGNsaWNrSW5mby5uYW1lMiwgY2xpY2tJbmZvLCBtZXRhZGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBub3JtYWxpemUgZGF0YSBmb3IgZHJpbGxkb3duIGV2ZW50IHRvIGhhbmRsZSBhIG1hcCBjbGlja1xuICAgIHZhciBjb252ZXJ0R2Vvdml6RHJpbGxkb3duVG9JbnRlbnRpb25zID0gZnVuY3Rpb24oY2xpY2tJbmZvKSB7XG4gICAgICAgIHZhciBsYXRMb25GaWVsZHMsIGxhdExvblZhbHVlcywgcGFyYW1zLFxuICAgICAgICAgICAgRFJJTExET1dOX1BST1BFUlRJRVMgPSB7XG4gICAgICAgICAgICAgICAgX2dlb19sYXRfZmllbGQ6ICdfZ2VvX2xhdF9maWVsZCcsXG4gICAgICAgICAgICAgICAgX2dlb19sb25fZmllbGQ6ICdfZ2VvX2xvbmdfZmllbGQnLFxuICAgICAgICAgICAgICAgIF9nZW9fYm91bmRzX3NvdXRoOiAnX2dlb19ib3VuZHNfc291dGgnLFxuICAgICAgICAgICAgICAgIF9nZW9fYm91bmRzX3dlc3Q6ICdfZ2VvX2JvdW5kc193ZXN0JyxcbiAgICAgICAgICAgICAgICBfZ2VvX2JvdW5kc19ub3J0aDogJ19nZW9fYm91bmRzX25vcnRoJyxcbiAgICAgICAgICAgICAgICBfZ2VvX2JvdW5kc19lYXN0OiAnX2dlb19ib3VuZHNfZWFzdCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFfLmFsbChEUklMTERPV05fUFJPUEVSVElFUywgZnVuY3Rpb24oc3JjS2V5KSB7IHJldHVybiAhIWNsaWNrSW5mby5kYXRhW3NyY0tleV07IH0pKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2VhcmNoIHJlc3VsdHMgZGlkIG5vdCBjb250YWluIGJvdW5kIGluZm9ybWF0aW9uIGZvciB0aGUgbWFya2VyLiBUaGlzIGhhcHBlbnMgd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIHJlc3VsdHMgaGF2ZSBub3QgYmVlbiBwcm9kdWNlZCBieSB0aGUgZ2Vvc3RhdHMgY29tbWFuZC4gSW4gdGhpcyBjYXNlIHdlIGZhbGwgYmFja1xuICAgICAgICAgICAgLy8gdG8gYSAnZmllbGR2YWx1ZScgYWN0aW9uIHdpdGggdGhlIGZpcnN0IHR3byBmaWVsZHMsIHdoaWNoIHNob3VsZCBiZSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxuICAgICAgICAgICAgbGF0TG9uRmllbGRzID0gY2xpY2tJbmZvLmZpZWxkcy5zbGljZSgwLCAyKTtcbiAgICAgICAgICAgIGxhdExvblZhbHVlcyA9IF8obGF0TG9uRmllbGRzKS5tYXAoZnVuY3Rpb24oZikgeyByZXR1cm4gY2xpY2tJbmZvLmRhdGFbZl07IH0pO1xuXG4gICAgICAgICAgICBhcHBlbmRTcGxpdEluZm8obGF0TG9uRmllbGRzLCBsYXRMb25WYWx1ZXMsIGNsaWNrSW5mbyk7XG5cbiAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2ZpZWxkdmFsdWUnLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBsYXRMb25GaWVsZHMsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxhdExvblZhbHVlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gXyhEUklMTERPV05fUFJPUEVSVElFUykuY2hhaW4oKS5tYXAoZnVuY3Rpb24oc3JjS2V5LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Byb3AsIGNsaWNrSW5mby5kYXRhW3NyY0tleV1dO1xuICAgICAgICB9KS5vYmplY3QoKS52YWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiAoXy5leHRlbmQoeyBhY3Rpb246ICdnZW92aXonIH0sIHBhcmFtcykpO1xuICAgIH07XG5cbiAgICB2YXIgbm9ybWFsaXplRmllbGQgPSBmdW5jdGlvbihmaWVsZE5hbWUsIGNsaWNrSW5mbywgbWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKCFjbGlja0luZm9cbiAgICAgICAgICAgIHx8ICFjbGlja0luZm8uc3BsaXREYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWRGaWVsZE5hbWUgPSBjbGlja0luZm8uc3BsaXREYXRhU291cmNlICsgJzogJyArIGZpZWxkTmFtZTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YVt1cGRhdGVkRmllbGROYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVkRmllbGROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgRHJpbGxkb3duID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgaW50ZW50aW9ucyBwYXJzZXIgd2hpY2ggdGhlbiBnZW5lcmF0ZXMgYSBuZXcgc2VhcmNoIHN0cmluZyBhbmQgdGltZSByYW5nZSBiYXNlZCBvbiB0aGUgb3JpZ2luYWxcbiAgICAgKiBzZWFyY2ggc3RyaW5nIG9mIHRoZSBtYW5hZ2VyIGFuZCB0aGUgY2xpY2sgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpY2tJbmZvIHtPYmplY3R9IC0ge1xuICAgICAqICAgICAgbmFtZS92YWx1ZSwgbmFtZTIvdmFsdWUyIHtTdHJpbmd9XG4gICAgICogICAgICBfc3BhbiB7TnVtYmVyfVxuICAgICAqICAgICAgdHlwZSB7U3RyaW5nfVxuICAgICAqICAgICAgcm93Q29udGV4dCB7T2JqZWN0fSBtYXAgb2YgYWxsIGtleS12YWx1ZSBwYWlycyBpbiB0aGUgcm93XG4gICAgICogICAgICBvcmlnaW5hbEV2ZW50IHtqUXVlcnkgRXZlbnR9IHRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50XG4gICAgICogIH1cbiAgICAgKiBAcGFyYW0gcXVlcnkge09iamVjdH0gLSB0aGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBxdWVyeSAtIHtcbiAgICAgKiAgICAgc2VhcmNoIHtTdHJpbmd9IHRoZSBjdXJyZW50IHNlYXJjaCBzdHJpbmdcbiAgICAgKiAgICAgZWFybGllc3Qge1N0cmluZ30gdGhlIGN1cnJlbnQgZWFybGllc3QgdGltZVxuICAgICAqICAgICBsYXRlc3Qge1N0cmluZ30gdGhlIGN1cnJlbnQgbGF0ZXN0IHRpbWVcbiAgICAgKiB9XG4gICAgICogQHBhcmFtIG1ldGFkYXRhIC0gdGhlIGN1cnJlbnQgZmllbGQgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25Nb2RlbCAtIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uIG1vZGVsXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gLSB7XG4gICAgICogICAgICBuZWdhdGUge0Jvb2xlYW59IC0gSW52ZXJ0IHRoZSBkcmlsbGRvd24gaW50ZW50aW9uXG4gICAgICogICAgICBzdHJpcFJlcG9ydHNTZWFyY2gge0Jvb2xlYW59IC0gZGVmYXVsdCB0cnVlLCBzdHJpcCBvZiBhbGwgcmVwb3J0aW5nIGNvbW1hbmRzLCBkcmlsbCBkb3duIGludG8gZXZlbnRzXG4gICAgICogICAgICBuZXdTZWFyY2gge0Jvb2xlYW59IC0gZGVmYXVsdCBmYWxzZSwgZHJpbGwgZG93biBpbnRvIGFsbCBldmVudHMsIGlnbm9yZXMgY3VycmVudCBzZWFyY2ggc3RyaW5nXG4gICAgICogICAgICBkcmlsbGRvd25OZXdUYWIge0Jvb2xlYW59IC0gd2hldGhlciB0byBvcGVuIGEgbmV3IHRhYiBmb3IgdGhlIGRyaWxsZG93biBhY3Rpb24sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCBpcyB0byBpbnNwZWN0IHRoZSBjbGlja0luZm8gZm9yIGEgbW9kaWZpZXIga2V5XG4gICAgICogICAgICBmaWVsZHMge0FycmF5fSAtIGxpc3Qgb2YgYWRkaXRpb25hbCBmaWVsZCBjb25zdHJhaW50cyB0byBhcHBseSB0byBjZWxsIGRyaWxsZG93blxuICAgICAqICAgICAgdmFsdWVzIHtBcnJheX0gLSBsaXN0IG9mIGFkZGl0aW9uYWwgdmFsdWUgY29uc3RyYWludHMgKDEgdG8gMSBjb3JyZXNwb25kZW5jZSB3aXRoIFwiZmllbGRzXCIgYWJvdmUpXG4gICAgICogIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgaW50ZW50aW9ucyBwYXJzZXIgLSB3aGljaCBpcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2VhcmNoXG4gICAgICogICAgICAgICAgICAgIHN0cmluZyAocSkgYW5kIHRoZSB0aW1lIHJhbmdlIChlYXJsaWVzdCBhbmQgbGF0ZXN0KVxuICAgICAqL1xuICAgIERyaWxsZG93bi5hcHBseURyaWxsZG93bkludGVudGlvbiA9IGZ1bmN0aW9uKGNsaWNrSW5mbywgcXVlcnksIG1ldGFkYXRhLCBhcHBsaWNhdGlvbk1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgIHZhciBzZWFyY2ggPSBvcHRpb25zLm5ld1NlYXJjaCA/ICcqJyA6IHF1ZXJ5LnNlYXJjaCxcbiAgICAgICAgICAgIG5ld1RhYiA9IERyaWxsZG93bi5zaG91bGREcmlsbGRvd25Jbk5ld1RhYihjbGlja0luZm8sIG9wdGlvbnMpLFxuICAgICAgICAgICAgaW50ZW50aW9uc1BhcnNlciA9IG5ldyBJbnRlbnRpb25zUGFyc2VyKCk7XG5cbiAgICAgICAgaWYgKGNsaWNrSW5mby5uYW1lID09PSAnX3RpbWUnKSB7XG4gICAgICAgICAgICBpbnRlbnRpb25zUGFyc2VyLnNldCh7XG4gICAgICAgICAgICAgICAgJ2Rpc3BhdGNoLmVhcmxpZXN0X3RpbWUnOiBjbGlja0luZm8udmFsdWVcbiAgICAgICAgICAgIH0sIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGlja0luZm8uX3NwYW4pIHtcbiAgICAgICAgICAgIGludGVudGlvbnNQYXJzZXIuc2V0KHtcbiAgICAgICAgICAgICAgICAnZGlzcGF0Y2gubGF0ZXN0X3RpbWUnOiBKU09OLnN0cmluZ2lmeShNYXRoLnJvdW5kKChwYXJzZUZsb2F0KGNsaWNrSW5mby52YWx1ZSkgKyBjbGlja0luZm8uX3NwYW4pICogMTAwMCkgLyAxMDAwKVxuICAgICAgICAgICAgfSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW50ZW50aW9uUGFyYW1zID0ge1xuICAgICAgICAgICAgbmVnYXRlOiBvcHRpb25zLmhhc093blByb3BlcnR5KCduZWdhdGUnKSA/IG9wdGlvbnMubmVnYXRlIDogY29tcHV0ZUFsdEtleShjbGlja0luZm8pLFxuICAgICAgICAgICAgc3RyaXBSZXBvcnRzU2VhcmNoOiBvcHRpb25zLmhhc093blByb3BlcnR5KCdzdHJpcFJlcG9ydHNTZWFyY2gnKSA/IG9wdGlvbnMuc3RyaXBSZXBvcnRzU2VhcmNoIDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5maWVsZHMgJiYgb3B0aW9ucy5maWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgXy5leHRlbmQoaW50ZW50aW9uUGFyYW1zLCB7IGFjdGlvbjogJ2ZpZWxkdmFsdWUnLCBmaWVsZDogb3B0aW9ucy5maWVsZHMsIHZhbHVlOiBvcHRpb25zLnZhbHVlcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGlja0luZm8udHlwZSA9PT0gJ2dlb3ZpeicpIHtcbiAgICAgICAgICAgIF8uZXh0ZW5kKGludGVudGlvblBhcmFtcywgY29udmVydEdlb3ZpekRyaWxsZG93blRvSW50ZW50aW9ucyhjbGlja0luZm8pKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbGlja0luZm8udHlwZSA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgIF8uZXh0ZW5kKGludGVudGlvblBhcmFtcywgY29udmVydENvbHVtbkRyaWxsZG93blRvSW50ZW50aW9ucyhjbGlja0luZm8sIG1ldGFkYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xpY2tJbmZvLnR5cGUgPT09ICdyb3cnKSB7XG4gICAgICAgICAgICBfLmV4dGVuZChpbnRlbnRpb25QYXJhbXMsIGNvbnZlcnRSb3dEcmlsbGRvd25Ub0ludGVudGlvbnMoY2xpY2tJbmZvLCBtZXRhZGF0YSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNsaWNrSW5mby50eXBlID09PSAnYWRkdGVybScpIHtcbiAgICAgICAgICAgIF8uZXh0ZW5kKGludGVudGlvblBhcmFtcywgY29udmVydEFkZFRlcm1EcmlsbGRvd25Ub0ludGVudGlvbnMoY2xpY2tJbmZvLCBtZXRhZGF0YSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy5leHRlbmQoaW50ZW50aW9uUGFyYW1zLCBjb252ZXJ0Q2VsbERyaWxsZG93blRvSW50ZW50aW9ucyhjbGlja0luZm8sIG1ldGFkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmluZm8oJ0FwcGx5aW5nIGRyaWxsZG93biBpbnRlbnRpb24nLCBpbnRlbnRpb25QYXJhbXMpO1xuICAgICAgICB2YXIgZGZkID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICBpbnRlbnRpb25zUGFyc2VyLmZldGNoKHtcbiAgICAgICAgICAgIGRhdGE6IF8uZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBxOiBzZWFyY2gsXG4gICAgICAgICAgICAgICAgZmllbGRNZXRhRGF0YTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpLFxuICAgICAgICAgICAgICAgIGFwcDogYXBwbGljYXRpb25Nb2RlbC5nZXQoJ2FwcCcpLFxuICAgICAgICAgICAgICAgIG93bmVyOiBhcHBsaWNhdGlvbk1vZGVsLmdldCgnb3duZXInKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9vbmx5OiB0cnVlXG4gICAgICAgICAgICB9LCBpbnRlbnRpb25QYXJhbXMpXG4gICAgICAgIH0pLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZmQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgJ3EnOiBzcGx1bmtVdGlsLnN0cmlwTGVhZGluZ1NlYXJjaENvbW1hbmQoaW50ZW50aW9uc1BhcnNlci5nZXQoJ2Z1bGxTZWFyY2gnKSksXG4gICAgICAgICAgICAgICAgJ2VhcmxpZXN0JzogaW50ZW50aW9uc1BhcnNlci5nZXQoJ2Rpc3BhdGNoLmVhcmxpZXN0X3RpbWUnKSB8fCBxdWVyeS5lYXJsaWVzdCB8fCAwLFxuICAgICAgICAgICAgICAgICdsYXRlc3QnOiBpbnRlbnRpb25zUGFyc2VyLmdldCgnZGlzcGF0Y2gubGF0ZXN0X3RpbWUnKSB8fCBxdWVyeS5sYXRlc3QgfHwgJydcbiAgICAgICAgICAgIH0sIG5ld1RhYik7XG4gICAgICAgIH0pLmZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZmQucmVqZWN0LmFwcGx5KGRmZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRmZC5wcm9taXNlKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZHJpbGxkb3duIHNob3VsZCBiZSBpbiBhIG5ldyB0YWIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpY2tJbmZvIHtPYmplY3R9IChzZWUgYXBwbHlEcmlsbGRvd25JbnRlbnRpb24gYWJvdmUpXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gKHNlZSBhcHBseURyaWxsZG93bkludGVudGlvbiBhYm92ZSlcbiAgICAgKi9cbiAgICBEcmlsbGRvd24uc2hvdWxkRHJpbGxkb3duSW5OZXdUYWIgPSBmdW5jdGlvbihjbGlja0luZm8sIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBtb2RpZmllcktleSA9IGNsaWNrSW5mby5oYXNPd25Qcm9wZXJ0eSgnbW9kaWZpZXJLZXknKSA/IGNsaWNrSW5mby5tb2RpZmllcktleSA6IGNvbXB1dGVNb2RpZmllcktleShjbGlja0luZm8pO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZHJpbGxkb3duTmV3VGFiJykgPyBvcHRpb25zLmRyaWxsZG93bk5ld1RhYiA6IG1vZGlmaWVyS2V5O1xuICAgIH07XG5cbiAgICAvLyB3ZSB3YW50IHRob3NlIGZ1bmN0aW9ucyB0byBiZSB0ZXN0YWJsZVxuICAgIERyaWxsZG93bi5fY29udmVydFJvd0RyaWxsZG93blRvSW50ZW50aW9ucyA9IGNvbnZlcnRSb3dEcmlsbGRvd25Ub0ludGVudGlvbnM7XG4gICAgRHJpbGxkb3duLl9jb252ZXJ0Q2VsbERyaWxsZG93blRvSW50ZW50aW9ucyA9IGNvbnZlcnRDZWxsRHJpbGxkb3duVG9JbnRlbnRpb25zO1xuICAgIERyaWxsZG93bi5fY29udmVydENvbHVtbkRyaWxsZG93blRvSW50ZW50aW9ucyA9IGNvbnZlcnRDb2x1bW5EcmlsbGRvd25Ub0ludGVudGlvbnM7XG4gICAgRHJpbGxkb3duLl9jb252ZXJ0QWRkVGVybURyaWxsZG93blRvSW50ZW50aW9ucyA9IGNvbnZlcnRBZGRUZXJtRHJpbGxkb3duVG9JbnRlbnRpb25zO1xuICAgIERyaWxsZG93bi5fY29udmVydEdlb3ZpekRyaWxsZG93blRvSW50ZW50aW9ucyA9IGNvbnZlcnRHZW92aXpEcmlsbGRvd25Ub0ludGVudGlvbnM7XG4gICAgRHJpbGxkb3duLl9ub3JtYWxpemVGaWVsZCA9IG5vcm1hbGl6ZUZpZWxkO1xuXG4gICAgcmV0dXJuIERyaWxsZG93bjtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvdXRpbC9kcmlsbGRvd24uanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvZHJpbGxkb3duXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "models/services/search/IntentionsParser":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @author sfishel\n *\n * Model representation of the intentions parser endpoint.\n *\n * The endpoint is still in flux, so there is a little hackery here to try to expose the interface we will eventually have\n * from splunkd but don't have yet.\n *\n * Sample REST response:\n\n   {\n        \"remoteSearch\": \"litsearch * | eval  myfield = 10  | search somefield = somevalue  | addinfo  type=count label=prereport_events | fields  keepcolorder=t \\\"_bkt\\\" \\\"_cd\\\" \\\"_si\\\" \\\"host\\\" \\\"index\\\" \\\"linecount\\\" \\\"prestats_reserved_*\\\" \\\"psrsvd_*\\\" \\\"source\\\" \\\"sourcetype\\\" \\\"splunk_server\\\"  | remotetl  nb=300 et=2147483647.000000 lt=0.000000 max_count=1000 max_prefetch=100 | prestats  count\",\n        \"remoteTimeOrdered\": true,\n        \"eventsSearch\": \"search *   | eval myfield = 10  | search somefield = somevalue \",\n        \"eventsTimeOrdered\": true,\n        \"eventsStreaming\": true,\n        \"reportsSearch\": \"stats  count\",\n        \"canSummarize\": false,\n        \"commands\": [\n            {\n                \"command\": \"search\",\n                \"rawargs\": \"*  \",\n                \"pipeline\": \"streaming\",\n                \"args\": {\n                    \"search\": [\n                        \"*\"\n                    ]\n                },\n                \"isGenerating\": true,\n                \"streamType\": \"SP_STREAM\"\n            },\n            {\n                \"command\": \"eval\",\n                \"rawargs\": \"myfield = 10 \",\n                \"pipeline\": \"streaming\",\n                \"args\": \" myfield = 10 \",\n                \"isGenerating\": false,\n                \"streamType\": \"SP_STREAM\"\n            },\n            {\n                \"command\": \"search\",\n                \"rawargs\": \"somefield = somevalue \",\n                \"pipeline\": \"streaming\",\n                \"args\": {\n                    \"search\": [\n                        \"somefield = somevalue \"\n                    ]\n                },\n                \"isGenerating\": false,\n                \"streamType\": \"SP_STREAM\"\n            },\n            {\n                \"command\": \"stats\",\n                \"rawargs\": \"count\",\n                \"pipeline\": \"report\",\n                \"args\": {\n                    \"stat-specifiers\": [\n                        {\n                            \"function\": \"count\",\n                            \"rename\": \"count\"\n                        }\n                    ]\n                },\n                \"isGenerating\": false,\n                \"streamType\": \"SP_STREAMREPORT\",\n                \"isStreamingOpRequired\": false,\n                \"preStreamingOp\": \"prestats count\"\n            }\n        ]\n    }\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(\"shim/jquery\"),\n            __webpack_require__(\"require/underscore\"),\n            __webpack_require__(\"require/backbone\"),\n            __webpack_require__(\"models/Base\"),\n            __webpack_require__(\"util/splunkd_utils\"),\n            __webpack_require__(\"shim/splunk.util\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = function(\n            $,\n            _,\n            Backbone,\n            Base,\n            splunkDUtils,\n            splunkUtils\n        ) {\n\n    var DELIMITER = ':!:';\n\n    return Base.extend({\n\n        url: 'search/intentionsparser',\n\n        sync: function(method, model, options) {\n            if(method !== 'read') {\n                throw new Error('Sync operation not supported: ' + method);\n            }\n\n            options = $.extend(true, {}, options);\n            // these URLs can be quite long, so we make this request by POST\n            options.type = 'POST';\n            var data = options.data;\n            if(_.isArray(data.field)) {\n                data.field = data.field.join(DELIMITER);\n                data.value = data.value.join(DELIMITER);\n            }\n\n            // TEMPORARY: currently a different endpoint has to be used if you just want to parse the search with no action\n            // eventually they will be unified in the same endpoint so we just switch the URL here for the time being\n            var url = (options.data && options.data.action) ? model.url : 'search/parser',\n                syncOptions = splunkDUtils.prepareSyncOptions(options, url);\n\n            if(syncOptions.data && syncOptions.data.q) {\n                syncOptions.data.q = splunkUtils.addLeadingSearchCommand(syncOptions.data.q, true);\n            }\n\n            return Base.prototype.sync.call(this, 'read', model, syncOptions);\n        },\n        \n        fullSearch: function() {\n            var fullSearch = this.get('fullSearch');\n            \n            if(fullSearch) {\n                return splunkUtils.stripLeadingSearchCommand(fullSearch);\n            }\n            var reportsSearch = this.get('reportsSearch') || '',\n                eventsSearch = splunkUtils.stripLeadingSearchCommand(this.get('eventsSearch') || '');\n            \n            // Per the discussion in SPL-130978, adding a leading \"|\" to the eventSearch \n            // when eventSearch doesn't start with \"search\"\n            eventsSearch = (eventsSearch && (eventsSearch === this.get('eventsSearch'))) ? '| ' + eventsSearch : eventsSearch;\n            //reportSearch need the leading pipe \"|\" before combining with the eventsSearch\n            reportsSearch = reportsSearch ? ' | ' + reportsSearch : reportsSearch;\n            return eventsSearch + reportsSearch;\n        },\n\n        isReportsSearch: function() {\n            var reportsSearch = this.get('reportsSearch');\n            return reportsSearch ? true : false;\n        }\n\n    });\n\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL21vZGVscy9zZXJ2aWNlcy9zZWFyY2gvSW50ZW50aW9uc1BhcnNlci5qcz9iMzIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTCxDQUFDIiwiZmlsZSI6Im1vZGVscy9zZXJ2aWNlcy9zZWFyY2gvSW50ZW50aW9uc1BhcnNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGF1dGhvciBzZmlzaGVsXG4gKlxuICogTW9kZWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVudGlvbnMgcGFyc2VyIGVuZHBvaW50LlxuICpcbiAqIFRoZSBlbmRwb2ludCBpcyBzdGlsbCBpbiBmbHV4LCBzbyB0aGVyZSBpcyBhIGxpdHRsZSBoYWNrZXJ5IGhlcmUgdG8gdHJ5IHRvIGV4cG9zZSB0aGUgaW50ZXJmYWNlIHdlIHdpbGwgZXZlbnR1YWxseSBoYXZlXG4gKiBmcm9tIHNwbHVua2QgYnV0IGRvbid0IGhhdmUgeWV0LlxuICpcbiAqIFNhbXBsZSBSRVNUIHJlc3BvbnNlOlxuXG4gICB7XG4gICAgICAgIFwicmVtb3RlU2VhcmNoXCI6IFwibGl0c2VhcmNoICogfCBldmFsICBteWZpZWxkID0gMTAgIHwgc2VhcmNoIHNvbWVmaWVsZCA9IHNvbWV2YWx1ZSAgfCBhZGRpbmZvICB0eXBlPWNvdW50IGxhYmVsPXByZXJlcG9ydF9ldmVudHMgfCBmaWVsZHMgIGtlZXBjb2xvcmRlcj10IFxcXCJfYmt0XFxcIiBcXFwiX2NkXFxcIiBcXFwiX3NpXFxcIiBcXFwiaG9zdFxcXCIgXFxcImluZGV4XFxcIiBcXFwibGluZWNvdW50XFxcIiBcXFwicHJlc3RhdHNfcmVzZXJ2ZWRfKlxcXCIgXFxcInBzcnN2ZF8qXFxcIiBcXFwic291cmNlXFxcIiBcXFwic291cmNldHlwZVxcXCIgXFxcInNwbHVua19zZXJ2ZXJcXFwiICB8IHJlbW90ZXRsICBuYj0zMDAgZXQ9MjE0NzQ4MzY0Ny4wMDAwMDAgbHQ9MC4wMDAwMDAgbWF4X2NvdW50PTEwMDAgbWF4X3ByZWZldGNoPTEwMCB8IHByZXN0YXRzICBjb3VudFwiLFxuICAgICAgICBcInJlbW90ZVRpbWVPcmRlcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZXZlbnRzU2VhcmNoXCI6IFwic2VhcmNoICogICB8IGV2YWwgbXlmaWVsZCA9IDEwICB8IHNlYXJjaCBzb21lZmllbGQgPSBzb21ldmFsdWUgXCIsXG4gICAgICAgIFwiZXZlbnRzVGltZU9yZGVyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJldmVudHNTdHJlYW1pbmdcIjogdHJ1ZSxcbiAgICAgICAgXCJyZXBvcnRzU2VhcmNoXCI6IFwic3RhdHMgIGNvdW50XCIsXG4gICAgICAgIFwiY2FuU3VtbWFyaXplXCI6IGZhbHNlLFxuICAgICAgICBcImNvbW1hbmRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImNvbW1hbmRcIjogXCJzZWFyY2hcIixcbiAgICAgICAgICAgICAgICBcInJhd2FyZ3NcIjogXCIqICBcIixcbiAgICAgICAgICAgICAgICBcInBpcGVsaW5lXCI6IFwic3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJhcmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzZWFyY2hcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIqXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJpc0dlbmVyYXRpbmdcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInN0cmVhbVR5cGVcIjogXCJTUF9TVFJFQU1cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImNvbW1hbmRcIjogXCJldmFsXCIsXG4gICAgICAgICAgICAgICAgXCJyYXdhcmdzXCI6IFwibXlmaWVsZCA9IDEwIFwiLFxuICAgICAgICAgICAgICAgIFwicGlwZWxpbmVcIjogXCJzdHJlYW1pbmdcIixcbiAgICAgICAgICAgICAgICBcImFyZ3NcIjogXCIgbXlmaWVsZCA9IDEwIFwiLFxuICAgICAgICAgICAgICAgIFwiaXNHZW5lcmF0aW5nXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwic3RyZWFtVHlwZVwiOiBcIlNQX1NUUkVBTVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiY29tbWFuZFwiOiBcInNlYXJjaFwiLFxuICAgICAgICAgICAgICAgIFwicmF3YXJnc1wiOiBcInNvbWVmaWVsZCA9IHNvbWV2YWx1ZSBcIixcbiAgICAgICAgICAgICAgICBcInBpcGVsaW5lXCI6IFwic3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJhcmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzZWFyY2hcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzb21lZmllbGQgPSBzb21ldmFsdWUgXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJpc0dlbmVyYXRpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJzdHJlYW1UeXBlXCI6IFwiU1BfU1RSRUFNXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJjb21tYW5kXCI6IFwic3RhdHNcIixcbiAgICAgICAgICAgICAgICBcInJhd2FyZ3NcIjogXCJjb3VudFwiLFxuICAgICAgICAgICAgICAgIFwicGlwZWxpbmVcIjogXCJyZXBvcnRcIixcbiAgICAgICAgICAgICAgICBcImFyZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInN0YXQtc3BlY2lmaWVyc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBcImNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZW5hbWVcIjogXCJjb3VudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiaXNHZW5lcmF0aW5nXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwic3RyZWFtVHlwZVwiOiBcIlNQX1NUUkVBTVJFUE9SVFwiLFxuICAgICAgICAgICAgICAgIFwiaXNTdHJlYW1pbmdPcFJlcXVpcmVkXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwicHJlU3RyZWFtaW5nT3BcIjogXCJwcmVzdGF0cyBjb3VudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9XG4gKi9cblxuZGVmaW5lKFtcbiAgICAgICAgICAgICdqcXVlcnknLFxuICAgICAgICAgICAgJ3VuZGVyc2NvcmUnLFxuICAgICAgICAgICAgJ2JhY2tib25lJyxcbiAgICAgICAgICAgICdtb2RlbHMvQmFzZScsXG4gICAgICAgICAgICAndXRpbC9zcGx1bmtkX3V0aWxzJyxcbiAgICAgICAgICAgICdzcGx1bmsudXRpbCdcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24oXG4gICAgICAgICAgICAkLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIEJhY2tib25lLFxuICAgICAgICAgICAgQmFzZSxcbiAgICAgICAgICAgIHNwbHVua0RVdGlscyxcbiAgICAgICAgICAgIHNwbHVua1V0aWxzXG4gICAgICAgICkge1xuXG4gICAgdmFyIERFTElNSVRFUiA9ICc6ITonO1xuXG4gICAgcmV0dXJuIEJhc2UuZXh0ZW5kKHtcblxuICAgICAgICB1cmw6ICdzZWFyY2gvaW50ZW50aW9uc3BhcnNlcicsXG5cbiAgICAgICAgc3luYzogZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYobWV0aG9kICE9PSAncmVhZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bmMgb3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQ6ICcgKyBtZXRob2QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gdGhlc2UgVVJMcyBjYW4gYmUgcXVpdGUgbG9uZywgc28gd2UgbWFrZSB0aGlzIHJlcXVlc3QgYnkgUE9TVFxuICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gJ1BPU1QnO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICAgICAgICBpZihfLmlzQXJyYXkoZGF0YS5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmZpZWxkID0gZGF0YS5maWVsZC5qb2luKERFTElNSVRFUik7XG4gICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IGRhdGEudmFsdWUuam9pbihERUxJTUlURVIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBURU1QT1JBUlk6IGN1cnJlbnRseSBhIGRpZmZlcmVudCBlbmRwb2ludCBoYXMgdG8gYmUgdXNlZCBpZiB5b3UganVzdCB3YW50IHRvIHBhcnNlIHRoZSBzZWFyY2ggd2l0aCBubyBhY3Rpb25cbiAgICAgICAgICAgIC8vIGV2ZW50dWFsbHkgdGhleSB3aWxsIGJlIHVuaWZpZWQgaW4gdGhlIHNhbWUgZW5kcG9pbnQgc28gd2UganVzdCBzd2l0Y2ggdGhlIFVSTCBoZXJlIGZvciB0aGUgdGltZSBiZWluZ1xuICAgICAgICAgICAgdmFyIHVybCA9IChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhLmFjdGlvbikgPyBtb2RlbC51cmwgOiAnc2VhcmNoL3BhcnNlcicsXG4gICAgICAgICAgICAgICAgc3luY09wdGlvbnMgPSBzcGx1bmtEVXRpbHMucHJlcGFyZVN5bmNPcHRpb25zKG9wdGlvbnMsIHVybCk7XG5cbiAgICAgICAgICAgIGlmKHN5bmNPcHRpb25zLmRhdGEgJiYgc3luY09wdGlvbnMuZGF0YS5xKSB7XG4gICAgICAgICAgICAgICAgc3luY09wdGlvbnMuZGF0YS5xID0gc3BsdW5rVXRpbHMuYWRkTGVhZGluZ1NlYXJjaENvbW1hbmQoc3luY09wdGlvbnMuZGF0YS5xLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIEJhc2UucHJvdG90eXBlLnN5bmMuY2FsbCh0aGlzLCAncmVhZCcsIG1vZGVsLCBzeW5jT3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBmdWxsU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmdWxsU2VhcmNoID0gdGhpcy5nZXQoJ2Z1bGxTZWFyY2gnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZnVsbFNlYXJjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGx1bmtVdGlscy5zdHJpcExlYWRpbmdTZWFyY2hDb21tYW5kKGZ1bGxTZWFyY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcG9ydHNTZWFyY2ggPSB0aGlzLmdldCgncmVwb3J0c1NlYXJjaCcpIHx8ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50c1NlYXJjaCA9IHNwbHVua1V0aWxzLnN0cmlwTGVhZGluZ1NlYXJjaENvbW1hbmQodGhpcy5nZXQoJ2V2ZW50c1NlYXJjaCcpIHx8ICcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUGVyIHRoZSBkaXNjdXNzaW9uIGluIFNQTC0xMzA5NzgsIGFkZGluZyBhIGxlYWRpbmcgXCJ8XCIgdG8gdGhlIGV2ZW50U2VhcmNoIFxuICAgICAgICAgICAgLy8gd2hlbiBldmVudFNlYXJjaCBkb2Vzbid0IHN0YXJ0IHdpdGggXCJzZWFyY2hcIlxuICAgICAgICAgICAgZXZlbnRzU2VhcmNoID0gKGV2ZW50c1NlYXJjaCAmJiAoZXZlbnRzU2VhcmNoID09PSB0aGlzLmdldCgnZXZlbnRzU2VhcmNoJykpKSA/ICd8ICcgKyBldmVudHNTZWFyY2ggOiBldmVudHNTZWFyY2g7XG4gICAgICAgICAgICAvL3JlcG9ydFNlYXJjaCBuZWVkIHRoZSBsZWFkaW5nIHBpcGUgXCJ8XCIgYmVmb3JlIGNvbWJpbmluZyB3aXRoIHRoZSBldmVudHNTZWFyY2hcbiAgICAgICAgICAgIHJlcG9ydHNTZWFyY2ggPSByZXBvcnRzU2VhcmNoID8gJyB8ICcgKyByZXBvcnRzU2VhcmNoIDogcmVwb3J0c1NlYXJjaDtcbiAgICAgICAgICAgIHJldHVybiBldmVudHNTZWFyY2ggKyByZXBvcnRzU2VhcmNoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzUmVwb3J0c1NlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVwb3J0c1NlYXJjaCA9IHRoaXMuZ2V0KCdyZXBvcnRzU2VhcmNoJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0c1NlYXJjaCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL21vZGVscy9zZXJ2aWNlcy9zZWFyY2gvSW50ZW50aW9uc1BhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gbW9kZWxzL3NlcnZpY2VzL3NlYXJjaC9JbnRlbnRpb25zUGFyc2VyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "util/time":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(\"require/underscore\"),\n        __webpack_require__(\"stubs/i18n\"),\n        __webpack_require__(\"shim/splunk.util\"),\n        __webpack_require__(\"util/moment\"),\n        __webpack_require__(\"util/console\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, i18n, splunkUtils, moment, console) {\n\n        var BD_TIME_REGEX_MILLIS = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)[+-]{1}\\d{2}[:]?\\d{2}$/,\n            BD_TIME_REGEX_NO_MILLIS = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})[+-]{1}\\d{2}[:]?\\d{2}$/,\n            STRIP_TIMEZONE_REGEX = /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.{0,1}(\\d*))[+-]{1}\\d{2}[:]?\\d{2}$/,\n            u = {},\n            language = i18n.locale_name().substring(0, 2),\n            ISO_PATTERN = '%Y-%m-%dT%H:%M:%S.%Q%:z';\n        \n        u.s = u.sec = u.secs = u.second = u.seconds = {abbr: \"s\",  singular: _(\"second\").t(), plural: _(\"seconds\").t()};\n        u.m = u.min = u.mins = u.minute = u.minutes = {abbr: \"m\", singular: _(\"minute\").t(), plural: _(\"minutes\").t()};\n        u.h = u.hr  = u.hrs  = u.hour   = u.hours   = {abbr: \"h\", singular: _(\"hour\").t(), plural: _(\"hours\").t()};\n        u.d = u.day = u.days = {abbr: \"d\", singular: _(\"day\").t(), plural: _(\"days\").t()};\n        u.w = u.week = u.weeks = {abbr: \"w\", singular: _(\"week\").t(), plural: _(\"weeks\").t()};\n        u.mon = u.month = u.months = {abbr: \"mon\", singular: _(\"month\").t(), plural: _(\"months\").t()};\n        u.q = u.qtr = u.qtrs = u.quarter = u.quarters = {abbr: \"q\", singular: _(\"quarter\").t(), plural: _(\"quarters\").t()};\n        u.y = u.yr = u.yrs = u.year = u.years = {abbr: \"y\", singular: _(\"year\").t(), plural: _(\"years\").t()};\n            \n        var TIME_UNITS = u;\n    \n        var BdTime = function(isoString) {\n            var bdPieces = BD_TIME_REGEX_MILLIS.exec(isoString) || BD_TIME_REGEX_NO_MILLIS.exec(isoString);\n            if(!bdPieces) {\n                this.isInvalid = true;\n            }\n            else {\n                this.year   = parseInt(bdPieces[1], 10);\n                this.month  = parseInt(bdPieces[2], 10);\n                this.day    = parseInt(bdPieces[3], 10);\n                this.hour   = parseInt(bdPieces[4], 10);\n                this.minute = parseInt(bdPieces[5], 10);\n                this.second = parseInt(bdPieces[6], 10);\n                this.millisecond = bdPieces.length > 7 ? parseInt(bdPieces[7], 10) : 0;\n            }\n        };\n    \n        var extractBdTime = function(timeString) {\n            return new BdTime(timeString);\n        };\n    \n        var bdTimeToDateObject = function(bdTime) {\n            var year     = bdTime.year,\n                month    = bdTime.month - 1,\n                day      = bdTime.day,\n                hour     = bdTime.hour,\n                minute   = bdTime.minute,\n                second   = bdTime.second,\n                millisecond = bdTime.millisecond;\n    \n            return new Date(year, month, day, hour, minute, second, millisecond);\n        };\n\n        var getTimezoneString = function(dateObj) {\n            var timezoneOffset = dateObj.getTimezoneOffset(),\n                absoluteValueTimezoneOffset = Math.abs(timezoneOffset),\n                hours = Math.floor(absoluteValueTimezoneOffset / 60),\n                minutes = absoluteValueTimezoneOffset % 60,\n                formattedHours = hours < 10 ? '0' + hours : '' + hours,\n                formattedMinutes = minutes < 10 ? '0' + minutes : '' + minutes,\n                timezone = (timezoneOffset > 0 ? '-' : '+') + formattedHours + ':' + formattedMinutes;\n            \n            return timezone;\n        };\n\n        /*\n         * Converts a time in seconds to a year/day/hour/minute/second format.\n         * If hourCap flag is true, then years/days aren't included in the conversion,\n         * and hours is allowed to be larger than 24.\n         * @param seconds: the number of seconds to convert\n         * @param hourCap [optional]: whether to cap everything above hour, default false.\n         * @return {Object}\n        */\n        var secondsToSeparatedDate = function(time, hourCap) {\n            var years = 0, days = 0, hours, minutes, seconds, curTimeCounter = time;\n\n            if (!hourCap) {\n                years = Math.floor(curTimeCounter / 31557600); // 365.25 days per year\n                curTimeCounter -= years * 31557600;\n\n                days = Math.floor(curTimeCounter / 86400);\n                curTimeCounter -= days * 86400;\n            }\n\n            hours = Math.floor(curTimeCounter / 3600);\n            curTimeCounter -= hours * 3600;\n\n            minutes = Math.floor(curTimeCounter / 60);\n            curTimeCounter -= minutes * 60;\n\n            // We never want to show a time of 0 for everything, so if we started with something like\n            // 0.1 for time, just ceil the counter. Otherwise round it.\n            seconds = time < 1 ? Math.ceil(curTimeCounter) : Math.round(curTimeCounter);\n\n            return {\n                years: years,\n                days: days,\n                hours: hours,\n                minutes: minutes,\n                seconds: seconds\n            };\n        };\n    \n        var isoToDateObject = function(isoString) {\n            var matches = STRIP_TIMEZONE_REGEX.exec(isoString);\n            if (matches) {\n                var isoWithoutTimezone = matches[1],\n                    isoWithSpoofedTimezone = isoWithoutTimezone + getTimezoneString(new Date()),\n                    correctedIso = isoWithoutTimezone + getTimezoneString(moment(isoWithSpoofedTimezone).toDate());\n                return moment(correctedIso).toDate();\n            }\n\n            return new Date(NaN);\n        };\n        \n        var jsDateToSplunkDateTimeWithMicroseconds = function(jsDate) {\n            var dateTime = new i18n.DateTime({\n                date: jsDate,\n                year: jsDate.getFullYear(),\n                month: jsDate.getMonth() + 1,\n                day: jsDate.getDate(),\n                hour: jsDate.getHours(),\n                minute: jsDate.getMinutes(),\n                second: jsDate.getSeconds(),\n                microsecond: jsDate.getMilliseconds() * 1000\n            });\n            dateTime.weekday = function() {\n                var d = this.date.getDay() - 1;\n                if (d < 0)\n                    d = 6;\n                return d;\n            };\n            return dateTime;\n        };\n\n        var _calculateTimeFormat = function(time, spanSeries) {\n            var span = parseFloat(spanSeries[0]);\n            if(!(time instanceof BdTime)) {\n                time = extractBdTime(time);\n            }\n            if (!span) {\n                return time.millisecond === 0 ? 'second' : 'millisecond';\n            }\n\n            if((span >= 0 && span < 1) || (time.millisecond !== 0)) {\n                return 'millisecond';\n            }\n            if((span >= 1 && span < 60) || (time.second !== 0)) {\n                return 'second';\n            }\n            if((span >= 60 && span < 3600) || (time.minute !== 0)) {\n                return 'minute';\n            }\n            if ((span >= 3600 && span <= 82800) || (time.hour !== 0)) { // 23 hour (82800)\n                return 'hour';\n            }\n            if ((span > 82800 && span <= 2419200) || (time.day !== 1)) { // 1 day to 28 days\n                return 'day';\n            }\n            if ((span > 2419200 && span <= 31535999) || (time.month !== 1)) { // 28 days - 1 year\n                return 'month';\n            }\n            if (span >= 31536000) { // year\n                return 'year';\n            }\n            console.log('_span value (' + span + ') did not meet any time formatting condition');\n            return 'second';\n        };\n    \n        var determineLabelGranularity = function(times, spanSeries) {\n            if(!(times[0] instanceof BdTime)) {\n                times = _(times).map(extractBdTime);\n            }\n            times = _(times).filter(function(time) { return !time.isInvalid; });\n            if(times.length === 1 && (!spanSeries || spanSeries.length === 0)) {\n                return times[0].millisecond === 0 ? 'second' : 'millisecond';\n            }\n            if(times.length === 1 && spanSeries) {\n                return _calculateTimeFormat(times[0], spanSeries);\n            }\n            var milliseconds = [],\n                seconds = [],\n                minutes = [],\n                hours   = [],\n                days    = [],\n                months  = [],\n    \n                allInListMatch = function(list, matchMe) {\n                    for(var i = 0; i < list.length; i++) {\n                        if(list[i] !== matchMe) {\n                            return false;\n                        }\n                    }\n                    return true;\n                };\n    \n            _(times).each(function(time) {\n                milliseconds.push(time.millisecond);\n                seconds.push(time.second);\n                minutes.push(time.minute);\n                hours.push(time.hour);\n                days.push(time.day);\n                months.push(time.month);\n            });\n\n            if(!allInListMatch(milliseconds, 0)) {\n                return 'millisecond';\n            }\n            if(!allInListMatch(seconds, 0)) {\n                return 'second';\n            }\n            if(!allInListMatch(minutes, 0)) {\n                return 'minute';\n            }\n            if((!allInListMatch(hours, 0))) {\n                return 'hour';\n            }\n            if(!allInListMatch(days, 1)) {\n                return 'day';\n            }\n            if(!allInListMatch(months, 1)) {\n                return 'month';\n            }\n            return 'year';\n        };\n    \n        var isValidIsoTime = function(str) {\n            return BD_TIME_REGEX_MILLIS.test(str) || BD_TIME_REGEX_NO_MILLIS.test(str);\n        };\n        \n    \n        /**\n         * Epoch seconds to LocaleString\n         * @param epochTime\n         * @return {String}\n         */\n        var convertToLocalTime = function(epochTime) {\n            if (!epochTime) {\n                return null;\n            }\n            return new Date(epochTime*1000).toLocaleString();\n        };\n    \n        /**\n         * Converts time difference to \"1 year, 6 months ago\"; \"20 minutes, 30 seconds ago\"\n         * @param endTime Unix epoch seconds\n         * @param startTime [optional] Unix epoch seconds; By default - current time.\n         * @param withoutSuffix [optional] true to omit the \"ago\" suffix\n         * @return {String}\n         */\n        var convertToRelativeTime = function(endTime, startTime, withoutSuffix) {\n            if (!endTime) {\n                return null;\n            }\n            var endMoment = moment.unix(endTime);\n            return startTime !== undefined ?\n                    endMoment.from(moment.unix(startTime), withoutSuffix) :\n                    endMoment.fromNow(withoutSuffix);\n        };\n\n        /**\n         * Converts parsed time amount and unit to seconds. Converts 1h to 3600.\n         * @param amount {Number}\n         * @param unit {String} ('s', 'm', 'h', 'd')\n         * @return {Number}\n         */\n        var convertAmountAndUnitToSeconds = function(amount, unit) {\n            var seconds = amount;\n            switch (unit) {\n                case 'd':\n                    seconds *= 24 * 60 * 60;\n                    break;\n                case 'h':\n                    seconds *= 60 * 60;\n                    break;\n                case 'm':\n                    seconds *= 60;\n                    break;\n            }\n            return seconds;\n        };\n\n        var getRelativeStringFromSeconds = function(seconds, removeAgo) {\n            if (_.isString(seconds)) {\n                seconds = parseInt(seconds, 10);\n            }\n            \n            var now = new Date(),\n                startTime = now.getTime() / 1000,\n                endTime = startTime - seconds;\n            \n            return convertToRelativeTime(endTime, startTime, removeAgo);\n        };\n        \n        /*  \n         * Normalize units to their shortest abbreviations.\n         * Required is an optional parameter, defaults to true.\n         * If required and there is no match, s is returned.\n         * \n         */\n        var normalizeUnit = function(abbr, required) {\n            var hasUnit = TIME_UNITS.hasOwnProperty(abbr),\n                defaultUnit = required === false ? '' : TIME_UNITS.s.abbr;\n            return hasUnit ? TIME_UNITS[abbr].abbr : defaultUnit;\n        };\n        \n        var parseTimeString = function(timeString){\n            if (!_.isString(timeString)) {\n                return false;\n            }\n            //This regex is not a validator of splunk time! Use the TimeParser for that!\n            //-1, -1s, -1@s, -1s@s, +1, +1s, +1@s, +1s@s, s@s, rt@s, @s, rtnow, now\n            var parse = timeString.match(/^\\s*(rt|)([-+]?)(\\d*)([a-zA-Z]*)(@?)([a-zA-Z]*)(\\d*)\\s*$/);\n                                           //   1     2     3       4       5       6      7\n            if (parse) {\n                var normalizedUnit = normalizeUnit(parse[4], false),\n                    hasSnap = (parse[5] !== '');\n                \n                return {\n                    amount: (normalizedUnit ? (parseInt(parse[3], 10) || 1) : 0),\n                    unit: normalizedUnit,\n                    hasSnap: hasSnap,\n                    snapUnit: normalizeUnit(parse[6], false),\n                    snapUnitAmount: parseInt(parse[7], 10),\n                    isNow: parse[4] === \"now\",\n                    isRealTime: parse[1] === 'rt',\n                    isPositive: parse[2] === \"+\" || true,\n                    parse: parse \n                };\n            }\n            \n            return false;\n        };\n\n        /*\n         *  Takes timeStrings of the format \"-7d\" or \"+5h\"\n         *  and returns a breakdown of the +/-, amount, and unit components.\n         *  Also, returns false if the timeString is not of a valid\n         *  Splunk relative time modifier format.\n         *  Ignores 'snapTo' '@' syntax.\n         */\n        var parseTimeModifier = function(timeString) {\n            if (!_.isString(timeString)) {\n                return false;\n            }\n            var parse = timeString.match(/^([+-])([0-9]+)([a-zA-Z]+)@?[a-zA-Z]*$/),\n                timeVariance,\n                amount,\n                unit;\n            if (parse) {\n                timeVariance = parse[1];\n                amount = parse[2];\n                unit = normalizeUnit(parse[3], false);\n                return {\n                    timeVariance: timeVariance,\n                    amount: amount,\n                    unit: unit\n                };\n            }\n            return false;\n        };\n        \n        var isRealtime = function(time) {\n            return (_.isString(time) && time.indexOf(\"rt\") === 0);\n        };\n        \n        var stripRTSafe = function(timeString, isLatest) {\n            var sign,\n                parsedTimeString,\n                strippedString;\n            \n            if (!isRealtime(timeString)) {\n                return timeString;\n            }\n            \n            parsedTimeString = parseTimeString(timeString);\n            if (!parsedTimeString) {\n                return timeString;\n            }\n            \n            if (parsedTimeString.unit || parsedTimeString.isNow) {\n                return parsedTimeString.parse.slice(2, parsedTimeString.parse.length).join(\"\");\n            }\n            \n            strippedString = parsedTimeString.parse.slice(3, parsedTimeString.parse.length).join(\"\");\n            if (strippedString) {\n                sign = parsedTimeString.isPositive ? \"+\" : \"-\";\n                return sign + strippedString;\n            }\n            \n            if (isLatest) {\n                return \"\";\n            } else {\n                return \"0\";\n            }\n        };\n\n        /**\n         * @param {Object} options {\n         *     iso: time,\n         *     unit: w|d|m|h|s|ms\n         *     amount: <int> \n         *     type: plus|minus|plusminus\n         * }\n         */\n        var rangeFromIsoAndOffset = function(iso, unit, amount, type) {\n            amount = parseInt(amount, 10);\n            amount = isNaN(amount) ? 1 : amount;\n            type = type === undefined ? 'plusminus' : type;\n            if (['plus', 'minus', 'plusminus'].indexOf(type) === -1) {\n                throw new Error('Invalid type');\n            }\n            var origanalDate = new Date(iso),\n                lowerRange = new Date(iso),\n                upperRange = new Date(iso);\n\n            switch(unit) {\n                case 'w': \n                    lowerRange.setDate(lowerRange.getDate() - (7 * amount));\n                    upperRange.setDate(upperRange.getDate() + (7 * amount));\n                    break;\n                case 'd': \n                    lowerRange.setDate(lowerRange.getDate() - amount);\n                    upperRange.setDate(upperRange.getDate() + amount);\n                    break;\n                case 'h': \n                    lowerRange.setHours(lowerRange.getHours() - amount);\n                    upperRange.setHours(upperRange.getHours() + amount);\n                    break;\n                case 'm': \n                    lowerRange.setMinutes(lowerRange.getMinutes() - amount);\n                    upperRange.setMinutes(upperRange.getMinutes() + amount);\n                    break;\n                case 's': \n                    lowerRange.setSeconds(lowerRange.getSeconds() - amount);\n                    upperRange.setSeconds(upperRange.getSeconds() + amount);\n                    break;\n                case 'ms': \n                    lowerRange.setMilliseconds(lowerRange.getMilliseconds() - amount);\n                    upperRange.setMilliseconds(upperRange.getMilliseconds() + amount);\n                    break;\n                default:\n                    throw new Error('Invalid unit');\n            }\n            return { \n                lowerRange: (type === 'minus' || type === 'plusminus') ? lowerRange : origanalDate,\n                upperRange: (type === 'plus' || type === 'plusminus') ? upperRange : origanalDate \n            }; \n        };\n        \n        var isAbsolute = function(time) {\n            if (time === undefined) {\n                return false;\n            }\n            return _.isNumber(time) || !(/^(now|-|\\+|@|rt).*/.test(time));\n        };\n        \n        var isEpoch = function(time) {\n            return _.isNumber(time) || (_.isString(time) && /^\\d+((\\.\\d+)|(\\d*))$/.test(time) && time !== '0');\n        };\n        \n        var timeAndJsDateIsWholeDay = function(time, jsDate) {\n            if (isAbsolute(time) && jsDate) {\n                return (jsDate.getHours() == 0) && (jsDate.getMinutes() == 0) && (jsDate.getSeconds() == 0) && (jsDate.getMilliseconds() == 0);\n            }\n            return false;\n        };\n        \n        var isNow = function(time) {\n            if (!time) {\n                return true;\n            }\n            return (_.isString(time) && ((time === '') || (/now/.test(time))));\n        };\n        \n        var isEmpty = function(time) {\n            if (time === '0') {\n                return true;\n            }\n            return (!time);\n        };\n\n        var compareTwoTimeRanges = function(earliest1, latest1, earliest2, latest2) {\n            // Check if they are \"all time\"\n            if (isEmpty(earliest1) && isEmpty(earliest2) && isNow(latest1) && isNow(latest2)) {\n                return true;\n            }\n\n            if (isEmpty(earliest1) && isEmpty(earliest2) && (latest1 === latest2)) {\n                return true;\n            }\n\n            if ((earliest1 === earliest2) && isNow(latest1) && isNow(latest2)) {\n                return true;\n            }\n\n            return (earliest1 === earliest2) && (latest1 === latest2);\n        };\n        \n        var findPresetLabel = function(presetsCollection, earliest, latest) {\n            var presetModel;\n            \n            if (presetsCollection.length > 0) {\n                //TODO: this should probably get moved to the Times collection\n                presetModel = presetsCollection.find(function(model) {\n                    var timesConfEarliest = model.entry.content.get(\"earliest_time\"),\n                        timesConfLatest = model.entry.content.get(\"latest_time\"),\n                        noEarliests = (isEmpty(timesConfEarliest) && isEmpty(earliest)),\n                        noLatests = (isEmpty(timesConfLatest) && isEmpty(latest)),\n                        isDisabled = model.isDisabled();\n                    \n                    return (!isDisabled && (noEarliests || (timesConfEarliest == earliest)) && (noLatests || (timesConfLatest == latest)));\n                });\n                \n                if (presetModel) {\n                    return presetModel.entry.content.get(\"label\");\n                }\n            }\n            return false;\n        };\n        \n        var generateRealtimeLabel = function(earliest, latest) {\n            var earliestParse, latestIsNow;\n            \n            if (isRealtime(earliest) || isRealtime(latest)) {\n                earliestParse = parseTimeString(earliest);\n                latestIsNow = isNow(latest);\n                \n                var labelTemplates = {\n                    s: _(\"%s second window\").t(),\n                    m: _(\"%s minute window\").t(),\n                    h: _(\"%s hour window\").t(),\n                    d: _(\"%s day window\").t(),\n                    w: _(\"%s week window\").t(),\n                    mon: _(\"%s month window\").t(),\n                    q: _(\"%s quarter window\").t(),\n                    y: _(\"%s year window\").t()\n                };\n            \n                //A windowed time with a latest time of now.\n                if (earliestParse && earliestParse.amount && latestIsNow && labelTemplates.hasOwnProperty(earliestParse.unit)) {\n                    return splunkUtils.sprintf(labelTemplates[earliestParse.unit], earliestParse.amount);\n                } \n                \n                //Other Real-Time.\n                return _(\"Real-time\").t();\n            }\n            return false;\n        };\n        \n        var generateRelativeTimeLabel = function(earliest, latest) {\n            var earliestParse = parseTimeString(earliest),\n                latestIsNow = isNow(latest),\n                latestParse = parseTimeString(latest);\n            \n            if (!earliestParse || earliestParse.isRealTime || latestParse.isRealTime) {\n                return false;\n            }\n            \n            if (earliestParse.amount\n                    && (!earliestParse.snapUnit || earliestParse.unit === earliestParse.snapUnit)\n                    && (latestParse.isNow || (latestParse.snapUnit && !latestParse.amount))\n                    && (!latestParse.snapUnit || earliestParse.unit === latestParse.snapUnit)) {\n                return splunkUtils.sprintf(_(\"Last %s %s\").t(), earliestParse.amount,\n                    TIME_UNITS[earliestParse.unit][earliestParse.amount > 1? 'plural' : 'singular']);\n            }\n            \n            return false;\n        };\n        \n        var generateBetweenTimeLabel = function(earliest, earliestJSDate, latest, latestJSDate) {\n            var earliestIsWholeDay = timeAndJsDateIsWholeDay(earliest, earliestJSDate),\n                latestIsWholeDay = timeAndJsDateIsWholeDay(latest, latestJSDate);\n            \n            if (earliestIsWholeDay && latestIsWholeDay) {\n                if (language == 'en') {\n                    return i18n.format_datetime_range(null, earliestJSDate, latestJSDate, true);\n                } else {\n                    var labelDate = new Date(latestJSDate.getTime());\n                    labelDate.setDate(labelDate.getDate() -1);\n                    return splunkUtils.sprintf(_(\"%s through %s\").t(), i18n.format_date(earliestJSDate, 'short'), i18n.format_date(labelDate, 'short'));\n                }\n            }\n            \n            return false;\n        };\n        \n        var generateSinceDateLabel = function(earliest, earliestJSDate, latest){\n            var earliestIsWholeDay = timeAndJsDateIsWholeDay(earliest, earliestJSDate),\n                latestIsNow = isNow(latest);\n            \n            if (earliestIsWholeDay && latestIsNow) {\n                return splunkUtils.sprintf(_(\"Since %s\").t(), i18n.format_date(earliestJSDate, 'short'));\n            }\n            \n            return false;\n        };\n        \n        var generateBeforeDateLabel = function(earliest, latest, latestJSDate) {            \n            if (isEmpty(earliest) && timeAndJsDateIsWholeDay(latest, latestJSDate)) {\n                return splunkUtils.sprintf(_(\"Before %s\").t(), i18n.format_date(latestJSDate, 'short'));\n            }\n            \n            return false;\n        };\n        \n        var generateDateTimeRangeLabel = function(earliest, latest) {\n            if (!isEmpty(earliest) && isAbsolute(earliest) && isAbsolute(latest)) {\n                return _(\"Date time range\").t();\n            }\n            return false;\n        };\n        \n        var generateSinceTimeRangeLabel = function(earliest, latest) {\n            if (isAbsolute(earliest) && isNow(latest)) {\n                return _(\"Since date time\").t();\n            }\n            return false;\n         };\n         \n         var generateBeforeTimeRangeLabel = function(earliest, latest) {\n             if (isEmpty(earliest) && isAbsolute(latest)) {\n                 return _(\"Before date time\").t();\n             }\n             return false;\n         };\n         \n         var generateAllTimeLabel = function(earliest, latest) {\n             if (isEmpty(earliest) && isNow(latest)) {\n                 return _(\"All time\").t();\n             }\n             return false;\n         };\n\n        var makeTodayRelativeWithNoTimeZone = function(time) {\n            var date = new Date(time),\n                mDate = moment(date),\n                iscurrentDate = (mDate).isSame(new Date(), \"day\");\n            if(iscurrentDate)\n            {\n                return (mDate).fromNow();\n            }\n\n            return date.toString().slice(0,24);\n        };\n    \n        /**\n        * presets: <collections.services.data.ui.TimesV2>\n        **/\n        var generateLabel = function(presetsCollection, earliest, earliestJSDate, latest, latestJSDate) {\n            return generateAllTimeLabel(earliest, latest) ||\n                findPresetLabel(presetsCollection, earliest, latest) ||\n                generateRealtimeLabel(earliest, latest) ||\n                generateRelativeTimeLabel(earliest, latest) ||\n                generateBetweenTimeLabel(earliest, earliestJSDate, latest, latestJSDate) ||\n                generateSinceDateLabel(earliest, earliestJSDate, latest) ||\n                generateBeforeDateLabel(earliest, latest, latestJSDate) ||\n                generateDateTimeRangeLabel(earliest, latest) ||\n                generateSinceTimeRangeLabel(earliest, latest) ||\n                generateBeforeTimeRangeLabel(earliest, latest) ||\n                _(\"Custom time\").t();\n        };\n\n        var RESULTS_TIMESTAMP_FORMATS = {\n            year: 'YYYY',\n            month: 'YYYY-MM',\n            day: 'YYYY-MM-dd',\n            hour: 'YYYY-MM-dd HH:00',\n            minute: 'YYYY-MM-dd HH:mm:00',\n            second: 'YYYY-MM-dd HH:mm:ss',\n            millisecond: 'YYYY-MM-dd HH:mm:ss.TTT'\n        };\n        \n        return ({\n            extractBdTime: extractBdTime,\n            bdTimeToDateObject: bdTimeToDateObject,\n            rangeFromIsoAndOffset: rangeFromIsoAndOffset,\n            getTimezoneString: getTimezoneString,\n            isoToDateObject: isoToDateObject,\n            determineLabelGranularity: determineLabelGranularity,\n            isValidIsoTime: isValidIsoTime,\n            TIME_UNITS: TIME_UNITS,\n            ISO_PATTERN: ISO_PATTERN,\n            normalizeUnit: normalizeUnit,\n            parseTimeString: parseTimeString,\n            parseTimeModifier: parseTimeModifier,\n            isRealtime: isRealtime,\n            stripRTSafe: stripRTSafe,\n            isAbsolute: isAbsolute,\n            isEpoch: isEpoch,\n            timeAndJsDateIsWholeDay: timeAndJsDateIsWholeDay,\n            isNow: isNow,\n            isEmpty: isEmpty,\n            compareTwoTimeRanges: compareTwoTimeRanges,\n            findPresetLabel: findPresetLabel,\n            generateRealtimeLabel: generateRealtimeLabel,\n            generateRelativeTimeLabel: generateRelativeTimeLabel,\n            generateBetweenTimeLabel: generateBetweenTimeLabel,\n            generateSinceDateLabel: generateSinceDateLabel,\n            generateBeforeDateLabel: generateBeforeDateLabel,\n            generateDateTimeRangeLabel: generateDateTimeRangeLabel,\n            generateSinceTimeRangeLabel: generateSinceTimeRangeLabel,\n            generateBeforeTimeRangeLabel: generateBeforeTimeRangeLabel,\n            generateAllTimeLabel: generateAllTimeLabel,\n            generateLabel: generateLabel,\n            convertToRelativeTime: convertToRelativeTime,\n            convertToLocalTime: convertToLocalTime,\n            jsDateToSplunkDateTimeWithMicroseconds: jsDateToSplunkDateTimeWithMicroseconds,\n            getRelativeStringFromSeconds: getRelativeStringFromSeconds,\n            convertAmountAndUnitToSeconds: convertAmountAndUnitToSeconds,\n            secondsToSeparatedDate: secondsToSeparatedDate,\n            makeTodayRelativeWithNoTimeZone: makeTodayRelativeWithNoTimeZone,\n            RESULTS_TIMESTAMP_FORMATS: RESULTS_TIMESTAMP_FORMATS\n        });\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvdGltZS5qcz9iYzA4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJnRUFBQSxpQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FDQTs7QUFFQSx5Q0FBeUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFO0FBQ2hILDRDQUE0QyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUU7QUFDNUcseUNBQXlDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksV0FBVyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUU7QUFDM0csa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxzQ0FBc0M7QUFDdEMseURBQXlEO0FBQ3pELGlEQUFpRDs7QUFFakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHdCQUF3QixFQUFFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsd0JBQXdCLE9BQU87QUFDL0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0I7QUFDQTtBQUNBO0FBQ0EsYztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvSkFDQSIsImZpbGUiOiJ1dGlsL3RpbWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoXG4gICAgW1xuICAgICAgICAndW5kZXJzY29yZScsXG4gICAgICAgICdzcGx1bmsuaTE4bicsXG4gICAgICAgICdzcGx1bmsudXRpbCcsXG4gICAgICAgICd1dGlsL21vbWVudCcsXG4gICAgICAgICd1dGlsL2NvbnNvbGUnXG4gICAgXSxcbiAgICBmdW5jdGlvbihfLCBpMThuLCBzcGx1bmtVdGlscywgbW9tZW50LCBjb25zb2xlKSB7XG5cbiAgICAgICAgdmFyIEJEX1RJTUVfUkVHRVhfTUlMTElTID0gL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KVxcLihcXGQrKVsrLV17MX1cXGR7Mn1bOl0/XFxkezJ9JC8sXG4gICAgICAgICAgICBCRF9USU1FX1JFR0VYX05PX01JTExJUyA9IC9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSlbKy1dezF9XFxkezJ9WzpdP1xcZHsyfSQvLFxuICAgICAgICAgICAgU1RSSVBfVElNRVpPTkVfUkVHRVggPSAvXihcXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfVxcLnswLDF9KFxcZCopKVsrLV17MX1cXGR7Mn1bOl0/XFxkezJ9JC8sXG4gICAgICAgICAgICB1ID0ge30sXG4gICAgICAgICAgICBsYW5ndWFnZSA9IGkxOG4ubG9jYWxlX25hbWUoKS5zdWJzdHJpbmcoMCwgMiksXG4gICAgICAgICAgICBJU09fUEFUVEVSTiA9ICclWS0lbS0lZFQlSDolTTolUy4lUSU6eic7XG4gICAgICAgIFxuICAgICAgICB1LnMgPSB1LnNlYyA9IHUuc2VjcyA9IHUuc2Vjb25kID0gdS5zZWNvbmRzID0ge2FiYnI6IFwic1wiLCAgc2luZ3VsYXI6IF8oXCJzZWNvbmRcIikudCgpLCBwbHVyYWw6IF8oXCJzZWNvbmRzXCIpLnQoKX07XG4gICAgICAgIHUubSA9IHUubWluID0gdS5taW5zID0gdS5taW51dGUgPSB1Lm1pbnV0ZXMgPSB7YWJicjogXCJtXCIsIHNpbmd1bGFyOiBfKFwibWludXRlXCIpLnQoKSwgcGx1cmFsOiBfKFwibWludXRlc1wiKS50KCl9O1xuICAgICAgICB1LmggPSB1LmhyICA9IHUuaHJzICA9IHUuaG91ciAgID0gdS5ob3VycyAgID0ge2FiYnI6IFwiaFwiLCBzaW5ndWxhcjogXyhcImhvdXJcIikudCgpLCBwbHVyYWw6IF8oXCJob3Vyc1wiKS50KCl9O1xuICAgICAgICB1LmQgPSB1LmRheSA9IHUuZGF5cyA9IHthYmJyOiBcImRcIiwgc2luZ3VsYXI6IF8oXCJkYXlcIikudCgpLCBwbHVyYWw6IF8oXCJkYXlzXCIpLnQoKX07XG4gICAgICAgIHUudyA9IHUud2VlayA9IHUud2Vla3MgPSB7YWJicjogXCJ3XCIsIHNpbmd1bGFyOiBfKFwid2Vla1wiKS50KCksIHBsdXJhbDogXyhcIndlZWtzXCIpLnQoKX07XG4gICAgICAgIHUubW9uID0gdS5tb250aCA9IHUubW9udGhzID0ge2FiYnI6IFwibW9uXCIsIHNpbmd1bGFyOiBfKFwibW9udGhcIikudCgpLCBwbHVyYWw6IF8oXCJtb250aHNcIikudCgpfTtcbiAgICAgICAgdS5xID0gdS5xdHIgPSB1LnF0cnMgPSB1LnF1YXJ0ZXIgPSB1LnF1YXJ0ZXJzID0ge2FiYnI6IFwicVwiLCBzaW5ndWxhcjogXyhcInF1YXJ0ZXJcIikudCgpLCBwbHVyYWw6IF8oXCJxdWFydGVyc1wiKS50KCl9O1xuICAgICAgICB1LnkgPSB1LnlyID0gdS55cnMgPSB1LnllYXIgPSB1LnllYXJzID0ge2FiYnI6IFwieVwiLCBzaW5ndWxhcjogXyhcInllYXJcIikudCgpLCBwbHVyYWw6IF8oXCJ5ZWFyc1wiKS50KCl9O1xuICAgICAgICAgICAgXG4gICAgICAgIHZhciBUSU1FX1VOSVRTID0gdTtcbiAgICBcbiAgICAgICAgdmFyIEJkVGltZSA9IGZ1bmN0aW9uKGlzb1N0cmluZykge1xuICAgICAgICAgICAgdmFyIGJkUGllY2VzID0gQkRfVElNRV9SRUdFWF9NSUxMSVMuZXhlYyhpc29TdHJpbmcpIHx8IEJEX1RJTUVfUkVHRVhfTk9fTUlMTElTLmV4ZWMoaXNvU3RyaW5nKTtcbiAgICAgICAgICAgIGlmKCFiZFBpZWNlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueWVhciAgID0gcGFyc2VJbnQoYmRQaWVjZXNbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoICA9IHBhcnNlSW50KGJkUGllY2VzWzJdLCAxMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXkgICAgPSBwYXJzZUludChiZFBpZWNlc1szXSwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuaG91ciAgID0gcGFyc2VJbnQoYmRQaWVjZXNbNF0sIDEwKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZSA9IHBhcnNlSW50KGJkUGllY2VzWzVdLCAxMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmQgPSBwYXJzZUludChiZFBpZWNlc1s2XSwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmQgPSBiZFBpZWNlcy5sZW5ndGggPiA3ID8gcGFyc2VJbnQoYmRQaWVjZXNbN10sIDEwKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHZhciBleHRyYWN0QmRUaW1lID0gZnVuY3Rpb24odGltZVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCZFRpbWUodGltZVN0cmluZyk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHZhciBiZFRpbWVUb0RhdGVPYmplY3QgPSBmdW5jdGlvbihiZFRpbWUpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyICAgICA9IGJkVGltZS55ZWFyLFxuICAgICAgICAgICAgICAgIG1vbnRoICAgID0gYmRUaW1lLm1vbnRoIC0gMSxcbiAgICAgICAgICAgICAgICBkYXkgICAgICA9IGJkVGltZS5kYXksXG4gICAgICAgICAgICAgICAgaG91ciAgICAgPSBiZFRpbWUuaG91cixcbiAgICAgICAgICAgICAgICBtaW51dGUgICA9IGJkVGltZS5taW51dGUsXG4gICAgICAgICAgICAgICAgc2Vjb25kICAgPSBiZFRpbWUuc2Vjb25kLFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gYmRUaW1lLm1pbGxpc2Vjb25kO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFRpbWV6b25lU3RyaW5nID0gZnVuY3Rpb24oZGF0ZU9iaikge1xuICAgICAgICAgICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gZGF0ZU9iai5nZXRUaW1lem9uZU9mZnNldCgpLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVmFsdWVUaW1lem9uZU9mZnNldCA9IE1hdGguYWJzKHRpbWV6b25lT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGguZmxvb3IoYWJzb2x1dGVWYWx1ZVRpbWV6b25lT2Zmc2V0IC8gNjApLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBhYnNvbHV0ZVZhbHVlVGltZXpvbmVPZmZzZXQgJSA2MCxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRIb3VycyA9IGhvdXJzIDwgMTAgPyAnMCcgKyBob3VycyA6ICcnICsgaG91cnMsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkTWludXRlcyA9IG1pbnV0ZXMgPCAxMCA/ICcwJyArIG1pbnV0ZXMgOiAnJyArIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgdGltZXpvbmUgPSAodGltZXpvbmVPZmZzZXQgPiAwID8gJy0nIDogJysnKSArIGZvcm1hdHRlZEhvdXJzICsgJzonICsgZm9ybWF0dGVkTWludXRlcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRpbWV6b25lO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIENvbnZlcnRzIGEgdGltZSBpbiBzZWNvbmRzIHRvIGEgeWVhci9kYXkvaG91ci9taW51dGUvc2Vjb25kIGZvcm1hdC5cbiAgICAgICAgICogSWYgaG91ckNhcCBmbGFnIGlzIHRydWUsIHRoZW4geWVhcnMvZGF5cyBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlIGNvbnZlcnNpb24sXG4gICAgICAgICAqIGFuZCBob3VycyBpcyBhbGxvd2VkIHRvIGJlIGxhcmdlciB0aGFuIDI0LlxuICAgICAgICAgKiBAcGFyYW0gc2Vjb25kczogdGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGNvbnZlcnRcbiAgICAgICAgICogQHBhcmFtIGhvdXJDYXAgW29wdGlvbmFsXTogd2hldGhlciB0byBjYXAgZXZlcnl0aGluZyBhYm92ZSBob3VyLCBkZWZhdWx0IGZhbHNlLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICovXG4gICAgICAgIHZhciBzZWNvbmRzVG9TZXBhcmF0ZWREYXRlID0gZnVuY3Rpb24odGltZSwgaG91ckNhcCkge1xuICAgICAgICAgICAgdmFyIHllYXJzID0gMCwgZGF5cyA9IDAsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBjdXJUaW1lQ291bnRlciA9IHRpbWU7XG5cbiAgICAgICAgICAgIGlmICghaG91ckNhcCkge1xuICAgICAgICAgICAgICAgIHllYXJzID0gTWF0aC5mbG9vcihjdXJUaW1lQ291bnRlciAvIDMxNTU3NjAwKTsgLy8gMzY1LjI1IGRheXMgcGVyIHllYXJcbiAgICAgICAgICAgICAgICBjdXJUaW1lQ291bnRlciAtPSB5ZWFycyAqIDMxNTU3NjAwO1xuXG4gICAgICAgICAgICAgICAgZGF5cyA9IE1hdGguZmxvb3IoY3VyVGltZUNvdW50ZXIgLyA4NjQwMCk7XG4gICAgICAgICAgICAgICAgY3VyVGltZUNvdW50ZXIgLT0gZGF5cyAqIDg2NDAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBob3VycyA9IE1hdGguZmxvb3IoY3VyVGltZUNvdW50ZXIgLyAzNjAwKTtcbiAgICAgICAgICAgIGN1clRpbWVDb3VudGVyIC09IGhvdXJzICogMzYwMDtcblxuICAgICAgICAgICAgbWludXRlcyA9IE1hdGguZmxvb3IoY3VyVGltZUNvdW50ZXIgLyA2MCk7XG4gICAgICAgICAgICBjdXJUaW1lQ291bnRlciAtPSBtaW51dGVzICogNjA7XG5cbiAgICAgICAgICAgIC8vIFdlIG5ldmVyIHdhbnQgdG8gc2hvdyBhIHRpbWUgb2YgMCBmb3IgZXZlcnl0aGluZywgc28gaWYgd2Ugc3RhcnRlZCB3aXRoIHNvbWV0aGluZyBsaWtlXG4gICAgICAgICAgICAvLyAwLjEgZm9yIHRpbWUsIGp1c3QgY2VpbCB0aGUgY291bnRlci4gT3RoZXJ3aXNlIHJvdW5kIGl0LlxuICAgICAgICAgICAgc2Vjb25kcyA9IHRpbWUgPCAxID8gTWF0aC5jZWlsKGN1clRpbWVDb3VudGVyKSA6IE1hdGgucm91bmQoY3VyVGltZUNvdW50ZXIpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHllYXJzOiB5ZWFycyxcbiAgICAgICAgICAgICAgICBkYXlzOiBkYXlzLFxuICAgICAgICAgICAgICAgIGhvdXJzOiBob3VycyxcbiAgICAgICAgICAgICAgICBtaW51dGVzOiBtaW51dGVzLFxuICAgICAgICAgICAgICAgIHNlY29uZHM6IHNlY29uZHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHZhciBpc29Ub0RhdGVPYmplY3QgPSBmdW5jdGlvbihpc29TdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gU1RSSVBfVElNRVpPTkVfUkVHRVguZXhlYyhpc29TdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNvV2l0aG91dFRpbWV6b25lID0gbWF0Y2hlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgaXNvV2l0aFNwb29mZWRUaW1lem9uZSA9IGlzb1dpdGhvdXRUaW1lem9uZSArIGdldFRpbWV6b25lU3RyaW5nKG5ldyBEYXRlKCkpLFxuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRJc28gPSBpc29XaXRob3V0VGltZXpvbmUgKyBnZXRUaW1lem9uZVN0cmluZyhtb21lbnQoaXNvV2l0aFNwb29mZWRUaW1lem9uZSkudG9EYXRlKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtb21lbnQoY29ycmVjdGVkSXNvKS50b0RhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIganNEYXRlVG9TcGx1bmtEYXRlVGltZVdpdGhNaWNyb3NlY29uZHMgPSBmdW5jdGlvbihqc0RhdGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRlVGltZSA9IG5ldyBpMThuLkRhdGVUaW1lKHtcbiAgICAgICAgICAgICAgICBkYXRlOiBqc0RhdGUsXG4gICAgICAgICAgICAgICAgeWVhcjoganNEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgbW9udGg6IGpzRGF0ZS5nZXRNb250aCgpICsgMSxcbiAgICAgICAgICAgICAgICBkYXk6IGpzRGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICAgICAgaG91cjoganNEYXRlLmdldEhvdXJzKCksXG4gICAgICAgICAgICAgICAgbWludXRlOiBqc0RhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICAgICAgICAgIHNlY29uZDoganNEYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgICAgICAgICBtaWNyb3NlY29uZDoganNEYXRlLmdldE1pbGxpc2Vjb25kcygpICogMTAwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRlVGltZS53ZWVrZGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGUuZ2V0RGF5KCkgLSAxO1xuICAgICAgICAgICAgICAgIGlmIChkIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVUaW1lO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfY2FsY3VsYXRlVGltZUZvcm1hdCA9IGZ1bmN0aW9uKHRpbWUsIHNwYW5TZXJpZXMpIHtcbiAgICAgICAgICAgIHZhciBzcGFuID0gcGFyc2VGbG9hdChzcGFuU2VyaWVzWzBdKTtcbiAgICAgICAgICAgIGlmKCEodGltZSBpbnN0YW5jZW9mIEJkVGltZSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gZXh0cmFjdEJkVGltZSh0aW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3Bhbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lLm1pbGxpc2Vjb25kID09PSAwID8gJ3NlY29uZCcgOiAnbWlsbGlzZWNvbmQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZigoc3BhbiA+PSAwICYmIHNwYW4gPCAxKSB8fCAodGltZS5taWxsaXNlY29uZCAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21pbGxpc2Vjb25kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKChzcGFuID49IDEgJiYgc3BhbiA8IDYwKSB8fCAodGltZS5zZWNvbmQgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdzZWNvbmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoKHNwYW4gPj0gNjAgJiYgc3BhbiA8IDM2MDApIHx8ICh0aW1lLm1pbnV0ZSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21pbnV0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHNwYW4gPj0gMzYwMCAmJiBzcGFuIDw9IDgyODAwKSB8fCAodGltZS5ob3VyICE9PSAwKSkgeyAvLyAyMyBob3VyICg4MjgwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hvdXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChzcGFuID4gODI4MDAgJiYgc3BhbiA8PSAyNDE5MjAwKSB8fCAodGltZS5kYXkgIT09IDEpKSB7IC8vIDEgZGF5IHRvIDI4IGRheXNcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHNwYW4gPiAyNDE5MjAwICYmIHNwYW4gPD0gMzE1MzU5OTkpIHx8ICh0aW1lLm1vbnRoICE9PSAxKSkgeyAvLyAyOCBkYXlzIC0gMSB5ZWFyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdtb250aCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BhbiA+PSAzMTUzNjAwMCkgeyAvLyB5ZWFyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdfc3BhbiB2YWx1ZSAoJyArIHNwYW4gKyAnKSBkaWQgbm90IG1lZXQgYW55IHRpbWUgZm9ybWF0dGluZyBjb25kaXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiAnc2Vjb25kJztcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgdmFyIGRldGVybWluZUxhYmVsR3JhbnVsYXJpdHkgPSBmdW5jdGlvbih0aW1lcywgc3BhblNlcmllcykge1xuICAgICAgICAgICAgaWYoISh0aW1lc1swXSBpbnN0YW5jZW9mIEJkVGltZSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lcyA9IF8odGltZXMpLm1hcChleHRyYWN0QmRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWVzID0gXyh0aW1lcykuZmlsdGVyKGZ1bmN0aW9uKHRpbWUpIHsgcmV0dXJuICF0aW1lLmlzSW52YWxpZDsgfSk7XG4gICAgICAgICAgICBpZih0aW1lcy5sZW5ndGggPT09IDEgJiYgKCFzcGFuU2VyaWVzIHx8IHNwYW5TZXJpZXMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lc1swXS5taWxsaXNlY29uZCA9PT0gMCA/ICdzZWNvbmQnIDogJ21pbGxpc2Vjb25kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRpbWVzLmxlbmd0aCA9PT0gMSAmJiBzcGFuU2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYWxjdWxhdGVUaW1lRm9ybWF0KHRpbWVzWzBdLCBzcGFuU2VyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBbXSxcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gW10sXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPSBbXSxcbiAgICAgICAgICAgICAgICBkYXlzICAgID0gW10sXG4gICAgICAgICAgICAgICAgbW9udGhzICA9IFtdLFxuICAgIFxuICAgICAgICAgICAgICAgIGFsbEluTGlzdE1hdGNoID0gZnVuY3Rpb24obGlzdCwgbWF0Y2hNZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobGlzdFtpXSAhPT0gbWF0Y2hNZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgXyh0aW1lcykuZWFjaChmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzLnB1c2godGltZS5taWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgc2Vjb25kcy5wdXNoKHRpbWUuc2Vjb25kKTtcbiAgICAgICAgICAgICAgICBtaW51dGVzLnB1c2godGltZS5taW51dGUpO1xuICAgICAgICAgICAgICAgIGhvdXJzLnB1c2godGltZS5ob3VyKTtcbiAgICAgICAgICAgICAgICBkYXlzLnB1c2godGltZS5kYXkpO1xuICAgICAgICAgICAgICAgIG1vbnRocy5wdXNoKHRpbWUubW9udGgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmKCFhbGxJbkxpc3RNYXRjaChtaWxsaXNlY29uZHMsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtaWxsaXNlY29uZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighYWxsSW5MaXN0TWF0Y2goc2Vjb25kcywgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NlY29uZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighYWxsSW5MaXN0TWF0Y2gobWludXRlcywgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21pbnV0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZigoIWFsbEluTGlzdE1hdGNoKGhvdXJzLCAwKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hvdXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWFsbEluTGlzdE1hdGNoKGRheXMsIDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWFsbEluTGlzdE1hdGNoKG1vbnRocywgMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAneWVhcic7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHZhciBpc1ZhbGlkSXNvVGltZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIEJEX1RJTUVfUkVHRVhfTUlMTElTLnRlc3Qoc3RyKSB8fCBCRF9USU1FX1JFR0VYX05PX01JTExJUy50ZXN0KHN0cik7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogRXBvY2ggc2Vjb25kcyB0byBMb2NhbGVTdHJpbmdcbiAgICAgICAgICogQHBhcmFtIGVwb2NoVGltZVxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY29udmVydFRvTG9jYWxUaW1lID0gZnVuY3Rpb24oZXBvY2hUaW1lKSB7XG4gICAgICAgICAgICBpZiAoIWVwb2NoVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGVwb2NoVGltZSoxMDAwKS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGltZSBkaWZmZXJlbmNlIHRvIFwiMSB5ZWFyLCA2IG1vbnRocyBhZ29cIjsgXCIyMCBtaW51dGVzLCAzMCBzZWNvbmRzIGFnb1wiXG4gICAgICAgICAqIEBwYXJhbSBlbmRUaW1lIFVuaXggZXBvY2ggc2Vjb25kc1xuICAgICAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIFtvcHRpb25hbF0gVW5peCBlcG9jaCBzZWNvbmRzOyBCeSBkZWZhdWx0IC0gY3VycmVudCB0aW1lLlxuICAgICAgICAgKiBAcGFyYW0gd2l0aG91dFN1ZmZpeCBbb3B0aW9uYWxdIHRydWUgdG8gb21pdCB0aGUgXCJhZ29cIiBzdWZmaXhcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNvbnZlcnRUb1JlbGF0aXZlVGltZSA9IGZ1bmN0aW9uKGVuZFRpbWUsIHN0YXJ0VGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgaWYgKCFlbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW5kTW9tZW50ID0gbW9tZW50LnVuaXgoZW5kVGltZSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICBlbmRNb21lbnQuZnJvbShtb21lbnQudW5peChzdGFydFRpbWUpLCB3aXRob3V0U3VmZml4KSA6XG4gICAgICAgICAgICAgICAgICAgIGVuZE1vbWVudC5mcm9tTm93KHdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBwYXJzZWQgdGltZSBhbW91bnQgYW5kIHVuaXQgdG8gc2Vjb25kcy4gQ29udmVydHMgMWggdG8gMzYwMC5cbiAgICAgICAgICogQHBhcmFtIGFtb3VudCB7TnVtYmVyfVxuICAgICAgICAgKiBAcGFyYW0gdW5pdCB7U3RyaW5nfSAoJ3MnLCAnbScsICdoJywgJ2QnKVxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY29udmVydEFtb3VudEFuZFVuaXRUb1NlY29uZHMgPSBmdW5jdGlvbihhbW91bnQsIHVuaXQpIHtcbiAgICAgICAgICAgIHZhciBzZWNvbmRzID0gYW1vdW50O1xuICAgICAgICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgKj0gMjQgKiA2MCAqIDYwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyAqPSA2MCAqIDYwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyAqPSA2MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2Vjb25kcztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0UmVsYXRpdmVTdHJpbmdGcm9tU2Vjb25kcyA9IGZ1bmN0aW9uKHNlY29uZHMsIHJlbW92ZUFnbykge1xuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoc2Vjb25kcykpIHtcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gcGFyc2VJbnQoc2Vjb25kcywgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBub3cuZ2V0VGltZSgpIC8gMTAwMCxcbiAgICAgICAgICAgICAgICBlbmRUaW1lID0gc3RhcnRUaW1lIC0gc2Vjb25kcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1JlbGF0aXZlVGltZShlbmRUaW1lLCBzdGFydFRpbWUsIHJlbW92ZUFnbyk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvKiAgXG4gICAgICAgICAqIE5vcm1hbGl6ZSB1bml0cyB0byB0aGVpciBzaG9ydGVzdCBhYmJyZXZpYXRpb25zLlxuICAgICAgICAgKiBSZXF1aXJlZCBpcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIsIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqIElmIHJlcXVpcmVkIGFuZCB0aGVyZSBpcyBubyBtYXRjaCwgcyBpcyByZXR1cm5lZC5cbiAgICAgICAgICogXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbm9ybWFsaXplVW5pdCA9IGZ1bmN0aW9uKGFiYnIsIHJlcXVpcmVkKSB7XG4gICAgICAgICAgICB2YXIgaGFzVW5pdCA9IFRJTUVfVU5JVFMuaGFzT3duUHJvcGVydHkoYWJiciksXG4gICAgICAgICAgICAgICAgZGVmYXVsdFVuaXQgPSByZXF1aXJlZCA9PT0gZmFsc2UgPyAnJyA6IFRJTUVfVU5JVFMucy5hYmJyO1xuICAgICAgICAgICAgcmV0dXJuIGhhc1VuaXQgPyBUSU1FX1VOSVRTW2FiYnJdLmFiYnIgOiBkZWZhdWx0VW5pdDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBwYXJzZVRpbWVTdHJpbmcgPSBmdW5jdGlvbih0aW1lU3RyaW5nKXtcbiAgICAgICAgICAgIGlmICghXy5pc1N0cmluZyh0aW1lU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vVGhpcyByZWdleCBpcyBub3QgYSB2YWxpZGF0b3Igb2Ygc3BsdW5rIHRpbWUhIFVzZSB0aGUgVGltZVBhcnNlciBmb3IgdGhhdCFcbiAgICAgICAgICAgIC8vLTEsIC0xcywgLTFAcywgLTFzQHMsICsxLCArMXMsICsxQHMsICsxc0BzLCBzQHMsIHJ0QHMsIEBzLCBydG5vdywgbm93XG4gICAgICAgICAgICB2YXIgcGFyc2UgPSB0aW1lU3RyaW5nLm1hdGNoKC9eXFxzKihydHwpKFstK10/KShcXGQqKShbYS16QS1aXSopKEA/KShbYS16QS1aXSopKFxcZCopXFxzKiQvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIDEgICAgIDIgICAgIDMgICAgICAgNCAgICAgICA1ICAgICAgIDYgICAgICA3XG4gICAgICAgICAgICBpZiAocGFyc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZFVuaXQgPSBub3JtYWxpemVVbml0KHBhcnNlWzRdLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIGhhc1NuYXAgPSAocGFyc2VbNV0gIT09ICcnKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IChub3JtYWxpemVkVW5pdCA/IChwYXJzZUludChwYXJzZVszXSwgMTApIHx8IDEpIDogMCksXG4gICAgICAgICAgICAgICAgICAgIHVuaXQ6IG5vcm1hbGl6ZWRVbml0LFxuICAgICAgICAgICAgICAgICAgICBoYXNTbmFwOiBoYXNTbmFwLFxuICAgICAgICAgICAgICAgICAgICBzbmFwVW5pdDogbm9ybWFsaXplVW5pdChwYXJzZVs2XSwgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBzbmFwVW5pdEFtb3VudDogcGFyc2VJbnQocGFyc2VbN10sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgaXNOb3c6IHBhcnNlWzRdID09PSBcIm5vd1wiLFxuICAgICAgICAgICAgICAgICAgICBpc1JlYWxUaW1lOiBwYXJzZVsxXSA9PT0gJ3J0JyxcbiAgICAgICAgICAgICAgICAgICAgaXNQb3NpdGl2ZTogcGFyc2VbMl0gPT09IFwiK1wiIHx8IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBwYXJzZSBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICogIFRha2VzIHRpbWVTdHJpbmdzIG9mIHRoZSBmb3JtYXQgXCItN2RcIiBvciBcIis1aFwiXG4gICAgICAgICAqICBhbmQgcmV0dXJucyBhIGJyZWFrZG93biBvZiB0aGUgKy8tLCBhbW91bnQsIGFuZCB1bml0IGNvbXBvbmVudHMuXG4gICAgICAgICAqICBBbHNvLCByZXR1cm5zIGZhbHNlIGlmIHRoZSB0aW1lU3RyaW5nIGlzIG5vdCBvZiBhIHZhbGlkXG4gICAgICAgICAqICBTcGx1bmsgcmVsYXRpdmUgdGltZSBtb2RpZmllciBmb3JtYXQuXG4gICAgICAgICAqICBJZ25vcmVzICdzbmFwVG8nICdAJyBzeW50YXguXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcGFyc2VUaW1lTW9kaWZpZXIgPSBmdW5jdGlvbih0aW1lU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcodGltZVN0cmluZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyc2UgPSB0aW1lU3RyaW5nLm1hdGNoKC9eKFsrLV0pKFswLTldKykoW2EtekEtWl0rKUA/W2EtekEtWl0qJC8pLFxuICAgICAgICAgICAgICAgIHRpbWVWYXJpYW5jZSxcbiAgICAgICAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgICAgICAgdW5pdDtcbiAgICAgICAgICAgIGlmIChwYXJzZSkge1xuICAgICAgICAgICAgICAgIHRpbWVWYXJpYW5jZSA9IHBhcnNlWzFdO1xuICAgICAgICAgICAgICAgIGFtb3VudCA9IHBhcnNlWzJdO1xuICAgICAgICAgICAgICAgIHVuaXQgPSBub3JtYWxpemVVbml0KHBhcnNlWzNdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZVZhcmlhbmNlOiB0aW1lVmFyaWFuY2UsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgICAgICAgICB1bml0OiB1bml0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBpc1JlYWx0aW1lID0gZnVuY3Rpb24odGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIChfLmlzU3RyaW5nKHRpbWUpICYmIHRpbWUuaW5kZXhPZihcInJ0XCIpID09PSAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdHJpcFJUU2FmZSA9IGZ1bmN0aW9uKHRpbWVTdHJpbmcsIGlzTGF0ZXN0KSB7XG4gICAgICAgICAgICB2YXIgc2lnbixcbiAgICAgICAgICAgICAgICBwYXJzZWRUaW1lU3RyaW5nLFxuICAgICAgICAgICAgICAgIHN0cmlwcGVkU3RyaW5nO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWlzUmVhbHRpbWUodGltZVN0cmluZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZVN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGFyc2VkVGltZVN0cmluZyA9IHBhcnNlVGltZVN0cmluZyh0aW1lU3RyaW5nKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VkVGltZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocGFyc2VkVGltZVN0cmluZy51bml0IHx8IHBhcnNlZFRpbWVTdHJpbmcuaXNOb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkVGltZVN0cmluZy5wYXJzZS5zbGljZSgyLCBwYXJzZWRUaW1lU3RyaW5nLnBhcnNlLmxlbmd0aCkuam9pbihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3RyaXBwZWRTdHJpbmcgPSBwYXJzZWRUaW1lU3RyaW5nLnBhcnNlLnNsaWNlKDMsIHBhcnNlZFRpbWVTdHJpbmcucGFyc2UubGVuZ3RoKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgaWYgKHN0cmlwcGVkU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IHBhcnNlZFRpbWVTdHJpbmcuaXNQb3NpdGl2ZSA/IFwiK1wiIDogXCItXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyBzdHJpcHBlZFN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGlzTGF0ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMge1xuICAgICAgICAgKiAgICAgaXNvOiB0aW1lLFxuICAgICAgICAgKiAgICAgdW5pdDogd3xkfG18aHxzfG1zXG4gICAgICAgICAqICAgICBhbW91bnQ6IDxpbnQ+IFxuICAgICAgICAgKiAgICAgdHlwZTogcGx1c3xtaW51c3xwbHVzbWludXNcbiAgICAgICAgICogfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJhbmdlRnJvbUlzb0FuZE9mZnNldCA9IGZ1bmN0aW9uKGlzbywgdW5pdCwgYW1vdW50LCB0eXBlKSB7XG4gICAgICAgICAgICBhbW91bnQgPSBwYXJzZUludChhbW91bnQsIDEwKTtcbiAgICAgICAgICAgIGFtb3VudCA9IGlzTmFOKGFtb3VudCkgPyAxIDogYW1vdW50O1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgPT09IHVuZGVmaW5lZCA/ICdwbHVzbWludXMnIDogdHlwZTtcbiAgICAgICAgICAgIGlmIChbJ3BsdXMnLCAnbWludXMnLCAncGx1c21pbnVzJ10uaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9yaWdhbmFsRGF0ZSA9IG5ldyBEYXRlKGlzbyksXG4gICAgICAgICAgICAgICAgbG93ZXJSYW5nZSA9IG5ldyBEYXRlKGlzbyksXG4gICAgICAgICAgICAgICAgdXBwZXJSYW5nZSA9IG5ldyBEYXRlKGlzbyk7XG5cbiAgICAgICAgICAgIHN3aXRjaCh1bml0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndyc6IFxuICAgICAgICAgICAgICAgICAgICBsb3dlclJhbmdlLnNldERhdGUobG93ZXJSYW5nZS5nZXREYXRlKCkgLSAoNyAqIGFtb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclJhbmdlLnNldERhdGUodXBwZXJSYW5nZS5nZXREYXRlKCkgKyAoNyAqIGFtb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkJzogXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUmFuZ2Uuc2V0RGF0ZShsb3dlclJhbmdlLmdldERhdGUoKSAtIGFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUmFuZ2Uuc2V0RGF0ZSh1cHBlclJhbmdlLmdldERhdGUoKSArIGFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOiBcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJSYW5nZS5zZXRIb3Vycyhsb3dlclJhbmdlLmdldEhvdXJzKCkgLSBhbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclJhbmdlLnNldEhvdXJzKHVwcGVyUmFuZ2UuZ2V0SG91cnMoKSArIGFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ20nOiBcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJSYW5nZS5zZXRNaW51dGVzKGxvd2VyUmFuZ2UuZ2V0TWludXRlcygpIC0gYW1vdW50KTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJSYW5nZS5zZXRNaW51dGVzKHVwcGVyUmFuZ2UuZ2V0TWludXRlcygpICsgYW1vdW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncyc6IFxuICAgICAgICAgICAgICAgICAgICBsb3dlclJhbmdlLnNldFNlY29uZHMobG93ZXJSYW5nZS5nZXRTZWNvbmRzKCkgLSBhbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclJhbmdlLnNldFNlY29uZHModXBwZXJSYW5nZS5nZXRTZWNvbmRzKCkgKyBhbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtcyc6IFxuICAgICAgICAgICAgICAgICAgICBsb3dlclJhbmdlLnNldE1pbGxpc2Vjb25kcyhsb3dlclJhbmdlLmdldE1pbGxpc2Vjb25kcygpIC0gYW1vdW50KTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJSYW5nZS5zZXRNaWxsaXNlY29uZHModXBwZXJSYW5nZS5nZXRNaWxsaXNlY29uZHMoKSArIGFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICAgICAgICBsb3dlclJhbmdlOiAodHlwZSA9PT0gJ21pbnVzJyB8fCB0eXBlID09PSAncGx1c21pbnVzJykgPyBsb3dlclJhbmdlIDogb3JpZ2FuYWxEYXRlLFxuICAgICAgICAgICAgICAgIHVwcGVyUmFuZ2U6ICh0eXBlID09PSAncGx1cycgfHwgdHlwZSA9PT0gJ3BsdXNtaW51cycpID8gdXBwZXJSYW5nZSA6IG9yaWdhbmFsRGF0ZSBcbiAgICAgICAgICAgIH07IFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICBpZiAodGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF8uaXNOdW1iZXIodGltZSkgfHwgISgvXihub3d8LXxcXCt8QHxydCkuKi8udGVzdCh0aW1lKSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgaXNFcG9jaCA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmlzTnVtYmVyKHRpbWUpIHx8IChfLmlzU3RyaW5nKHRpbWUpICYmIC9eXFxkKygoXFwuXFxkKyl8KFxcZCopKSQvLnRlc3QodGltZSkgJiYgdGltZSAhPT0gJzAnKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciB0aW1lQW5kSnNEYXRlSXNXaG9sZURheSA9IGZ1bmN0aW9uKHRpbWUsIGpzRGF0ZSkge1xuICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUodGltZSkgJiYganNEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChqc0RhdGUuZ2V0SG91cnMoKSA9PSAwKSAmJiAoanNEYXRlLmdldE1pbnV0ZXMoKSA9PSAwKSAmJiAoanNEYXRlLmdldFNlY29uZHMoKSA9PSAwKSAmJiAoanNEYXRlLmdldE1pbGxpc2Vjb25kcygpID09IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGlzTm93ID0gZnVuY3Rpb24odGltZSkge1xuICAgICAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKF8uaXNTdHJpbmcodGltZSkgJiYgKCh0aW1lID09PSAnJykgfHwgKC9ub3cvLnRlc3QodGltZSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgaXNFbXB0eSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aW1lID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoIXRpbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjb21wYXJlVHdvVGltZVJhbmdlcyA9IGZ1bmN0aW9uKGVhcmxpZXN0MSwgbGF0ZXN0MSwgZWFybGllc3QyLCBsYXRlc3QyKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGV5IGFyZSBcImFsbCB0aW1lXCJcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGVhcmxpZXN0MSkgJiYgaXNFbXB0eShlYXJsaWVzdDIpICYmIGlzTm93KGxhdGVzdDEpICYmIGlzTm93KGxhdGVzdDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGVhcmxpZXN0MSkgJiYgaXNFbXB0eShlYXJsaWVzdDIpICYmIChsYXRlc3QxID09PSBsYXRlc3QyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGVhcmxpZXN0MSA9PT0gZWFybGllc3QyKSAmJiBpc05vdyhsYXRlc3QxKSAmJiBpc05vdyhsYXRlc3QyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKGVhcmxpZXN0MSA9PT0gZWFybGllc3QyKSAmJiAobGF0ZXN0MSA9PT0gbGF0ZXN0Mik7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgZmluZFByZXNldExhYmVsID0gZnVuY3Rpb24ocHJlc2V0c0NvbGxlY3Rpb24sIGVhcmxpZXN0LCBsYXRlc3QpIHtcbiAgICAgICAgICAgIHZhciBwcmVzZXRNb2RlbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHByZXNldHNDb2xsZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvL1RPRE86IHRoaXMgc2hvdWxkIHByb2JhYmx5IGdldCBtb3ZlZCB0byB0aGUgVGltZXMgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIHByZXNldE1vZGVsID0gcHJlc2V0c0NvbGxlY3Rpb24uZmluZChmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXNDb25mRWFybGllc3QgPSBtb2RlbC5lbnRyeS5jb250ZW50LmdldChcImVhcmxpZXN0X3RpbWVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc0NvbmZMYXRlc3QgPSBtb2RlbC5lbnRyeS5jb250ZW50LmdldChcImxhdGVzdF90aW1lXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9FYXJsaWVzdHMgPSAoaXNFbXB0eSh0aW1lc0NvbmZFYXJsaWVzdCkgJiYgaXNFbXB0eShlYXJsaWVzdCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9MYXRlc3RzID0gKGlzRW1wdHkodGltZXNDb25mTGF0ZXN0KSAmJiBpc0VtcHR5KGxhdGVzdCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZCA9IG1vZGVsLmlzRGlzYWJsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIWlzRGlzYWJsZWQgJiYgKG5vRWFybGllc3RzIHx8ICh0aW1lc0NvbmZFYXJsaWVzdCA9PSBlYXJsaWVzdCkpICYmIChub0xhdGVzdHMgfHwgKHRpbWVzQ29uZkxhdGVzdCA9PSBsYXRlc3QpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHByZXNldE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXRNb2RlbC5lbnRyeS5jb250ZW50LmdldChcImxhYmVsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBnZW5lcmF0ZVJlYWx0aW1lTGFiZWwgPSBmdW5jdGlvbihlYXJsaWVzdCwgbGF0ZXN0KSB7XG4gICAgICAgICAgICB2YXIgZWFybGllc3RQYXJzZSwgbGF0ZXN0SXNOb3c7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpc1JlYWx0aW1lKGVhcmxpZXN0KSB8fCBpc1JlYWx0aW1lKGxhdGVzdCkpIHtcbiAgICAgICAgICAgICAgICBlYXJsaWVzdFBhcnNlID0gcGFyc2VUaW1lU3RyaW5nKGVhcmxpZXN0KTtcbiAgICAgICAgICAgICAgICBsYXRlc3RJc05vdyA9IGlzTm93KGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsVGVtcGxhdGVzID0ge1xuICAgICAgICAgICAgICAgICAgICBzOiBfKFwiJXMgc2Vjb25kIHdpbmRvd1wiKS50KCksXG4gICAgICAgICAgICAgICAgICAgIG06IF8oXCIlcyBtaW51dGUgd2luZG93XCIpLnQoKSxcbiAgICAgICAgICAgICAgICAgICAgaDogXyhcIiVzIGhvdXIgd2luZG93XCIpLnQoKSxcbiAgICAgICAgICAgICAgICAgICAgZDogXyhcIiVzIGRheSB3aW5kb3dcIikudCgpLFxuICAgICAgICAgICAgICAgICAgICB3OiBfKFwiJXMgd2VlayB3aW5kb3dcIikudCgpLFxuICAgICAgICAgICAgICAgICAgICBtb246IF8oXCIlcyBtb250aCB3aW5kb3dcIikudCgpLFxuICAgICAgICAgICAgICAgICAgICBxOiBfKFwiJXMgcXVhcnRlciB3aW5kb3dcIikudCgpLFxuICAgICAgICAgICAgICAgICAgICB5OiBfKFwiJXMgeWVhciB3aW5kb3dcIikudCgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vQSB3aW5kb3dlZCB0aW1lIHdpdGggYSBsYXRlc3QgdGltZSBvZiBub3cuXG4gICAgICAgICAgICAgICAgaWYgKGVhcmxpZXN0UGFyc2UgJiYgZWFybGllc3RQYXJzZS5hbW91bnQgJiYgbGF0ZXN0SXNOb3cgJiYgbGFiZWxUZW1wbGF0ZXMuaGFzT3duUHJvcGVydHkoZWFybGllc3RQYXJzZS51bml0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BsdW5rVXRpbHMuc3ByaW50ZihsYWJlbFRlbXBsYXRlc1tlYXJsaWVzdFBhcnNlLnVuaXRdLCBlYXJsaWVzdFBhcnNlLmFtb3VudCk7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL090aGVyIFJlYWwtVGltZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gXyhcIlJlYWwtdGltZVwiKS50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgZ2VuZXJhdGVSZWxhdGl2ZVRpbWVMYWJlbCA9IGZ1bmN0aW9uKGVhcmxpZXN0LCBsYXRlc3QpIHtcbiAgICAgICAgICAgIHZhciBlYXJsaWVzdFBhcnNlID0gcGFyc2VUaW1lU3RyaW5nKGVhcmxpZXN0KSxcbiAgICAgICAgICAgICAgICBsYXRlc3RJc05vdyA9IGlzTm93KGxhdGVzdCksXG4gICAgICAgICAgICAgICAgbGF0ZXN0UGFyc2UgPSBwYXJzZVRpbWVTdHJpbmcobGF0ZXN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFlYXJsaWVzdFBhcnNlIHx8IGVhcmxpZXN0UGFyc2UuaXNSZWFsVGltZSB8fCBsYXRlc3RQYXJzZS5pc1JlYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZWFybGllc3RQYXJzZS5hbW91bnRcbiAgICAgICAgICAgICAgICAgICAgJiYgKCFlYXJsaWVzdFBhcnNlLnNuYXBVbml0IHx8IGVhcmxpZXN0UGFyc2UudW5pdCA9PT0gZWFybGllc3RQYXJzZS5zbmFwVW5pdClcbiAgICAgICAgICAgICAgICAgICAgJiYgKGxhdGVzdFBhcnNlLmlzTm93IHx8IChsYXRlc3RQYXJzZS5zbmFwVW5pdCAmJiAhbGF0ZXN0UGFyc2UuYW1vdW50KSlcbiAgICAgICAgICAgICAgICAgICAgJiYgKCFsYXRlc3RQYXJzZS5zbmFwVW5pdCB8fCBlYXJsaWVzdFBhcnNlLnVuaXQgPT09IGxhdGVzdFBhcnNlLnNuYXBVbml0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGx1bmtVdGlscy5zcHJpbnRmKF8oXCJMYXN0ICVzICVzXCIpLnQoKSwgZWFybGllc3RQYXJzZS5hbW91bnQsXG4gICAgICAgICAgICAgICAgICAgIFRJTUVfVU5JVFNbZWFybGllc3RQYXJzZS51bml0XVtlYXJsaWVzdFBhcnNlLmFtb3VudCA+IDE/ICdwbHVyYWwnIDogJ3Npbmd1bGFyJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgZ2VuZXJhdGVCZXR3ZWVuVGltZUxhYmVsID0gZnVuY3Rpb24oZWFybGllc3QsIGVhcmxpZXN0SlNEYXRlLCBsYXRlc3QsIGxhdGVzdEpTRGF0ZSkge1xuICAgICAgICAgICAgdmFyIGVhcmxpZXN0SXNXaG9sZURheSA9IHRpbWVBbmRKc0RhdGVJc1dob2xlRGF5KGVhcmxpZXN0LCBlYXJsaWVzdEpTRGF0ZSksXG4gICAgICAgICAgICAgICAgbGF0ZXN0SXNXaG9sZURheSA9IHRpbWVBbmRKc0RhdGVJc1dob2xlRGF5KGxhdGVzdCwgbGF0ZXN0SlNEYXRlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGVhcmxpZXN0SXNXaG9sZURheSAmJiBsYXRlc3RJc1dob2xlRGF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlID09ICdlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkxOG4uZm9ybWF0X2RhdGV0aW1lX3JhbmdlKG51bGwsIGVhcmxpZXN0SlNEYXRlLCBsYXRlc3RKU0RhdGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbERhdGUgPSBuZXcgRGF0ZShsYXRlc3RKU0RhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRlLnNldERhdGUobGFiZWxEYXRlLmdldERhdGUoKSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGx1bmtVdGlscy5zcHJpbnRmKF8oXCIlcyB0aHJvdWdoICVzXCIpLnQoKSwgaTE4bi5mb3JtYXRfZGF0ZShlYXJsaWVzdEpTRGF0ZSwgJ3Nob3J0JyksIGkxOG4uZm9ybWF0X2RhdGUobGFiZWxEYXRlLCAnc2hvcnQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgZ2VuZXJhdGVTaW5jZURhdGVMYWJlbCA9IGZ1bmN0aW9uKGVhcmxpZXN0LCBlYXJsaWVzdEpTRGF0ZSwgbGF0ZXN0KXtcbiAgICAgICAgICAgIHZhciBlYXJsaWVzdElzV2hvbGVEYXkgPSB0aW1lQW5kSnNEYXRlSXNXaG9sZURheShlYXJsaWVzdCwgZWFybGllc3RKU0RhdGUpLFxuICAgICAgICAgICAgICAgIGxhdGVzdElzTm93ID0gaXNOb3cobGF0ZXN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGVhcmxpZXN0SXNXaG9sZURheSAmJiBsYXRlc3RJc05vdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGx1bmtVdGlscy5zcHJpbnRmKF8oXCJTaW5jZSAlc1wiKS50KCksIGkxOG4uZm9ybWF0X2RhdGUoZWFybGllc3RKU0RhdGUsICdzaG9ydCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGdlbmVyYXRlQmVmb3JlRGF0ZUxhYmVsID0gZnVuY3Rpb24oZWFybGllc3QsIGxhdGVzdCwgbGF0ZXN0SlNEYXRlKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaXNFbXB0eShlYXJsaWVzdCkgJiYgdGltZUFuZEpzRGF0ZUlzV2hvbGVEYXkobGF0ZXN0LCBsYXRlc3RKU0RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwbHVua1V0aWxzLnNwcmludGYoXyhcIkJlZm9yZSAlc1wiKS50KCksIGkxOG4uZm9ybWF0X2RhdGUobGF0ZXN0SlNEYXRlLCAnc2hvcnQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBnZW5lcmF0ZURhdGVUaW1lUmFuZ2VMYWJlbCA9IGZ1bmN0aW9uKGVhcmxpZXN0LCBsYXRlc3QpIHtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eShlYXJsaWVzdCkgJiYgaXNBYnNvbHV0ZShlYXJsaWVzdCkgJiYgaXNBYnNvbHV0ZShsYXRlc3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8oXCJEYXRlIHRpbWUgcmFuZ2VcIikudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGdlbmVyYXRlU2luY2VUaW1lUmFuZ2VMYWJlbCA9IGZ1bmN0aW9uKGVhcmxpZXN0LCBsYXRlc3QpIHtcbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKGVhcmxpZXN0KSAmJiBpc05vdyhsYXRlc3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8oXCJTaW5jZSBkYXRlIHRpbWVcIikudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgfTtcbiAgICAgICAgIFxuICAgICAgICAgdmFyIGdlbmVyYXRlQmVmb3JlVGltZVJhbmdlTGFiZWwgPSBmdW5jdGlvbihlYXJsaWVzdCwgbGF0ZXN0KSB7XG4gICAgICAgICAgICAgaWYgKGlzRW1wdHkoZWFybGllc3QpICYmIGlzQWJzb2x1dGUobGF0ZXN0KSkge1xuICAgICAgICAgICAgICAgICByZXR1cm4gXyhcIkJlZm9yZSBkYXRlIHRpbWVcIikudCgpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICB9O1xuICAgICAgICAgXG4gICAgICAgICB2YXIgZ2VuZXJhdGVBbGxUaW1lTGFiZWwgPSBmdW5jdGlvbihlYXJsaWVzdCwgbGF0ZXN0KSB7XG4gICAgICAgICAgICAgaWYgKGlzRW1wdHkoZWFybGllc3QpICYmIGlzTm93KGxhdGVzdCkpIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIF8oXCJBbGwgdGltZVwiKS50KCk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1ha2VUb2RheVJlbGF0aXZlV2l0aE5vVGltZVpvbmUgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpLFxuICAgICAgICAgICAgICAgIG1EYXRlID0gbW9tZW50KGRhdGUpLFxuICAgICAgICAgICAgICAgIGlzY3VycmVudERhdGUgPSAobURhdGUpLmlzU2FtZShuZXcgRGF0ZSgpLCBcImRheVwiKTtcbiAgICAgICAgICAgIGlmKGlzY3VycmVudERhdGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChtRGF0ZSkuZnJvbU5vdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0ZS50b1N0cmluZygpLnNsaWNlKDAsMjQpO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgKiBwcmVzZXRzOiA8Y29sbGVjdGlvbnMuc2VydmljZXMuZGF0YS51aS5UaW1lc1YyPlxuICAgICAgICAqKi9cbiAgICAgICAgdmFyIGdlbmVyYXRlTGFiZWwgPSBmdW5jdGlvbihwcmVzZXRzQ29sbGVjdGlvbiwgZWFybGllc3QsIGVhcmxpZXN0SlNEYXRlLCBsYXRlc3QsIGxhdGVzdEpTRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQWxsVGltZUxhYmVsKGVhcmxpZXN0LCBsYXRlc3QpIHx8XG4gICAgICAgICAgICAgICAgZmluZFByZXNldExhYmVsKHByZXNldHNDb2xsZWN0aW9uLCBlYXJsaWVzdCwgbGF0ZXN0KSB8fFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlUmVhbHRpbWVMYWJlbChlYXJsaWVzdCwgbGF0ZXN0KSB8fFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlUmVsYXRpdmVUaW1lTGFiZWwoZWFybGllc3QsIGxhdGVzdCkgfHxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUJldHdlZW5UaW1lTGFiZWwoZWFybGllc3QsIGVhcmxpZXN0SlNEYXRlLCBsYXRlc3QsIGxhdGVzdEpTRGF0ZSkgfHxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZVNpbmNlRGF0ZUxhYmVsKGVhcmxpZXN0LCBlYXJsaWVzdEpTRGF0ZSwgbGF0ZXN0KSB8fFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlQmVmb3JlRGF0ZUxhYmVsKGVhcmxpZXN0LCBsYXRlc3QsIGxhdGVzdEpTRGF0ZSkgfHxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZURhdGVUaW1lUmFuZ2VMYWJlbChlYXJsaWVzdCwgbGF0ZXN0KSB8fFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlU2luY2VUaW1lUmFuZ2VMYWJlbChlYXJsaWVzdCwgbGF0ZXN0KSB8fFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlQmVmb3JlVGltZVJhbmdlTGFiZWwoZWFybGllc3QsIGxhdGVzdCkgfHxcbiAgICAgICAgICAgICAgICBfKFwiQ3VzdG9tIHRpbWVcIikudCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBSRVNVTFRTX1RJTUVTVEFNUF9GT1JNQVRTID0ge1xuICAgICAgICAgICAgeWVhcjogJ1lZWVknLFxuICAgICAgICAgICAgbW9udGg6ICdZWVlZLU1NJyxcbiAgICAgICAgICAgIGRheTogJ1lZWVktTU0tZGQnLFxuICAgICAgICAgICAgaG91cjogJ1lZWVktTU0tZGQgSEg6MDAnLFxuICAgICAgICAgICAgbWludXRlOiAnWVlZWS1NTS1kZCBISDptbTowMCcsXG4gICAgICAgICAgICBzZWNvbmQ6ICdZWVlZLU1NLWRkIEhIOm1tOnNzJyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiAnWVlZWS1NTS1kZCBISDptbTpzcy5UVFQnXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIGV4dHJhY3RCZFRpbWU6IGV4dHJhY3RCZFRpbWUsXG4gICAgICAgICAgICBiZFRpbWVUb0RhdGVPYmplY3Q6IGJkVGltZVRvRGF0ZU9iamVjdCxcbiAgICAgICAgICAgIHJhbmdlRnJvbUlzb0FuZE9mZnNldDogcmFuZ2VGcm9tSXNvQW5kT2Zmc2V0LFxuICAgICAgICAgICAgZ2V0VGltZXpvbmVTdHJpbmc6IGdldFRpbWV6b25lU3RyaW5nLFxuICAgICAgICAgICAgaXNvVG9EYXRlT2JqZWN0OiBpc29Ub0RhdGVPYmplY3QsXG4gICAgICAgICAgICBkZXRlcm1pbmVMYWJlbEdyYW51bGFyaXR5OiBkZXRlcm1pbmVMYWJlbEdyYW51bGFyaXR5LFxuICAgICAgICAgICAgaXNWYWxpZElzb1RpbWU6IGlzVmFsaWRJc29UaW1lLFxuICAgICAgICAgICAgVElNRV9VTklUUzogVElNRV9VTklUUyxcbiAgICAgICAgICAgIElTT19QQVRURVJOOiBJU09fUEFUVEVSTixcbiAgICAgICAgICAgIG5vcm1hbGl6ZVVuaXQ6IG5vcm1hbGl6ZVVuaXQsXG4gICAgICAgICAgICBwYXJzZVRpbWVTdHJpbmc6IHBhcnNlVGltZVN0cmluZyxcbiAgICAgICAgICAgIHBhcnNlVGltZU1vZGlmaWVyOiBwYXJzZVRpbWVNb2RpZmllcixcbiAgICAgICAgICAgIGlzUmVhbHRpbWU6IGlzUmVhbHRpbWUsXG4gICAgICAgICAgICBzdHJpcFJUU2FmZTogc3RyaXBSVFNhZmUsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiBpc0Fic29sdXRlLFxuICAgICAgICAgICAgaXNFcG9jaDogaXNFcG9jaCxcbiAgICAgICAgICAgIHRpbWVBbmRKc0RhdGVJc1dob2xlRGF5OiB0aW1lQW5kSnNEYXRlSXNXaG9sZURheSxcbiAgICAgICAgICAgIGlzTm93OiBpc05vdyxcbiAgICAgICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgICAgICAgICBjb21wYXJlVHdvVGltZVJhbmdlczogY29tcGFyZVR3b1RpbWVSYW5nZXMsXG4gICAgICAgICAgICBmaW5kUHJlc2V0TGFiZWw6IGZpbmRQcmVzZXRMYWJlbCxcbiAgICAgICAgICAgIGdlbmVyYXRlUmVhbHRpbWVMYWJlbDogZ2VuZXJhdGVSZWFsdGltZUxhYmVsLFxuICAgICAgICAgICAgZ2VuZXJhdGVSZWxhdGl2ZVRpbWVMYWJlbDogZ2VuZXJhdGVSZWxhdGl2ZVRpbWVMYWJlbCxcbiAgICAgICAgICAgIGdlbmVyYXRlQmV0d2VlblRpbWVMYWJlbDogZ2VuZXJhdGVCZXR3ZWVuVGltZUxhYmVsLFxuICAgICAgICAgICAgZ2VuZXJhdGVTaW5jZURhdGVMYWJlbDogZ2VuZXJhdGVTaW5jZURhdGVMYWJlbCxcbiAgICAgICAgICAgIGdlbmVyYXRlQmVmb3JlRGF0ZUxhYmVsOiBnZW5lcmF0ZUJlZm9yZURhdGVMYWJlbCxcbiAgICAgICAgICAgIGdlbmVyYXRlRGF0ZVRpbWVSYW5nZUxhYmVsOiBnZW5lcmF0ZURhdGVUaW1lUmFuZ2VMYWJlbCxcbiAgICAgICAgICAgIGdlbmVyYXRlU2luY2VUaW1lUmFuZ2VMYWJlbDogZ2VuZXJhdGVTaW5jZVRpbWVSYW5nZUxhYmVsLFxuICAgICAgICAgICAgZ2VuZXJhdGVCZWZvcmVUaW1lUmFuZ2VMYWJlbDogZ2VuZXJhdGVCZWZvcmVUaW1lUmFuZ2VMYWJlbCxcbiAgICAgICAgICAgIGdlbmVyYXRlQWxsVGltZUxhYmVsOiBnZW5lcmF0ZUFsbFRpbWVMYWJlbCxcbiAgICAgICAgICAgIGdlbmVyYXRlTGFiZWw6IGdlbmVyYXRlTGFiZWwsXG4gICAgICAgICAgICBjb252ZXJ0VG9SZWxhdGl2ZVRpbWU6IGNvbnZlcnRUb1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGNvbnZlcnRUb0xvY2FsVGltZTogY29udmVydFRvTG9jYWxUaW1lLFxuICAgICAgICAgICAganNEYXRlVG9TcGx1bmtEYXRlVGltZVdpdGhNaWNyb3NlY29uZHM6IGpzRGF0ZVRvU3BsdW5rRGF0ZVRpbWVXaXRoTWljcm9zZWNvbmRzLFxuICAgICAgICAgICAgZ2V0UmVsYXRpdmVTdHJpbmdGcm9tU2Vjb25kczogZ2V0UmVsYXRpdmVTdHJpbmdGcm9tU2Vjb25kcyxcbiAgICAgICAgICAgIGNvbnZlcnRBbW91bnRBbmRVbml0VG9TZWNvbmRzOiBjb252ZXJ0QW1vdW50QW5kVW5pdFRvU2Vjb25kcyxcbiAgICAgICAgICAgIHNlY29uZHNUb1NlcGFyYXRlZERhdGU6IHNlY29uZHNUb1NlcGFyYXRlZERhdGUsXG4gICAgICAgICAgICBtYWtlVG9kYXlSZWxhdGl2ZVdpdGhOb1RpbWVab25lOiBtYWtlVG9kYXlSZWxhdGl2ZVdpdGhOb1RpbWVab25lLFxuICAgICAgICAgICAgUkVTVUxUU19USU1FU1RBTVBfRk9STUFUUzogUkVTVUxUU19USU1FU1RBTVBfRk9STUFUU1xuICAgICAgICB9KTtcbiAgICB9XG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvdGltZS5qc1xuLy8gbW9kdWxlIGlkID0gdXRpbC90aW1lXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "util/moment":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"stubs/i18n\"), __webpack_require__(270)], __WEBPACK_AMD_DEFINE_RESULT__ = function(i18n, moment){\n    var initFn = i18n.moment_install;\n    if(typeof initFn === 'function') {\n        initFn(moment);\n    }\n    return moment;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvbW9tZW50LmpzPzdlNmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoidXRpbC9tb21lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWydzcGx1bmsuaTE4bicsICdtb21lbnQnXSxmdW5jdGlvbihpMThuLCBtb21lbnQpe1xuICAgIHZhciBpbml0Rm4gPSBpMThuLm1vbWVudF9pbnN0YWxsO1xuICAgIGlmKHR5cGVvZiBpbml0Rm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5pdEZuKG1vbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBtb21lbnQ7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvdXRpbC9tb21lbnQuanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvbW9tZW50XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 270:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {//! moment.js\n//! version : 2.8.4\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n(function (undefined) {\n    /************************************\n        Constants\n    ************************************/\n\n    var moment,\n        VERSION = '2.8.4',\n        // the global-scope this is NOT the global object in Node.js\n        globalScope = typeof global !== 'undefined' ? global : this,\n        oldGlobalMoment,\n        round = Math.round,\n        hasOwnProperty = Object.prototype.hasOwnProperty,\n        i,\n\n        YEAR = 0,\n        MONTH = 1,\n        DATE = 2,\n        HOUR = 3,\n        MINUTE = 4,\n        SECOND = 5,\n        MILLISECOND = 6,\n\n        // internal storage for locale config files\n        locales = {},\n\n        // extra moment internal properties (plugins register props here)\n        momentProperties = [],\n\n        // check for nodeJS\n        hasModule = (typeof module !== 'undefined' && module && module.exports),\n\n        // ASP.NET json date format regex\n        aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i,\n        aspNetTimeSpanJsonRegex = /(\\-)?(?:(\\d*)\\.)?(\\d+)\\:(\\d+)(?:\\:(\\d+)\\.?(\\d{3})?)?/,\n\n        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,\n\n        // format tokens\n        formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,\n        localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,\n\n        // parsing token regexes\n        parseTokenOneOrTwoDigits = /\\d\\d?/, // 0 - 99\n        parseTokenOneToThreeDigits = /\\d{1,3}/, // 0 - 999\n        parseTokenOneToFourDigits = /\\d{1,4}/, // 0 - 9999\n        parseTokenOneToSixDigits = /[+\\-]?\\d{1,6}/, // -999,999 - 999,999\n        parseTokenDigits = /\\d+/, // nonzero number of digits\n        parseTokenWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.\n        parseTokenTimezone = /Z|[\\+\\-]\\d\\d:?\\d\\d/gi, // +00:00 -00:00 +0000 -0000 or Z\n        parseTokenT = /T/i, // T (ISO separator)\n        parseTokenOffsetMs = /[\\+\\-]?\\d+/, // 1234567890123\n        parseTokenTimestampMs = /[\\+\\-]?\\d+(\\.\\d{1,3})?/, // 123456789 123456789.123\n\n        //strict parsing regexes\n        parseTokenOneDigit = /\\d/, // 0 - 9\n        parseTokenTwoDigits = /\\d\\d/, // 00 - 99\n        parseTokenThreeDigits = /\\d{3}/, // 000 - 999\n        parseTokenFourDigits = /\\d{4}/, // 0000 - 9999\n        parseTokenSixDigits = /[+-]?\\d{6}/, // -999,999 - 999,999\n        parseTokenSignedNumber = /[+-]?\\d+/, // -inf - inf\n\n        // iso 8601 regex\n        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n        isoRegex = /^\\s*(?:[+-]\\d{6}|\\d{4})-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n\n        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',\n\n        isoDates = [\n            ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d{2}-\\d{2}/],\n            ['YYYY-MM-DD', /\\d{4}-\\d{2}-\\d{2}/],\n            ['GGGG-[W]WW-E', /\\d{4}-W\\d{2}-\\d/],\n            ['GGGG-[W]WW', /\\d{4}-W\\d{2}/],\n            ['YYYY-DDD', /\\d{4}-\\d{3}/]\n        ],\n\n        // iso time formats and regexes\n        isoTimes = [\n            ['HH:mm:ss.SSSS', /(T| )\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n            ['HH:mm:ss', /(T| )\\d\\d:\\d\\d:\\d\\d/],\n            ['HH:mm', /(T| )\\d\\d:\\d\\d/],\n            ['HH', /(T| )\\d\\d/]\n        ],\n\n        // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-15', '30']\n        parseTimezoneChunker = /([\\+\\-]|\\d\\d)/gi,\n\n        // getter and setter names\n        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),\n        unitMillisecondFactors = {\n            'Milliseconds' : 1,\n            'Seconds' : 1e3,\n            'Minutes' : 6e4,\n            'Hours' : 36e5,\n            'Days' : 864e5,\n            'Months' : 2592e6,\n            'Years' : 31536e6\n        },\n\n        unitAliases = {\n            ms : 'millisecond',\n            s : 'second',\n            m : 'minute',\n            h : 'hour',\n            d : 'day',\n            D : 'date',\n            w : 'week',\n            W : 'isoWeek',\n            M : 'month',\n            Q : 'quarter',\n            y : 'year',\n            DDD : 'dayOfYear',\n            e : 'weekday',\n            E : 'isoWeekday',\n            gg: 'weekYear',\n            GG: 'isoWeekYear'\n        },\n\n        camelFunctions = {\n            dayofyear : 'dayOfYear',\n            isoweekday : 'isoWeekday',\n            isoweek : 'isoWeek',\n            weekyear : 'weekYear',\n            isoweekyear : 'isoWeekYear'\n        },\n\n        // format function strings\n        formatFunctions = {},\n\n        // default relative time thresholds\n        relativeTimeThresholds = {\n            s: 45,  // seconds to minute\n            m: 45,  // minutes to hour\n            h: 22,  // hours to day\n            d: 26,  // days to month\n            M: 11   // months to year\n        },\n\n        // tokens to ordinalize and pad\n        ordinalizeTokens = 'DDD w W M D d'.split(' '),\n        paddedTokens = 'M D H h m s w W'.split(' '),\n\n        formatTokenFunctions = {\n            M    : function () {\n                return this.month() + 1;\n            },\n            MMM  : function (format) {\n                return this.localeData().monthsShort(this, format);\n            },\n            MMMM : function (format) {\n                return this.localeData().months(this, format);\n            },\n            D    : function () {\n                return this.date();\n            },\n            DDD  : function () {\n                return this.dayOfYear();\n            },\n            d    : function () {\n                return this.day();\n            },\n            dd   : function (format) {\n                return this.localeData().weekdaysMin(this, format);\n            },\n            ddd  : function (format) {\n                return this.localeData().weekdaysShort(this, format);\n            },\n            dddd : function (format) {\n                return this.localeData().weekdays(this, format);\n            },\n            w    : function () {\n                return this.week();\n            },\n            W    : function () {\n                return this.isoWeek();\n            },\n            YY   : function () {\n                return leftZeroFill(this.year() % 100, 2);\n            },\n            YYYY : function () {\n                return leftZeroFill(this.year(), 4);\n            },\n            YYYYY : function () {\n                return leftZeroFill(this.year(), 5);\n            },\n            YYYYYY : function () {\n                var y = this.year(), sign = y >= 0 ? '+' : '-';\n                return sign + leftZeroFill(Math.abs(y), 6);\n            },\n            gg   : function () {\n                return leftZeroFill(this.weekYear() % 100, 2);\n            },\n            gggg : function () {\n                return leftZeroFill(this.weekYear(), 4);\n            },\n            ggggg : function () {\n                return leftZeroFill(this.weekYear(), 5);\n            },\n            GG   : function () {\n                return leftZeroFill(this.isoWeekYear() % 100, 2);\n            },\n            GGGG : function () {\n                return leftZeroFill(this.isoWeekYear(), 4);\n            },\n            GGGGG : function () {\n                return leftZeroFill(this.isoWeekYear(), 5);\n            },\n            e : function () {\n                return this.weekday();\n            },\n            E : function () {\n                return this.isoWeekday();\n            },\n            a    : function () {\n                return this.localeData().meridiem(this.hours(), this.minutes(), true);\n            },\n            A    : function () {\n                return this.localeData().meridiem(this.hours(), this.minutes(), false);\n            },\n            H    : function () {\n                return this.hours();\n            },\n            h    : function () {\n                return this.hours() % 12 || 12;\n            },\n            m    : function () {\n                return this.minutes();\n            },\n            s    : function () {\n                return this.seconds();\n            },\n            S    : function () {\n                return toInt(this.milliseconds() / 100);\n            },\n            SS   : function () {\n                return leftZeroFill(toInt(this.milliseconds() / 10), 2);\n            },\n            SSS  : function () {\n                return leftZeroFill(this.milliseconds(), 3);\n            },\n            SSSS : function () {\n                return leftZeroFill(this.milliseconds(), 3);\n            },\n            Z    : function () {\n                var a = -this.zone(),\n                    b = '+';\n                if (a < 0) {\n                    a = -a;\n                    b = '-';\n                }\n                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);\n            },\n            ZZ   : function () {\n                var a = -this.zone(),\n                    b = '+';\n                if (a < 0) {\n                    a = -a;\n                    b = '-';\n                }\n                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);\n            },\n            z : function () {\n                return this.zoneAbbr();\n            },\n            zz : function () {\n                return this.zoneName();\n            },\n            x    : function () {\n                return this.valueOf();\n            },\n            X    : function () {\n                return this.unix();\n            },\n            Q : function () {\n                return this.quarter();\n            }\n        },\n\n        deprecations = {},\n\n        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];\n\n    // Pick the first defined of two or three arguments. dfl comes from\n    // default.\n    function dfl(a, b, c) {\n        switch (arguments.length) {\n            case 2: return a != null ? a : b;\n            case 3: return a != null ? a : b != null ? b : c;\n            default: throw new Error('Implement me');\n        }\n    }\n\n    function hasOwnProp(a, b) {\n        return hasOwnProperty.call(a, b);\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object, and es5 standard is not very\n        // helpful.\n        return {\n            empty : false,\n            unusedTokens : [],\n            unusedInput : [],\n            overflow : -2,\n            charsLeftOver : 0,\n            nullInput : false,\n            invalidMonth : null,\n            invalidFormat : false,\n            userInvalidated : false,\n            iso: false\n        };\n    }\n\n    function printMsg(msg) {\n        if (moment.suppressDeprecationWarnings === false &&\n                typeof console !== 'undefined' && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n        return extend(function () {\n            if (firstTime) {\n                printMsg(msg);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    function deprecateSimple(name, msg) {\n        if (!deprecations[name]) {\n            printMsg(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    function padToken(func, count) {\n        return function (a) {\n            return leftZeroFill(func.call(this, a), count);\n        };\n    }\n    function ordinalizeToken(func, period) {\n        return function (a) {\n            return this.localeData().ordinal(func.call(this, a), period);\n        };\n    }\n\n    while (ordinalizeTokens.length) {\n        i = ordinalizeTokens.pop();\n        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);\n    }\n    while (paddedTokens.length) {\n        i = paddedTokens.pop();\n        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);\n    }\n    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);\n\n\n    /************************************\n        Constructors\n    ************************************/\n\n    function Locale() {\n    }\n\n    // Moment prototype object\n    function Moment(config, skipOverflow) {\n        if (skipOverflow !== false) {\n            checkOverflow(config);\n        }\n        copyConfig(this, config);\n        this._d = new Date(+config._d);\n    }\n\n    // Duration Constructor\n    function Duration(duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 36e5; // 1000 * 60 * 60\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = moment.localeData();\n\n        this._bubble();\n    }\n\n    /************************************\n        Helpers\n    ************************************/\n\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (typeof from._isAMomentObject !== 'undefined') {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (typeof from._i !== 'undefined') {\n            to._i = from._i;\n        }\n        if (typeof from._f !== 'undefined') {\n            to._f = from._f;\n        }\n        if (typeof from._l !== 'undefined') {\n            to._l = from._l;\n        }\n        if (typeof from._strict !== 'undefined') {\n            to._strict = from._strict;\n        }\n        if (typeof from._tzm !== 'undefined') {\n            to._tzm = from._tzm;\n        }\n        if (typeof from._isUTC !== 'undefined') {\n            to._isUTC = from._isUTC;\n        }\n        if (typeof from._offset !== 'undefined') {\n            to._offset = from._offset;\n        }\n        if (typeof from._pf !== 'undefined') {\n            to._pf = from._pf;\n        }\n        if (typeof from._locale !== 'undefined') {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i in momentProperties) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (typeof val !== 'undefined') {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    function absRound(number) {\n        if (number < 0) {\n            return Math.ceil(number);\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    // left zero fill a number\n    // see http://jsperf.com/left-zero-filling for performance comparison\n    function leftZeroFill(number, targetLength, forceSign) {\n        var output = '' + Math.abs(number),\n            sign = number >= 0;\n\n        while (output.length < targetLength) {\n            output = '0' + output;\n        }\n        return (sign ? (forceSign ? '+' : '') : '-') + output;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        other = makeAs(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = moment.duration(val, period);\n            addOrSubtractDurationFromMoment(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = duration._days,\n            months = duration._months;\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (milliseconds) {\n            mom._d.setTime(+mom._d + milliseconds * isAdding);\n        }\n        if (days) {\n            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);\n        }\n        if (months) {\n            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);\n        }\n        if (updateOffset) {\n            moment.updateOffset(mom, days || months);\n        }\n    }\n\n    // check if is an array\n    function isArray(input) {\n        return Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isDate(input) {\n        return Object.prototype.toString.call(input) === '[object Date]' ||\n            input instanceof Date;\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function normalizeUnits(units) {\n        if (units) {\n            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');\n            units = unitAliases[units] || camelFunctions[lowered] || lowered;\n        }\n        return units;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    function makeList(field) {\n        var count, setter;\n\n        if (field.indexOf('week') === 0) {\n            count = 7;\n            setter = 'day';\n        }\n        else if (field.indexOf('month') === 0) {\n            count = 12;\n            setter = 'month';\n        }\n        else {\n            return;\n        }\n\n        moment[field] = function (format, index) {\n            var i, getter,\n                method = moment._locale[field],\n                results = [];\n\n            if (typeof format === 'number') {\n                index = format;\n                format = undefined;\n            }\n\n            getter = function (i) {\n                var m = moment().utc().set(setter, i);\n                return method.call(moment._locale, m, format || '');\n            };\n\n            if (index != null) {\n                return getter(index);\n            }\n            else {\n                for (i = 0; i < count; i++) {\n                    results.push(getter(i));\n                }\n                return results;\n            }\n        };\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            if (coercedNumber >= 0) {\n                value = Math.floor(coercedNumber);\n            } else {\n                value = Math.ceil(coercedNumber);\n            }\n        }\n\n        return value;\n    }\n\n    function daysInMonth(year, month) {\n        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n    }\n\n    function weeksInYear(year, dow, doy) {\n        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;\n    }\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    function checkOverflow(m) {\n        var overflow;\n        if (m._a && m._pf.overflow === -2) {\n            overflow =\n                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :\n                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :\n                m._a[HOUR] < 0 || m._a[HOUR] > 24 ||\n                    (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||\n                                           m._a[SECOND] !== 0 ||\n                                           m._a[MILLISECOND] !== 0)) ? HOUR :\n                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :\n                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :\n                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n\n            m._pf.overflow = overflow;\n        }\n    }\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            m._isValid = !isNaN(m._d.getTime()) &&\n                m._pf.overflow < 0 &&\n                !m._pf.empty &&\n                !m._pf.invalidMonth &&\n                !m._pf.nullInput &&\n                !m._pf.invalidFormat &&\n                !m._pf.userInvalidated;\n\n            if (m._strict) {\n                m._isValid = m._isValid &&\n                    m._pf.charsLeftOver === 0 &&\n                    m._pf.unusedTokens.length === 0 &&\n                    m._pf.bigHour === undefined;\n            }\n        }\n        return m._isValid;\n    }\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return null;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        if (!locales[name] && hasModule) {\n            try {\n                oldLocale = moment.locale();\n                __webpack_require__(272)(\"./\" + name);\n                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales\n                moment.locale(oldLocale);\n            } catch (e) { }\n        }\n        return locales[name];\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function makeAs(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (moment.isMoment(input) || isDate(input) ?\n                    +input : +moment(input)) - (+res);\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(+res._d + diff);\n            moment.updateOffset(res, false);\n            return res;\n        } else {\n            return moment(input).local();\n        }\n    }\n\n    /************************************\n        Locale\n    ************************************/\n\n\n    extend(Locale.prototype, {\n\n        set : function (config) {\n            var prop, i;\n            for (i in config) {\n                prop = config[i];\n                if (typeof prop === 'function') {\n                    this[i] = prop;\n                } else {\n                    this['_' + i] = prop;\n                }\n            }\n            // Lenient ordinal parsing accepts just a number in addition to\n            // number + (possibly) stuff coming from _ordinalParseLenient.\n            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\\d{1,2}/.source);\n        },\n\n        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        months : function (m) {\n            return this._months[m.month()];\n        },\n\n        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        monthsShort : function (m) {\n            return this._monthsShort[m.month()];\n        },\n\n        monthsParse : function (monthName, format, strict) {\n            var i, mom, regex;\n\n            if (!this._monthsParse) {\n                this._monthsParse = [];\n                this._longMonthsParse = [];\n                this._shortMonthsParse = [];\n            }\n\n            for (i = 0; i < 12; i++) {\n                // make the regex if we don't have it already\n                mom = moment.utc([2000, i]);\n                if (strict && !this._longMonthsParse[i]) {\n                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n                }\n                if (!strict && !this._monthsParse[i]) {\n                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n                }\n                // test the regex\n                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                    return i;\n                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                    return i;\n                } else if (!strict && this._monthsParse[i].test(monthName)) {\n                    return i;\n                }\n            }\n        },\n\n        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdays : function (m) {\n            return this._weekdays[m.day()];\n        },\n\n        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysShort : function (m) {\n            return this._weekdaysShort[m.day()];\n        },\n\n        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        weekdaysMin : function (m) {\n            return this._weekdaysMin[m.day()];\n        },\n\n        weekdaysParse : function (weekdayName) {\n            var i, mom, regex;\n\n            if (!this._weekdaysParse) {\n                this._weekdaysParse = [];\n            }\n\n            for (i = 0; i < 7; i++) {\n                // make the regex if we don't have it already\n                if (!this._weekdaysParse[i]) {\n                    mom = moment([2000, 1]).day(i);\n                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n                }\n                // test the regex\n                if (this._weekdaysParse[i].test(weekdayName)) {\n                    return i;\n                }\n            }\n        },\n\n        _longDateFormat : {\n            LTS : 'h:mm:ss A',\n            LT : 'h:mm A',\n            L : 'MM/DD/YYYY',\n            LL : 'MMMM D, YYYY',\n            LLL : 'MMMM D, YYYY LT',\n            LLLL : 'dddd, MMMM D, YYYY LT'\n        },\n        longDateFormat : function (key) {\n            var output = this._longDateFormat[key];\n            if (!output && this._longDateFormat[key.toUpperCase()]) {\n                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {\n                    return val.slice(1);\n                });\n                this._longDateFormat[key] = output;\n            }\n            return output;\n        },\n\n        isPM : function (input) {\n            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n            // Using charAt should be more compatible.\n            return ((input + '').toLowerCase().charAt(0) === 'p');\n        },\n\n        _meridiemParse : /[ap]\\.?m?\\.?/i,\n        meridiem : function (hours, minutes, isLower) {\n            if (hours > 11) {\n                return isLower ? 'pm' : 'PM';\n            } else {\n                return isLower ? 'am' : 'AM';\n            }\n        },\n\n        _calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        calendar : function (key, mom, now) {\n            var output = this._calendar[key];\n            return typeof output === 'function' ? output.apply(mom, [now]) : output;\n        },\n\n        _relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n\n        relativeTime : function (number, withoutSuffix, string, isFuture) {\n            var output = this._relativeTime[string];\n            return (typeof output === 'function') ?\n                output(number, withoutSuffix, string, isFuture) :\n                output.replace(/%d/i, number);\n        },\n\n        pastFuture : function (diff, output) {\n            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);\n        },\n\n        ordinal : function (number) {\n            return this._ordinal.replace('%d', number);\n        },\n        _ordinal : '%d',\n        _ordinalParse : /\\d{1,2}/,\n\n        preparse : function (string) {\n            return string;\n        },\n\n        postformat : function (string) {\n            return string;\n        },\n\n        week : function (mom) {\n            return weekOfYear(mom, this._week.dow, this._week.doy).week;\n        },\n\n        _week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        },\n\n        _invalidDate: 'Invalid date',\n        invalidDate: function () {\n            return this._invalidDate;\n        }\n    });\n\n    /************************************\n        Formatting\n    ************************************/\n\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '';\n            for (i = 0; i < length; i++) {\n                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n\n        if (!formatFunctions[format]) {\n            formatFunctions[format] = makeFormatFunction(format);\n        }\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n\n    /************************************\n        Parsing\n    ************************************/\n\n\n    // get the regex to find the next token\n    function getParseRegexForToken(token, config) {\n        var a, strict = config._strict;\n        switch (token) {\n        case 'Q':\n            return parseTokenOneDigit;\n        case 'DDDD':\n            return parseTokenThreeDigits;\n        case 'YYYY':\n        case 'GGGG':\n        case 'gggg':\n            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;\n        case 'Y':\n        case 'G':\n        case 'g':\n            return parseTokenSignedNumber;\n        case 'YYYYYY':\n        case 'YYYYY':\n        case 'GGGGG':\n        case 'ggggg':\n            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;\n        case 'S':\n            if (strict) {\n                return parseTokenOneDigit;\n            }\n            /* falls through */\n        case 'SS':\n            if (strict) {\n                return parseTokenTwoDigits;\n            }\n            /* falls through */\n        case 'SSS':\n            if (strict) {\n                return parseTokenThreeDigits;\n            }\n            /* falls through */\n        case 'DDD':\n            return parseTokenOneToThreeDigits;\n        case 'MMM':\n        case 'MMMM':\n        case 'dd':\n        case 'ddd':\n        case 'dddd':\n            return parseTokenWord;\n        case 'a':\n        case 'A':\n            return config._locale._meridiemParse;\n        case 'x':\n            return parseTokenOffsetMs;\n        case 'X':\n            return parseTokenTimestampMs;\n        case 'Z':\n        case 'ZZ':\n            return parseTokenTimezone;\n        case 'T':\n            return parseTokenT;\n        case 'SSSS':\n            return parseTokenDigits;\n        case 'MM':\n        case 'DD':\n        case 'YY':\n        case 'GG':\n        case 'gg':\n        case 'HH':\n        case 'hh':\n        case 'mm':\n        case 'ss':\n        case 'ww':\n        case 'WW':\n            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;\n        case 'M':\n        case 'D':\n        case 'd':\n        case 'H':\n        case 'h':\n        case 'm':\n        case 's':\n        case 'w':\n        case 'W':\n        case 'e':\n        case 'E':\n            return parseTokenOneOrTwoDigits;\n        case 'Do':\n            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;\n        default :\n            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\\\', '')), 'i'));\n            return a;\n        }\n    }\n\n    function timezoneMinutesFromString(string) {\n        string = string || '';\n        var possibleTzMatches = (string.match(parseTokenTimezone) || []),\n            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],\n            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],\n            minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return parts[0] === '+' ? -minutes : minutes;\n    }\n\n    // function to convert string input to date\n    function addTimeToArrayFromToken(token, input, config) {\n        var a, datePartArray = config._a;\n\n        switch (token) {\n        // QUARTER\n        case 'Q':\n            if (input != null) {\n                datePartArray[MONTH] = (toInt(input) - 1) * 3;\n            }\n            break;\n        // MONTH\n        case 'M' : // fall through to MM\n        case 'MM' :\n            if (input != null) {\n                datePartArray[MONTH] = toInt(input) - 1;\n            }\n            break;\n        case 'MMM' : // fall through to MMMM\n        case 'MMMM' :\n            a = config._locale.monthsParse(input, token, config._strict);\n            // if we didn't find a month name, mark the date as invalid.\n            if (a != null) {\n                datePartArray[MONTH] = a;\n            } else {\n                config._pf.invalidMonth = input;\n            }\n            break;\n        // DAY OF MONTH\n        case 'D' : // fall through to DD\n        case 'DD' :\n            if (input != null) {\n                datePartArray[DATE] = toInt(input);\n            }\n            break;\n        case 'Do' :\n            if (input != null) {\n                datePartArray[DATE] = toInt(parseInt(\n                            input.match(/\\d{1,2}/)[0], 10));\n            }\n            break;\n        // DAY OF YEAR\n        case 'DDD' : // fall through to DDDD\n        case 'DDDD' :\n            if (input != null) {\n                config._dayOfYear = toInt(input);\n            }\n\n            break;\n        // YEAR\n        case 'YY' :\n            datePartArray[YEAR] = moment.parseTwoDigitYear(input);\n            break;\n        case 'YYYY' :\n        case 'YYYYY' :\n        case 'YYYYYY' :\n            datePartArray[YEAR] = toInt(input);\n            break;\n        // AM / PM\n        case 'a' : // fall through to A\n        case 'A' :\n            config._isPm = config._locale.isPM(input);\n            break;\n        // HOUR\n        case 'h' : // fall through to hh\n        case 'hh' :\n            config._pf.bigHour = true;\n            /* falls through */\n        case 'H' : // fall through to HH\n        case 'HH' :\n            datePartArray[HOUR] = toInt(input);\n            break;\n        // MINUTE\n        case 'm' : // fall through to mm\n        case 'mm' :\n            datePartArray[MINUTE] = toInt(input);\n            break;\n        // SECOND\n        case 's' : // fall through to ss\n        case 'ss' :\n            datePartArray[SECOND] = toInt(input);\n            break;\n        // MILLISECOND\n        case 'S' :\n        case 'SS' :\n        case 'SSS' :\n        case 'SSSS' :\n            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);\n            break;\n        // UNIX OFFSET (MILLISECONDS)\n        case 'x':\n            config._d = new Date(toInt(input));\n            break;\n        // UNIX TIMESTAMP WITH MS\n        case 'X':\n            config._d = new Date(parseFloat(input) * 1000);\n            break;\n        // TIMEZONE\n        case 'Z' : // fall through to ZZ\n        case 'ZZ' :\n            config._useUTC = true;\n            config._tzm = timezoneMinutesFromString(input);\n            break;\n        // WEEKDAY - human\n        case 'dd':\n        case 'ddd':\n        case 'dddd':\n            a = config._locale.weekdaysParse(input);\n            // if we didn't get a weekday name, mark the date as invalid\n            if (a != null) {\n                config._w = config._w || {};\n                config._w['d'] = a;\n            } else {\n                config._pf.invalidWeekday = input;\n            }\n            break;\n        // WEEK, WEEK DAY - numeric\n        case 'w':\n        case 'ww':\n        case 'W':\n        case 'WW':\n        case 'd':\n        case 'e':\n        case 'E':\n            token = token.substr(0, 1);\n            /* falls through */\n        case 'gggg':\n        case 'GGGG':\n        case 'GGGGG':\n            token = token.substr(0, 2);\n            if (input) {\n                config._w = config._w || {};\n                config._w[token] = toInt(input);\n            }\n            break;\n        case 'gg':\n        case 'GG':\n            config._w = config._w || {};\n            config._w[token] = moment.parseTwoDigitYear(input);\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);\n            week = dfl(w.W, 1);\n            weekday = dfl(w.E, 1);\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);\n            week = dfl(w.w, 1);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < dow) {\n                    ++week;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);\n\n        config._a[YEAR] = temp.year;\n        config._dayOfYear = temp.dayOfYear;\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function dateFromConfig(config) {\n        var i, date, input = [], currentDate, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear) {\n            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse)) {\n                config._pf._overflowDayOfYear = true;\n            }\n\n            date = makeUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);\n        // Apply timezone offset from input. The actual zone can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n    }\n\n    function dateFromObject(config) {\n        var normalizedInput;\n\n        if (config._d) {\n            return;\n        }\n\n        normalizedInput = normalizeObjectUnits(config._i);\n        config._a = [\n            normalizedInput.year,\n            normalizedInput.month,\n            normalizedInput.day || normalizedInput.date,\n            normalizedInput.hour,\n            normalizedInput.minute,\n            normalizedInput.second,\n            normalizedInput.millisecond\n        ];\n\n        dateFromConfig(config);\n    }\n\n    function currentDateArray(config) {\n        var now = new Date();\n        if (config._useUTC) {\n            return [\n                now.getUTCFullYear(),\n                now.getUTCMonth(),\n                now.getUTCDate()\n            ];\n        } else {\n            return [now.getFullYear(), now.getMonth(), now.getDate()];\n        }\n    }\n\n    // date from string and format string\n    function makeDateFromStringAndFormat(config) {\n        if (config._f === moment.ISO_8601) {\n            parseISO(config);\n            return;\n        }\n\n        config._a = [];\n        config._pf.empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    config._pf.unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    config._pf.empty = false;\n                }\n                else {\n                    config._pf.unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                config._pf.unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        config._pf.charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            config._pf.unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {\n            config._pf.bigHour = undefined;\n        }\n        // handle am pm\n        if (config._isPm && config._a[HOUR] < 12) {\n            config._a[HOUR] += 12;\n        }\n        // if is 12 am, change hours to 0\n        if (config._isPm === false && config._a[HOUR] === 12) {\n            config._a[HOUR] = 0;\n        }\n        dateFromConfig(config);\n        checkOverflow(config);\n    }\n\n    function unescapeFormat(s) {\n        return s.replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        });\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function regexpEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    // date from string and array of format strings\n    function makeDateFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            config._pf.invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._pf = defaultParsingFlags();\n            tempConfig._f = config._f[i];\n            makeDateFromStringAndFormat(tempConfig);\n\n            if (!isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += tempConfig._pf.charsLeftOver;\n\n            //or tokens\n            currentScore += tempConfig._pf.unusedTokens.length * 10;\n\n            tempConfig._pf.score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    // date from iso format\n    function parseISO(config) {\n        var i, l,\n            string = config._i,\n            match = isoRegex.exec(string);\n\n        if (match) {\n            config._pf.iso = true;\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(string)) {\n                    // match[5] should be 'T' or undefined\n                    config._f = isoDates[i][0] + (match[6] || ' ');\n                    break;\n                }\n            }\n            for (i = 0, l = isoTimes.length; i < l; i++) {\n                if (isoTimes[i][1].exec(string)) {\n                    config._f += isoTimes[i][0];\n                    break;\n                }\n            }\n            if (string.match(parseTokenTimezone)) {\n                config._f += 'Z';\n            }\n            makeDateFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function makeDateFromString(config) {\n        parseISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n            moment.createFromInputFallback(config);\n        }\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function makeDateFromInput(config) {\n        var input = config._i, matched;\n        if (input === undefined) {\n            config._d = new Date();\n        } else if (isDate(input)) {\n            config._d = new Date(+input);\n        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {\n            config._d = new Date(+matched[1]);\n        } else if (typeof input === 'string') {\n            makeDateFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            dateFromConfig(config);\n        } else if (typeof(input) === 'object') {\n            dateFromObject(config);\n        } else if (typeof(input) === 'number') {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            moment.createFromInputFallback(config);\n        }\n    }\n\n    function makeDate(y, m, d, h, M, s, ms) {\n        //can't just apply() to create a date:\n        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        //the date constructor doesn't accept years < 1970\n        if (y < 1970) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function makeUTCDate(y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n        if (y < 1970) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n    function parseWeekday(input, locale) {\n        if (typeof input === 'string') {\n            if (!isNaN(input)) {\n                input = parseInt(input, 10);\n            }\n            else {\n                input = locale.weekdaysParse(input);\n                if (typeof input !== 'number') {\n                    return null;\n                }\n            }\n        }\n        return input;\n    }\n\n    /************************************\n        Relative Time\n    ************************************/\n\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime(posNegDuration, withoutSuffix, locale) {\n        var duration = moment.duration(posNegDuration).abs(),\n            seconds = round(duration.as('s')),\n            minutes = round(duration.as('m')),\n            hours = round(duration.as('h')),\n            days = round(duration.as('d')),\n            months = round(duration.as('M')),\n            years = round(duration.as('y')),\n\n            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||\n                minutes === 1 && ['m'] ||\n                minutes < relativeTimeThresholds.m && ['mm', minutes] ||\n                hours === 1 && ['h'] ||\n                hours < relativeTimeThresholds.h && ['hh', hours] ||\n                days === 1 && ['d'] ||\n                days < relativeTimeThresholds.d && ['dd', days] ||\n                months === 1 && ['M'] ||\n                months < relativeTimeThresholds.M && ['MM', months] ||\n                years === 1 && ['y'] || ['yy', years];\n\n        args[2] = withoutSuffix;\n        args[3] = +posNegDuration > 0;\n        args[4] = locale;\n        return substituteTimeAgo.apply({}, args);\n    }\n\n\n    /************************************\n        Week of Year\n    ************************************/\n\n\n    // firstDayOfWeek       0 = sun, 6 = sat\n    //                      the day of the week that starts the week\n    //                      (usually sunday or monday)\n    // firstDayOfWeekOfYear 0 = sun, 6 = sat\n    //                      the first week is the week that contains the first\n    //                      of this day of the week\n    //                      (eg. ISO weeks use thursday (4))\n    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {\n        var end = firstDayOfWeekOfYear - firstDayOfWeek,\n            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),\n            adjustedMoment;\n\n\n        if (daysToDayOfWeek > end) {\n            daysToDayOfWeek -= 7;\n        }\n\n        if (daysToDayOfWeek < end - 7) {\n            daysToDayOfWeek += 7;\n        }\n\n        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');\n        return {\n            week: Math.ceil(adjustedMoment.dayOfYear() / 7),\n            year: adjustedMoment.year()\n        };\n    }\n\n    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {\n        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;\n\n        d = d === 0 ? 7 : d;\n        weekday = weekday != null ? weekday : firstDayOfWeek;\n        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);\n        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;\n\n        return {\n            year: dayOfYear > 0 ? year : year - 1,\n            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear\n        };\n    }\n\n    /************************************\n        Top Level Functions\n    ************************************/\n\n    function makeMoment(config) {\n        var input = config._i,\n            format = config._f,\n            res;\n\n        config._locale = config._locale || moment.localeData(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return moment.invalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (moment.isMoment(input)) {\n            return new Moment(input, true);\n        } else if (format) {\n            if (isArray(format)) {\n                makeDateFromStringAndArray(config);\n            } else {\n                makeDateFromStringAndFormat(config);\n            }\n        } else {\n            makeDateFromInput(config);\n        }\n\n        res = new Moment(config);\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    moment = function (input, format, locale, strict) {\n        var c;\n\n        if (typeof(locale) === 'boolean') {\n            strict = locale;\n            locale = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c = {};\n        c._isAMomentObject = true;\n        c._i = input;\n        c._f = format;\n        c._l = locale;\n        c._strict = strict;\n        c._isUTC = false;\n        c._pf = defaultParsingFlags();\n\n        return makeMoment(c);\n    };\n\n    moment.suppressDeprecationWarnings = false;\n\n    moment.createFromInputFallback = deprecate(\n        'moment construction falls back to js Date. This is ' +\n        'discouraged and will be removed in upcoming major ' +\n        'release. Please refer to ' +\n        'https://github.com/moment/moment/issues/1407 for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return moment();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    moment.min = function () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    };\n\n    moment.max = function () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    };\n\n    // creating with utc\n    moment.utc = function (input, format, locale, strict) {\n        var c;\n\n        if (typeof(locale) === 'boolean') {\n            strict = locale;\n            locale = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c = {};\n        c._isAMomentObject = true;\n        c._useUTC = true;\n        c._isUTC = true;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n        c._pf = defaultParsingFlags();\n\n        return makeMoment(c).utc();\n    };\n\n    // creating with unix timestamp (in seconds)\n    moment.unix = function (input) {\n        return moment(input * 1000);\n    };\n\n    // duration\n    moment.duration = function (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            parseIso,\n            diffRes;\n\n        if (moment.isDuration(input)) {\n            duration = {\n                ms: input._milliseconds,\n                d: input._days,\n                M: input._months\n            };\n        } else if (typeof input === 'number') {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y: 0,\n                d: toInt(match[DATE]) * sign,\n                h: toInt(match[HOUR]) * sign,\n                m: toInt(match[MINUTE]) * sign,\n                s: toInt(match[SECOND]) * sign,\n                ms: toInt(match[MILLISECOND]) * sign\n            };\n        } else if (!!(match = isoDurationRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            parseIso = function (inp) {\n                // We'd normally use ~~inp for this, but unfortunately it also\n                // converts floats to ints.\n                // inp may be undefined, so careful calling replace on it.\n                var res = inp && parseFloat(inp.replace(',', '.'));\n                // apply sign while we're at it\n                return (isNaN(res) ? 0 : res) * sign;\n            };\n            duration = {\n                y: parseIso(match[2]),\n                M: parseIso(match[3]),\n                d: parseIso(match[4]),\n                h: parseIso(match[5]),\n                m: parseIso(match[6]),\n                s: parseIso(match[7]),\n                w: parseIso(match[8])\n            };\n        } else if (typeof duration === 'object' &&\n                ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(moment(duration.from), moment(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    };\n\n    // version number\n    moment.version = VERSION;\n\n    // default format\n    moment.defaultFormat = isoFormat;\n\n    // constant that refers to the ISO standard\n    moment.ISO_8601 = function () {};\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    moment.momentProperties = momentProperties;\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    moment.updateOffset = function () {};\n\n    // This function allows you to set a threshold for relative time strings\n    moment.relativeTimeThreshold = function (threshold, limit) {\n        if (relativeTimeThresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return relativeTimeThresholds[threshold];\n        }\n        relativeTimeThresholds[threshold] = limit;\n        return true;\n    };\n\n    moment.lang = deprecate(\n        'moment.lang is deprecated. Use moment.locale instead.',\n        function (key, value) {\n            return moment.locale(key, value);\n        }\n    );\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    moment.locale = function (key, values) {\n        var data;\n        if (key) {\n            if (typeof(values) !== 'undefined') {\n                data = moment.defineLocale(key, values);\n            }\n            else {\n                data = moment.localeData(key);\n            }\n\n            if (data) {\n                moment.duration._locale = moment._locale = data;\n            }\n        }\n\n        return moment._locale._abbr;\n    };\n\n    moment.defineLocale = function (name, values) {\n        if (values !== null) {\n            values.abbr = name;\n            if (!locales[name]) {\n                locales[name] = new Locale();\n            }\n            locales[name].set(values);\n\n            // backwards compat for now: also set the locale\n            moment.locale(name);\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    };\n\n    moment.langData = deprecate(\n        'moment.langData is deprecated. Use moment.localeData instead.',\n        function (key) {\n            return moment.localeData(key);\n        }\n    );\n\n    // returns locale data\n    moment.localeData = function (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return moment._locale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    };\n\n    // compare moment object\n    moment.isMoment = function (obj) {\n        return obj instanceof Moment ||\n            (obj != null && hasOwnProp(obj, '_isAMomentObject'));\n    };\n\n    // for typechecking Duration objects\n    moment.isDuration = function (obj) {\n        return obj instanceof Duration;\n    };\n\n    for (i = lists.length - 1; i >= 0; --i) {\n        makeList(lists[i]);\n    }\n\n    moment.normalizeUnits = function (units) {\n        return normalizeUnits(units);\n    };\n\n    moment.invalid = function (flags) {\n        var m = moment.utc(NaN);\n        if (flags != null) {\n            extend(m._pf, flags);\n        }\n        else {\n            m._pf.userInvalidated = true;\n        }\n\n        return m;\n    };\n\n    moment.parseZone = function () {\n        return moment.apply(null, arguments).parseZone();\n    };\n\n    moment.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    /************************************\n        Moment Prototype\n    ************************************/\n\n\n    extend(moment.fn = Moment.prototype, {\n\n        clone : function () {\n            return moment(this);\n        },\n\n        valueOf : function () {\n            return +this._d + ((this._offset || 0) * 60000);\n        },\n\n        unix : function () {\n            return Math.floor(+this / 1000);\n        },\n\n        toString : function () {\n            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n        },\n\n        toDate : function () {\n            return this._offset ? new Date(+this) : this._d;\n        },\n\n        toISOString : function () {\n            var m = moment(this).utc();\n            if (0 < m.year() && m.year() <= 9999) {\n                if ('function' === typeof Date.prototype.toISOString) {\n                    // native implementation is ~50x faster, use it when we can\n                    return this.toDate().toISOString();\n                } else {\n                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n                }\n            } else {\n                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n            }\n        },\n\n        toArray : function () {\n            var m = this;\n            return [\n                m.year(),\n                m.month(),\n                m.date(),\n                m.hours(),\n                m.minutes(),\n                m.seconds(),\n                m.milliseconds()\n            ];\n        },\n\n        isValid : function () {\n            return isValid(this);\n        },\n\n        isDSTShifted : function () {\n            if (this._a) {\n                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;\n            }\n\n            return false;\n        },\n\n        parsingFlags : function () {\n            return extend({}, this._pf);\n        },\n\n        invalidAt: function () {\n            return this._pf.overflow;\n        },\n\n        utc : function (keepLocalTime) {\n            return this.zone(0, keepLocalTime);\n        },\n\n        local : function (keepLocalTime) {\n            if (this._isUTC) {\n                this.zone(0, keepLocalTime);\n                this._isUTC = false;\n\n                if (keepLocalTime) {\n                    this.add(this._dateTzOffset(), 'm');\n                }\n            }\n            return this;\n        },\n\n        format : function (inputString) {\n            var output = formatMoment(this, inputString || moment.defaultFormat);\n            return this.localeData().postformat(output);\n        },\n\n        add : createAdder(1, 'add'),\n\n        subtract : createAdder(-1, 'subtract'),\n\n        diff : function (input, units, asFloat) {\n            var that = makeAs(input, this),\n                zoneDiff = (this.zone() - that.zone()) * 6e4,\n                diff, output, daysAdjust;\n\n            units = normalizeUnits(units);\n\n            if (units === 'year' || units === 'month') {\n                // average number of days in the months in the given dates\n                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2\n                // difference in months\n                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());\n                // adjust by taking difference in days, average number of days\n                // and dst in the given months.\n                daysAdjust = (this - moment(this).startOf('month')) -\n                    (that - moment(that).startOf('month'));\n                // same as above but with zones, to negate all dst\n                daysAdjust -= ((this.zone() - moment(this).startOf('month').zone()) -\n                        (that.zone() - moment(that).startOf('month').zone())) * 6e4;\n                output += daysAdjust / diff;\n                if (units === 'year') {\n                    output = output / 12;\n                }\n            } else {\n                diff = (this - that);\n                output = units === 'second' ? diff / 1e3 : // 1000\n                    units === 'minute' ? diff / 6e4 : // 1000 * 60\n                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60\n                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n                    diff;\n            }\n            return asFloat ? output : absRound(output);\n        },\n\n        from : function (time, withoutSuffix) {\n            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n        },\n\n        fromNow : function (withoutSuffix) {\n            return this.from(moment(), withoutSuffix);\n        },\n\n        calendar : function (time) {\n            // We want to compare the start of today, vs this.\n            // Getting start-of-today depends on whether we're zone'd or not.\n            var now = time || moment(),\n                sod = makeAs(now, this).startOf('day'),\n                diff = this.diff(sod, 'days', true),\n                format = diff < -6 ? 'sameElse' :\n                    diff < -1 ? 'lastWeek' :\n                    diff < 0 ? 'lastDay' :\n                    diff < 1 ? 'sameDay' :\n                    diff < 2 ? 'nextDay' :\n                    diff < 7 ? 'nextWeek' : 'sameElse';\n            return this.format(this.localeData().calendar(format, this, moment(now)));\n        },\n\n        isLeapYear : function () {\n            return isLeapYear(this.year());\n        },\n\n        isDST : function () {\n            return (this.zone() < this.clone().month(0).zone() ||\n                this.zone() < this.clone().month(5).zone());\n        },\n\n        day : function (input) {\n            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n            if (input != null) {\n                input = parseWeekday(input, this.localeData());\n                return this.add(input - day, 'd');\n            } else {\n                return day;\n            }\n        },\n\n        month : makeAccessor('Month', true),\n\n        startOf : function (units) {\n            units = normalizeUnits(units);\n            // the following switch intentionally omits break keywords\n            // to utilize falling through the cases.\n            switch (units) {\n            case 'year':\n                this.month(0);\n                /* falls through */\n            case 'quarter':\n            case 'month':\n                this.date(1);\n                /* falls through */\n            case 'week':\n            case 'isoWeek':\n            case 'day':\n                this.hours(0);\n                /* falls through */\n            case 'hour':\n                this.minutes(0);\n                /* falls through */\n            case 'minute':\n                this.seconds(0);\n                /* falls through */\n            case 'second':\n                this.milliseconds(0);\n                /* falls through */\n            }\n\n            // weeks are a special case\n            if (units === 'week') {\n                this.weekday(0);\n            } else if (units === 'isoWeek') {\n                this.isoWeekday(1);\n            }\n\n            // quarters are also special\n            if (units === 'quarter') {\n                this.month(Math.floor(this.month() / 3) * 3);\n            }\n\n            return this;\n        },\n\n        endOf: function (units) {\n            units = normalizeUnits(units);\n            if (units === undefined || units === 'millisecond') {\n                return this;\n            }\n            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n        },\n\n        isAfter: function (input, units) {\n            var inputMs;\n            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');\n            if (units === 'millisecond') {\n                input = moment.isMoment(input) ? input : moment(input);\n                return +this > +input;\n            } else {\n                inputMs = moment.isMoment(input) ? +input : +moment(input);\n                return inputMs < +this.clone().startOf(units);\n            }\n        },\n\n        isBefore: function (input, units) {\n            var inputMs;\n            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');\n            if (units === 'millisecond') {\n                input = moment.isMoment(input) ? input : moment(input);\n                return +this < +input;\n            } else {\n                inputMs = moment.isMoment(input) ? +input : +moment(input);\n                return +this.clone().endOf(units) < inputMs;\n            }\n        },\n\n        isSame: function (input, units) {\n            var inputMs;\n            units = normalizeUnits(units || 'millisecond');\n            if (units === 'millisecond') {\n                input = moment.isMoment(input) ? input : moment(input);\n                return +this === +input;\n            } else {\n                inputMs = +moment(input);\n                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));\n            }\n        },\n\n        min: deprecate(\n                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',\n                 function (other) {\n                     other = moment.apply(null, arguments);\n                     return other < this ? this : other;\n                 }\n         ),\n\n        max: deprecate(\n                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',\n                function (other) {\n                    other = moment.apply(null, arguments);\n                    return other > this ? this : other;\n                }\n        ),\n\n        // keepLocalTime = true means only change the timezone, without\n        // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->\n        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone\n        // +0200, so we adjust the time as needed, to be valid.\n        //\n        // Keeping the time actually adds/subtracts (one hour)\n        // from the actual represented time. That is why we call updateOffset\n        // a second time. In case it wants us to change the offset again\n        // _changeInProgress == true case, then we have to adjust, because\n        // there is no such time in the given timezone.\n        zone : function (input, keepLocalTime) {\n            var offset = this._offset || 0,\n                localAdjust;\n            if (input != null) {\n                if (typeof input === 'string') {\n                    input = timezoneMinutesFromString(input);\n                }\n                if (Math.abs(input) < 16) {\n                    input = input * 60;\n                }\n                if (!this._isUTC && keepLocalTime) {\n                    localAdjust = this._dateTzOffset();\n                }\n                this._offset = input;\n                this._isUTC = true;\n                if (localAdjust != null) {\n                    this.subtract(localAdjust, 'm');\n                }\n                if (offset !== input) {\n                    if (!keepLocalTime || this._changeInProgress) {\n                        addOrSubtractDurationFromMoment(this,\n                                moment.duration(offset - input, 'm'), 1, false);\n                    } else if (!this._changeInProgress) {\n                        this._changeInProgress = true;\n                        moment.updateOffset(this, true);\n                        this._changeInProgress = null;\n                    }\n                }\n            } else {\n                return this._isUTC ? offset : this._dateTzOffset();\n            }\n            return this;\n        },\n\n        zoneAbbr : function () {\n            return this._isUTC ? 'UTC' : '';\n        },\n\n        zoneName : function () {\n            return this._isUTC ? 'Coordinated Universal Time' : '';\n        },\n\n        parseZone : function () {\n            if (this._tzm) {\n                this.zone(this._tzm);\n            } else if (typeof this._i === 'string') {\n                this.zone(this._i);\n            }\n            return this;\n        },\n\n        hasAlignedHourOffset : function (input) {\n            if (!input) {\n                input = 0;\n            }\n            else {\n                input = moment(input).zone();\n            }\n\n            return (this.zone() - input) % 60 === 0;\n        },\n\n        daysInMonth : function () {\n            return daysInMonth(this.year(), this.month());\n        },\n\n        dayOfYear : function (input) {\n            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;\n            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n        },\n\n        quarter : function (input) {\n            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n        },\n\n        weekYear : function (input) {\n            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;\n            return input == null ? year : this.add((input - year), 'y');\n        },\n\n        isoWeekYear : function (input) {\n            var year = weekOfYear(this, 1, 4).year;\n            return input == null ? year : this.add((input - year), 'y');\n        },\n\n        week : function (input) {\n            var week = this.localeData().week(this);\n            return input == null ? week : this.add((input - week) * 7, 'd');\n        },\n\n        isoWeek : function (input) {\n            var week = weekOfYear(this, 1, 4).week;\n            return input == null ? week : this.add((input - week) * 7, 'd');\n        },\n\n        weekday : function (input) {\n            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n            return input == null ? weekday : this.add(input - weekday, 'd');\n        },\n\n        isoWeekday : function (input) {\n            // behaves the same as moment#day except\n            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n            // as a setter, sunday should belong to the previous week.\n            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);\n        },\n\n        isoWeeksInYear : function () {\n            return weeksInYear(this.year(), 1, 4);\n        },\n\n        weeksInYear : function () {\n            var weekInfo = this.localeData()._week;\n            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n        },\n\n        get : function (units) {\n            units = normalizeUnits(units);\n            return this[units]();\n        },\n\n        set : function (units, value) {\n            units = normalizeUnits(units);\n            if (typeof this[units] === 'function') {\n                this[units](value);\n            }\n            return this;\n        },\n\n        // If passed a locale key, it will set the locale for this\n        // instance.  Otherwise, it will return the locale configuration\n        // variables for this instance.\n        locale : function (key) {\n            var newLocaleData;\n\n            if (key === undefined) {\n                return this._locale._abbr;\n            } else {\n                newLocaleData = moment.localeData(key);\n                if (newLocaleData != null) {\n                    this._locale = newLocaleData;\n                }\n                return this;\n            }\n        },\n\n        lang : deprecate(\n            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n            function (key) {\n                if (key === undefined) {\n                    return this.localeData();\n                } else {\n                    return this.locale(key);\n                }\n            }\n        ),\n\n        localeData : function () {\n            return this._locale;\n        },\n\n        _dateTzOffset : function () {\n            // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n            // https://github.com/moment/moment/pull/1871\n            return Math.round(this._d.getTimezoneOffset() / 15) * 15;\n        }\n    });\n\n    function rawMonthSetter(mom, value) {\n        var dayOfMonth;\n\n        // TODO: Move this out of here!\n        if (typeof value === 'string') {\n            value = mom.localeData().monthsParse(value);\n            // TODO: Another silent failure?\n            if (typeof value !== 'number') {\n                return mom;\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(),\n                daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function rawGetter(mom, unit) {\n        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();\n    }\n\n    function rawSetter(mom, unit, value) {\n        if (unit === 'Month') {\n            return rawMonthSetter(mom, value);\n        } else {\n            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n        }\n    }\n\n    function makeAccessor(unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                rawSetter(this, unit, value);\n                moment.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return rawGetter(this, unit);\n            }\n        };\n    }\n\n    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);\n    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);\n    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour he wants. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);\n    // moment.fn.month is defined separately\n    moment.fn.date = makeAccessor('Date', true);\n    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));\n    moment.fn.year = makeAccessor('FullYear', true);\n    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));\n\n    // add plural methods\n    moment.fn.days = moment.fn.day;\n    moment.fn.months = moment.fn.month;\n    moment.fn.weeks = moment.fn.week;\n    moment.fn.isoWeeks = moment.fn.isoWeek;\n    moment.fn.quarters = moment.fn.quarter;\n\n    // add aliased format methods\n    moment.fn.toJSON = moment.fn.toISOString;\n\n    /************************************\n        Duration Prototype\n    ************************************/\n\n\n    function daysToYears (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        return days * 400 / 146097;\n    }\n\n    function yearsToDays (years) {\n        // years * 365 + absRound(years / 4) -\n        //     absRound(years / 100) + absRound(years / 400);\n        return years * 146097 / 400;\n    }\n\n    extend(moment.duration.fn = Duration.prototype, {\n\n        _bubble : function () {\n            var milliseconds = this._milliseconds,\n                days = this._days,\n                months = this._months,\n                data = this._data,\n                seconds, minutes, hours, years = 0;\n\n            // The following code bubbles up values, see the tests for\n            // examples of what that means.\n            data.milliseconds = milliseconds % 1000;\n\n            seconds = absRound(milliseconds / 1000);\n            data.seconds = seconds % 60;\n\n            minutes = absRound(seconds / 60);\n            data.minutes = minutes % 60;\n\n            hours = absRound(minutes / 60);\n            data.hours = hours % 24;\n\n            days += absRound(hours / 24);\n\n            // Accurately convert days to years, assume start from year 0.\n            years = absRound(daysToYears(days));\n            days -= absRound(yearsToDays(years));\n\n            // 30 days to a month\n            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.\n            months += absRound(days / 30);\n            days %= 30;\n\n            // 12 months -> 1 year\n            years += absRound(months / 12);\n            months %= 12;\n\n            data.days = days;\n            data.months = months;\n            data.years = years;\n        },\n\n        abs : function () {\n            this._milliseconds = Math.abs(this._milliseconds);\n            this._days = Math.abs(this._days);\n            this._months = Math.abs(this._months);\n\n            this._data.milliseconds = Math.abs(this._data.milliseconds);\n            this._data.seconds = Math.abs(this._data.seconds);\n            this._data.minutes = Math.abs(this._data.minutes);\n            this._data.hours = Math.abs(this._data.hours);\n            this._data.months = Math.abs(this._data.months);\n            this._data.years = Math.abs(this._data.years);\n\n            return this;\n        },\n\n        weeks : function () {\n            return absRound(this.days() / 7);\n        },\n\n        valueOf : function () {\n            return this._milliseconds +\n              this._days * 864e5 +\n              (this._months % 12) * 2592e6 +\n              toInt(this._months / 12) * 31536e6;\n        },\n\n        humanize : function (withSuffix) {\n            var output = relativeTime(this, !withSuffix, this.localeData());\n\n            if (withSuffix) {\n                output = this.localeData().pastFuture(+this, output);\n            }\n\n            return this.localeData().postformat(output);\n        },\n\n        add : function (input, val) {\n            // supports only 2.0-style add(1, 's') or add(moment)\n            var dur = moment.duration(input, val);\n\n            this._milliseconds += dur._milliseconds;\n            this._days += dur._days;\n            this._months += dur._months;\n\n            this._bubble();\n\n            return this;\n        },\n\n        subtract : function (input, val) {\n            var dur = moment.duration(input, val);\n\n            this._milliseconds -= dur._milliseconds;\n            this._days -= dur._days;\n            this._months -= dur._months;\n\n            this._bubble();\n\n            return this;\n        },\n\n        get : function (units) {\n            units = normalizeUnits(units);\n            return this[units.toLowerCase() + 's']();\n        },\n\n        as : function (units) {\n            var days, months;\n            units = normalizeUnits(units);\n\n            if (units === 'month' || units === 'year') {\n                days = this._days + this._milliseconds / 864e5;\n                months = this._months + daysToYears(days) * 12;\n                return units === 'month' ? months : months / 12;\n            } else {\n                // handle milliseconds separately because of floating point math errors (issue #1867)\n                days = this._days + Math.round(yearsToDays(this._months / 12));\n                switch (units) {\n                    case 'week': return days / 7 + this._milliseconds / 6048e5;\n                    case 'day': return days + this._milliseconds / 864e5;\n                    case 'hour': return days * 24 + this._milliseconds / 36e5;\n                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;\n                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;\n                    // Math.floor prevents floating point math errors here\n                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;\n                    default: throw new Error('Unknown unit ' + units);\n                }\n            }\n        },\n\n        lang : moment.fn.lang,\n        locale : moment.fn.locale,\n\n        toIsoString : deprecate(\n            'toIsoString() is deprecated. Please use toISOString() instead ' +\n            '(notice the capitals)',\n            function () {\n                return this.toISOString();\n            }\n        ),\n\n        toISOString : function () {\n            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n            var years = Math.abs(this.years()),\n                months = Math.abs(this.months()),\n                days = Math.abs(this.days()),\n                hours = Math.abs(this.hours()),\n                minutes = Math.abs(this.minutes()),\n                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);\n\n            if (!this.asSeconds()) {\n                // this is the same as C#'s (Noda) and python (isodate)...\n                // but not other JS (goog.date)\n                return 'P0D';\n            }\n\n            return (this.asSeconds() < 0 ? '-' : '') +\n                'P' +\n                (years ? years + 'Y' : '') +\n                (months ? months + 'M' : '') +\n                (days ? days + 'D' : '') +\n                ((hours || minutes || seconds) ? 'T' : '') +\n                (hours ? hours + 'H' : '') +\n                (minutes ? minutes + 'M' : '') +\n                (seconds ? seconds + 'S' : '');\n        },\n\n        localeData : function () {\n            return this._locale;\n        }\n    });\n\n    moment.duration.fn.toString = moment.duration.fn.toISOString;\n\n    function makeDurationGetter(name) {\n        moment.duration.fn[name] = function () {\n            return this._data[name];\n        };\n    }\n\n    for (i in unitMillisecondFactors) {\n        if (hasOwnProp(unitMillisecondFactors, i)) {\n            makeDurationGetter(i.toLowerCase());\n        }\n    }\n\n    moment.duration.fn.asMilliseconds = function () {\n        return this.as('ms');\n    };\n    moment.duration.fn.asSeconds = function () {\n        return this.as('s');\n    };\n    moment.duration.fn.asMinutes = function () {\n        return this.as('m');\n    };\n    moment.duration.fn.asHours = function () {\n        return this.as('h');\n    };\n    moment.duration.fn.asDays = function () {\n        return this.as('d');\n    };\n    moment.duration.fn.asWeeks = function () {\n        return this.as('weeks');\n    };\n    moment.duration.fn.asMonths = function () {\n        return this.as('M');\n    };\n    moment.duration.fn.asYears = function () {\n        return this.as('y');\n    };\n\n    /************************************\n        Default Locale\n    ************************************/\n\n\n    // Set default locale, other locale will inherit from English.\n    moment.locale('en', {\n        ordinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    /* EMBED_LOCALES */\n\n    /************************************\n        Exposing Moment\n    ************************************/\n\n    function makeGlobal(shouldDeprecate) {\n        /*global ender:false */\n        if (typeof ender !== 'undefined') {\n            return;\n        }\n        oldGlobalMoment = globalScope.moment;\n        if (shouldDeprecate) {\n            globalScope.moment = deprecate(\n                    'Accessing Moment through the global scope is ' +\n                    'deprecated, and will be removed in an upcoming ' +\n                    'release.',\n                    moment);\n        } else {\n            globalScope.moment = moment;\n        }\n    }\n\n    // CommonJS module is defined\n    if (hasModule) {\n        module.exports = moment;\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n            if (module.config && module.config() && module.config().noGlobal === true) {\n                // release the global variable\n                globalScope.moment = oldGlobalMoment;\n            }\n\n            return moment;\n        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        makeGlobal(true);\n    } else {\n        makeGlobal();\n    }\n}).call(this);\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(271)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvfi9tb21lbnQvbW9tZW50LmpzP2M5N2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImtDQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRkFBaUYsRUFBRTs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEtBQTBLLElBQUk7QUFDOUsscUVBQXFFLElBQUk7O0FBRXpFO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3Qyx3Q0FBd0MsSUFBSTtBQUM1Qyw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBLHFJQUFxSSxJQUFJO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJOztBQUVyRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QyxtQ0FBbUMsRUFBRTtBQUNyQyx1Q0FBdUMsRUFBRTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLEVBQUUsSUFBSSxFQUFFOztBQUUxQzs7QUFFQTtBQUNBLHFDQUFxQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDbkQsK0JBQStCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM3QyxpQ0FBaUMsRUFBRSxLQUFLLEVBQUU7QUFDMUMsK0JBQStCLEVBQUUsS0FBSyxFQUFFO0FBQ3hDLDZCQUE2QixFQUFFLElBQUksRUFBRTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsSUFBSTtBQUM3RixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEJBQTRCLElBQUk7O0FBRWhDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSw0QkFBNEI7QUFDNUIsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjguNFxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbihmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdGFudHNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgbW9tZW50LFxuICAgICAgICBWRVJTSU9OID0gJzIuOC40JyxcbiAgICAgICAgLy8gdGhlIGdsb2JhbC1zY29wZSB0aGlzIGlzIE5PVCB0aGUgZ2xvYmFsIG9iamVjdCBpbiBOb2RlLmpzXG4gICAgICAgIGdsb2JhbFNjb3BlID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0aGlzLFxuICAgICAgICBvbGRHbG9iYWxNb21lbnQsXG4gICAgICAgIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICBpLFxuXG4gICAgICAgIFlFQVIgPSAwLFxuICAgICAgICBNT05USCA9IDEsXG4gICAgICAgIERBVEUgPSAyLFxuICAgICAgICBIT1VSID0gMyxcbiAgICAgICAgTUlOVVRFID0gNCxcbiAgICAgICAgU0VDT05EID0gNSxcbiAgICAgICAgTUlMTElTRUNPTkQgPSA2LFxuXG4gICAgICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICAgICAgbG9jYWxlcyA9IHt9LFxuXG4gICAgICAgIC8vIGV4dHJhIG1vbWVudCBpbnRlcm5hbCBwcm9wZXJ0aWVzIChwbHVnaW5zIHJlZ2lzdGVyIHByb3BzIGhlcmUpXG4gICAgICAgIG1vbWVudFByb3BlcnRpZXMgPSBbXSxcblxuICAgICAgICAvLyBjaGVjayBmb3Igbm9kZUpTXG4gICAgICAgIGhhc01vZHVsZSA9ICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpLFxuXG4gICAgICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgICAgICBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pLFxuICAgICAgICBhc3BOZXRUaW1lU3Bhbkpzb25SZWdleCA9IC8oXFwtKT8oPzooXFxkKilcXC4pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKVxcLj8oXFxkezN9KT8pPy8sXG5cbiAgICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgICBpc29EdXJhdGlvblJlZ2V4ID0gL14oLSk/UCg/Oig/OihbMC05LC5dKilZKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKUQpPyg/OlQoPzooWzAtOSwuXSopSCk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilTKT8pP3woWzAtOSwuXSopVykkLyxcblxuICAgICAgICAvLyBmb3JtYXQgdG9rZW5zXG4gICAgICAgIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UXxZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xtbT98c3M/fFN7MSw0fXx4fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLFxuXG4gICAgICAgIC8vIHBhcnNpbmcgdG9rZW4gcmVnZXhlc1xuICAgICAgICBwYXJzZVRva2VuT25lT3JUd29EaWdpdHMgPSAvXFxkXFxkPy8sIC8vIDAgLSA5OVxuICAgICAgICBwYXJzZVRva2VuT25lVG9UaHJlZURpZ2l0cyA9IC9cXGR7MSwzfS8sIC8vIDAgLSA5OTlcbiAgICAgICAgcGFyc2VUb2tlbk9uZVRvRm91ckRpZ2l0cyA9IC9cXGR7MSw0fS8sIC8vIDAgLSA5OTk5XG4gICAgICAgIHBhcnNlVG9rZW5PbmVUb1NpeERpZ2l0cyA9IC9bK1xcLV0/XFxkezEsNn0vLCAvLyAtOTk5LDk5OSAtIDk5OSw5OTlcbiAgICAgICAgcGFyc2VUb2tlbkRpZ2l0cyA9IC9cXGQrLywgLy8gbm9uemVybyBudW1iZXIgb2YgZGlnaXRzXG4gICAgICAgIHBhcnNlVG9rZW5Xb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2ksIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgICAgICBwYXJzZVRva2VuVGltZXpvbmUgPSAvWnxbXFwrXFwtXVxcZFxcZDo/XFxkXFxkL2dpLCAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgcGFyc2VUb2tlblQgPSAvVC9pLCAvLyBUIChJU08gc2VwYXJhdG9yKVxuICAgICAgICBwYXJzZVRva2VuT2Zmc2V0TXMgPSAvW1xcK1xcLV0/XFxkKy8sIC8vIDEyMzQ1Njc4OTAxMjNcbiAgICAgICAgcGFyc2VUb2tlblRpbWVzdGFtcE1zID0gL1tcXCtcXC1dP1xcZCsoXFwuXFxkezEsM30pPy8sIC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAgICAgLy9zdHJpY3QgcGFyc2luZyByZWdleGVzXG4gICAgICAgIHBhcnNlVG9rZW5PbmVEaWdpdCA9IC9cXGQvLCAvLyAwIC0gOVxuICAgICAgICBwYXJzZVRva2VuVHdvRGlnaXRzID0gL1xcZFxcZC8sIC8vIDAwIC0gOTlcbiAgICAgICAgcGFyc2VUb2tlblRocmVlRGlnaXRzID0gL1xcZHszfS8sIC8vIDAwMCAtIDk5OVxuICAgICAgICBwYXJzZVRva2VuRm91ckRpZ2l0cyA9IC9cXGR7NH0vLCAvLyAwMDAwIC0gOTk5OVxuICAgICAgICBwYXJzZVRva2VuU2l4RGlnaXRzID0gL1srLV0/XFxkezZ9LywgLy8gLTk5OSw5OTkgLSA5OTksOTk5XG4gICAgICAgIHBhcnNlVG9rZW5TaWduZWROdW1iZXIgPSAvWystXT9cXGQrLywgLy8gLWluZiAtIGluZlxuXG4gICAgICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxuICAgICAgICBpc29SZWdleCA9IC9eXFxzKig/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyhbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG5cbiAgICAgICAgaXNvRm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJyxcblxuICAgICAgICBpc29EYXRlcyA9IFtcbiAgICAgICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkezJ9LVxcZHsyfS9dLFxuICAgICAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZHsyfS1cXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZHsyfS9dLFxuICAgICAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L11cbiAgICAgICAgXSxcblxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvKFR8IClcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIJywgLyhUfCApXFxkXFxkL11cbiAgICAgICAgXSxcblxuICAgICAgICAvLyB0aW1lem9uZSBjaHVua2VyICcrMTA6MDAnID4gWycxMCcsICcwMCddIG9yICctMTUzMCcgPiBbJy0xNScsICczMCddXG4gICAgICAgIHBhcnNlVGltZXpvbmVDaHVua2VyID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpLFxuXG4gICAgICAgIC8vIGdldHRlciBhbmQgc2V0dGVyIG5hbWVzXG4gICAgICAgIHByb3h5R2V0dGVyc0FuZFNldHRlcnMgPSAnRGF0ZXxIb3Vyc3xNaW51dGVzfFNlY29uZHN8TWlsbGlzZWNvbmRzJy5zcGxpdCgnfCcpLFxuICAgICAgICB1bml0TWlsbGlzZWNvbmRGYWN0b3JzID0ge1xuICAgICAgICAgICAgJ01pbGxpc2Vjb25kcycgOiAxLFxuICAgICAgICAgICAgJ1NlY29uZHMnIDogMWUzLFxuICAgICAgICAgICAgJ01pbnV0ZXMnIDogNmU0LFxuICAgICAgICAgICAgJ0hvdXJzJyA6IDM2ZTUsXG4gICAgICAgICAgICAnRGF5cycgOiA4NjRlNSxcbiAgICAgICAgICAgICdNb250aHMnIDogMjU5MmU2LFxuICAgICAgICAgICAgJ1llYXJzJyA6IDMxNTM2ZTZcbiAgICAgICAgfSxcblxuICAgICAgICB1bml0QWxpYXNlcyA9IHtcbiAgICAgICAgICAgIG1zIDogJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgIHMgOiAnc2Vjb25kJyxcbiAgICAgICAgICAgIG0gOiAnbWludXRlJyxcbiAgICAgICAgICAgIGggOiAnaG91cicsXG4gICAgICAgICAgICBkIDogJ2RheScsXG4gICAgICAgICAgICBEIDogJ2RhdGUnLFxuICAgICAgICAgICAgdyA6ICd3ZWVrJyxcbiAgICAgICAgICAgIFcgOiAnaXNvV2VlaycsXG4gICAgICAgICAgICBNIDogJ21vbnRoJyxcbiAgICAgICAgICAgIFEgOiAncXVhcnRlcicsXG4gICAgICAgICAgICB5IDogJ3llYXInLFxuICAgICAgICAgICAgREREIDogJ2RheU9mWWVhcicsXG4gICAgICAgICAgICBlIDogJ3dlZWtkYXknLFxuICAgICAgICAgICAgRSA6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgICAgIGdnOiAnd2Vla1llYXInLFxuICAgICAgICAgICAgR0c6ICdpc29XZWVrWWVhcidcbiAgICAgICAgfSxcblxuICAgICAgICBjYW1lbEZ1bmN0aW9ucyA9IHtcbiAgICAgICAgICAgIGRheW9meWVhciA6ICdkYXlPZlllYXInLFxuICAgICAgICAgICAgaXNvd2Vla2RheSA6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgICAgIGlzb3dlZWsgOiAnaXNvV2VlaycsXG4gICAgICAgICAgICB3ZWVreWVhciA6ICd3ZWVrWWVhcicsXG4gICAgICAgICAgICBpc293ZWVreWVhciA6ICdpc29XZWVrWWVhcidcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3JtYXQgZnVuY3Rpb24gc3RyaW5nc1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcblxuICAgICAgICAvLyBkZWZhdWx0IHJlbGF0aXZlIHRpbWUgdGhyZXNob2xkc1xuICAgICAgICByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzID0ge1xuICAgICAgICAgICAgczogNDUsICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgICAgIGg6IDIyLCAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgICAgICBkOiAyNiwgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB0b2tlbnMgdG8gb3JkaW5hbGl6ZSBhbmQgcGFkXG4gICAgICAgIG9yZGluYWxpemVUb2tlbnMgPSAnREREIHcgVyBNIEQgZCcuc3BsaXQoJyAnKSxcbiAgICAgICAgcGFkZGVkVG9rZW5zID0gJ00gRCBIIGggbSBzIHcgVycuc3BsaXQoJyAnKSxcblxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHtcbiAgICAgICAgICAgIE0gICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTU1NICA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBNTU1NIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBEICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBEREQgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGQgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGQgICA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZGQgIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGRkZCA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3ICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWsoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBXICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWsoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBZWSAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy55ZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFlZWVkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSwgNCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVlZWVkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSwgNSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVlZWVlZIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCksIHNpZ24gPSB5ID49IDAgPyAnKycgOiAnLSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyBsZWZ0WmVyb0ZpbGwoTWF0aC5hYnMoeSksIDYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdnICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLndlZWtZZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdnZ2cgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLndlZWtZZWFyKCksIDQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdnZ2dnIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy53ZWVrWWVhcigpLCA1KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBHRyAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5pc29XZWVrWWVhcigpICUgMTAwLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBHR0dHIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5pc29XZWVrWWVhcigpLCA0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBHR0dHRyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMuaXNvV2Vla1llYXIoKSwgNSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrZGF5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrZGF5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYSAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQSAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEggICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbnV0ZXMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0ludCh0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTUyAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodG9JbnQodGhpcy5taWxsaXNlY29uZHMoKSAvIDEwKSwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU1NTICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMubWlsbGlzZWNvbmRzKCksIDMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNTU1MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLm1pbGxpc2Vjb25kcygpLCAzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBaICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gLXRoaXMuem9uZSgpLFxuICAgICAgICAgICAgICAgICAgICBiID0gJysnO1xuICAgICAgICAgICAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhID0gLWE7XG4gICAgICAgICAgICAgICAgICAgIGIgPSAnLSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiICsgbGVmdFplcm9GaWxsKHRvSW50KGEgLyA2MCksIDIpICsgJzonICsgbGVmdFplcm9GaWxsKHRvSW50KGEpICUgNjAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFpaICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAtdGhpcy56b25lKCksXG4gICAgICAgICAgICAgICAgICAgIGIgPSAnKyc7XG4gICAgICAgICAgICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICAgICAgICAgICAgYiA9ICctJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSAvIDYwKSwgMikgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSkgJSA2MCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56b25lQWJicigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHp6IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnpvbmVOYW1lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bml4KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWFydGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVwcmVjYXRpb25zID0ge30sXG5cbiAgICAgICAgbGlzdHMgPSBbJ21vbnRocycsICdtb250aHNTaG9ydCcsICd3ZWVrZGF5cycsICd3ZWVrZGF5c1Nob3J0JywgJ3dlZWtkYXlzTWluJ107XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuIGRmbCBjb21lcyBmcm9tXG4gICAgLy8gZGVmYXVsdC5cbiAgICBmdW5jdGlvbiBkZmwoYSwgYiwgYykge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGEgIT0gbnVsbCA/IGEgOiBiO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gYSAhPSBudWxsID8gYSA6IGIgIT0gbnVsbCA/IGIgOiBjO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdJbXBsZW1lbnQgbWUnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QsIGFuZCBlczUgc3RhbmRhcmQgaXMgbm90IHZlcnlcbiAgICAgICAgLy8gaGVscGZ1bC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5IDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0IDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0IDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludE1zZyhtc2cpIHtcbiAgICAgICAgaWYgKG1vbWVudC5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICBwcmludE1zZyhtc2cpO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICBwcmludE1zZyhtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZFRva2VuKGZ1bmMsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbChmdW5jLmNhbGwodGhpcywgYSksIGNvdW50KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb3JkaW5hbGl6ZVRva2VuKGZ1bmMsIHBlcmlvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuY2FsbCh0aGlzLCBhKSwgcGVyaW9kKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB3aGlsZSAob3JkaW5hbGl6ZVRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgaSA9IG9yZGluYWxpemVUb2tlbnMucG9wKCk7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW2kgKyAnbyddID0gb3JkaW5hbGl6ZVRva2VuKGZvcm1hdFRva2VuRnVuY3Rpb25zW2ldLCBpKTtcbiAgICB9XG4gICAgd2hpbGUgKHBhZGRlZFRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgaSA9IHBhZGRlZFRva2Vucy5wb3AoKTtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbaSArIGldID0gcGFkVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnNbaV0sIDIpO1xuICAgIH1cbiAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucy5EREREID0gcGFkVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnMuRERELCAzKTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdHJ1Y3RvcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoKSB7XG4gICAgfVxuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnLCBza2lwT3ZlcmZsb3cpIHtcbiAgICAgICAgaWYgKHNraXBPdmVyZmxvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZSgrY29uZmlnLl9kKTtcbiAgICB9XG5cbiAgICAvLyBEdXJhdGlvbiBDb25zdHJ1Y3RvclxuICAgIGZ1bmN0aW9uIER1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMzZlNTsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbW9tZW50LmxvY2FsZURhdGEoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2lzQU1vbWVudE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9zdHJpY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fdHptICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2lzVVRDICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9vZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fcGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBmcm9tLl9wZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2xvY2FsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsZWZ0IHplcm8gZmlsbCBhIG51bWJlclxuICAgIC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9sZWZ0LXplcm8tZmlsbGluZyBmb3IgcGVyZm9ybWFuY2UgY29tcGFyaXNvblxuICAgIGZ1bmN0aW9uIGxlZnRaZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG5cbiAgICAgICAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIG90aGVyID0gbWFrZUFzKG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4nKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICBkdXIgPSBtb21lbnQuZHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkT3JTdWJ0cmFjdER1cmF0aW9uRnJvbU1vbWVudCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSBkdXJhdGlvbi5fbW9udGhzO1xuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUoK21vbS5fZCArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgcmF3U2V0dGVyKG1vbSwgJ0RhdGUnLCByYXdHZXR0ZXIobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICByYXdNb250aFNldHRlcihtb20sIHJhd0dldHRlcihtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBpcyBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXScgfHxcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIGlmICh1bml0cykge1xuICAgICAgICAgICAgdmFyIGxvd2VyZWQgPSB1bml0cy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyguKXMkLywgJyQxJyk7XG4gICAgICAgICAgICB1bml0cyA9IHVuaXRBbGlhc2VzW3VuaXRzXSB8fCBjYW1lbEZ1bmN0aW9uc1tsb3dlcmVkXSB8fCBsb3dlcmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bml0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlTGlzdChmaWVsZCkge1xuICAgICAgICB2YXIgY291bnQsIHNldHRlcjtcblxuICAgICAgICBpZiAoZmllbGQuaW5kZXhPZignd2VlaycpID09PSAwKSB7XG4gICAgICAgICAgICBjb3VudCA9IDc7XG4gICAgICAgICAgICBzZXR0ZXIgPSAnZGF5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZC5pbmRleE9mKCdtb250aCcpID09PSAwKSB7XG4gICAgICAgICAgICBjb3VudCA9IDEyO1xuICAgICAgICAgICAgc2V0dGVyID0gJ21vbnRoJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vbWVudFtmaWVsZF0gPSBmdW5jdGlvbiAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGksIGdldHRlcixcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBtb21lbnQuX2xvY2FsZVtmaWVsZF0sXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldHRlciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBtb21lbnQoKS51dGMoKS5zZXQoc2V0dGVyLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmNhbGwobW9tZW50Ll9sb2NhbGUsIG0sIGZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXIoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldHRlcihpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmNlaWwoY29lcmNlZE51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb21lbnQoW3llYXIsIDExLCAzMSArIGRvdyAtIGRveV0pLCBkb3csIGRveSkud2VlaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICBpZiAobS5fYSAmJiBtLl9wZi5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBtLl9hW01PTlRIXSA8IDAgfHwgbS5fYVtNT05USF0gPiAxMSA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBtLl9hW0RBVEVdIDwgMSB8fCBtLl9hW0RBVEVdID4gZGF5c0luTW9udGgobS5fYVtZRUFSXSwgbS5fYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgbS5fYVtIT1VSXSA8IDAgfHwgbS5fYVtIT1VSXSA+IDI0IHx8XG4gICAgICAgICAgICAgICAgICAgIChtLl9hW0hPVVJdID09PSAyNCAmJiAobS5fYVtNSU5VVEVdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5fYVtTRUNPTkRdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5fYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIG0uX2FbTUlOVVRFXSA8IDAgfHwgbS5fYVtNSU5VVEVdID4gNTkgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIG0uX2FbU0VDT05EXSA8IDAgfHwgbS5fYVtTRUNPTkRdID4gNTkgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIG0uX2FbTUlMTElTRUNPTkRdIDwgMCB8fCBtLl9hW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKG0uX3BmLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0uX3BmLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBtLl9wZi5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLnVzZXJJbnZhbGlkYXRlZDtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBtLl9pc1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIG0uX3BmLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbS5fcGYudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBtLl9wZi5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgaGFzTW9kdWxlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IG1vbWVudC5sb2NhbGUoKTtcbiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBkZWZpbmVMb2NhbGUgY3VycmVudGx5IGFsc28gc2V0cyB0aGUgZ2xvYmFsIGxvY2FsZSwgd2Ugd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICBtb21lbnQubG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIG1ha2VBcyhpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAobW9tZW50LmlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID9cbiAgICAgICAgICAgICAgICAgICAgK2lucHV0IDogK21vbWVudChpbnB1dCkpIC0gKCtyZXMpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUoK3Jlcy5fZCArIGRpZmYpO1xuICAgICAgICAgICAgbW9tZW50LnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBMb2NhbGVcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGV4dGVuZChMb2NhbGUucHJvdG90eXBlLCB7XG5cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9vcmRpbmFsUGFyc2VMZW5pZW50LlxuICAgICAgICAgICAgdGhpcy5fb3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAodGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSArICd8JyArIC9cXGR7MSwyfS8uc291cmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfbW9udGhzIDogJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRocyA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzW20ubW9udGgoKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb250aHNQYXJzZSA6IGZ1bmN0aW9uIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgICAgIG1vbSA9IG1vbWVudC51dGMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF93ZWVrZGF5cyA6ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzW20uZGF5KCldO1xuICAgICAgICB9LFxuXG4gICAgICAgIF93ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrZGF5c1BhcnNlIDogZnVuY3Rpb24gKHdlZWtkYXlOYW1lKSB7XG4gICAgICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbSA9IG1vbWVudChbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVFMgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgICAgIExUIDogJ2g6bW0gQScsXG4gICAgICAgICAgICBMIDogJ01NL0REL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdNTU1NIEQsIFlZWVkgTFQnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgTFQnXG4gICAgICAgIH0sXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgICAgICAgICBpZiAoIW91dHB1dCAmJiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV0ucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9tZXJpZGllbVBhcnNlIDogL1thcF1cXC4/bT9cXC4/L2ksXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDogZnVuY3Rpb24gKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicgPyBvdXRwdXQuYXBwbHkobW9tLCBbbm93XSkgOiBvdXRwdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIGFnbycsXG4gICAgICAgICAgICBzIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICAgICAgbSA6ICdhIG1pbnV0ZScsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgICAgIGggOiAnYW4gaG91cicsXG4gICAgICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgICAgICBkIDogJ2EgZGF5JyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICAgICAgTSA6ICdhIG1vbnRoJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgICAgICB5IDogJ2EgeWVhcicsXG4gICAgICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICAgICAgfSxcblxuICAgICAgICByZWxhdGl2ZVRpbWUgOiBmdW5jdGlvbiAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFzdEZ1dHVyZSA6IGZ1bmN0aW9uIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJyA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgX29yZGluYWwgOiAnJWQnLFxuICAgICAgICBfb3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9LyxcblxuICAgICAgICBwcmVwYXJzZSA6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zdGZvcm1hdCA6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2VlayA6IGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgICAgICB9LFxuXG4gICAgICAgIF93ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2ludmFsaWREYXRlOiAnSW52YWxpZCBkYXRlJyxcbiAgICAgICAgaW52YWxpZERhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGb3JtYXR0aW5nXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG5cbiAgICAgICAgaWYgKCFmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSkge1xuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFBhcnNpbmdcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIGdldCB0aGUgcmVnZXggdG8gZmluZCB0aGUgbmV4dCB0b2tlblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIHZhciBhLCBzdHJpY3QgPSBjb25maWcuX3N0cmljdDtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lRGlnaXQ7XG4gICAgICAgIGNhc2UgJ0REREQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaHJlZURpZ2l0cztcbiAgICAgICAgY2FzZSAnWVlZWSc6XG4gICAgICAgIGNhc2UgJ0dHR0cnOlxuICAgICAgICBjYXNlICdnZ2dnJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuRm91ckRpZ2l0cyA6IHBhcnNlVG9rZW5PbmVUb0ZvdXJEaWdpdHM7XG4gICAgICAgIGNhc2UgJ1knOlxuICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblNpZ25lZE51bWJlcjtcbiAgICAgICAgY2FzZSAnWVlZWVlZJzpcbiAgICAgICAgY2FzZSAnWVlZWVknOlxuICAgICAgICBjYXNlICdHR0dHRyc6XG4gICAgICAgIGNhc2UgJ2dnZ2dnJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuU2l4RGlnaXRzIDogcGFyc2VUb2tlbk9uZVRvU2l4RGlnaXRzO1xuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbk9uZURpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdTUyc6XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5Ud29EaWdpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ1NTUyc6XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaHJlZURpZ2l0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnREREJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lVG9UaHJlZURpZ2l0cztcbiAgICAgICAgY2FzZSAnTU1NJzpcbiAgICAgICAgY2FzZSAnTU1NTSc6XG4gICAgICAgIGNhc2UgJ2RkJzpcbiAgICAgICAgY2FzZSAnZGRkJzpcbiAgICAgICAgY2FzZSAnZGRkZCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbldvcmQ7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuX2xvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbk9mZnNldE1zO1xuICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGltZXN0YW1wTXM7XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICBjYXNlICdaWic6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRpbWV6b25lO1xuICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVDtcbiAgICAgICAgY2FzZSAnU1NTUyc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbkRpZ2l0cztcbiAgICAgICAgY2FzZSAnTU0nOlxuICAgICAgICBjYXNlICdERCc6XG4gICAgICAgIGNhc2UgJ1lZJzpcbiAgICAgICAgY2FzZSAnR0cnOlxuICAgICAgICBjYXNlICdnZyc6XG4gICAgICAgIGNhc2UgJ0hIJzpcbiAgICAgICAgY2FzZSAnaGgnOlxuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgIGNhc2UgJ3NzJzpcbiAgICAgICAgY2FzZSAnd3cnOlxuICAgICAgICBjYXNlICdXVyc6XG4gICAgICAgICAgICByZXR1cm4gc3RyaWN0ID8gcGFyc2VUb2tlblR3b0RpZ2l0cyA6IHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cztcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cztcbiAgICAgICAgY2FzZSAnRG8nOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IGNvbmZpZy5fbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBjb25maWcuX2xvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICBhID0gbmV3IFJlZ0V4cChyZWdleHBFc2NhcGUodW5lc2NhcGVGb3JtYXQodG9rZW4ucmVwbGFjZSgnXFxcXCcsICcnKSksICdpJykpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lem9uZU1pbnV0ZXNGcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcgfHwgJyc7XG4gICAgICAgIHZhciBwb3NzaWJsZVR6TWF0Y2hlcyA9IChzdHJpbmcubWF0Y2gocGFyc2VUb2tlblRpbWV6b25lKSB8fCBbXSksXG4gICAgICAgICAgICB0ekNodW5rID0gcG9zc2libGVUek1hdGNoZXNbcG9zc2libGVUek1hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW10sXG4gICAgICAgICAgICBwYXJ0cyA9ICh0ekNodW5rICsgJycpLm1hdGNoKHBhcnNlVGltZXpvbmVDaHVua2VyKSB8fCBbJy0nLCAwLCAwXSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gJysnID8gLW1pbnV0ZXMgOiBtaW51dGVzO1xuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIHRvIGNvbnZlcnQgc3RyaW5nIGlucHV0IHRvIGRhdGVcbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICB2YXIgYSwgZGF0ZVBhcnRBcnJheSA9IGNvbmZpZy5fYTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIFFVQVJURVJcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNT05USFxuICAgICAgICBjYXNlICdNJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBNTVxuICAgICAgICBjYXNlICdNTScgOlxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTU1NJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBNTU1NXG4gICAgICAgIGNhc2UgJ01NTU0nIDpcbiAgICAgICAgICAgIGEgPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTU9OVEhdID0gYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBEQVkgT0YgTU9OVEhcbiAgICAgICAgY2FzZSAnRCcgOiAvLyBmYWxsIHRocm91Z2ggdG8gRERcbiAgICAgICAgY2FzZSAnREQnIDpcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtEQVRFXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdEbycgOlxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W0RBVEVdID0gdG9JbnQocGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQubWF0Y2goL1xcZHsxLDJ9LylbMF0sIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gREFZIE9GIFlFQVJcbiAgICAgICAgY2FzZSAnREREJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBEREREXG4gICAgICAgIGNhc2UgJ0REREQnIDpcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBZRUFSXG4gICAgICAgIGNhc2UgJ1lZJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W1lFQVJdID0gbW9tZW50LnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdZWVlZJyA6XG4gICAgICAgIGNhc2UgJ1lZWVlZJyA6XG4gICAgICAgIGNhc2UgJ1lZWVlZWScgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtZRUFSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBTSAvIFBNXG4gICAgICAgIGNhc2UgJ2EnIDogLy8gZmFsbCB0aHJvdWdoIHRvIEFcbiAgICAgICAgY2FzZSAnQScgOlxuICAgICAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSE9VUlxuICAgICAgICBjYXNlICdoJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBoaFxuICAgICAgICBjYXNlICdoaCcgOlxuICAgICAgICAgICAgY29uZmlnLl9wZi5iaWdIb3VyID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnSCcgOiAvLyBmYWxsIHRocm91Z2ggdG8gSEhcbiAgICAgICAgY2FzZSAnSEgnIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gTUlOVVRFXG4gICAgICAgIGNhc2UgJ20nIDogLy8gZmFsbCB0aHJvdWdoIHRvIG1tXG4gICAgICAgIGNhc2UgJ21tJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU0VDT05EXG4gICAgICAgIGNhc2UgJ3MnIDogLy8gZmFsbCB0aHJvdWdoIHRvIHNzXG4gICAgICAgIGNhc2UgJ3NzJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gTUlMTElTRUNPTkRcbiAgICAgICAgY2FzZSAnUycgOlxuICAgICAgICBjYXNlICdTUycgOlxuICAgICAgICBjYXNlICdTU1MnIDpcbiAgICAgICAgY2FzZSAnU1NTUycgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFVOSVggT0ZGU0VUIChNSUxMSVNFQ09ORFMpXG4gICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBVTklYIFRJTUVTVEFNUCBXSVRIIE1TXG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUSU1FWk9ORVxuICAgICAgICBjYXNlICdaJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBaWlxuICAgICAgICBjYXNlICdaWicgOlxuICAgICAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSB0aW1lem9uZU1pbnV0ZXNGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBXRUVLREFZIC0gaHVtYW5cbiAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICBjYXNlICdkZGQnOlxuICAgICAgICBjYXNlICdkZGRkJzpcbiAgICAgICAgICAgIGEgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25maWcuX3dbJ2QnXSA9IGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBXRUVLLCBXRUVLIERBWSAtIG51bWVyaWNcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgIGNhc2UgJ3d3JzpcbiAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgIGNhc2UgJ1dXJzpcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4uc3Vic3RyKDAsIDEpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdnZ2dnJzpcbiAgICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICAgIGNhc2UgJ0dHR0dHJzpcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4uc3Vic3RyKDAsIDIpO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fd1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZ2cnOlxuICAgICAgICBjYXNlICdHRyc6XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjb25maWcuX3dbdG9rZW5dID0gbW9tZW50LnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcDtcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRmbCh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobW9tZW50KCksIDEsIDQpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRmbCh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRmbCh3LkUsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRmbCh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobW9tZW50KCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZmwody53LCAxKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IGRvdykge1xuICAgICAgICAgICAgICAgICAgICArK3dlZWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG95LCBkb3cpO1xuXG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGRhdGVGcm9tQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRmbChjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gbWFrZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gbWFrZVVUQ0RhdGUgOiBtYWtlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB6b25lIGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSArIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF0ZUZyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQ7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gW1xuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LnllYXIsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQubW9udGgsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQuZGF5IHx8IG5vcm1hbGl6ZWRJbnB1dC5kYXRlLFxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LmhvdXIsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQubWludXRlLFxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LnNlY29uZCxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZFxuICAgICAgICBdO1xuXG4gICAgICAgIGRhdGVGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDRGF0ZSgpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gbW9tZW50LklTT184NjAxKSB7XG4gICAgICAgICAgICBwYXJzZUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGNvbmZpZy5fcGYuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGNvbmZpZy5fcGYuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9wZi51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoY29uZmlnLl9wZi5iaWdIb3VyID09PSB0cnVlICYmIGNvbmZpZy5fYVtIT1VSXSA8PSAxMikge1xuICAgICAgICAgICAgY29uZmlnLl9wZi5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBhbSBwbVxuICAgICAgICBpZiAoY29uZmlnLl9pc1BtICYmIGNvbmZpZy5fYVtIT1VSXSA8IDEyKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgaXMgMTIgYW0sIGNoYW5nZSBob3VycyB0byAwXG4gICAgICAgIGlmIChjb25maWcuX2lzUG0gPT09IGZhbHNlICYmIGNvbmZpZy5fYVtIT1VSXSA9PT0gMTIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHJlZ2V4cEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gbWFrZURhdGVGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IHRlbXBDb25maWcuX3BmLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gdGVtcENvbmZpZy5fcGYudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9wZi5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBwYXJzZUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoc3RyaW5nKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fcGYuaXNvID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzVdIHNob3VsZCBiZSAnVCcgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fZiA9IGlzb0RhdGVzW2ldWzBdICsgKG1hdGNoWzZdIHx8ICcgJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fZiArPSBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaChwYXJzZVRva2VuVGltZXpvbmUpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9mICs9ICdaJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIG1ha2VEYXRlRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgcGFyc2VJU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICBtb21lbnQuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLCBtYXRjaGVkO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgraW5wdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGVGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRhdGVGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb21lbnQuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgZG9lc24ndCBhY2NlcHQgeWVhcnMgPCAxOTcwXG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgUmVsYXRpdmUgVGltZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpLFxuICAgICAgICAgICAgc2Vjb25kcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpLFxuICAgICAgICAgICAgbWludXRlcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpLFxuICAgICAgICAgICAgaG91cnMgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKSxcbiAgICAgICAgICAgIGRheXMgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKSxcbiAgICAgICAgICAgIG1vbnRocyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpLFxuICAgICAgICAgICAgeWVhcnMgPSByb3VuZChkdXJhdGlvbi5hcygneScpKSxcblxuICAgICAgICAgICAgYXJncyA9IHNlY29uZHMgPCByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzLnMgJiYgWydzJywgc2Vjb25kc10gfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzID09PSAxICYmIFsnbSddIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHJlbGF0aXZlVGltZVRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyA9PT0gMSAmJiBbJ2gnXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzIDwgcmVsYXRpdmVUaW1lVGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10gfHxcbiAgICAgICAgICAgICAgICBkYXlzID09PSAxICYmIFsnZCddIHx8XG4gICAgICAgICAgICAgICAgZGF5cyA8IHJlbGF0aXZlVGltZVRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10gfHxcbiAgICAgICAgICAgICAgICBtb250aHMgPT09IDEgJiYgWydNJ10gfHxcbiAgICAgICAgICAgICAgICBtb250aHMgPCByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gfHxcbiAgICAgICAgICAgICAgICB5ZWFycyA9PT0gMSAmJiBbJ3knXSB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFyZ3NbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhcmdzWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYXJnc1s0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KHt9LCBhcmdzKTtcbiAgICB9XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgV2VlayBvZiBZZWFyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBmaXJzdERheU9mV2VlayAgICAgICAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGRheSBvZiB0aGUgd2VlayB0aGF0IHN0YXJ0cyB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICh1c3VhbGx5IHN1bmRheSBvciBtb25kYXkpXG4gICAgLy8gZmlyc3REYXlPZldlZWtPZlllYXIgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCB3ZWVrIGlzIHRoZSB3ZWVrIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgb2YgdGhpcyBkYXkgb2YgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAoZWcuIElTTyB3ZWVrcyB1c2UgdGh1cnNkYXkgKDQpKVxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBmaXJzdERheU9mV2VlaywgZmlyc3REYXlPZldlZWtPZlllYXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gZmlyc3REYXlPZldlZWssXG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIG1vbS5kYXkoKSxcbiAgICAgICAgICAgIGFkanVzdGVkTW9tZW50O1xuXG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA+IGVuZCkge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrIC09IDc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrIDwgZW5kIC0gNykge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RlZE1vbWVudCA9IG1vbWVudChtb20pLmFkZChkYXlzVG9EYXlPZldlZWssICdkJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiBNYXRoLmNlaWwoYWRqdXN0ZWRNb21lbnQuZGF5T2ZZZWFyKCkgLyA3KSxcbiAgICAgICAgICAgIHllYXI6IGFkanVzdGVkTW9tZW50LnllYXIoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBmaXJzdERheU9mV2Vla09mWWVhciwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgdmFyIGQgPSBtYWtlVVRDRGF0ZSh5ZWFyLCAwLCAxKS5nZXRVVENEYXkoKSwgZGF5c1RvQWRkLCBkYXlPZlllYXI7XG5cbiAgICAgICAgZCA9IGQgPT09IDAgPyA3IDogZDtcbiAgICAgICAgd2Vla2RheSA9IHdlZWtkYXkgIT0gbnVsbCA/IHdlZWtkYXkgOiBmaXJzdERheU9mV2VlaztcbiAgICAgICAgZGF5c1RvQWRkID0gZmlyc3REYXlPZldlZWsgLSBkICsgKGQgPiBmaXJzdERheU9mV2Vla09mWWVhciA/IDcgOiAwKSAtIChkIDwgZmlyc3REYXlPZldlZWsgPyA3IDogMCk7XG4gICAgICAgIGRheU9mWWVhciA9IDcgKiAod2VlayAtIDEpICsgKHdlZWtkYXkgLSBmaXJzdERheU9mV2VlaykgKyBkYXlzVG9BZGQgKyAxO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiBkYXlPZlllYXIgPiAwID8geWVhciA6IHllYXIgLSAxLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiBkYXlPZlllYXIgPiAwID8gIGRheU9mWWVhciA6IGRheXNJblllYXIoeWVhciAtIDEpICsgZGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBUb3AgTGV2ZWwgRnVuY3Rpb25zXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gbWFrZU1vbWVudChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mLFxuICAgICAgICAgICAgcmVzO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbW9tZW50LmxvY2FsZURhdGEoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuaW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoaW5wdXQsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFrZURhdGVGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyA9IG5ldyBNb21lbnQoY29uZmlnKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIG1vbWVudCA9IGZ1bmN0aW9uIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICB2YXIgYztcblxuICAgICAgICBpZiAodHlwZW9mKGxvY2FsZSkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjID0ge307XG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBjLl9pc1VUQyA9IGZhbHNlO1xuICAgICAgICBjLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcblxuICAgICAgICByZXR1cm4gbWFrZU1vbWVudChjKTtcbiAgICB9O1xuXG4gICAgbW9tZW50LnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuXG4gICAgbW9tZW50LmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUuIFRoaXMgaXMgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHVwY29taW5nIG1ham9yICcgK1xuICAgICAgICAncmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MDcgZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIG1vbWVudC5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfTtcblxuICAgIG1vbWVudC5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgLy8gY3JlYXRpbmcgd2l0aCB1dGNcbiAgICBtb21lbnQudXRjID0gZnVuY3Rpb24gKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBjO1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMgPSB7fTtcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgYy5faXNVVEMgPSB0cnVlO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYy5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG5cbiAgICAgICAgcmV0dXJuIG1ha2VNb21lbnQoYykudXRjKCk7XG4gICAgfTtcblxuICAgIC8vIGNyZWF0aW5nIHdpdGggdW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpXG4gICAgbW9tZW50LnVuaXggPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChpbnB1dCAqIDEwMDApO1xuICAgIH07XG5cbiAgICAvLyBkdXJhdGlvblxuICAgIG1vbWVudC5kdXJhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBwYXJzZUlzbyxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXM6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTTogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRUaW1lU3Bhbkpzb25SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIGQ6IHRvSW50KG1hdGNoW0RBVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaDogdG9JbnQobWF0Y2hbSE9VUl0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtOiB0b0ludChtYXRjaFtNSU5VVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgczogdG9JbnQobWF0Y2hbU0VDT05EXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb0R1cmF0aW9uUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgcGFyc2VJc28gPSBmdW5jdGlvbiAoaW5wKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICAgICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiBwYXJzZUlzbyhtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgTTogcGFyc2VJc28obWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzRdKSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUlzbyhtYXRjaFs1XSksXG4gICAgICAgICAgICAgICAgbTogcGFyc2VJc28obWF0Y2hbNl0pLFxuICAgICAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzddKSxcbiAgICAgICAgICAgICAgICB3OiBwYXJzZUlzbyhtYXRjaFs4XSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShtb21lbnQoZHVyYXRpb24uZnJvbSksIG1vbWVudChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvLyB2ZXJzaW9uIG51bWJlclxuICAgIG1vbWVudC52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIC8vIGRlZmF1bHQgZm9ybWF0XG4gICAgbW9tZW50LmRlZmF1bHRGb3JtYXQgPSBpc29Gb3JtYXQ7XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgbW9tZW50LklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICBtb21lbnQubW9tZW50UHJvcGVydGllcyA9IG1vbWVudFByb3BlcnRpZXM7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgbW9tZW50LnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgbW9tZW50LnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGZ1bmN0aW9uICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZVRpbWVUaHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVsYXRpdmVUaW1lVGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF0aXZlVGltZVRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgbW9tZW50LmxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmxvY2FsZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgbW9tZW50LmxvY2FsZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZih2YWx1ZXMpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtb21lbnQuZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtb21lbnQubG9jYWxlRGF0YShrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vbWVudC5fbG9jYWxlLl9hYmJyO1xuICAgIH07XG5cbiAgICBtb21lbnQuZGVmaW5lTG9jYWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXS5zZXQodmFsdWVzKTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBtb21lbnQubG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb21lbnQubGFuZ0RhdGEgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5sb2NhbGVEYXRhKGtleSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIG1vbWVudC5sb2NhbGVEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH07XG5cbiAgICAvLyBjb21wYXJlIG1vbWVudCBvYmplY3RcbiAgICBtb21lbnQuaXNNb21lbnQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHxcbiAgICAgICAgICAgIChvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wKG9iaiwgJ19pc0FNb21lbnRPYmplY3QnKSk7XG4gICAgfTtcblxuICAgIC8vIGZvciB0eXBlY2hlY2tpbmcgRHVyYXRpb24gb2JqZWN0c1xuICAgIG1vbWVudC5pc0R1cmF0aW9uID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfTtcblxuICAgIGZvciAoaSA9IGxpc3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1ha2VMaXN0KGxpc3RzW2ldKTtcbiAgICB9XG5cbiAgICBtb21lbnQubm9ybWFsaXplVW5pdHMgPSBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICB9O1xuXG4gICAgbW9tZW50LmludmFsaWQgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBtb21lbnQudXRjKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQobS5fcGYsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG0uX3BmLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuXG4gICAgbW9tZW50LnBhcnNlWm9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH07XG5cbiAgICBtb21lbnQucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBNb21lbnQgUHJvdG90eXBlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBleHRlbmQobW9tZW50LmZuID0gTW9tZW50LnByb3RvdHlwZSwge1xuXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZU9mIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLl9kICsgKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5peCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCt0aGlzIC8gMTAwMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9EYXRlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCA/IG5ldyBEYXRlKCt0aGlzKSA6IHRoaXMuX2Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9JU09TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IG1vbWVudCh0aGlzKS51dGMoKTtcbiAgICAgICAgICAgIGlmICgwIDwgbS55ZWFyKCkgJiYgbS55ZWFyKCkgPD0gOTk5OSkge1xuICAgICAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b0FycmF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBtLnllYXIoKSxcbiAgICAgICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgbS5kYXRlKCksXG4gICAgICAgICAgICAgICAgbS5ob3VycygpLFxuICAgICAgICAgICAgICAgIG0ubWludXRlcygpLFxuICAgICAgICAgICAgICAgIG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgICAgIG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNWYWxpZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRFNUU2hpZnRlZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpICYmIGNvbXBhcmVBcnJheXModGhpcy5fYSwgKHRoaXMuX2lzVVRDID8gbW9tZW50LnV0Yyh0aGlzLl9hKSA6IG1vbWVudCh0aGlzLl9hKSkudG9BcnJheSgpKSA+IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzaW5nRmxhZ3MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCB0aGlzLl9wZik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW52YWxpZEF0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGYub3ZlcmZsb3c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXRjIDogZnVuY3Rpb24gKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnpvbmUoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9jYWwgOiBmdW5jdGlvbiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZCh0aGlzLl9kYXRlVHpPZmZzZXQoKSwgJ20nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXQgOiBmdW5jdGlvbiAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcgfHwgbW9tZW50LmRlZmF1bHRGb3JtYXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQgOiBjcmVhdGVBZGRlcigxLCAnYWRkJyksXG5cbiAgICAgICAgc3VidHJhY3QgOiBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0JyksXG5cbiAgICAgICAgZGlmZiA6IGZ1bmN0aW9uIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gbWFrZUFzKGlucHV0LCB0aGlzKSxcbiAgICAgICAgICAgICAgICB6b25lRGlmZiA9ICh0aGlzLnpvbmUoKSAtIHRoYXQuem9uZSgpKSAqIDZlNCxcbiAgICAgICAgICAgICAgICBkaWZmLCBvdXRwdXQsIGRheXNBZGp1c3Q7XG5cbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgIC8vIGF2ZXJhZ2UgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRocyBpbiB0aGUgZ2l2ZW4gZGF0ZXNcbiAgICAgICAgICAgICAgICBkaWZmID0gKHRoaXMuZGF5c0luTW9udGgoKSArIHRoYXQuZGF5c0luTW9udGgoKSkgKiA0MzJlNTsgLy8gMjQgKiA2MCAqIDYwICogMTAwMCAvIDJcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICAgICAgICAgIG91dHB1dCA9ICgodGhpcy55ZWFyKCkgLSB0aGF0LnllYXIoKSkgKiAxMikgKyAodGhpcy5tb250aCgpIC0gdGhhdC5tb250aCgpKTtcbiAgICAgICAgICAgICAgICAvLyBhZGp1c3QgYnkgdGFraW5nIGRpZmZlcmVuY2UgaW4gZGF5cywgYXZlcmFnZSBudW1iZXIgb2YgZGF5c1xuICAgICAgICAgICAgICAgIC8vIGFuZCBkc3QgaW4gdGhlIGdpdmVuIG1vbnRocy5cbiAgICAgICAgICAgICAgICBkYXlzQWRqdXN0ID0gKHRoaXMgLSBtb21lbnQodGhpcykuc3RhcnRPZignbW9udGgnKSkgLVxuICAgICAgICAgICAgICAgICAgICAodGhhdCAtIG1vbWVudCh0aGF0KS5zdGFydE9mKCdtb250aCcpKTtcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aXRoIHpvbmVzLCB0byBuZWdhdGUgYWxsIGRzdFxuICAgICAgICAgICAgICAgIGRheXNBZGp1c3QgLT0gKCh0aGlzLnpvbmUoKSAtIG1vbWVudCh0aGlzKS5zdGFydE9mKCdtb250aCcpLnpvbmUoKSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoYXQuem9uZSgpIC0gbW9tZW50KHRoYXQpLnN0YXJ0T2YoJ21vbnRoJykuem9uZSgpKSkgKiA2ZTQ7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGRheXNBZGp1c3QgLyBkaWZmO1xuICAgICAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDEyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9ICh0aGlzIC0gdGhhdCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGlmZiAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGlmZiAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGlmZiAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGlmZiAtIHpvbmVEaWZmKSAvIDg2NGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRpZmYgLSB6b25lRGlmZikgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgICAgICBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNSb3VuZChvdXRwdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZyb20gOiBmdW5jdGlvbiAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZyb21Ob3cgOiBmdW5jdGlvbiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShtb21lbnQoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsZW5kYXIgOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIHpvbmUnZCBvciBub3QuXG4gICAgICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBtb21lbnQoKSxcbiAgICAgICAgICAgICAgICBzb2QgPSBtYWtlQXMobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQodGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBtb21lbnQobm93KSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzTGVhcFllYXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNEU1QgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuem9uZSgpIDwgdGhpcy5jbG9uZSgpLm1vbnRoKDApLnpvbmUoKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuem9uZSgpIDwgdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnpvbmUoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF5IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW9udGggOiBtYWtlQWNjZXNzb3IoJ01vbnRoJywgdHJ1ZSksXG5cbiAgICAgICAgc3RhcnRPZiA6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kT2Y6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0FmdGVyOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG1vbWVudC5pc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IG1vbWVudChpbnB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICt0aGlzID4gK2lucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dE1zID0gbW9tZW50LmlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICttb21lbnQoaW5wdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dE1zIDwgK3RoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc0JlZm9yZTogZnVuY3Rpb24gKGlucHV0LCB1bml0cykge1xuICAgICAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBtb21lbnQuaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBtb21lbnQoaW5wdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiArdGhpcyA8ICtpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRNcyA9IG1vbWVudC5pc01vbWVudChpbnB1dCkgPyAraW5wdXQgOiArbW9tZW50KGlucHV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gK3RoaXMuY2xvbmUoKS5lbmRPZih1bml0cykgPCBpbnB1dE1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzU2FtZTogZnVuY3Rpb24gKGlucHV0LCB1bml0cykge1xuICAgICAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBtb21lbnQuaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBtb21lbnQoaW5wdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiArdGhpcyA9PT0gK2lucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dE1zID0gK21vbWVudChpbnB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICsodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gKyh0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IGRlcHJlY2F0ZShcbiAgICAgICAgICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSBtb21lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICksXG5cbiAgICAgICAgbWF4OiBkZXByZWNhdGUoXG4gICAgICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyID0gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICApLFxuXG4gICAgICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgICAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bem9uZSgyLCB0cnVlKV0tLT5cbiAgICAgICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCBpbnQgem9uZVxuICAgICAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgICAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAgICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgICAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICAgICAgem9uZSA6IGZ1bmN0aW9uIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IHRpbWV6b25lTWludXRlc0Zyb21TdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSB0aGlzLl9kYXRlVHpPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudC5kdXJhdGlvbihvZmZzZXQgLSBpbnB1dCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogdGhpcy5fZGF0ZVR6T2Zmc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB6b25lQWJiciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgem9uZU5hbWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2Vab25lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZSh0aGlzLl90em0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUodGhpcy5faSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNBbGlnbmVkSG91ck9mZnNldCA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gbW9tZW50KGlucHV0KS56b25lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAodGhpcy56b25lKCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXlzSW5Nb250aCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXlPZlllYXIgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkYXlPZlllYXIgPSByb3VuZCgobW9tZW50KHRoaXMpLnN0YXJ0T2YoJ2RheScpIC0gbW9tZW50KHRoaXMpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHF1YXJ0ZXIgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrWWVhciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KS55ZWFyO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvV2Vla1llYXIgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS55ZWFyO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2VlayA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzb1dlZWsgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWtkYXkgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvV2Vla2RheSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gdGhpcy5kYXkoKSB8fCA3IDogdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyBpbnB1dCA6IGlucHV0IC0gNyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvV2Vla3NJblllYXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWtzSW5ZZWFyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbdW5pdHNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgICAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgbG9jYWxlIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBtb21lbnQubG9jYWxlRGF0YShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGFuZyA6IGRlcHJlY2F0ZShcbiAgICAgICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICAgICAgbG9jYWxlRGF0YSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RhdGVUek9mZnNldCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByYXdNb250aFNldHRlcihtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBvdXQgb2YgaGVyZSFcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksXG4gICAgICAgICAgICAgICAgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByYXdHZXR0ZXIobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByYXdTZXR0ZXIobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ01vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHJhd01vbnRoU2V0dGVyKG1vbSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQWNjZXNzb3IodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByYXdTZXR0ZXIodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3R2V0dGVyKHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vbWVudC5mbi5taWxsaXNlY29uZCA9IG1vbWVudC5mbi5taWxsaXNlY29uZHMgPSBtYWtlQWNjZXNzb3IoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcbiAgICBtb21lbnQuZm4uc2Vjb25kID0gbW9tZW50LmZuLnNlY29uZHMgPSBtYWtlQWNjZXNzb3IoJ1NlY29uZHMnLCBmYWxzZSk7XG4gICAgbW9tZW50LmZuLm1pbnV0ZSA9IG1vbWVudC5mbi5taW51dGVzID0gbWFrZUFjY2Vzc29yKCdNaW51dGVzJywgZmFsc2UpO1xuICAgIC8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIGhlIHdhbnRzLiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgbW9tZW50LmZuLmhvdXIgPSBtb21lbnQuZm4uaG91cnMgPSBtYWtlQWNjZXNzb3IoJ0hvdXJzJywgdHJ1ZSk7XG4gICAgLy8gbW9tZW50LmZuLm1vbnRoIGlzIGRlZmluZWQgc2VwYXJhdGVseVxuICAgIG1vbWVudC5mbi5kYXRlID0gbWFrZUFjY2Vzc29yKCdEYXRlJywgdHJ1ZSk7XG4gICAgbW9tZW50LmZuLmRhdGVzID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIG1ha2VBY2Nlc3NvcignRGF0ZScsIHRydWUpKTtcbiAgICBtb21lbnQuZm4ueWVhciA9IG1ha2VBY2Nlc3NvcignRnVsbFllYXInLCB0cnVlKTtcbiAgICBtb21lbnQuZm4ueWVhcnMgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQuJywgbWFrZUFjY2Vzc29yKCdGdWxsWWVhcicsIHRydWUpKTtcblxuICAgIC8vIGFkZCBwbHVyYWwgbWV0aG9kc1xuICAgIG1vbWVudC5mbi5kYXlzID0gbW9tZW50LmZuLmRheTtcbiAgICBtb21lbnQuZm4ubW9udGhzID0gbW9tZW50LmZuLm1vbnRoO1xuICAgIG1vbWVudC5mbi53ZWVrcyA9IG1vbWVudC5mbi53ZWVrO1xuICAgIG1vbWVudC5mbi5pc29XZWVrcyA9IG1vbWVudC5mbi5pc29XZWVrO1xuICAgIG1vbWVudC5mbi5xdWFydGVycyA9IG1vbWVudC5mbi5xdWFydGVyO1xuXG4gICAgLy8gYWRkIGFsaWFzZWQgZm9ybWF0IG1ldGhvZHNcbiAgICBtb21lbnQuZm4udG9KU09OID0gbW9tZW50LmZuLnRvSVNPU3RyaW5nO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBEdXJhdGlvbiBQcm90b3R5cGVcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGZ1bmN0aW9uIGRheXNUb1llYXJzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgcmV0dXJuIGRheXMgKiA0MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geWVhcnNUb0RheXMgKHllYXJzKSB7XG4gICAgICAgIC8vIHllYXJzICogMzY1ICsgYWJzUm91bmQoeWVhcnMgLyA0KSAtXG4gICAgICAgIC8vICAgICBhYnNSb3VuZCh5ZWFycyAvIDEwMCkgKyBhYnNSb3VuZCh5ZWFycyAvIDQwMCk7XG4gICAgICAgIHJldHVybiB5ZWFycyAqIDE0NjA5NyAvIDQwMDtcbiAgICB9XG5cbiAgICBleHRlbmQobW9tZW50LmR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlLCB7XG5cbiAgICAgICAgX2J1YmJsZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXG4gICAgICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgICAgICAgICAgIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycyA9IDA7XG5cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICAgICAgc2Vjb25kcyA9IGFic1JvdW5kKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICAgICAgZGF0YS5zZWNvbmRzID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgICAgICBtaW51dGVzID0gYWJzUm91bmQoc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICAgICAgaG91cnMgPSBhYnNSb3VuZChtaW51dGVzIC8gNjApO1xuICAgICAgICAgICAgZGF0YS5ob3VycyA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgICAgIGRheXMgKz0gYWJzUm91bmQoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgICAgIC8vIEFjY3VyYXRlbHkgY29udmVydCBkYXlzIHRvIHllYXJzLCBhc3N1bWUgc3RhcnQgZnJvbSB5ZWFyIDAuXG4gICAgICAgICAgICB5ZWFycyA9IGFic1JvdW5kKGRheXNUb1llYXJzKGRheXMpKTtcbiAgICAgICAgICAgIGRheXMgLT0gYWJzUm91bmQoeWVhcnNUb0RheXMoeWVhcnMpKTtcblxuICAgICAgICAgICAgLy8gMzAgZGF5cyB0byBhIG1vbnRoXG4gICAgICAgICAgICAvLyBUT0RPIChpc2tyZW4pOiBVc2UgYW5jaG9yIGRhdGUgKGxpa2UgMXN0IEphbikgdG8gY29tcHV0ZSB0aGlzLlxuICAgICAgICAgICAgbW9udGhzICs9IGFic1JvdW5kKGRheXMgLyAzMCk7XG4gICAgICAgICAgICBkYXlzICU9IDMwO1xuXG4gICAgICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgICAgICB5ZWFycyArPSBhYnNSb3VuZChtb250aHMgLyAxMik7XG4gICAgICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgICAgIGRhdGEuZGF5cyA9IGRheXM7XG4gICAgICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcbiAgICAgICAgfSxcblxuICAgICAgICBhYnMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBNYXRoLmFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICAgICAgdGhpcy5fZGF5cyA9IE1hdGguYWJzKHRoaXMuX2RheXMpO1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzID0gTWF0aC5hYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICAgICAgdGhpcy5fZGF0YS5taWxsaXNlY29uZHMgPSBNYXRoLmFicyh0aGlzLl9kYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhLnNlY29uZHMgPSBNYXRoLmFicyh0aGlzLl9kYXRhLnNlY29uZHMpO1xuICAgICAgICAgICAgdGhpcy5fZGF0YS5taW51dGVzID0gTWF0aC5hYnModGhpcy5fZGF0YS5taW51dGVzKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuaG91cnMgPSBNYXRoLmFicyh0aGlzLl9kYXRhLmhvdXJzKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEubW9udGhzID0gTWF0aC5hYnModGhpcy5fZGF0YS5tb250aHMpO1xuICAgICAgICAgICAgdGhpcy5fZGF0YS55ZWFycyA9IE1hdGguYWJzKHRoaXMuX2RhdGEueWVhcnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhYnNSb3VuZCh0aGlzLmRheXMoKSAvIDcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHVtYW5pemUgOiBmdW5jdGlvbiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSh0aGlzLCAhd2l0aFN1ZmZpeCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuXG4gICAgICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMubG9jYWxlRGF0YSgpLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGlucHV0LCB2YWwpIHtcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChtb21lbnQpXG4gICAgICAgICAgICB2YXIgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlucHV0LCB2YWwpO1xuXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgKz0gZHVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgICAgICB0aGlzLl9kYXlzICs9IGR1ci5fZGF5cztcbiAgICAgICAgICAgIHRoaXMuX21vbnRocyArPSBkdXIuX21vbnRocztcblxuICAgICAgICAgICAgdGhpcy5fYnViYmxlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1YnRyYWN0IDogZnVuY3Rpb24gKGlucHV0LCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBkdXIgPSBtb21lbnQuZHVyYXRpb24oaW5wdXQsIHZhbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyAtPSBkdXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHRoaXMuX2RheXMgLT0gZHVyLl9kYXlzO1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzIC09IGR1ci5fbW9udGhzO1xuXG4gICAgICAgICAgICB0aGlzLl9idWJibGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IDogZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzLnRvTG93ZXJDYXNlKCkgKyAncyddKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXMgOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHZhciBkYXlzLCBtb250aHM7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIHRoaXMuX21pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb1llYXJzKGRheXMpICogMTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQoeWVhcnNUb0RheXModGhpcy5fbW9udGhzIC8gMTIpKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOiByZXR1cm4gZGF5cyAvIDcgKyB0aGlzLl9taWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RheSc6IHJldHVybiBkYXlzICsgdGhpcy5fbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOiByZXR1cm4gZGF5cyAqIDI0ICsgdGhpcy5fbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzogcmV0dXJuIGRheXMgKiAyNCAqIDYwICsgdGhpcy5fbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnOiByZXR1cm4gZGF5cyAqIDI0ICogNjAgKiA2MCArIHRoaXMuX21pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSArIHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGFuZyA6IG1vbWVudC5mbi5sYW5nLFxuICAgICAgICBsb2NhbGUgOiBtb21lbnQuZm4ubG9jYWxlLFxuXG4gICAgICAgIHRvSXNvU3RyaW5nIDogZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgJyArXG4gICAgICAgICAgICAnKG5vdGljZSB0aGUgY2FwaXRhbHMpJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICApLFxuXG4gICAgICAgIHRvSVNPU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgICAgIHZhciB5ZWFycyA9IE1hdGguYWJzKHRoaXMueWVhcnMoKSksXG4gICAgICAgICAgICAgICAgbW9udGhzID0gTWF0aC5hYnModGhpcy5tb250aHMoKSksXG4gICAgICAgICAgICAgICAgZGF5cyA9IE1hdGguYWJzKHRoaXMuZGF5cygpKSxcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGguYWJzKHRoaXMuaG91cnMoKSksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguYWJzKHRoaXMubWludXRlcygpKSxcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5hYnModGhpcy5zZWNvbmRzKCkgKyB0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTAwMCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5hc1NlY29uZHMoKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuYXNTZWNvbmRzKCkgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgICAgICh5ZWFycyA/IHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgICAgICAgICAobW9udGhzID8gbW9udGhzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgICAgICAoZGF5cyA/IGRheXMgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgICAgICgoaG91cnMgfHwgbWludXRlcyB8fCBzZWNvbmRzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKGhvdXJzID8gaG91cnMgKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgICAgIChtaW51dGVzID8gbWludXRlcyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPyBzZWNvbmRzICsgJ1MnIDogJycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvY2FsZURhdGEgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb21lbnQuZHVyYXRpb24uZm4udG9TdHJpbmcgPSBtb21lbnQuZHVyYXRpb24uZm4udG9JU09TdHJpbmc7XG5cbiAgICBmdW5jdGlvbiBtYWtlRHVyYXRpb25HZXR0ZXIobmFtZSkge1xuICAgICAgICBtb21lbnQuZHVyYXRpb24uZm5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKGkgaW4gdW5pdE1pbGxpc2Vjb25kRmFjdG9ycykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcCh1bml0TWlsbGlzZWNvbmRGYWN0b3JzLCBpKSkge1xuICAgICAgICAgICAgbWFrZUR1cmF0aW9uR2V0dGVyKGkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb21lbnQuZHVyYXRpb24uZm4uYXNNaWxsaXNlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzKCdtcycpO1xuICAgIH07XG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzU2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ3MnKTtcbiAgICB9O1xuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc01pbnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzKCdtJyk7XG4gICAgfTtcbiAgICBtb21lbnQuZHVyYXRpb24uZm4uYXNIb3VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ2gnKTtcbiAgICB9O1xuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc0RheXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzKCdkJyk7XG4gICAgfTtcbiAgICBtb21lbnQuZHVyYXRpb24uZm4uYXNXZWVrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ3dlZWtzJyk7XG4gICAgfTtcbiAgICBtb21lbnQuZHVyYXRpb24uZm4uYXNNb250aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzKCdNJyk7XG4gICAgfTtcbiAgICBtb21lbnQuZHVyYXRpb24uZm4uYXNZZWFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ3knKTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBEZWZhdWx0IExvY2FsZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gU2V0IGRlZmF1bHQgbG9jYWxlLCBvdGhlciBsb2NhbGUgd2lsbCBpbmhlcml0IGZyb20gRW5nbGlzaC5cbiAgICBtb21lbnQubG9jYWxlKCdlbicsIHtcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIEVNQkVEX0xPQ0FMRVMgKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRXhwb3NpbmcgTW9tZW50XG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gbWFrZUdsb2JhbChzaG91bGREZXByZWNhdGUpIHtcbiAgICAgICAgLypnbG9iYWwgZW5kZXI6ZmFsc2UgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbGRHbG9iYWxNb21lbnQgPSBnbG9iYWxTY29wZS5tb21lbnQ7XG4gICAgICAgIGlmIChzaG91bGREZXByZWNhdGUpIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlLm1vbWVudCA9IGRlcHJlY2F0ZShcbiAgICAgICAgICAgICAgICAgICAgJ0FjY2Vzc2luZyBNb21lbnQgdGhyb3VnaCB0aGUgZ2xvYmFsIHNjb3BlIGlzICcgK1xuICAgICAgICAgICAgICAgICAgICAnZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3JlbGVhc2UuJyxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlLm1vbWVudCA9IG1vbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbW1vbkpTIG1vZHVsZSBpcyBkZWZpbmVkXG4gICAgaWYgKGhhc01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1vbWVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ21vbWVudCcsIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuY29uZmlnICYmIG1vZHVsZS5jb25maWcoKSAmJiBtb2R1bGUuY29uZmlnKCkubm9HbG9iYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyByZWxlYXNlIHRoZSBnbG9iYWwgdmFyaWFibGVcbiAgICAgICAgICAgICAgICBnbG9iYWxTY29wZS5tb21lbnQgPSBvbGRHbG9iYWxNb21lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtb21lbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBtYWtlR2xvYmFsKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1ha2VHbG9iYWwoKTtcbiAgICB9XG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvfi9tb21lbnQvbW9tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 271:
/***/ (function(module, exports) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjcxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDI3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 272:
/***/ (function(module, exports, __webpack_require__) {

	eval("var map = {\n\t\"./de\": \"contrib/moment/lang/de\",\n\t\"./de.js\": \"contrib/moment/lang/de\",\n\t\"./en-debug\": \"contrib/moment/lang/en-debug\",\n\t\"./en-debug.js\": \"contrib/moment/lang/en-debug\",\n\t\"./en-gb\": \"contrib/moment/lang/en-gb\",\n\t\"./en-gb.js\": \"contrib/moment/lang/en-gb\",\n\t\"./en-us\": \"contrib/moment/lang/en-us\",\n\t\"./en-us.js\": \"contrib/moment/lang/en-us\",\n\t\"./fr\": \"contrib/moment/lang/fr\",\n\t\"./fr.js\": \"contrib/moment/lang/fr\",\n\t\"./it\": \"contrib/moment/lang/it\",\n\t\"./it.js\": \"contrib/moment/lang/it\",\n\t\"./ja\": \"contrib/moment/lang/ja\",\n\t\"./ja.js\": \"contrib/moment/lang/ja\",\n\t\"./ko\": \"contrib/moment/lang/ko\",\n\t\"./ko.js\": \"contrib/moment/lang/ko\",\n\t\"./zh-cn\": \"contrib/moment/lang/zh-cn\",\n\t\"./zh-cn.js\": \"contrib/moment/lang/zh-cn\",\n\t\"./zh-tw\": \"contrib/moment/lang/zh-tw\",\n\t\"./zh-tw.js\": \"contrib/moment/lang/zh-tw\"\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 272;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcgXlxcLlxcLy4qJD8zYjUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdURBQXVEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI3Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBtYXAgPSB7XG5cdFwiLi9kZVwiOiBcImNvbnRyaWIvbW9tZW50L2xhbmcvZGVcIixcblx0XCIuL2RlLmpzXCI6IFwiY29udHJpYi9tb21lbnQvbGFuZy9kZVwiLFxuXHRcIi4vZW4tZGVidWdcIjogXCJjb250cmliL21vbWVudC9sYW5nL2VuLWRlYnVnXCIsXG5cdFwiLi9lbi1kZWJ1Zy5qc1wiOiBcImNvbnRyaWIvbW9tZW50L2xhbmcvZW4tZGVidWdcIixcblx0XCIuL2VuLWdiXCI6IFwiY29udHJpYi9tb21lbnQvbGFuZy9lbi1nYlwiLFxuXHRcIi4vZW4tZ2IuanNcIjogXCJjb250cmliL21vbWVudC9sYW5nL2VuLWdiXCIsXG5cdFwiLi9lbi11c1wiOiBcImNvbnRyaWIvbW9tZW50L2xhbmcvZW4tdXNcIixcblx0XCIuL2VuLXVzLmpzXCI6IFwiY29udHJpYi9tb21lbnQvbGFuZy9lbi11c1wiLFxuXHRcIi4vZnJcIjogXCJjb250cmliL21vbWVudC9sYW5nL2ZyXCIsXG5cdFwiLi9mci5qc1wiOiBcImNvbnRyaWIvbW9tZW50L2xhbmcvZnJcIixcblx0XCIuL2l0XCI6IFwiY29udHJpYi9tb21lbnQvbGFuZy9pdFwiLFxuXHRcIi4vaXQuanNcIjogXCJjb250cmliL21vbWVudC9sYW5nL2l0XCIsXG5cdFwiLi9qYVwiOiBcImNvbnRyaWIvbW9tZW50L2xhbmcvamFcIixcblx0XCIuL2phLmpzXCI6IFwiY29udHJpYi9tb21lbnQvbGFuZy9qYVwiLFxuXHRcIi4va29cIjogXCJjb250cmliL21vbWVudC9sYW5nL2tvXCIsXG5cdFwiLi9rby5qc1wiOiBcImNvbnRyaWIvbW9tZW50L2xhbmcva29cIixcblx0XCIuL3poLWNuXCI6IFwiY29udHJpYi9tb21lbnQvbGFuZy96aC1jblwiLFxuXHRcIi4vemgtY24uanNcIjogXCJjb250cmliL21vbWVudC9sYW5nL3poLWNuXCIsXG5cdFwiLi96aC10d1wiOiBcImNvbnRyaWIvbW9tZW50L2xhbmcvemgtdHdcIixcblx0XCIuL3poLXR3LmpzXCI6IFwiY29udHJpYi9tb21lbnQvbGFuZy96aC10d1wiXG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHJldHVybiBtYXBbcmVxXSB8fCAoZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpIH0oKSk7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDI3MjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL21vbWVudC9sYW5nIF5cXC5cXC8uKiRcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/moment/lang/de":
/***/ (function(module, exports, __webpack_require__) {

	eval("// moment.js locale configuration\n// locale : german (de)\n// author : lluchs : https://github.com/lluchs\n// author: Menelion Elensúle: https://github.com/Oire\n\nfunction processRelativeTime(number, withoutSuffix, key, isFuture) {\n    var format = {\n        'm': ['eine Minute', 'einer Minute'],\n        'h': ['eine Stunde', 'einer Stunde'],\n        'd': ['ein Tag', 'einem Tag'],\n        'dd': [number + ' Tage', number + ' Tagen'],\n        'M': ['ein Monat', 'einem Monat'],\n        'MM': [number + ' Monate', number + ' Monaten'],\n        'y': ['ein Jahr', 'einem Jahr'],\n        'yy': [number + ' Jahre', number + ' Jahren']\n    };\n    return withoutSuffix ? format[key][0] : format[key][1];\n}\n\n__webpack_require__(270).defineLocale('de', {\n    months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n    monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),\n    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n    longDateFormat : {\n        LT: 'HH:mm [Uhr]',\n        L : 'DD.MM.YYYY',\n        LL : 'D. MMMM YYYY',\n        LLL : 'D. MMMM YYYY LT',\n        LLLL : 'dddd, D. MMMM YYYY LT'\n    },\n    calendar : {\n        sameDay: '[Heute um] LT',\n        sameElse: 'L',\n        nextDay: '[Morgen um] LT',\n        nextWeek: 'dddd [um] LT',\n        lastDay: '[Gestern um] LT',\n        lastWeek: '[letzten] dddd [um] LT'\n    },\n    relativeTime : {\n        future : 'in %s',\n        past : 'vor %s',\n        s : 'ein paar Sekunden',\n        m : processRelativeTime,\n        mm : '%d Minuten',\n        h : processRelativeTime,\n        hh : '%d Stunden',\n        d : processRelativeTime,\n        dd : processRelativeTime,\n        M : processRelativeTime,\n        MM : processRelativeTime,\n        y : processRelativeTime,\n        yy : processRelativeTime\n    },\n    ordinalParse: /\\d{1,2}\\./,\n    ordinal : '%d.',\n    week : {\n        dow : 1, // Monday is the first day of the week.\n        doy : 4  // The week that contains Jan 4th is the first week of the year.\n    }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvZGUuanM/YWRkMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJjb250cmliL21vbWVudC9sYW5nL2RlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyBsb2NhbGUgOiBnZXJtYW4gKGRlKVxuLy8gYXV0aG9yIDogbGx1Y2hzIDogaHR0cHM6Ly9naXRodWIuY29tL2xsdWNoc1xuLy8gYXV0aG9yOiBNZW5lbGlvbiBFbGVuc8O6bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9PaXJlXG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgdmFyIGZvcm1hdCA9IHtcbiAgICAgICAgJ20nOiBbJ2VpbmUgTWludXRlJywgJ2VpbmVyIE1pbnV0ZSddLFxuICAgICAgICAnaCc6IFsnZWluZSBTdHVuZGUnLCAnZWluZXIgU3R1bmRlJ10sXG4gICAgICAgICdkJzogWydlaW4gVGFnJywgJ2VpbmVtIFRhZyddLFxuICAgICAgICAnZGQnOiBbbnVtYmVyICsgJyBUYWdlJywgbnVtYmVyICsgJyBUYWdlbiddLFxuICAgICAgICAnTSc6IFsnZWluIE1vbmF0JywgJ2VpbmVtIE1vbmF0J10sXG4gICAgICAgICdNTSc6IFtudW1iZXIgKyAnIE1vbmF0ZScsIG51bWJlciArICcgTW9uYXRlbiddLFxuICAgICAgICAneSc6IFsnZWluIEphaHInLCAnZWluZW0gSmFociddLFxuICAgICAgICAneXknOiBbbnVtYmVyICsgJyBKYWhyZScsIG51bWJlciArICcgSmFocmVuJ11cbiAgICB9O1xuICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXTtcbn1cblxucmVxdWlyZSgnLi4vbW9tZW50JykuZGVmaW5lTG9jYWxlKCdkZScsIHtcbiAgICBtb250aHMgOiAnSmFudWFyX0ZlYnJ1YXJfTcOkcnpfQXByaWxfTWFpX0p1bmlfSnVsaV9BdWd1c3RfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGV6ZW1iZXInLnNwbGl0KCdfJyksXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuLl9GZWJyLl9NcnouX0Fwci5fTWFpX0p1bi5fSnVsLl9BdWcuX1NlcHQuX09rdC5fTm92Ll9EZXouJy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzIDogJ1Nvbm50YWdfTW9udGFnX0RpZW5zdGFnX01pdHR3b2NoX0Rvbm5lcnN0YWdfRnJlaXRhZ19TYW1zdGFnJy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU28uX01vLl9EaS5fTWkuX0RvLl9Gci5fU2EuJy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzTWluIDogJ1NvX01vX0RpX01pX0RvX0ZyX1NhJy5zcGxpdCgnXycpLFxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICBMVDogJ0hIOm1tIFtVaHJdJyxcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBMVCcsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIExUJ1xuICAgIH0sXG4gICAgY2FsZW5kYXIgOiB7XG4gICAgICAgIHNhbWVEYXk6ICdbSGV1dGUgdW1dIExUJyxcbiAgICAgICAgc2FtZUVsc2U6ICdMJyxcbiAgICAgICAgbmV4dERheTogJ1tNb3JnZW4gdW1dIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt1bV0gTFQnLFxuICAgICAgICBsYXN0RGF5OiAnW0dlc3Rlcm4gdW1dIExUJyxcbiAgICAgICAgbGFzdFdlZWs6ICdbbGV0enRlbl0gZGRkZCBbdW1dIExUJ1xuICAgIH0sXG4gICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0IDogJ3ZvciAlcycsXG4gICAgICAgIHMgOiAnZWluIHBhYXIgU2VrdW5kZW4nLFxuICAgICAgICBtIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgbW0gOiAnJWQgTWludXRlbicsXG4gICAgICAgIGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICBoaCA6ICclZCBTdHVuZGVuJyxcbiAgICAgICAgZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgIGRkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgIE1NIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgeSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgIHl5IDogcHJvY2Vzc1JlbGF0aXZlVGltZVxuICAgIH0sXG4gICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICB3ZWVrIDoge1xuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvZGUuanNcbi8vIG1vZHVsZSBpZCA9IGNvbnRyaWIvbW9tZW50L2xhbmcvZGVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/moment/lang/en-debug":
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(270).locale('en-debug', {});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvZW4tZGVidWcuanM/OWE0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw4Q0FBMEMiLCJmaWxlIjoiY29udHJpYi9tb21lbnQvbGFuZy9lbi1kZWJ1Zy5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4uL21vbWVudCcpLmxvY2FsZSgnZW4tZGVidWcnLCB7fSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9tb21lbnQvbGFuZy9lbi1kZWJ1Zy5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9tb21lbnQvbGFuZy9lbi1kZWJ1Z1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/moment/lang/en-gb":
/***/ (function(module, exports, __webpack_require__) {

	eval("// moment.js locale configuration\n// locale : great britain english (en-gb)\n// author : Chris Gedrim : https://github.com/chrisgedrim\n\n__webpack_require__(270).defineLocale('en-gb', {\n    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n    longDateFormat : {\n        LT : 'HH:mm',\n        L : 'DD/MM/YYYY',\n        LL : 'D MMMM YYYY',\n        LLL : 'D MMMM YYYY LT',\n        LLLL : 'dddd, D MMMM YYYY LT'\n    },\n    calendar : {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    },\n    relativeTime : {\n        future : 'in %s',\n        past : '%s ago',\n        s : 'a few seconds',\n        m : 'a minute',\n        mm : '%d minutes',\n        h : 'an hour',\n        hh : '%d hours',\n        d : 'a day',\n        dd : '%d days',\n        M : 'a month',\n        MM : '%d months',\n        y : 'a year',\n        yy : '%d years'\n    },\n    ordinalParse: /\\d{1,2}(st|nd|rd|th)/,\n    ordinal : function (number) {\n        var b = number % 10,\n            output = (~~(number % 100 / 10) === 1) ? 'th' :\n            (b === 1) ? 'st' :\n            (b === 2) ? 'nd' :\n            (b === 3) ? 'rd' : 'th';\n        return number + output;\n    },\n    week : {\n        dow : 1, // Monday is the first day of the week.\n        doy : 4  // The week that contains Jan 4th is the first week of the year.\n    }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvZW4tZ2IuanM/YmY4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6ImNvbnRyaWIvbW9tZW50L2xhbmcvZW4tZ2IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vIGxvY2FsZSA6IGdyZWF0IGJyaXRhaW4gZW5nbGlzaCAoZW4tZ2IpXG4vLyBhdXRob3IgOiBDaHJpcyBHZWRyaW0gOiBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNnZWRyaW1cblxucmVxdWlyZSgnLi4vbW9tZW50JykuZGVmaW5lTG9jYWxlKCdlbi1nYicsIHtcbiAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcbiAgICB3ZWVrZGF5cyA6ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICB3ZWVrZGF5c01pbiA6ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBMVCcsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgTFQnXG4gICAgfSxcbiAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH0sXG4gICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0IDogJyVzIGFnbycsXG4gICAgICAgIHMgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIG0gOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfSxcbiAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdHxuZHxyZHx0aCkvLFxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgIH0sXG4gICAgd2VlayA6IHtcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL21vbWVudC9sYW5nL2VuLWdiLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL21vbWVudC9sYW5nL2VuLWdiXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "contrib/moment/lang/en-us":
/***/ (function(module, exports, __webpack_require__) {

	eval("__webpack_require__(270).locale('en-us', {\n    compactRelativeTime: {\n        s: \"<1m\",\n        m: \"1m\",\n        mm: \"%dm\",\n        h: \"1h\",\n        hh: \"%dh\"\n    }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvZW4tdXMuanM/NDEzOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJjb250cmliL21vbWVudC9sYW5nL2VuLXVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi4vbW9tZW50JykubG9jYWxlKCdlbi11cycsIHtcbiAgICBjb21wYWN0UmVsYXRpdmVUaW1lOiB7XG4gICAgICAgIHM6IFwiPDFtXCIsXG4gICAgICAgIG06IFwiMW1cIixcbiAgICAgICAgbW06IFwiJWRtXCIsXG4gICAgICAgIGg6IFwiMWhcIixcbiAgICAgICAgaGg6IFwiJWRoXCJcbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL21vbWVudC9sYW5nL2VuLXVzLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL21vbWVudC9sYW5nL2VuLXVzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "contrib/moment/lang/fr":
/***/ (function(module, exports, __webpack_require__) {

	eval("//! moment.js locale configuration\n//! locale : french (fr)\n//! author : John Fischer : https://github.com/jfroffice\n\n__webpack_require__(270).defineLocale('fr', {\n    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),\n    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),\n    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),\n    longDateFormat : {\n        LT : 'HH:mm',\n        LTS : 'HH:mm:ss',\n        L : 'DD/MM/YYYY',\n        LL : 'D MMMM YYYY',\n        LLL : 'D MMMM YYYY HH:mm',\n        LLLL : 'dddd D MMMM YYYY HH:mm'\n    },\n    calendar : {\n        sameDay: '[Aujourd\\'hui à] LT',\n        nextDay: '[Demain à] LT',\n        nextWeek: 'dddd [à] LT',\n        lastDay: '[Hier à] LT',\n        lastWeek: 'dddd [dernier à] LT',\n        sameElse: 'L'\n    },\n    relativeTime : {\n        future : 'dans %s',\n        past : 'il y a %s',\n        s : 'quelques secondes',\n        m : 'une minute',\n        mm : '%d minutes',\n        h : 'une heure',\n        hh : '%d heures',\n        d : 'un jour',\n        dd : '%d jours',\n        M : 'un mois',\n        MM : '%d mois',\n        y : 'un an',\n        yy : '%d ans'\n    },\n    ordinalParse: /\\d{1,2}(er|)/,\n    ordinal : function (number) {\n        return number + (number === 1 ? 'er' : '');\n    },\n    week : {\n        dow : 1, // Monday is the first day of the week.\n        doy : 4  // The week that contains Jan 4th is the first week of the year.\n    }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvZnIuanM/MmFlMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJjb250cmliL21vbWVudC9sYW5nL2ZyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IGZyZW5jaCAoZnIpXG4vLyEgYXV0aG9yIDogSm9obiBGaXNjaGVyIDogaHR0cHM6Ly9naXRodWIuY29tL2pmcm9mZmljZVxuXG5yZXF1aXJlKCcuLi9tb21lbnQnKS5kZWZpbmVMb2NhbGUoJ2ZyJywge1xuICAgIG1vbnRocyA6ICdqYW52aWVyX2bDqXZyaWVyX21hcnNfYXZyaWxfbWFpX2p1aW5fanVpbGxldF9hb8O7dF9zZXB0ZW1icmVfb2N0b2JyZV9ub3ZlbWJyZV9kw6ljZW1icmUnLnNwbGl0KCdfJyksXG4gICAgbW9udGhzU2hvcnQgOiAnamFudi5fZsOpdnIuX21hcnNfYXZyLl9tYWlfanVpbl9qdWlsLl9hb8O7dF9zZXB0Ll9vY3QuX25vdi5fZMOpYy4nLnNwbGl0KCdfJyksXG4gICAgd2Vla2RheXMgOiAnZGltYW5jaGVfbHVuZGlfbWFyZGlfbWVyY3JlZGlfamV1ZGlfdmVuZHJlZGlfc2FtZWRpJy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzU2hvcnQgOiAnZGltLl9sdW4uX21hci5fbWVyLl9qZXUuX3Zlbi5fc2FtLicuc3BsaXQoJ18nKSxcbiAgICB3ZWVrZGF5c01pbiA6ICdEaV9MdV9NYV9NZV9KZV9WZV9TYScuc3BsaXQoJ18nKSxcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICB9LFxuICAgIGNhbGVuZGFyIDoge1xuICAgICAgICBzYW1lRGF5OiAnW0F1am91cmRcXCdodWkgw6BdIExUJyxcbiAgICAgICAgbmV4dERheTogJ1tEZW1haW4gw6BdIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvDoF0gTFQnLFxuICAgICAgICBsYXN0RGF5OiAnW0hpZXIgw6BdIExUJyxcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFtkZXJuaWVyIMOgXSBMVCcsXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICB9LFxuICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgZnV0dXJlIDogJ2RhbnMgJXMnLFxuICAgICAgICBwYXN0IDogJ2lsIHkgYSAlcycsXG4gICAgICAgIHMgOiAncXVlbHF1ZXMgc2Vjb25kZXMnLFxuICAgICAgICBtIDogJ3VuZSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCA6ICd1bmUgaGV1cmUnLFxuICAgICAgICBoaCA6ICclZCBoZXVyZXMnLFxuICAgICAgICBkIDogJ3VuIGpvdXInLFxuICAgICAgICBkZCA6ICclZCBqb3VycycsXG4gICAgICAgIE0gOiAndW4gbW9pcycsXG4gICAgICAgIE1NIDogJyVkIG1vaXMnLFxuICAgICAgICB5IDogJ3VuIGFuJyxcbiAgICAgICAgeXkgOiAnJWQgYW5zJ1xuICAgIH0sXG4gICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oZXJ8KS8sXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlciArIChudW1iZXIgPT09IDEgPyAnZXInIDogJycpO1xuICAgIH0sXG4gICAgd2VlayA6IHtcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL21vbWVudC9sYW5nL2ZyLmpzXG4vLyBtb2R1bGUgaWQgPSBjb250cmliL21vbWVudC9sYW5nL2ZyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "contrib/moment/lang/it":
/***/ (function(module, exports, __webpack_require__) {

	eval("// moment.js locale configuration\n// locale : italian (it)\n// author : Lorenzo : https://github.com/aliem\n// author: Mattia Larentis: https://github.com/nostalgiaz\n\n__webpack_require__(270).defineLocale('it', {\n    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),\n    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),\n    weekdays : 'Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato'.split('_'),\n    weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),\n    weekdaysMin : 'D_L_Ma_Me_G_V_S'.split('_'),\n    longDateFormat : {\n        LT : 'HH:mm',\n        L : 'DD/MM/YYYY',\n        LL : 'D MMMM YYYY',\n        LLL : 'D MMMM YYYY LT',\n        LLLL : 'dddd, D MMMM YYYY LT'\n    },\n    calendar : {\n        sameDay: '[Oggi alle] LT',\n        nextDay: '[Domani alle] LT',\n        nextWeek: 'dddd [alle] LT',\n        lastDay: '[Ieri alle] LT',\n        lastWeek: '[lo scorso] dddd [alle] LT',\n        sameElse: 'L'\n    },\n    relativeTime : {\n        future : function (s) {\n            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;\n        },\n        past : '%s fa',\n        s : 'alcuni secondi',\n        m : 'un minuto',\n        mm : '%d minuti',\n        h : 'un\\'ora',\n        hh : '%d ore',\n        d : 'un giorno',\n        dd : '%d giorni',\n        M : 'un mese',\n        MM : '%d mesi',\n        y : 'un anno',\n        yy : '%d anni'\n    },\n    ordinalParse : /\\d{1,2}º/,\n    ordinal: '%dº',\n    week : {\n        dow : 1, // Monday is the first day of the week.\n        doy : 4  // The week that contains Jan 4th is the first week of the year.\n    }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvaXQuanM/NGViMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJjb250cmliL21vbWVudC9sYW5nL2l0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyBsb2NhbGUgOiBpdGFsaWFuIChpdClcbi8vIGF1dGhvciA6IExvcmVuem8gOiBodHRwczovL2dpdGh1Yi5jb20vYWxpZW1cbi8vIGF1dGhvcjogTWF0dGlhIExhcmVudGlzOiBodHRwczovL2dpdGh1Yi5jb20vbm9zdGFsZ2lhelxuXG5yZXF1aXJlKCcuLi9tb21lbnQnKS5kZWZpbmVMb2NhbGUoJ2l0Jywge1xuICAgIG1vbnRocyA6ICdnZW5uYWlvX2ZlYmJyYWlvX21hcnpvX2FwcmlsZV9tYWdnaW9fZ2l1Z25vX2x1Z2xpb19hZ29zdG9fc2V0dGVtYnJlX290dG9icmVfbm92ZW1icmVfZGljZW1icmUnLnNwbGl0KCdfJyksXG4gICAgbW9udGhzU2hvcnQgOiAnZ2VuX2ZlYl9tYXJfYXByX21hZ19naXVfbHVnX2Fnb19zZXRfb3R0X25vdl9kaWMnLnNwbGl0KCdfJyksXG4gICAgd2Vla2RheXMgOiAnRG9tZW5pY2FfTHVuZWTDrF9NYXJ0ZWTDrF9NZXJjb2xlZMOsX0dpb3ZlZMOsX1ZlbmVyZMOsX1NhYmF0bycuc3BsaXQoJ18nKSxcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0RvbV9MdW5fTWFyX01lcl9HaW9fVmVuX1NhYicuc3BsaXQoJ18nKSxcbiAgICB3ZWVrZGF5c01pbiA6ICdEX0xfTWFfTWVfR19WX1MnLnNwbGl0KCdfJyksXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgTFQnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIExUJ1xuICAgIH0sXG4gICAgY2FsZW5kYXIgOiB7XG4gICAgICAgIHNhbWVEYXk6ICdbT2dnaSBhbGxlXSBMVCcsXG4gICAgICAgIG5leHREYXk6ICdbRG9tYW5pIGFsbGVdIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthbGxlXSBMVCcsXG4gICAgICAgIGxhc3REYXk6ICdbSWVyaSBhbGxlXSBMVCcsXG4gICAgICAgIGxhc3RXZWVrOiAnW2xvIHNjb3Jzb10gZGRkZCBbYWxsZV0gTFQnLFxuICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgfSxcbiAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgIGZ1dHVyZSA6IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgvXlswLTldLiskLykudGVzdChzKSA/ICd0cmEnIDogJ2luJykgKyAnICcgKyBzO1xuICAgICAgICB9LFxuICAgICAgICBwYXN0IDogJyVzIGZhJyxcbiAgICAgICAgcyA6ICdhbGN1bmkgc2Vjb25kaScsXG4gICAgICAgIG0gOiAndW4gbWludXRvJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRpJyxcbiAgICAgICAgaCA6ICd1blxcJ29yYScsXG4gICAgICAgIGhoIDogJyVkIG9yZScsXG4gICAgICAgIGQgOiAndW4gZ2lvcm5vJyxcbiAgICAgICAgZGQgOiAnJWQgZ2lvcm5pJyxcbiAgICAgICAgTSA6ICd1biBtZXNlJyxcbiAgICAgICAgTU0gOiAnJWQgbWVzaScsXG4gICAgICAgIHkgOiAndW4gYW5ubycsXG4gICAgICAgIHl5IDogJyVkIGFubmknXG4gICAgfSxcbiAgICBvcmRpbmFsUGFyc2UgOiAvXFxkezEsMn3Cui8sXG4gICAgb3JkaW5hbDogJyVkwronLFxuICAgIHdlZWsgOiB7XG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9tb21lbnQvbGFuZy9pdC5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9tb21lbnQvbGFuZy9pdFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/moment/lang/ja":
/***/ (function(module, exports, __webpack_require__) {

	eval("// moment.js locale configuration\n// locale : japanese (ja)\n// author : LI Long : https://github.com/baryon\n\n__webpack_require__(270).defineLocale('ja', {\n    months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),\n    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),\n    weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),\n    weekdaysShort : '日_月_火_水_木_金_土'.split('_'),\n    weekdaysMin : '日_月_火_水_木_金_土'.split('_'),\n    longDateFormat : {\n        LT : 'Ah時m分',\n        L : 'YYYY/MM/DD',\n        LL : 'YYYY年M月D日',\n        LLL : 'YYYY年M月D日LT',\n        LLLL : 'YYYY年M月D日LT dddd'\n    },\n    meridiem : function (hour, minute, isLower) {\n        if (hour < 12) {\n            return '午前';\n        } else {\n            return '午後';\n        }\n    },\n    calendar : {\n        sameDay : '[今日] LT',\n        nextDay : '[明日] LT',\n        nextWeek : '[来週]dddd LT',\n        lastDay : '[昨日] LT',\n        lastWeek : '[前週]dddd LT',\n        sameElse : 'L'\n    },\n    relativeTime : {\n        future : '%s後',\n        past : '%s前',\n        s : '数秒',\n        m : '1分',\n        mm : '%d分',\n        h : '1時間',\n        hh : '%d時間',\n        d : '1日',\n        dd : '%d日',\n        M : '1ヶ月',\n        MM : '%dヶ月',\n        y : '1年',\n        yy : '%d年'\n    }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvamEuanM/MjBlNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiY29udHJpYi9tb21lbnQvbGFuZy9qYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8gbG9jYWxlIDogamFwYW5lc2UgKGphKVxuLy8gYXV0aG9yIDogTEkgTG9uZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYXJ5b25cblxucmVxdWlyZSgnLi4vbW9tZW50JykuZGVmaW5lTG9jYWxlKCdqYScsIHtcbiAgICBtb250aHMgOiAnMeaciF8y5pyIXzPmnIhfNOaciF815pyIXzbmnIhfN+aciF845pyIXznmnIhfMTDmnIhfMTHmnIhfMTLmnIgnLnNwbGl0KCdfJyksXG4gICAgbW9udGhzU2hvcnQgOiAnMeaciF8y5pyIXzPmnIhfNOaciF815pyIXzbmnIhfN+aciF845pyIXznmnIhfMTDmnIhfMTHmnIhfMTLmnIgnLnNwbGl0KCdfJyksXG4gICAgd2Vla2RheXMgOiAn5pel5puc5pelX+aciOabnOaXpV/ngavmm5zml6Vf5rC05puc5pelX+acqOabnOaXpV/ph5Hmm5zml6Vf5Zyf5puc5pelJy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzU2hvcnQgOiAn5pelX+aciF/ngatf5rC0X+acqF/ph5Ff5ZyfJy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzTWluIDogJ+aXpV/mnIhf54GrX+awtF/mnKhf6YeRX+Wcnycuc3BsaXQoJ18nKSxcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgTFQgOiAnQWjmmYJt5YiGJyxcbiAgICAgICAgTCA6ICdZWVlZL01NL0REJyxcbiAgICAgICAgTEwgOiAnWVlZWeW5tE3mnIhE5pelJyxcbiAgICAgICAgTExMIDogJ1lZWVnlubRN5pyIROaXpUxUJyxcbiAgICAgICAgTExMTCA6ICdZWVlZ5bm0TeaciETml6VMVCBkZGRkJ1xuICAgIH0sXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgIHJldHVybiAn5Y2I5YmNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAn5Y2I5b6MJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2FsZW5kYXIgOiB7XG4gICAgICAgIHNhbWVEYXkgOiAnW+S7iuaXpV0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1vmmI7ml6VdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnW+adpemAsV1kZGRkIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdb5pio5pelXSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1vliY3pgLFdZGRkZCBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfSxcbiAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgIGZ1dHVyZSA6ICclc+W+jCcsXG4gICAgICAgIHBhc3QgOiAnJXPliY0nLFxuICAgICAgICBzIDogJ+aVsOenkicsXG4gICAgICAgIG0gOiAnMeWIhicsXG4gICAgICAgIG1tIDogJyVk5YiGJyxcbiAgICAgICAgaCA6ICcx5pmC6ZaTJyxcbiAgICAgICAgaGggOiAnJWTmmYLplpMnLFxuICAgICAgICBkIDogJzHml6UnLFxuICAgICAgICBkZCA6ICclZOaXpScsXG4gICAgICAgIE0gOiAnMeODtuaciCcsXG4gICAgICAgIE1NIDogJyVk44O25pyIJyxcbiAgICAgICAgeSA6ICcx5bm0JyxcbiAgICAgICAgeXkgOiAnJWTlubQnXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9tb21lbnQvbGFuZy9qYS5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9tb21lbnQvbGFuZy9qYVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/moment/lang/ko":
/***/ (function(module, exports, __webpack_require__) {

	eval("// moment.js locale configuration\n// locale : korean (ko)\n//\n// authors\n//\n// - Kyungwook, Park : https://github.com/kyungw00k\n// - Jeeeyul Lee <jeeeyul@gmail.com>\n__webpack_require__(270).defineLocale('ko', {\n    months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),\n    monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),\n    weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),\n    weekdaysShort : '일_월_화_수_목_금_토'.split('_'),\n    weekdaysMin : '일_월_화_수_목_금_토'.split('_'),\n    longDateFormat : {\n        LT : 'A h시 m분',\n        L : 'YYYY.MM.DD',\n        LL : 'YYYY년 MMMM D일',\n        LLL : 'YYYY년 MMMM D일 LT',\n        LLLL : 'YYYY년 MMMM D일 dddd LT'\n    },\n    meridiem : function (hour, minute, isUpper) {\n        return hour < 12 ? '오전' : '오후';\n    },\n    calendar : {\n        sameDay : '오늘 LT',\n        nextDay : '내일 LT',\n        nextWeek : 'dddd LT',\n        lastDay : '어제 LT',\n        lastWeek : '지난주 dddd LT',\n        sameElse : 'L'\n    },\n    relativeTime : {\n        future : '%s 후',\n        past : '%s 전',\n        s : '몇초',\n        ss : '%d초',\n        m : '일분',\n        mm : '%d분',\n        h : '한시간',\n        hh : '%d시간',\n        d : '하루',\n        dd : '%d일',\n        M : '한달',\n        MM : '%d달',\n        y : '일년',\n        yy : '%d년'\n    },\n    ordinalParse : /\\d{1,2}일/,\n    ordinal : '%d일',\n    meridiemParse : /(오전|오후)/,\n    isPM : function (token) {\n        return token === '오후';\n    }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcva28uanM/ZTA5NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJjb250cmliL21vbWVudC9sYW5nL2tvLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyBsb2NhbGUgOiBrb3JlYW4gKGtvKVxuLy9cbi8vIGF1dGhvcnNcbi8vXG4vLyAtIEt5dW5nd29vaywgUGFyayA6IGh0dHBzOi8vZ2l0aHViLmNvbS9reXVuZ3cwMGtcbi8vIC0gSmVlZXl1bCBMZWUgPGplZWV5dWxAZ21haWwuY29tPlxucmVxdWlyZSgnLi4vbW9tZW50JykuZGVmaW5lTG9jYWxlKCdrbycsIHtcbiAgICBtb250aHMgOiAnMeyblF8y7JuUXzPsm5RfNOyblF817JuUXzbsm5RfN+yblF847JuUXznsm5RfMTDsm5RfMTHsm5RfMTLsm5QnLnNwbGl0KCdfJyksXG4gICAgbW9udGhzU2hvcnQgOiAnMeyblF8y7JuUXzPsm5RfNOyblF817JuUXzbsm5RfN+yblF847JuUXznsm5RfMTDsm5RfMTHsm5RfMTLsm5QnLnNwbGl0KCdfJyksXG4gICAgd2Vla2RheXMgOiAn7J287JqU7J28X+yblOyalOydvF/tmZTsmpTsnbxf7IiY7JqU7J28X+uqqeyalOydvF/quIjsmpTsnbxf7Yag7JqU7J28Jy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzU2hvcnQgOiAn7J28X+yblF/tmZRf7IiYX+uqqV/quIhf7YagJy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzTWluIDogJ+ydvF/sm5Rf7ZmUX+yImF/rqqlf6riIX+2GoCcuc3BsaXQoJ18nKSxcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgTFQgOiAnQSBo7IucIG3rtoQnLFxuICAgICAgICBMIDogJ1lZWVkuTU0uREQnLFxuICAgICAgICBMTCA6ICdZWVlZ64WEIE1NTU0gROydvCcsXG4gICAgICAgIExMTCA6ICdZWVlZ64WEIE1NTU0gROydvCBMVCcsXG4gICAgICAgIExMTEwgOiAnWVlZWeuFhCBNTU1NIETsnbwgZGRkZCBMVCdcbiAgICB9LFxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNVcHBlcikge1xuICAgICAgICByZXR1cm4gaG91ciA8IDEyID8gJ+yYpOyghCcgOiAn7Jik7ZuEJztcbiAgICB9LFxuICAgIGNhbGVuZGFyIDoge1xuICAgICAgICBzYW1lRGF5IDogJ+yYpOuKmCBMVCcsXG4gICAgICAgIG5leHREYXkgOiAn64K07J28IExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAn7Ja07KCcIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAn7KeA64Kc7KO8IGRkZGQgTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH0sXG4gICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICBmdXR1cmUgOiAnJXMg7ZuEJyxcbiAgICAgICAgcGFzdCA6ICclcyDsoIQnLFxuICAgICAgICBzIDogJ+uqh+y0iCcsXG4gICAgICAgIHNzIDogJyVk7LSIJyxcbiAgICAgICAgbSA6ICfsnbzrtoQnLFxuICAgICAgICBtbSA6ICclZOu2hCcsXG4gICAgICAgIGggOiAn7ZWc7Iuc6rCEJyxcbiAgICAgICAgaGggOiAnJWTsi5zqsIQnLFxuICAgICAgICBkIDogJ+2VmOujqCcsXG4gICAgICAgIGRkIDogJyVk7J28JyxcbiAgICAgICAgTSA6ICftlZzri6wnLFxuICAgICAgICBNTSA6ICclZOuLrCcsXG4gICAgICAgIHkgOiAn7J2864WEJyxcbiAgICAgICAgeXkgOiAnJWTrhYQnXG4gICAgfSxcbiAgICBvcmRpbmFsUGFyc2UgOiAvXFxkezEsMn3snbwvLFxuICAgIG9yZGluYWwgOiAnJWTsnbwnLFxuICAgIG1lcmlkaWVtUGFyc2UgOiAvKOyYpOyghHzsmKTtm4QpLyxcbiAgICBpc1BNIDogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbiA9PT0gJ+yYpO2bhCc7XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9tb21lbnQvbGFuZy9rby5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9tb21lbnQvbGFuZy9rb1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/moment/lang/zh-cn":
/***/ (function(module, exports, __webpack_require__) {

	eval("// moment.js locale configuration\n// locale : chinese (zh-cn)\n// author : suupic : https://github.com/suupic\n// author : Zeno Zeng : https://github.com/zenozeng\n__webpack_require__(270).defineLocale('zh-cn', {\n    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),\n    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),\n    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),\n    weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),\n    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),\n    longDateFormat : {\n        LT : 'Ah点mm',\n        L : 'YYYY-MM-DD',\n        LL : 'YYYY年MMMD日',\n        LLL : 'YYYY年MMMD日LT',\n        LLLL : 'YYYY年MMMD日ddddLT',\n        l : 'YYYY-MM-DD',\n        ll : 'YYYY年MMMD日',\n        lll : 'YYYY年MMMD日LT',\n        llll : 'YYYY年MMMD日ddddLT'\n    },\n    meridiem : function (hour, minute, isLower) {\n        var hm = hour * 100 + minute;\n        if (hm < 600) {\n            return '凌晨';\n        } else if (hm < 900) {\n            return '早上';\n        } else if (hm < 1130) {\n            return '上午';\n        } else if (hm < 1230) {\n            return '中午';\n        } else if (hm < 1800) {\n            return '下午';\n        } else {\n            return '晚上';\n        }\n    },\n    calendar : {\n        sameDay : function () {\n            return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';\n        },\n        nextDay : function () {\n            return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';\n        },\n        lastDay : function () {\n            return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';\n        },\n        nextWeek : function () {\n            var startOfWeek, prefix;\n            startOfWeek = moment().startOf('week');\n            prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[下]' : '[本]';\n            return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';\n        },\n        lastWeek : function () {\n            var startOfWeek, prefix;\n            startOfWeek = moment().startOf('week');\n            prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';\n            return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';\n        },\n        sameElse : 'LL'\n    },\n    ordinalParse: /\\d{1,2}(日|月|周)/,\n    ordinal : function (number, period) {\n        switch (period) {\n        case 'd':\n        case 'D':\n        case 'DDD':\n            return number + '日';\n        case 'M':\n            return number + '月';\n        case 'w':\n        case 'W':\n            return number + '周';\n        default:\n            return number;\n        }\n    },\n    relativeTime : {\n        future : '%s内',\n        past : '%s前',\n        s : '几秒',\n        m : '1分钟',\n        mm : '%d分钟',\n        h : '1小时',\n        hh : '%d小时',\n        d : '1天',\n        dd : '%d天',\n        M : '1个月',\n        MM : '%d个月',\n        y : '1年',\n        yy : '%d年'\n    },\n    week : {\n        // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效\n        dow : 1, // Monday is the first day of the week.\n        doy : 4  // The week that contains Jan 4th is the first week of the year.\n    }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvemgtY24uanM/ODRmNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6ImNvbnRyaWIvbW9tZW50L2xhbmcvemgtY24uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vIGxvY2FsZSA6IGNoaW5lc2UgKHpoLWNuKVxuLy8gYXV0aG9yIDogc3V1cGljIDogaHR0cHM6Ly9naXRodWIuY29tL3N1dXBpY1xuLy8gYXV0aG9yIDogWmVubyBaZW5nIDogaHR0cHM6Ly9naXRodWIuY29tL3plbm96ZW5nXG5yZXF1aXJlKCcuLi9tb21lbnQnKS5kZWZpbmVMb2NhbGUoJ3poLWNuJywge1xuICAgIG1vbnRocyA6ICfkuIDmnIhf5LqM5pyIX+S4ieaciF/lm5vmnIhf5LqU5pyIX+WFreaciF/kuIPmnIhf5YWr5pyIX+S5neaciF/ljYHmnIhf5Y2B5LiA5pyIX+WNgeS6jOaciCcuc3BsaXQoJ18nKSxcbiAgICBtb250aHNTaG9ydCA6ICcx5pyIXzLmnIhfM+aciF805pyIXzXmnIhfNuaciF835pyIXzjmnIhfOeaciF8xMOaciF8xMeaciF8xMuaciCcuc3BsaXQoJ18nKSxcbiAgICB3ZWVrZGF5cyA6ICfmmJ/mnJ/ml6Vf5pif5pyf5LiAX+aYn+acn+S6jF/mmJ/mnJ/kuIlf5pif5pyf5ZubX+aYn+acn+S6lF/mmJ/mnJ/lha0nLnNwbGl0KCdfJyksXG4gICAgd2Vla2RheXNTaG9ydCA6ICflkajml6Vf5ZGo5LiAX+WRqOS6jF/lkajkuIlf5ZGo5ZubX+WRqOS6lF/lkajlha0nLnNwbGl0KCdfJyksXG4gICAgd2Vla2RheXNNaW4gOiAn5pelX+S4gF/kuoxf5LiJX+Wbm1/kupRf5YWtJy5zcGxpdCgnXycpLFxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICBMVCA6ICdBaOeCuW1tJyxcbiAgICAgICAgTCA6ICdZWVlZLU1NLUREJyxcbiAgICAgICAgTEwgOiAnWVlZWeW5tE1NTUTml6UnLFxuICAgICAgICBMTEwgOiAnWVlZWeW5tE1NTUTml6VMVCcsXG4gICAgICAgIExMTEwgOiAnWVlZWeW5tE1NTUTml6VkZGRkTFQnLFxuICAgICAgICBsIDogJ1lZWVktTU0tREQnLFxuICAgICAgICBsbCA6ICdZWVlZ5bm0TU1NROaXpScsXG4gICAgICAgIGxsbCA6ICdZWVlZ5bm0TU1NROaXpUxUJyxcbiAgICAgICAgbGxsbCA6ICdZWVlZ5bm0TU1NROaXpWRkZGRMVCdcbiAgICB9LFxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICB2YXIgaG0gPSBob3VyICogMTAwICsgbWludXRlO1xuICAgICAgICBpZiAoaG0gPCA2MDApIHtcbiAgICAgICAgICAgIHJldHVybiAn5YeM5pmoJztcbiAgICAgICAgfSBlbHNlIGlmIChobSA8IDkwMCkge1xuICAgICAgICAgICAgcmV0dXJuICfml6nkuIonO1xuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTEzMCkge1xuICAgICAgICAgICAgcmV0dXJuICfkuIrljYgnO1xuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTIzMCkge1xuICAgICAgICAgICAgcmV0dXJuICfkuK3ljYgnO1xuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTgwMCkge1xuICAgICAgICAgICAgcmV0dXJuICfkuIvljYgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICfmmZrkuIonO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbnV0ZXMoKSA9PT0gMCA/ICdb5LuK5aSpXUFoW+eCueaVtF0nIDogJ1vku4rlpKldTFQnO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0RGF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWludXRlcygpID09PSAwID8gJ1vmmI7lpKldQWhb54K55pW0XScgOiAnW+aYjuWkqV1MVCc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhc3REYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW51dGVzKCkgPT09IDAgPyAnW+aYqOWkqV1BaFvngrnmlbRdJyA6ICdb5pio5aSpXUxUJztcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZldlZWssIHByZWZpeDtcbiAgICAgICAgICAgIHN0YXJ0T2ZXZWVrID0gbW9tZW50KCkuc3RhcnRPZignd2VlaycpO1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy51bml4KCkgLSBzdGFydE9mV2Vlay51bml4KCkgPj0gNyAqIDI0ICogMzYwMCA/ICdb5LiLXScgOiAnW+acrF0nO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWludXRlcygpID09PSAwID8gcHJlZml4ICsgJ2RkZEFo54K55pW0JyA6IHByZWZpeCArICdkZGRBaOeCuW1tJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZldlZWssIHByZWZpeDtcbiAgICAgICAgICAgIHN0YXJ0T2ZXZWVrID0gbW9tZW50KCkuc3RhcnRPZignd2VlaycpO1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy51bml4KCkgPCBzdGFydE9mV2Vlay51bml4KCkgID8gJ1vkuIpdJyA6ICdb5pysXSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW51dGVzKCkgPT09IDAgPyBwcmVmaXggKyAnZGRkQWjngrnmlbQnIDogcHJlZml4ICsgJ2RkZEFo54K5bW0nO1xuICAgICAgICB9LFxuICAgICAgICBzYW1lRWxzZSA6ICdMTCdcbiAgICB9LFxuICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KOaXpXzmnIh85ZGoKS8sXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGNhc2UgJ0RERCc6XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aXpSc7XG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfmnIgnO1xuICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+WRqCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgIGZ1dHVyZSA6ICclc+WGhScsXG4gICAgICAgIHBhc3QgOiAnJXPliY0nLFxuICAgICAgICBzIDogJ+WHoOenkicsXG4gICAgICAgIG0gOiAnMeWIhumSnycsXG4gICAgICAgIG1tIDogJyVk5YiG6ZKfJyxcbiAgICAgICAgaCA6ICcx5bCP5pe2JyxcbiAgICAgICAgaGggOiAnJWTlsI/ml7YnLFxuICAgICAgICBkIDogJzHlpKknLFxuICAgICAgICBkZCA6ICclZOWkqScsXG4gICAgICAgIE0gOiAnMeS4quaciCcsXG4gICAgICAgIE1NIDogJyVk5Liq5pyIJyxcbiAgICAgICAgeSA6ICcx5bm0JyxcbiAgICAgICAgeXkgOiAnJWTlubQnXG4gICAgfSxcbiAgICB3ZWVrIDoge1xuICAgICAgICAvLyBHQi9UIDc0MDgtMTk5NOOAiuaVsOaNruWFg+WSjOS6pOaNouagvOW8j8K35L+h5oGv5Lqk5o2iwrfml6XmnJ/lkozml7bpl7TooajnpLrms5XjgIvkuI5JU08gODYwMToxOTg4562J5pWIXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9tb21lbnQvbGFuZy96aC1jbi5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9tb21lbnQvbGFuZy96aC1jblxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "contrib/moment/lang/zh-tw":
/***/ (function(module, exports, __webpack_require__) {

	eval("// moment.js locale configuration\n// locale : traditional chinese (zh-tw)\n// author : Ben : https://github.com/ben-lin\n\n__webpack_require__(270).defineLocale('zh-tw', {\n    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),\n    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),\n    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),\n    weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),\n    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),\n    longDateFormat : {\n        LT : 'Ah點mm',\n        L : 'YYYY年MMMD日',\n        LL : 'YYYY年MMMD日',\n        LLL : 'YYYY年MMMD日LT',\n        LLLL : 'YYYY年MMMD日ddddLT',\n        l : 'YYYY年MMMD日',\n        ll : 'YYYY年MMMD日',\n        lll : 'YYYY年MMMD日LT',\n        llll : 'YYYY年MMMD日ddddLT'\n    },\n    meridiem : function (hour, minute, isLower) {\n        var hm = hour * 100 + minute;\n        if (hm < 900) {\n            return '早上';\n        } else if (hm < 1130) {\n            return '上午';\n        } else if (hm < 1230) {\n            return '中午';\n        } else if (hm < 1800) {\n            return '下午';\n        } else {\n            return '晚上';\n        }\n    },\n    calendar : {\n        sameDay : '[今天]LT',\n        nextDay : '[明天]LT',\n        nextWeek : '[下]ddddLT',\n        lastDay : '[昨天]LT',\n        lastWeek : '[上]ddddLT',\n        sameElse : 'L'\n    },\n    ordinalParse: /\\d{1,2}(日|月|週)/,\n    ordinal : function (number, period) {\n        switch (period) {\n        case 'd' :\n        case 'D' :\n        case 'DDD' :\n            return number + '日';\n        case 'M' :\n            return number + '月';\n        case 'w' :\n        case 'W' :\n            return number + '週';\n        default :\n            return number;\n        }\n    },\n    relativeTime : {\n        future : '%s內',\n        past : '%s前',\n        s : '幾秒',\n        m : '一分鐘',\n        mm : '%d分鐘',\n        h : '一小時',\n        hh : '%d小時',\n        d : '一天',\n        dd : '%d天',\n        M : '一個月',\n        MM : '%d個月',\n        y : '一年',\n        yy : '%d年'\n    }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvbW9tZW50L2xhbmcvemgtdHcuanM/NThmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiY29udHJpYi9tb21lbnQvbGFuZy96aC10dy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8gbG9jYWxlIDogdHJhZGl0aW9uYWwgY2hpbmVzZSAoemgtdHcpXG4vLyBhdXRob3IgOiBCZW4gOiBodHRwczovL2dpdGh1Yi5jb20vYmVuLWxpblxuXG5yZXF1aXJlKCcuLi9tb21lbnQnKS5kZWZpbmVMb2NhbGUoJ3poLXR3Jywge1xuICAgIG1vbnRocyA6ICfkuIDmnIhf5LqM5pyIX+S4ieaciF/lm5vmnIhf5LqU5pyIX+WFreaciF/kuIPmnIhf5YWr5pyIX+S5neaciF/ljYHmnIhf5Y2B5LiA5pyIX+WNgeS6jOaciCcuc3BsaXQoJ18nKSxcbiAgICBtb250aHNTaG9ydCA6ICcx5pyIXzLmnIhfM+aciF805pyIXzXmnIhfNuaciF835pyIXzjmnIhfOeaciF8xMOaciF8xMeaciF8xMuaciCcuc3BsaXQoJ18nKSxcbiAgICB3ZWVrZGF5cyA6ICfmmJ/mnJ/ml6Vf5pif5pyf5LiAX+aYn+acn+S6jF/mmJ/mnJ/kuIlf5pif5pyf5ZubX+aYn+acn+S6lF/mmJ/mnJ/lha0nLnNwbGl0KCdfJyksXG4gICAgd2Vla2RheXNTaG9ydCA6ICfpgLHml6Vf6YCx5LiAX+mAseS6jF/pgLHkuIlf6YCx5ZubX+mAseS6lF/pgLHlha0nLnNwbGl0KCdfJyksXG4gICAgd2Vla2RheXNNaW4gOiAn5pelX+S4gF/kuoxf5LiJX+Wbm1/kupRf5YWtJy5zcGxpdCgnXycpLFxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICBMVCA6ICdBaOm7nm1tJyxcbiAgICAgICAgTCA6ICdZWVlZ5bm0TU1NROaXpScsXG4gICAgICAgIExMIDogJ1lZWVnlubRNTU1E5pelJyxcbiAgICAgICAgTExMIDogJ1lZWVnlubRNTU1E5pelTFQnLFxuICAgICAgICBMTExMIDogJ1lZWVnlubRNTU1E5pelZGRkZExUJyxcbiAgICAgICAgbCA6ICdZWVlZ5bm0TU1NROaXpScsXG4gICAgICAgIGxsIDogJ1lZWVnlubRNTU1E5pelJyxcbiAgICAgICAgbGxsIDogJ1lZWVnlubRNTU1E5pelTFQnLFxuICAgICAgICBsbGxsIDogJ1lZWVnlubRNTU1E5pelZGRkZExUJ1xuICAgIH0sXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgIHZhciBobSA9IGhvdXIgKiAxMDAgKyBtaW51dGU7XG4gICAgICAgIGlmIChobSA8IDkwMCkge1xuICAgICAgICAgICAgcmV0dXJuICfml6nkuIonO1xuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTEzMCkge1xuICAgICAgICAgICAgcmV0dXJuICfkuIrljYgnO1xuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTIzMCkge1xuICAgICAgICAgICAgcmV0dXJuICfkuK3ljYgnO1xuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTgwMCkge1xuICAgICAgICAgICAgcmV0dXJuICfkuIvljYgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICfmmZrkuIonO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgc2FtZURheSA6ICdb5LuK5aSpXUxUJyxcbiAgICAgICAgbmV4dERheSA6ICdb5piO5aSpXUxUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnW+S4i11kZGRkTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1vmmKjlpKldTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdb5LiKXWRkZGRMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfSxcbiAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSjml6V85pyIfOmAsSkvLFxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcbiAgICAgICAgY2FzZSAnZCcgOlxuICAgICAgICBjYXNlICdEJyA6XG4gICAgICAgIGNhc2UgJ0RERCcgOlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfml6UnO1xuICAgICAgICBjYXNlICdNJyA6XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aciCc7XG4gICAgICAgIGNhc2UgJ3cnIDpcbiAgICAgICAgY2FzZSAnVycgOlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfpgLEnO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgZnV0dXJlIDogJyVz5YWnJyxcbiAgICAgICAgcGFzdCA6ICclc+WJjScsXG4gICAgICAgIHMgOiAn5bm+56eSJyxcbiAgICAgICAgbSA6ICfkuIDliIbpkJgnLFxuICAgICAgICBtbSA6ICclZOWIhumQmCcsXG4gICAgICAgIGggOiAn5LiA5bCP5pmCJyxcbiAgICAgICAgaGggOiAnJWTlsI/mmYInLFxuICAgICAgICBkIDogJ+S4gOWkqScsXG4gICAgICAgIGRkIDogJyVk5aSpJyxcbiAgICAgICAgTSA6ICfkuIDlgIvmnIgnLFxuICAgICAgICBNTSA6ICclZOWAi+aciCcsXG4gICAgICAgIHkgOiAn5LiA5bm0JyxcbiAgICAgICAgeXkgOiAnJWTlubQnXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvY29udHJpYi9tb21lbnQvbGFuZy96aC10dy5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9tb21lbnQvbGFuZy96aC10d1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "util/color_utils":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Util package for working with colors.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"require/underscore\")], __WEBPACK_AMD_DEFINE_RESULT__ = function(_) {\n\n    var hslColorFromRgbColor = function(rgbColor) {\n        /**\n         * convert from [r,g,b] to [h,s,l]\n         *  r,g,b: [0,255]\n         *  h: [0,360)\n         *  s: [0,100]\n         *  l: [0,100]\n         *  Uses algorithm as specified on Wikipedia http://en.wikipedia.org/wiki/HSL_and_HSV\n         */\n\n        var r = rgbColor[0];\n        var g = rgbColor[1];\n        var b = rgbColor[2];\n        var computedH = 0;\n        var computedS = 0;\n        var computedL = 0;\n\n        if (r === null || g === null || b === null ||\n            isNaN(r) || isNaN(g)|| isNaN(b) ) {\n            return null;\n        }\n\n        if (r < 0 || g < 0 || b < 0 ||\n            r > 255 || g > 255 || b > 255) {\n            return null;\n        }\n\n        r = r / 255;\n        g = g / 255;\n        b = b / 255;\n        var minRGB = Math.min(r, Math.min(g, b));\n        var maxRGB = Math.max(r, Math.max(g, b));\n        var chroma = maxRGB - minRGB;\n\n        var h_prime = 0;\n        if (chroma == 0) {\n            h_prime = 0;\n        }\n        else if (maxRGB == r) {\n            h_prime = ((g - b) / chroma) % 6;\n        } else if (maxRGB == g) {\n            h_prime = ((b - r) / chroma) + 2;\n        } else if (maxRGB == b) {\n            h_prime = ((r - g) / chroma) + 4;\n        }\n\n        var h = h_prime * 60;\n        while (h < 0)\n        {\n            h += 360;\n        }\n        while (h > 360)\n        {\n            h -= 360;\n        }\n\n        var l = 0.5 * (maxRGB + minRGB);\n\n        var s = 0;\n        if (chroma == 0) {\n            s = 0;\n        } else {\n            s = chroma / (1 - Math.abs(2 * l - 1));\n        }\n\n        if (s < 0) { s = 0; }\n        if (s > 1) { s = 1; }\n        if (l < 0) { l = 0; }\n        if (l > 1) { l = 1; }\n\n        return [h, s * 100, l * 100];\n    };\n\n    var rgbColorFromHslColor = function(hslColor) {\n        /**\n         * convert from [h,s,l] to [r,g,b]\n         *  r,g,b: [0,255]\n         *  h: [0,360)\n         *  s: [0,100]\n         *  l: [0,100]\n         *  Uses algorithm as specified on Wikipedia http://en.wikipedia.org/wiki/HSL_and_HSV\n         */\n        if (hslColor.length != 3) {\n            return null;\n        }\n\n        var h = hslColor[0],\n            s = hslColor[1],\n            l = hslColor[2];\n\n        s = s / 100;\n        l = l / 100;\n\n        while (h < 0)\n        {\n            h += 360;\n        }\n        while (h > 360)\n        {\n            h -= 360;\n        }\n\n        if (h < 0 || h > 360 ||\n            s < 0 || s > 1 ||\n            l < 0 || l > 1)\n        {\n            return null;\n        }\n\n        // chroma\n        var c = (1 - Math.abs(2 * l - 1)) * s;\n\n        // determine color components (sans lightness)\n        var h1 = h / 60;\n        var x = c * (1 - Math.abs((h1 % 2) - 1));\n        var r1 = 0,\n            g1 = 0,\n            b1 = 0;\n\n        if (h1 < 1) {\n            r1 = c;\n            g1 = x;\n        } else if (h1 < 2) {\n            r1 = x;\n            g1 = c;\n        } else if (h1 < 3) {\n            g1 = c;\n            b1 = x;\n        } else if (h1 < 4) {\n            g1 = x;\n            b1 = c;\n        } else if (h1 < 5) {\n            r1 = x;\n            b1 = c;\n        } else {\n            r1 = c;\n            b1 = x;\n        }\n\n        // add lightness component to get r,g,b\n        var m = l - 0.5 * c;\n        var r = r1 + m,\n            g = g1 + m,\n            b = b1 + m;\n\n        // return in [0,255] range\n        r *= 255;\n        g *= 255;\n        b *= 255;\n\n        return [r, g, b];\n    };\n\n    var rgbColorFromRgbString = function(rgbColorString) {\n        /**\n         * given \"rgb(r,g,b)\" converts to [r,g,b]\n         */\n\n        var rgbValueStrings = rgbColorString.match(/^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/);\n        if (rgbValueStrings === null) {\n            return null;\n        }\n\n        var rgbColor = [parseInt(rgbValueStrings[1], 10),\n                        parseInt(rgbValueStrings[2], 10),\n                        parseInt(rgbValueStrings[3], 10)];\n\n        return rgbColor;\n    };\n\n    var rgbStringFromRgbColor = function(rgbColor) {\n        /**\n         * given [r,g,b] returns \"rgb(r,g,b)\"\n         *  r, g, b are all rounded to nearest integers\n         */\n        if (rgbColor.length != 3) {\n            return null;\n        }\n\n        var roundedRgbColor = _.map(rgbColor, Math.round);\n        var rgbString = \"rgb(\" + roundedRgbColor[0] + \", \" + roundedRgbColor[1] + \", \" + roundedRgbColor[2] + \")\";\n        return rgbString;\n    };\n\n    var hslStringFromHslColor = function(hslColor) {\n        /**\n         * given [h,s,l] returns \"hsl(h,s%,l%)\"\n         *  h, s, l are all rounded to nearest integers\n         */\n        if (hslColor.length != 3) {\n            return null;\n        }\n        var roundedHslColor = _.map(hslColor, Math.round);\n        var hslString = \"hsl(\" + roundedHslColor[0] + \", \" + roundedHslColor[1] + \"%, \" + roundedHslColor[2] + \"%)\";\n        return hslString;\n    };\n\n    var hslColorFromHslString = function(hslColorString) {\n        /**\n         * given \"hsl(h,s%,l%)\" returns [h,s,l]\n         */\n        var hslValueStrings = hslColorString.match(/^hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)$/);\n        if (hslValueStrings === null) {\n            return null;\n        }\n\n        var hslColor = [parseInt(hslValueStrings[1], 10),\n                        parseInt(hslValueStrings[2], 10),\n                        parseInt(hslValueStrings[3], 10)];\n\n        return hslColor;\n    };\n\n    var rgbColorFromHexString = function(hexColorString) {\n        /**\n         * given \"#RRGGBB\" returns [r,g,b]\n         */\n        var normHexColorString = normalizeHexString(hexColorString);\n        var hexValueStrings = normHexColorString.match(/^#?([\\dA-Fa-f]{2})([\\dA-Fa-f]{2})([\\dA-Fa-f]{2})$/);\n        if (hexValueStrings === null) {\n            return null;\n        }\n\n        var rgbColor = [parseInt(hexValueStrings[1], 16),\n                        parseInt(hexValueStrings[2], 16),\n                        parseInt(hexValueStrings[3], 16)];\n\n        return rgbColor;\n    };\n\n    var hexStringFromRgbColor = function(rgbColor) {\n        /**\n         * given [r,g,b] returns \"#RRGGBB\"\n         *  r,g,b rounded to nearest integers\n         */\n        if (rgbColor.length != 3) {\n            return null;\n        }\n\n        var roundedRgbColor = _.map(rgbColor, Math.round);\n        var hexComponents = _.map(roundedRgbColor, function(num) {\n            var hex = num.toString(16);\n            if (hex.length < 2) {\n                hex = \"0\" + hex;\n            }\n            return hex.toUpperCase();\n        });\n        var hexString = \"#\" + hexComponents[0] + hexComponents[1] + hexComponents[2];\n        return hexString;\n    };\n\n    var normalizeHexString = function(hexString) {\n        /**\n         * given \"rrggbb\", \"RRGGBB\", \"#rrggbb\", \"#RRGGBB\" returns \"#RRGGBB\"\n         */\n        var normString = '#' + hexString.replace('#','');\n        normString = normString.toUpperCase();\n        // check for #RGB, to convert to #RRGGBB\n        var hexValueStrings = normString.match(/^#?([\\dA-F])([\\dA-F])([\\dA-F])$/);\n        if (hexValueStrings !== null) {\n            normString = '#' + hexValueStrings[1] + hexValueStrings[1] +\n                               hexValueStrings[2] + hexValueStrings[2] +\n                               hexValueStrings[3] + hexValueStrings[3];\n        }\n        return normString;\n    };\n\n    var modifyLuminosityOfHslColor = function(hslColor, luminosityMultiplier){\n        /**\n         * adjusts the luminosity of the specified hsl color by multiplying by luminosityMultiplier\n         *  l is clamped to within [0,100]\n         */\n        var modHslColor = hslColor.slice(0);\n\n        modHslColor[2] *= luminosityMultiplier;\n        if (modHslColor[2] > 100) {\n            modHslColor[2] = 100;\n        } else if (modHslColor[2] < 0) {\n            modHslColor[2] = 100;\n        }\n\n        return modHslColor;\n    };\n\n    var modifyLuminosityOfRgbColor = function(rgbColor, luminosityMultiplier){\n        /**\n         * adjusts the luminosity of the specified rgb color by luminosityMultiplier\n         *   1 - convert to hsl\n         *   2 - l *= luminosityMultiplier AND clamp(0,100)\n         *   3 - convert back to rgb\n         */\n        var hslColor = hslColorFromRgbColor(rgbColor);\n        var modHslColor = modifyLuminosityOfHslColor(hslColor, luminosityMultiplier);\n        var modRgbColor = rgbColorFromHslColor(modHslColor);\n        return modRgbColor;\n    };\n\n    var modifyLuminosityOfHexString = function(hexString, luminosityMultiplier){\n        /**\n         * adjusts the luminosity of the specified rgb color by luminosityMultiplier\n         *   1 - convert to rgb, then to hsl\n         *   2 - l *= luminosityMultiplier AND clamp(0,100)\n         *   3 - convert back to rgb, then to hex\n         */\n        var rgbColor = rgbColorFromHexString(hexString);\n        var modRgbColor = modifyLuminosityOfRgbColor(rgbColor, luminosityMultiplier);\n        var modHexString = hexStringFromRgbColor(modRgbColor);\n        return modHexString;\n    };\n\n    var generateGradientStylesWithMidColor = function(startColor, midColor, colorStop, endColor){\n        /**\n         * returns array of gradient style directives that cover set of browsers\n         * builds gradient from three colors, places the midColor at colorStop percent\n         *  startColor, midColor, endColor are css interpretable colors\n         *  colorStop is \"stop%\", e.g. \"50%\", \"80%\"\n         */\n        var gradients =\n            [\n                ' -webkit-gradient(linear, 0 0, 0 100%, from(@startColor), color-stop(@colorStop, @midColor), to(@endColor)) ',\n                ' -webkit-linear-gradient(@startColor, @midColor @colorStop, @endColor) ',\n                ' -moz-linear-gradient(top, @startColor, @midColor @colorStop, @endColor) ',\n                ' -o-linear-gradient(@startColor, @midColor @colorStop, @endColor) ',\n                ' linear-gradient(@startColor, @midColor @colorStop, @endColor) ',\n                // note: this uses filter instead of bg-image\n                \" progid:DXImageTransform.Microsoft.gradient(startColorstr='@startColor', endColorstr='@endColor', GradientType=0) \"  // IE9 and down, gets no color-stop at all for proper fallback\n            ];\n        for (var i=0;i<gradients.length;i++){\n            gradients[i] = gradients[i].replace(/@startColor/g, startColor);\n            gradients[i] = gradients[i].replace(/@midColor/g, midColor);\n            gradients[i] = gradients[i].replace(/@colorStop/g, colorStop);\n            gradients[i] = gradients[i].replace(/@endColor/g, endColor);\n        }\n        return gradients;\n    };\n\n    var generateGradientStyles = function(startColor, endColor){\n        /**\n         * returns array of gradient style directives that cover set of browsers\n         * builds gradient from two colors\n         *  startColor, endColor are css interpretable colors\n         */\n        var gradients =\n            [\n                ' -moz-linear-gradient(top, @startColor, @endColor) ', // FF 3.6+\n                ' -webkit-gradient(linear, 0 0, 0 100%, from(@startColor), to(@endColor))', // Safari 4+, Chrome 2+\n                ' -webkit-linear-gradient(top, @startColor, @endColor) ', // Safari 5.1+, Chrome 10+\n                ' -o-linear-gradient(top, @startColor, @endColor) ', // Opera 11.10\n                ' linear-gradient(to bottom, @startColor, @endColor) ', // Standard, IE10\n                // note: this uses filter instead of bg-image\n                \" progid:DXImageTransform.Microsoft.gradient(startColorstr='@startColor', endColorstr='@endColor', GradientType=0)  \" // IE9 and down\n            ];\n        for (var i=0;i<gradients.length;i++){\n            gradients[i] = gradients[i].replace(/@startColor/g, startColor);\n            gradients[i] = gradients[i].replace(/@endColor/g, endColor);\n        }\n        return gradients;\n    };\n\n    // Prefixes hex value with provided symbols (e.g. '0x' or '#')\n    var replaceSymbols = function(string, symbols) {\n        if (!string) {\n            return '';\n        }\n        var strippedString = this.stripSymbols(string);\n        return symbols + strippedString;\n    };\n\n    // Removes '0x' and '#' prefixes to return just the color hex value itself\n    var stripSymbols = function(string) {\n        if (!string) {\n            return '';\n        }\n        if (string.substring(0,2) === '0x') {\n            return string.substring(2);\n        }\n        if (string.substring(0,1) === '#') {\n            return string.substring(1);\n        }\n        return string;\n    };\n\n    var interpolateColors = function(color1, color2, p) {\n        var r1 = (color1 >> 16) & 0xFF,\n            g1 = (color1 >> 8) & 0xFF,\n            b1 = color1 & 0xFF,\n\n            r2 = (color2 >> 16) & 0xFF,\n            g2 = (color2 >> 8) & 0xFF,\n            b2 = color2 & 0xFF,\n\n            rInterp = r1 + Math.round((r2 - r1) * p),\n            gInterp = g1 + Math.round((g2 - g1) * p),\n            bInterp = b1 + Math.round((b2 - b1) * p);\n\n        return ((rInterp << 16) | (gInterp << 8) | bInterp);\n    };\n\n    return {\n        hslColorFromRgbColor: hslColorFromRgbColor,\n        rgbColorFromHslColor: rgbColorFromHslColor,\n        hslColorFromHslString: hslColorFromHslString,\n        rgbColorFromRgbString: rgbColorFromRgbString,\n        hslStringFromHslColor: hslStringFromHslColor,\n        rgbStringFromRgbColor: rgbStringFromRgbColor,\n        rgbColorFromHexString: rgbColorFromHexString,\n        hexStringFromRgbColor: hexStringFromRgbColor,\n        normalizeHexString: normalizeHexString,\n        modifyLuminosityOfHslColor: modifyLuminosityOfHslColor,\n        modifyLuminosityOfRgbColor: modifyLuminosityOfRgbColor,\n        modifyLuminosityOfHexString: modifyLuminosityOfHexString,\n        generateGradientStylesWithMidColor: generateGradientStylesWithMidColor,\n        generateGradientStyles: generateGradientStyles,\n        replaceSymbols: replaceSymbols,\n        stripSymbols: stripSymbols,\n        interpolateColors: interpolateColors\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvY29sb3JfdXRpbHMuanM/MGNlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRTtBQUN2RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InV0aWwvY29sb3JfdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWwgcGFja2FnZSBmb3Igd29ya2luZyB3aXRoIGNvbG9ycy5cbiAqL1xuZGVmaW5lKFsndW5kZXJzY29yZSddLCBmdW5jdGlvbihfKSB7XG5cbiAgICB2YXIgaHNsQ29sb3JGcm9tUmdiQ29sb3IgPSBmdW5jdGlvbihyZ2JDb2xvcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogY29udmVydCBmcm9tIFtyLGcsYl0gdG8gW2gscyxsXVxuICAgICAgICAgKiAgcixnLGI6IFswLDI1NV1cbiAgICAgICAgICogIGg6IFswLDM2MClcbiAgICAgICAgICogIHM6IFswLDEwMF1cbiAgICAgICAgICogIGw6IFswLDEwMF1cbiAgICAgICAgICogIFVzZXMgYWxnb3JpdGhtIGFzIHNwZWNpZmllZCBvbiBXaWtpcGVkaWEgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTVlxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgciA9IHJnYkNvbG9yWzBdO1xuICAgICAgICB2YXIgZyA9IHJnYkNvbG9yWzFdO1xuICAgICAgICB2YXIgYiA9IHJnYkNvbG9yWzJdO1xuICAgICAgICB2YXIgY29tcHV0ZWRIID0gMDtcbiAgICAgICAgdmFyIGNvbXB1dGVkUyA9IDA7XG4gICAgICAgIHZhciBjb21wdXRlZEwgPSAwO1xuXG4gICAgICAgIGlmIChyID09PSBudWxsIHx8IGcgPT09IG51bGwgfHwgYiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgaXNOYU4ocikgfHwgaXNOYU4oZyl8fCBpc05hTihiKSApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIgPCAwIHx8IGcgPCAwIHx8IGIgPCAwIHx8XG4gICAgICAgICAgICByID4gMjU1IHx8IGcgPiAyNTUgfHwgYiA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByID0gciAvIDI1NTtcbiAgICAgICAgZyA9IGcgLyAyNTU7XG4gICAgICAgIGIgPSBiIC8gMjU1O1xuICAgICAgICB2YXIgbWluUkdCID0gTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpO1xuICAgICAgICB2YXIgbWF4UkdCID0gTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuICAgICAgICB2YXIgY2hyb21hID0gbWF4UkdCIC0gbWluUkdCO1xuXG4gICAgICAgIHZhciBoX3ByaW1lID0gMDtcbiAgICAgICAgaWYgKGNocm9tYSA9PSAwKSB7XG4gICAgICAgICAgICBoX3ByaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXhSR0IgPT0gcikge1xuICAgICAgICAgICAgaF9wcmltZSA9ICgoZyAtIGIpIC8gY2hyb21hKSAlIDY7XG4gICAgICAgIH0gZWxzZSBpZiAobWF4UkdCID09IGcpIHtcbiAgICAgICAgICAgIGhfcHJpbWUgPSAoKGIgLSByKSAvIGNocm9tYSkgKyAyO1xuICAgICAgICB9IGVsc2UgaWYgKG1heFJHQiA9PSBiKSB7XG4gICAgICAgICAgICBoX3ByaW1lID0gKChyIC0gZykgLyBjaHJvbWEpICsgNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoID0gaF9wcmltZSAqIDYwO1xuICAgICAgICB3aGlsZSAoaCA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGggKz0gMzYwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChoID4gMzYwKVxuICAgICAgICB7XG4gICAgICAgICAgICBoIC09IDM2MDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsID0gMC41ICogKG1heFJHQiArIG1pblJHQik7XG5cbiAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICBpZiAoY2hyb21hID09IDApIHtcbiAgICAgICAgICAgIHMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IGNocm9tYSAvICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocyA8IDApIHsgcyA9IDA7IH1cbiAgICAgICAgaWYgKHMgPiAxKSB7IHMgPSAxOyB9XG4gICAgICAgIGlmIChsIDwgMCkgeyBsID0gMDsgfVxuICAgICAgICBpZiAobCA+IDEpIHsgbCA9IDE7IH1cblxuICAgICAgICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xuICAgIH07XG5cbiAgICB2YXIgcmdiQ29sb3JGcm9tSHNsQ29sb3IgPSBmdW5jdGlvbihoc2xDb2xvcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogY29udmVydCBmcm9tIFtoLHMsbF0gdG8gW3IsZyxiXVxuICAgICAgICAgKiAgcixnLGI6IFswLDI1NV1cbiAgICAgICAgICogIGg6IFswLDM2MClcbiAgICAgICAgICogIHM6IFswLDEwMF1cbiAgICAgICAgICogIGw6IFswLDEwMF1cbiAgICAgICAgICogIFVzZXMgYWxnb3JpdGhtIGFzIHNwZWNpZmllZCBvbiBXaWtpcGVkaWEgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTVlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGhzbENvbG9yLmxlbmd0aCAhPSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoID0gaHNsQ29sb3JbMF0sXG4gICAgICAgICAgICBzID0gaHNsQ29sb3JbMV0sXG4gICAgICAgICAgICBsID0gaHNsQ29sb3JbMl07XG5cbiAgICAgICAgcyA9IHMgLyAxMDA7XG4gICAgICAgIGwgPSBsIC8gMTAwO1xuXG4gICAgICAgIHdoaWxlIChoIDwgMClcbiAgICAgICAge1xuICAgICAgICAgICAgaCArPSAzNjA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGggPiAzNjApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGggLT0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggPCAwIHx8IGggPiAzNjAgfHxcbiAgICAgICAgICAgIHMgPCAwIHx8IHMgPiAxIHx8XG4gICAgICAgICAgICBsIDwgMCB8fCBsID4gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaHJvbWFcbiAgICAgICAgdmFyIGMgPSAoMSAtIE1hdGguYWJzKDIgKiBsIC0gMSkpICogcztcblxuICAgICAgICAvLyBkZXRlcm1pbmUgY29sb3IgY29tcG9uZW50cyAoc2FucyBsaWdodG5lc3MpXG4gICAgICAgIHZhciBoMSA9IGggLyA2MDtcbiAgICAgICAgdmFyIHggPSBjICogKDEgLSBNYXRoLmFicygoaDEgJSAyKSAtIDEpKTtcbiAgICAgICAgdmFyIHIxID0gMCxcbiAgICAgICAgICAgIGcxID0gMCxcbiAgICAgICAgICAgIGIxID0gMDtcblxuICAgICAgICBpZiAoaDEgPCAxKSB7XG4gICAgICAgICAgICByMSA9IGM7XG4gICAgICAgICAgICBnMSA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoaDEgPCAyKSB7XG4gICAgICAgICAgICByMSA9IHg7XG4gICAgICAgICAgICBnMSA9IGM7XG4gICAgICAgIH0gZWxzZSBpZiAoaDEgPCAzKSB7XG4gICAgICAgICAgICBnMSA9IGM7XG4gICAgICAgICAgICBiMSA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoaDEgPCA0KSB7XG4gICAgICAgICAgICBnMSA9IHg7XG4gICAgICAgICAgICBiMSA9IGM7XG4gICAgICAgIH0gZWxzZSBpZiAoaDEgPCA1KSB7XG4gICAgICAgICAgICByMSA9IHg7XG4gICAgICAgICAgICBiMSA9IGM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByMSA9IGM7XG4gICAgICAgICAgICBiMSA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgbGlnaHRuZXNzIGNvbXBvbmVudCB0byBnZXQgcixnLGJcbiAgICAgICAgdmFyIG0gPSBsIC0gMC41ICogYztcbiAgICAgICAgdmFyIHIgPSByMSArIG0sXG4gICAgICAgICAgICBnID0gZzEgKyBtLFxuICAgICAgICAgICAgYiA9IGIxICsgbTtcblxuICAgICAgICAvLyByZXR1cm4gaW4gWzAsMjU1XSByYW5nZVxuICAgICAgICByICo9IDI1NTtcbiAgICAgICAgZyAqPSAyNTU7XG4gICAgICAgIGIgKj0gMjU1O1xuXG4gICAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgfTtcblxuICAgIHZhciByZ2JDb2xvckZyb21SZ2JTdHJpbmcgPSBmdW5jdGlvbihyZ2JDb2xvclN0cmluZykge1xuICAgICAgICAvKipcbiAgICAgICAgICogZ2l2ZW4gXCJyZ2IocixnLGIpXCIgY29udmVydHMgdG8gW3IsZyxiXVxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgcmdiVmFsdWVTdHJpbmdzID0gcmdiQ29sb3JTdHJpbmcubWF0Y2goL15yZ2JcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKSQvKTtcbiAgICAgICAgaWYgKHJnYlZhbHVlU3RyaW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmdiQ29sb3IgPSBbcGFyc2VJbnQocmdiVmFsdWVTdHJpbmdzWzFdLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChyZ2JWYWx1ZVN0cmluZ3NbMl0sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHJnYlZhbHVlU3RyaW5nc1szXSwgMTApXTtcblxuICAgICAgICByZXR1cm4gcmdiQ29sb3I7XG4gICAgfTtcblxuICAgIHZhciByZ2JTdHJpbmdGcm9tUmdiQ29sb3IgPSBmdW5jdGlvbihyZ2JDb2xvcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogZ2l2ZW4gW3IsZyxiXSByZXR1cm5zIFwicmdiKHIsZyxiKVwiXG4gICAgICAgICAqICByLCBnLCBiIGFyZSBhbGwgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXJzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocmdiQ29sb3IubGVuZ3RoICE9IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdW5kZWRSZ2JDb2xvciA9IF8ubWFwKHJnYkNvbG9yLCBNYXRoLnJvdW5kKTtcbiAgICAgICAgdmFyIHJnYlN0cmluZyA9IFwicmdiKFwiICsgcm91bmRlZFJnYkNvbG9yWzBdICsgXCIsIFwiICsgcm91bmRlZFJnYkNvbG9yWzFdICsgXCIsIFwiICsgcm91bmRlZFJnYkNvbG9yWzJdICsgXCIpXCI7XG4gICAgICAgIHJldHVybiByZ2JTdHJpbmc7XG4gICAgfTtcblxuICAgIHZhciBoc2xTdHJpbmdGcm9tSHNsQ29sb3IgPSBmdW5jdGlvbihoc2xDb2xvcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogZ2l2ZW4gW2gscyxsXSByZXR1cm5zIFwiaHNsKGgscyUsbCUpXCJcbiAgICAgICAgICogIGgsIHMsIGwgYXJlIGFsbCByb3VuZGVkIHRvIG5lYXJlc3QgaW50ZWdlcnNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChoc2xDb2xvci5sZW5ndGggIT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdW5kZWRIc2xDb2xvciA9IF8ubWFwKGhzbENvbG9yLCBNYXRoLnJvdW5kKTtcbiAgICAgICAgdmFyIGhzbFN0cmluZyA9IFwiaHNsKFwiICsgcm91bmRlZEhzbENvbG9yWzBdICsgXCIsIFwiICsgcm91bmRlZEhzbENvbG9yWzFdICsgXCIlLCBcIiArIHJvdW5kZWRIc2xDb2xvclsyXSArIFwiJSlcIjtcbiAgICAgICAgcmV0dXJuIGhzbFN0cmluZztcbiAgICB9O1xuXG4gICAgdmFyIGhzbENvbG9yRnJvbUhzbFN0cmluZyA9IGZ1bmN0aW9uKGhzbENvbG9yU3RyaW5nKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnaXZlbiBcImhzbChoLHMlLGwlKVwiIHJldHVybnMgW2gscyxsXVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGhzbFZhbHVlU3RyaW5ncyA9IGhzbENvbG9yU3RyaW5nLm1hdGNoKC9eaHNsXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKSVcXHMqLFxccyooXFxkKyklXFxzKlxcKSQvKTtcbiAgICAgICAgaWYgKGhzbFZhbHVlU3RyaW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHNsQ29sb3IgPSBbcGFyc2VJbnQoaHNsVmFsdWVTdHJpbmdzWzFdLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChoc2xWYWx1ZVN0cmluZ3NbMl0sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGhzbFZhbHVlU3RyaW5nc1szXSwgMTApXTtcblxuICAgICAgICByZXR1cm4gaHNsQ29sb3I7XG4gICAgfTtcblxuICAgIHZhciByZ2JDb2xvckZyb21IZXhTdHJpbmcgPSBmdW5jdGlvbihoZXhDb2xvclN0cmluZykge1xuICAgICAgICAvKipcbiAgICAgICAgICogZ2l2ZW4gXCIjUlJHR0JCXCIgcmV0dXJucyBbcixnLGJdXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbm9ybUhleENvbG9yU3RyaW5nID0gbm9ybWFsaXplSGV4U3RyaW5nKGhleENvbG9yU3RyaW5nKTtcbiAgICAgICAgdmFyIGhleFZhbHVlU3RyaW5ncyA9IG5vcm1IZXhDb2xvclN0cmluZy5tYXRjaCgvXiM/KFtcXGRBLUZhLWZdezJ9KShbXFxkQS1GYS1mXXsyfSkoW1xcZEEtRmEtZl17Mn0pJC8pO1xuICAgICAgICBpZiAoaGV4VmFsdWVTdHJpbmdzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZ2JDb2xvciA9IFtwYXJzZUludChoZXhWYWx1ZVN0cmluZ3NbMV0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGhleFZhbHVlU3RyaW5nc1syXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoaGV4VmFsdWVTdHJpbmdzWzNdLCAxNildO1xuXG4gICAgICAgIHJldHVybiByZ2JDb2xvcjtcbiAgICB9O1xuXG4gICAgdmFyIGhleFN0cmluZ0Zyb21SZ2JDb2xvciA9IGZ1bmN0aW9uKHJnYkNvbG9yKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnaXZlbiBbcixnLGJdIHJldHVybnMgXCIjUlJHR0JCXCJcbiAgICAgICAgICogIHIsZyxiIHJvdW5kZWQgdG8gbmVhcmVzdCBpbnRlZ2Vyc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJnYkNvbG9yLmxlbmd0aCAhPSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3VuZGVkUmdiQ29sb3IgPSBfLm1hcChyZ2JDb2xvciwgTWF0aC5yb3VuZCk7XG4gICAgICAgIHZhciBoZXhDb21wb25lbnRzID0gXy5tYXAocm91bmRlZFJnYkNvbG9yLCBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGV4LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaGV4U3RyaW5nID0gXCIjXCIgKyBoZXhDb21wb25lbnRzWzBdICsgaGV4Q29tcG9uZW50c1sxXSArIGhleENvbXBvbmVudHNbMl07XG4gICAgICAgIHJldHVybiBoZXhTdHJpbmc7XG4gICAgfTtcblxuICAgIHZhciBub3JtYWxpemVIZXhTdHJpbmcgPSBmdW5jdGlvbihoZXhTdHJpbmcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdpdmVuIFwicnJnZ2JiXCIsIFwiUlJHR0JCXCIsIFwiI3JyZ2diYlwiLCBcIiNSUkdHQkJcIiByZXR1cm5zIFwiI1JSR0dCQlwiXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbm9ybVN0cmluZyA9ICcjJyArIGhleFN0cmluZy5yZXBsYWNlKCcjJywnJyk7XG4gICAgICAgIG5vcm1TdHJpbmcgPSBub3JtU3RyaW5nLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIC8vIGNoZWNrIGZvciAjUkdCLCB0byBjb252ZXJ0IHRvICNSUkdHQkJcbiAgICAgICAgdmFyIGhleFZhbHVlU3RyaW5ncyA9IG5vcm1TdHJpbmcubWF0Y2goL14jPyhbXFxkQS1GXSkoW1xcZEEtRl0pKFtcXGRBLUZdKSQvKTtcbiAgICAgICAgaWYgKGhleFZhbHVlU3RyaW5ncyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9ybVN0cmluZyA9ICcjJyArIGhleFZhbHVlU3RyaW5nc1sxXSArIGhleFZhbHVlU3RyaW5nc1sxXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4VmFsdWVTdHJpbmdzWzJdICsgaGV4VmFsdWVTdHJpbmdzWzJdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXhWYWx1ZVN0cmluZ3NbM10gKyBoZXhWYWx1ZVN0cmluZ3NbM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1TdHJpbmc7XG4gICAgfTtcblxuICAgIHZhciBtb2RpZnlMdW1pbm9zaXR5T2ZIc2xDb2xvciA9IGZ1bmN0aW9uKGhzbENvbG9yLCBsdW1pbm9zaXR5TXVsdGlwbGllcil7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGp1c3RzIHRoZSBsdW1pbm9zaXR5IG9mIHRoZSBzcGVjaWZpZWQgaHNsIGNvbG9yIGJ5IG11bHRpcGx5aW5nIGJ5IGx1bWlub3NpdHlNdWx0aXBsaWVyXG4gICAgICAgICAqICBsIGlzIGNsYW1wZWQgdG8gd2l0aGluIFswLDEwMF1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBtb2RIc2xDb2xvciA9IGhzbENvbG9yLnNsaWNlKDApO1xuXG4gICAgICAgIG1vZEhzbENvbG9yWzJdICo9IGx1bWlub3NpdHlNdWx0aXBsaWVyO1xuICAgICAgICBpZiAobW9kSHNsQ29sb3JbMl0gPiAxMDApIHtcbiAgICAgICAgICAgIG1vZEhzbENvbG9yWzJdID0gMTAwO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZEhzbENvbG9yWzJdIDwgMCkge1xuICAgICAgICAgICAgbW9kSHNsQ29sb3JbMl0gPSAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kSHNsQ29sb3I7XG4gICAgfTtcblxuICAgIHZhciBtb2RpZnlMdW1pbm9zaXR5T2ZSZ2JDb2xvciA9IGZ1bmN0aW9uKHJnYkNvbG9yLCBsdW1pbm9zaXR5TXVsdGlwbGllcil7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGp1c3RzIHRoZSBsdW1pbm9zaXR5IG9mIHRoZSBzcGVjaWZpZWQgcmdiIGNvbG9yIGJ5IGx1bWlub3NpdHlNdWx0aXBsaWVyXG4gICAgICAgICAqICAgMSAtIGNvbnZlcnQgdG8gaHNsXG4gICAgICAgICAqICAgMiAtIGwgKj0gbHVtaW5vc2l0eU11bHRpcGxpZXIgQU5EIGNsYW1wKDAsMTAwKVxuICAgICAgICAgKiAgIDMgLSBjb252ZXJ0IGJhY2sgdG8gcmdiXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaHNsQ29sb3IgPSBoc2xDb2xvckZyb21SZ2JDb2xvcihyZ2JDb2xvcik7XG4gICAgICAgIHZhciBtb2RIc2xDb2xvciA9IG1vZGlmeUx1bWlub3NpdHlPZkhzbENvbG9yKGhzbENvbG9yLCBsdW1pbm9zaXR5TXVsdGlwbGllcik7XG4gICAgICAgIHZhciBtb2RSZ2JDb2xvciA9IHJnYkNvbG9yRnJvbUhzbENvbG9yKG1vZEhzbENvbG9yKTtcbiAgICAgICAgcmV0dXJuIG1vZFJnYkNvbG9yO1xuICAgIH07XG5cbiAgICB2YXIgbW9kaWZ5THVtaW5vc2l0eU9mSGV4U3RyaW5nID0gZnVuY3Rpb24oaGV4U3RyaW5nLCBsdW1pbm9zaXR5TXVsdGlwbGllcil7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGp1c3RzIHRoZSBsdW1pbm9zaXR5IG9mIHRoZSBzcGVjaWZpZWQgcmdiIGNvbG9yIGJ5IGx1bWlub3NpdHlNdWx0aXBsaWVyXG4gICAgICAgICAqICAgMSAtIGNvbnZlcnQgdG8gcmdiLCB0aGVuIHRvIGhzbFxuICAgICAgICAgKiAgIDIgLSBsICo9IGx1bWlub3NpdHlNdWx0aXBsaWVyIEFORCBjbGFtcCgwLDEwMClcbiAgICAgICAgICogICAzIC0gY29udmVydCBiYWNrIHRvIHJnYiwgdGhlbiB0byBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHZhciByZ2JDb2xvciA9IHJnYkNvbG9yRnJvbUhleFN0cmluZyhoZXhTdHJpbmcpO1xuICAgICAgICB2YXIgbW9kUmdiQ29sb3IgPSBtb2RpZnlMdW1pbm9zaXR5T2ZSZ2JDb2xvcihyZ2JDb2xvciwgbHVtaW5vc2l0eU11bHRpcGxpZXIpO1xuICAgICAgICB2YXIgbW9kSGV4U3RyaW5nID0gaGV4U3RyaW5nRnJvbVJnYkNvbG9yKG1vZFJnYkNvbG9yKTtcbiAgICAgICAgcmV0dXJuIG1vZEhleFN0cmluZztcbiAgICB9O1xuXG4gICAgdmFyIGdlbmVyYXRlR3JhZGllbnRTdHlsZXNXaXRoTWlkQ29sb3IgPSBmdW5jdGlvbihzdGFydENvbG9yLCBtaWRDb2xvciwgY29sb3JTdG9wLCBlbmRDb2xvcil7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIGFycmF5IG9mIGdyYWRpZW50IHN0eWxlIGRpcmVjdGl2ZXMgdGhhdCBjb3ZlciBzZXQgb2YgYnJvd3NlcnNcbiAgICAgICAgICogYnVpbGRzIGdyYWRpZW50IGZyb20gdGhyZWUgY29sb3JzLCBwbGFjZXMgdGhlIG1pZENvbG9yIGF0IGNvbG9yU3RvcCBwZXJjZW50XG4gICAgICAgICAqICBzdGFydENvbG9yLCBtaWRDb2xvciwgZW5kQ29sb3IgYXJlIGNzcyBpbnRlcnByZXRhYmxlIGNvbG9yc1xuICAgICAgICAgKiAgY29sb3JTdG9wIGlzIFwic3RvcCVcIiwgZS5nLiBcIjUwJVwiLCBcIjgwJVwiXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZ3JhZGllbnRzID1cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnIC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCAwIDAsIDAgMTAwJSwgZnJvbShAc3RhcnRDb2xvciksIGNvbG9yLXN0b3AoQGNvbG9yU3RvcCwgQG1pZENvbG9yKSwgdG8oQGVuZENvbG9yKSkgJyxcbiAgICAgICAgICAgICAgICAnIC13ZWJraXQtbGluZWFyLWdyYWRpZW50KEBzdGFydENvbG9yLCBAbWlkQ29sb3IgQGNvbG9yU3RvcCwgQGVuZENvbG9yKSAnLFxuICAgICAgICAgICAgICAgICcgLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCBAc3RhcnRDb2xvciwgQG1pZENvbG9yIEBjb2xvclN0b3AsIEBlbmRDb2xvcikgJyxcbiAgICAgICAgICAgICAgICAnIC1vLWxpbmVhci1ncmFkaWVudChAc3RhcnRDb2xvciwgQG1pZENvbG9yIEBjb2xvclN0b3AsIEBlbmRDb2xvcikgJyxcbiAgICAgICAgICAgICAgICAnIGxpbmVhci1ncmFkaWVudChAc3RhcnRDb2xvciwgQG1pZENvbG9yIEBjb2xvclN0b3AsIEBlbmRDb2xvcikgJyxcbiAgICAgICAgICAgICAgICAvLyBub3RlOiB0aGlzIHVzZXMgZmlsdGVyIGluc3RlYWQgb2YgYmctaW1hZ2VcbiAgICAgICAgICAgICAgICBcIiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nQHN0YXJ0Q29sb3InLCBlbmRDb2xvcnN0cj0nQGVuZENvbG9yJywgR3JhZGllbnRUeXBlPTApIFwiICAvLyBJRTkgYW5kIGRvd24sIGdldHMgbm8gY29sb3Itc3RvcCBhdCBhbGwgZm9yIHByb3BlciBmYWxsYmFja1xuICAgICAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaT0wO2k8Z3JhZGllbnRzLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgZ3JhZGllbnRzW2ldID0gZ3JhZGllbnRzW2ldLnJlcGxhY2UoL0BzdGFydENvbG9yL2csIHN0YXJ0Q29sb3IpO1xuICAgICAgICAgICAgZ3JhZGllbnRzW2ldID0gZ3JhZGllbnRzW2ldLnJlcGxhY2UoL0BtaWRDb2xvci9nLCBtaWRDb2xvcik7XG4gICAgICAgICAgICBncmFkaWVudHNbaV0gPSBncmFkaWVudHNbaV0ucmVwbGFjZSgvQGNvbG9yU3RvcC9nLCBjb2xvclN0b3ApO1xuICAgICAgICAgICAgZ3JhZGllbnRzW2ldID0gZ3JhZGllbnRzW2ldLnJlcGxhY2UoL0BlbmRDb2xvci9nLCBlbmRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYWRpZW50cztcbiAgICB9O1xuXG4gICAgdmFyIGdlbmVyYXRlR3JhZGllbnRTdHlsZXMgPSBmdW5jdGlvbihzdGFydENvbG9yLCBlbmRDb2xvcil7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIGFycmF5IG9mIGdyYWRpZW50IHN0eWxlIGRpcmVjdGl2ZXMgdGhhdCBjb3ZlciBzZXQgb2YgYnJvd3NlcnNcbiAgICAgICAgICogYnVpbGRzIGdyYWRpZW50IGZyb20gdHdvIGNvbG9yc1xuICAgICAgICAgKiAgc3RhcnRDb2xvciwgZW5kQ29sb3IgYXJlIGNzcyBpbnRlcnByZXRhYmxlIGNvbG9yc1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGdyYWRpZW50cyA9XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJyAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsIEBzdGFydENvbG9yLCBAZW5kQ29sb3IpICcsIC8vIEZGIDMuNitcbiAgICAgICAgICAgICAgICAnIC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCAwIDAsIDAgMTAwJSwgZnJvbShAc3RhcnRDb2xvciksIHRvKEBlbmRDb2xvcikpJywgLy8gU2FmYXJpIDQrLCBDaHJvbWUgMitcbiAgICAgICAgICAgICAgICAnIC13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgQHN0YXJ0Q29sb3IsIEBlbmRDb2xvcikgJywgLy8gU2FmYXJpIDUuMSssIENocm9tZSAxMCtcbiAgICAgICAgICAgICAgICAnIC1vLWxpbmVhci1ncmFkaWVudCh0b3AsIEBzdGFydENvbG9yLCBAZW5kQ29sb3IpICcsIC8vIE9wZXJhIDExLjEwXG4gICAgICAgICAgICAgICAgJyBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCBAc3RhcnRDb2xvciwgQGVuZENvbG9yKSAnLCAvLyBTdGFuZGFyZCwgSUUxMFxuICAgICAgICAgICAgICAgIC8vIG5vdGU6IHRoaXMgdXNlcyBmaWx0ZXIgaW5zdGVhZCBvZiBiZy1pbWFnZVxuICAgICAgICAgICAgICAgIFwiIHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPSdAc3RhcnRDb2xvcicsIGVuZENvbG9yc3RyPSdAZW5kQ29sb3InLCBHcmFkaWVudFR5cGU9MCkgIFwiIC8vIElFOSBhbmQgZG93blxuICAgICAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaT0wO2k8Z3JhZGllbnRzLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgZ3JhZGllbnRzW2ldID0gZ3JhZGllbnRzW2ldLnJlcGxhY2UoL0BzdGFydENvbG9yL2csIHN0YXJ0Q29sb3IpO1xuICAgICAgICAgICAgZ3JhZGllbnRzW2ldID0gZ3JhZGllbnRzW2ldLnJlcGxhY2UoL0BlbmRDb2xvci9nLCBlbmRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYWRpZW50cztcbiAgICB9O1xuXG4gICAgLy8gUHJlZml4ZXMgaGV4IHZhbHVlIHdpdGggcHJvdmlkZWQgc3ltYm9scyAoZS5nLiAnMHgnIG9yICcjJylcbiAgICB2YXIgcmVwbGFjZVN5bWJvbHMgPSBmdW5jdGlvbihzdHJpbmcsIHN5bWJvbHMpIHtcbiAgICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaXBwZWRTdHJpbmcgPSB0aGlzLnN0cmlwU3ltYm9scyhzdHJpbmcpO1xuICAgICAgICByZXR1cm4gc3ltYm9scyArIHN0cmlwcGVkU3RyaW5nO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmVzICcweCcgYW5kICcjJyBwcmVmaXhlcyB0byByZXR1cm4ganVzdCB0aGUgY29sb3IgaGV4IHZhbHVlIGl0c2VsZlxuICAgIHZhciBzdHJpcFN5bWJvbHMgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nLnN1YnN0cmluZygwLDIpID09PSAnMHgnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nLnN1YnN0cmluZygwLDEpID09PSAnIycpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcblxuICAgIHZhciBpbnRlcnBvbGF0ZUNvbG9ycyA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCBwKSB7XG4gICAgICAgIHZhciByMSA9IChjb2xvcjEgPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIGcxID0gKGNvbG9yMSA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBiMSA9IGNvbG9yMSAmIDB4RkYsXG5cbiAgICAgICAgICAgIHIyID0gKGNvbG9yMiA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgZzIgPSAoY29sb3IyID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGIyID0gY29sb3IyICYgMHhGRixcblxuICAgICAgICAgICAgckludGVycCA9IHIxICsgTWF0aC5yb3VuZCgocjIgLSByMSkgKiBwKSxcbiAgICAgICAgICAgIGdJbnRlcnAgPSBnMSArIE1hdGgucm91bmQoKGcyIC0gZzEpICogcCksXG4gICAgICAgICAgICBiSW50ZXJwID0gYjEgKyBNYXRoLnJvdW5kKChiMiAtIGIxKSAqIHApO1xuXG4gICAgICAgIHJldHVybiAoKHJJbnRlcnAgPDwgMTYpIHwgKGdJbnRlcnAgPDwgOCkgfCBiSW50ZXJwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaHNsQ29sb3JGcm9tUmdiQ29sb3I6IGhzbENvbG9yRnJvbVJnYkNvbG9yLFxuICAgICAgICByZ2JDb2xvckZyb21Ic2xDb2xvcjogcmdiQ29sb3JGcm9tSHNsQ29sb3IsXG4gICAgICAgIGhzbENvbG9yRnJvbUhzbFN0cmluZzogaHNsQ29sb3JGcm9tSHNsU3RyaW5nLFxuICAgICAgICByZ2JDb2xvckZyb21SZ2JTdHJpbmc6IHJnYkNvbG9yRnJvbVJnYlN0cmluZyxcbiAgICAgICAgaHNsU3RyaW5nRnJvbUhzbENvbG9yOiBoc2xTdHJpbmdGcm9tSHNsQ29sb3IsXG4gICAgICAgIHJnYlN0cmluZ0Zyb21SZ2JDb2xvcjogcmdiU3RyaW5nRnJvbVJnYkNvbG9yLFxuICAgICAgICByZ2JDb2xvckZyb21IZXhTdHJpbmc6IHJnYkNvbG9yRnJvbUhleFN0cmluZyxcbiAgICAgICAgaGV4U3RyaW5nRnJvbVJnYkNvbG9yOiBoZXhTdHJpbmdGcm9tUmdiQ29sb3IsXG4gICAgICAgIG5vcm1hbGl6ZUhleFN0cmluZzogbm9ybWFsaXplSGV4U3RyaW5nLFxuICAgICAgICBtb2RpZnlMdW1pbm9zaXR5T2ZIc2xDb2xvcjogbW9kaWZ5THVtaW5vc2l0eU9mSHNsQ29sb3IsXG4gICAgICAgIG1vZGlmeUx1bWlub3NpdHlPZlJnYkNvbG9yOiBtb2RpZnlMdW1pbm9zaXR5T2ZSZ2JDb2xvcixcbiAgICAgICAgbW9kaWZ5THVtaW5vc2l0eU9mSGV4U3RyaW5nOiBtb2RpZnlMdW1pbm9zaXR5T2ZIZXhTdHJpbmcsXG4gICAgICAgIGdlbmVyYXRlR3JhZGllbnRTdHlsZXNXaXRoTWlkQ29sb3I6IGdlbmVyYXRlR3JhZGllbnRTdHlsZXNXaXRoTWlkQ29sb3IsXG4gICAgICAgIGdlbmVyYXRlR3JhZGllbnRTdHlsZXM6IGdlbmVyYXRlR3JhZGllbnRTdHlsZXMsXG4gICAgICAgIHJlcGxhY2VTeW1ib2xzOiByZXBsYWNlU3ltYm9scyxcbiAgICAgICAgc3RyaXBTeW1ib2xzOiBzdHJpcFN5bWJvbHMsXG4gICAgICAgIGludGVycG9sYXRlQ29sb3JzOiBpbnRlcnBvbGF0ZUNvbG9yc1xuICAgIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy91dGlsL2NvbG9yX3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSB1dGlsL2NvbG9yX3V0aWxzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "util/moment/relative":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"util/moment\"), __webpack_require__(\"require/underscore\")], __WEBPACK_AMD_DEFINE_RESULT__ = function(moment, _) {\n\n    var UNITS = {\n        second: 's,sec,secs,second,seconds',\n        minute: 'm,min,minute,minutes',\n        hour: 'h,hr,hrs,hour,hours',\n        day: 'd,day,days',\n        week: 'w,week,weeks',\n        month: 'mon,month,months',\n        quarter: 'q,qtr,qtrs,quarter,quarters',\n        year: 'y,yr,yrs,year,years'\n    };\n\n    var unitMap = _.once(function() {\n        var result = {};\n        _(UNITS).each(function(aliases, unit) {\n            _(aliases.split(',')).each(function(alias) {\n                result[alias] = unit;\n            });\n        });\n        return result;\n    });\n\n    function parseRemainder(result, remainder) {\n        while (remainder.length) {\n            var match = remainder.match(/([+-]?\\d+)([a-z]\\w*)/);\n            result.push(parseRelativeTimeExpressionPart(remainder));\n            remainder = remainder.substring(match[0].length);\n        }\n    }\n\n    function parseRelativeTimeExpressionPart(part) {\n        if (part == 'now') {\n            return {now: true};\n        } else {\n            var match = part.match(/([+-]?\\d+)([a-z]\\w*)/);\n            if (match) {\n                var amount = match[1];\n                var unit = match[2];\n                var momentUnit = unitMap()[unit];\n                if (!momentUnit) {\n                    throw new Error('Invalid unit ' + JSON.stringify(unit) + ' in relative time expression');\n                }\n                return {\n                    amount: parseInt(amount, 10),\n                    unit: momentUnit\n                };\n            } else {\n                throw new Error('Invalid relative time expression: ' + JSON.stringify(part));\n            }\n        }\n    }\n\n    function parseRelativeTimeExpression(expr, options) {\n        options || (options = {});\n        if (expr == null) {\n            return;\n        }\n        expr = String(expr).trim();\n\n        if (/^-?\\d+$/.test(expr)) {\n            var plainNumber = parseInt(expr, 10);\n            if (options.treatPlainNumberAs) {\n                return [{\n                    amount: plainNumber,\n                    unit: unitMap()[options.treatPlainNumberAs]\n                }];\n            } else if (options.allowAbsoluteValue !== false) {\n                // Absolute/epoch time expression\n                return [{absolute: parseInt(expr, 10)}];\n            } else {\n                throw new Error('Absolute time value ' + JSON.stringify(expr) + 'is not allowed in relative time expression');\n            }\n        }\n\n        var result = [];\n        var parts = expr.split('@', 2);\n\n        if (parts[0] !== '') {\n            result.push(parseRelativeTimeExpressionPart(parts[0]));\n        }\n\n        if (parts.length > 1) {\n            var snap = parts[1].match(/^[a-z]\\w*/);\n            if (snap) {\n                snap = snap[0];\n                var remainder = parts[1].substring(snap.length);\n                var weekday = snap.match(/w([0-6])/);\n                if (weekday) {\n                    result.push({snapTo: 'week'}, {amount: parseInt(weekday[1], 10), unit: 'day'});\n                } else {\n                    var snapUnit = unitMap()[snap];\n                    if (!snapUnit) {\n                        throw new Error('Invalid snap-to unit ' + JSON.stringify(snapUnit) + ' in relative time expression');\n                    }\n                    result.push({snapTo: snapUnit});\n                }\n                if (remainder.length) {\n                    parseRemainder(result, remainder);\n                }\n            } else {\n                throw new Error('Invalid snap-to expression: ' + JSON.stringify(parts[1]));\n            }\n        }\n\n        return result;\n    }\n\n    function applyRelativeTimeExpressionPart(m, expr) {\n        if (expr.absolute != null) {\n            return moment.unix(expr.absolute);\n        } else if (expr.now === true) {\n            return moment();\n        } else if (expr.amount != null) {\n            return moment(m).add(expr.amount, expr.unit);\n        } else if (expr.snapTo) {\n            return moment(m).startOf(expr.snapTo);\n        } else {\n            throw new Error('Invalid parsed time expression part: ' + JSON.stringify(expr));\n        }\n    }\n\n    function applyRelativeTimeExpression(m, parsed) {\n        return _.inject(parsed, applyRelativeTimeExpressionPart, m);\n    }\n\n    moment.fn.applyRelative = function(expr, options) {\n        return applyRelativeTimeExpression(this, parseRelativeTimeExpression(expr, options));\n    };\n\n    function isRelativeTimeExpression(val, options) {\n        try {\n            var parsed = parseRelativeTimeExpression(val, options);\n            return parsed.length > 0;\n        } catch(e) {\n            return false;\n        }\n    }\n    \n    return {\n        parseRelativeTimeExpression: parseRelativeTimeExpression,\n        applyRelativeTimeExpression: applyRelativeTimeExpression,\n        applyRelativeTimeExpressionPart: applyRelativeTimeExpressionPart,\n        isRelativeTimeExpression: isRelativeTimeExpression\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvbW9tZW50L3JlbGF0aXZlLmpzP2RhYjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdFQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlLEdBQUcsOENBQThDO0FBQ2pHLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InV0aWwvbW9tZW50L3JlbGF0aXZlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFsndXRpbC9tb21lbnQnLCAndW5kZXJzY29yZSddLCBmdW5jdGlvbihtb21lbnQsIF8pIHtcblxuICAgIHZhciBVTklUUyA9IHtcbiAgICAgICAgc2Vjb25kOiAncyxzZWMsc2VjcyxzZWNvbmQsc2Vjb25kcycsXG4gICAgICAgIG1pbnV0ZTogJ20sbWluLG1pbnV0ZSxtaW51dGVzJyxcbiAgICAgICAgaG91cjogJ2gsaHIsaHJzLGhvdXIsaG91cnMnLFxuICAgICAgICBkYXk6ICdkLGRheSxkYXlzJyxcbiAgICAgICAgd2VlazogJ3csd2Vlayx3ZWVrcycsXG4gICAgICAgIG1vbnRoOiAnbW9uLG1vbnRoLG1vbnRocycsXG4gICAgICAgIHF1YXJ0ZXI6ICdxLHF0cixxdHJzLHF1YXJ0ZXIscXVhcnRlcnMnLFxuICAgICAgICB5ZWFyOiAneSx5cix5cnMseWVhcix5ZWFycydcbiAgICB9O1xuXG4gICAgdmFyIHVuaXRNYXAgPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgXyhVTklUUykuZWFjaChmdW5jdGlvbihhbGlhc2VzLCB1bml0KSB7XG4gICAgICAgICAgICBfKGFsaWFzZXMuc3BsaXQoJywnKSkuZWFjaChmdW5jdGlvbihhbGlhcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFthbGlhc10gPSB1bml0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VSZW1haW5kZXIocmVzdWx0LCByZW1haW5kZXIpIHtcbiAgICAgICAgd2hpbGUgKHJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHJlbWFpbmRlci5tYXRjaCgvKFsrLV0/XFxkKykoW2Etel1cXHcqKS8pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VSZWxhdGl2ZVRpbWVFeHByZXNzaW9uUGFydChyZW1haW5kZXIpKTtcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IHJlbWFpbmRlci5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUmVsYXRpdmVUaW1lRXhwcmVzc2lvblBhcnQocGFydCkge1xuICAgICAgICBpZiAocGFydCA9PSAnbm93Jykge1xuICAgICAgICAgICAgcmV0dXJuIHtub3c6IHRydWV9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcGFydC5tYXRjaCgvKFsrLV0/XFxkKykoW2Etel1cXHcqKS8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFtb3VudCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgdmFyIG1vbWVudFVuaXQgPSB1bml0TWFwKClbdW5pdF07XG4gICAgICAgICAgICAgICAgaWYgKCFtb21lbnRVbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0ICcgKyBKU09OLnN0cmluZ2lmeSh1bml0KSArICcgaW4gcmVsYXRpdmUgdGltZSBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogcGFyc2VJbnQoYW1vdW50LCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHVuaXQ6IG1vbWVudFVuaXRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVsYXRpdmUgdGltZSBleHByZXNzaW9uOiAnICsgSlNPTi5zdHJpbmdpZnkocGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VSZWxhdGl2ZVRpbWVFeHByZXNzaW9uKGV4cHIsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgaWYgKGV4cHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIgPSBTdHJpbmcoZXhwcikudHJpbSgpO1xuXG4gICAgICAgIGlmICgvXi0/XFxkKyQvLnRlc3QoZXhwcikpIHtcbiAgICAgICAgICAgIHZhciBwbGFpbk51bWJlciA9IHBhcnNlSW50KGV4cHIsIDEwKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRyZWF0UGxhaW5OdW1iZXJBcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHBsYWluTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICB1bml0OiB1bml0TWFwKClbb3B0aW9ucy50cmVhdFBsYWluTnVtYmVyQXNdXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dBYnNvbHV0ZVZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIEFic29sdXRlL2Vwb2NoIHRpbWUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIHJldHVybiBbe2Fic29sdXRlOiBwYXJzZUludChleHByLCAxMCl9XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBYnNvbHV0ZSB0aW1lIHZhbHVlICcgKyBKU09OLnN0cmluZ2lmeShleHByKSArICdpcyBub3QgYWxsb3dlZCBpbiByZWxhdGl2ZSB0aW1lIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHBhcnRzID0gZXhwci5zcGxpdCgnQCcsIDIpO1xuXG4gICAgICAgIGlmIChwYXJ0c1swXSAhPT0gJycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlUmVsYXRpdmVUaW1lRXhwcmVzc2lvblBhcnQocGFydHNbMF0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgc25hcCA9IHBhcnRzWzFdLm1hdGNoKC9eW2Etel1cXHcqLyk7XG4gICAgICAgICAgICBpZiAoc25hcCkge1xuICAgICAgICAgICAgICAgIHNuYXAgPSBzbmFwWzBdO1xuICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSBwYXJ0c1sxXS5zdWJzdHJpbmcoc25hcC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gc25hcC5tYXRjaCgvdyhbMC02XSkvKTtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7c25hcFRvOiAnd2Vlayd9LCB7YW1vdW50OiBwYXJzZUludCh3ZWVrZGF5WzFdLCAxMCksIHVuaXQ6ICdkYXknfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXBVbml0ID0gdW5pdE1hcCgpW3NuYXBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNuYXBVbml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc25hcC10byB1bml0ICcgKyBKU09OLnN0cmluZ2lmeShzbmFwVW5pdCkgKyAnIGluIHJlbGF0aXZlIHRpbWUgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtzbmFwVG86IHNuYXBVbml0fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlUmVtYWluZGVyKHJlc3VsdCwgcmVtYWluZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzbmFwLXRvIGV4cHJlc3Npb246ICcgKyBKU09OLnN0cmluZ2lmeShwYXJ0c1sxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVJlbGF0aXZlVGltZUV4cHJlc3Npb25QYXJ0KG0sIGV4cHIpIHtcbiAgICAgICAgaWYgKGV4cHIuYWJzb2x1dGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC51bml4KGV4cHIuYWJzb2x1dGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cHIubm93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwci5hbW91bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudChtKS5hZGQoZXhwci5hbW91bnQsIGV4cHIudW5pdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwci5zbmFwVG8pIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQobSkuc3RhcnRPZihleHByLnNuYXBUbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyc2VkIHRpbWUgZXhwcmVzc2lvbiBwYXJ0OiAnICsgSlNPTi5zdHJpbmdpZnkoZXhwcikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlSZWxhdGl2ZVRpbWVFeHByZXNzaW9uKG0sIHBhcnNlZCkge1xuICAgICAgICByZXR1cm4gXy5pbmplY3QocGFyc2VkLCBhcHBseVJlbGF0aXZlVGltZUV4cHJlc3Npb25QYXJ0LCBtKTtcbiAgICB9XG5cbiAgICBtb21lbnQuZm4uYXBwbHlSZWxhdGl2ZSA9IGZ1bmN0aW9uKGV4cHIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5UmVsYXRpdmVUaW1lRXhwcmVzc2lvbih0aGlzLCBwYXJzZVJlbGF0aXZlVGltZUV4cHJlc3Npb24oZXhwciwgb3B0aW9ucykpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1JlbGF0aXZlVGltZUV4cHJlc3Npb24odmFsLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVRpbWVFeHByZXNzaW9uKHZhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkLmxlbmd0aCA+IDA7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcnNlUmVsYXRpdmVUaW1lRXhwcmVzc2lvbjogcGFyc2VSZWxhdGl2ZVRpbWVFeHByZXNzaW9uLFxuICAgICAgICBhcHBseVJlbGF0aXZlVGltZUV4cHJlc3Npb246IGFwcGx5UmVsYXRpdmVUaW1lRXhwcmVzc2lvbixcbiAgICAgICAgYXBwbHlSZWxhdGl2ZVRpbWVFeHByZXNzaW9uUGFydDogYXBwbHlSZWxhdGl2ZVRpbWVFeHByZXNzaW9uUGFydCxcbiAgICAgICAgaXNSZWxhdGl2ZVRpbWVFeHByZXNzaW9uOiBpc1JlbGF0aXZlVGltZUV4cHJlc3Npb25cbiAgICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3dlYi9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvdXRpbC9tb21lbnQvcmVsYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IHV0aWwvbW9tZW50L3JlbGF0aXZlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ "util/theme_utils":
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n__webpack_require__(10);\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getCurrentTheme = getCurrentTheme;\nexports.getXmlEditorTheme = getXmlEditorTheme;\nexports.getSearchEditorTheme = getSearchEditorTheme;\nvar defaultTheme = 'light';\n\nfunction getCurrentTheme() {\n    // eslint-disable-next-line no-underscore-dangle\n    return window.__splunk_page_theme__ || defaultTheme;\n}\n\nfunction getXmlEditorTheme() {\n    var pageTheme = getCurrentTheme();\n    return pageTheme === 'dark' ? 'ace/theme/xml-dark' : 'ace/theme/chrome';\n}\n\nfunction getSearchEditorTheme() {\n    var pageTheme = getCurrentTheme();\n    return pageTheme === 'dark' ? 'dark' : 'light';\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvdGhlbWVfdXRpbHMuZXM/NTE3ZiJdLCJuYW1lcyI6WyJnZXRDdXJyZW50VGhlbWUiLCJnZXRYbWxFZGl0b3JUaGVtZSIsImdldFNlYXJjaEVkaXRvclRoZW1lIiwiZGVmYXVsdFRoZW1lIiwid2luZG93IiwiX19zcGx1bmtfcGFnZV90aGVtZV9fIiwicGFnZVRoZW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O1FBRWdCQSxlLEdBQUFBLGU7UUFLQUMsaUIsR0FBQUEsaUI7UUFLQUMsb0IsR0FBQUEsb0I7QUFaaEIsSUFBTUMsZUFBZSxPQUFyQjs7QUFFTyxTQUFTSCxlQUFULEdBQTJCO0FBQzlCO0FBQ0EsV0FBT0ksT0FBT0MscUJBQVAsSUFBZ0NGLFlBQXZDO0FBQ0g7O0FBRU0sU0FBU0YsaUJBQVQsR0FBNkI7QUFDaEMsUUFBTUssWUFBWU4saUJBQWxCO0FBQ0EsV0FBT00sY0FBYyxNQUFkLEdBQXVCLG9CQUF2QixHQUE4QyxrQkFBckQ7QUFDSDs7QUFFTSxTQUFTSixvQkFBVCxHQUFnQztBQUNuQyxRQUFNSSxZQUFZTixpQkFBbEI7QUFDQSxXQUFPTSxjQUFjLE1BQWQsR0FBdUIsTUFBdkIsR0FBZ0MsT0FBdkM7QUFDSCIsImZpbGUiOiJ1dGlsL3RoZW1lX3V0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGVmYXVsdFRoZW1lID0gJ2xpZ2h0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRUaGVtZSgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICByZXR1cm4gd2luZG93Ll9fc3BsdW5rX3BhZ2VfdGhlbWVfXyB8fCBkZWZhdWx0VGhlbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRYbWxFZGl0b3JUaGVtZSgpIHtcbiAgICBjb25zdCBwYWdlVGhlbWUgPSBnZXRDdXJyZW50VGhlbWUoKTtcbiAgICByZXR1cm4gcGFnZVRoZW1lID09PSAnZGFyaycgPyAnYWNlL3RoZW1lL3htbC1kYXJrJyA6ICdhY2UvdGhlbWUvY2hyb21lJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlYXJjaEVkaXRvclRoZW1lKCkge1xuICAgIGNvbnN0IHBhZ2VUaGVtZSA9IGdldEN1cnJlbnRUaGVtZSgpO1xuICAgIHJldHVybiBwYWdlVGhlbWUgPT09ICdkYXJrJyA/ICdkYXJrJyA6ICdsaWdodCc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3V0aWwvdGhlbWVfdXRpbHMuZXMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ "splunk/palettes/ColorCodes":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\n    var Class = __webpack_require__(\"contrib/jg_lib/Class\");\n    var Color = __webpack_require__(\"contrib/jg_lib/graphics/Color\");\n\n    return Class(module.id, function(ColorCodes) {\n\n        // Public Static Constants\n\n        ColorCodes.CATEGORICAL = [\n            \"#006d9c\", \"#4fa484\", \"#ec9960\", \"#af575a\", \"#b6c75a\", \"#62b3b2\", \"#294e70\", \"#738795\", \"#edd051\", \"#bd9872\",\n            \"#5a4575\", \"#7ea77b\", \"#708794\", \"#d7c6b7\", \"#339bb2\", \"#55672d\", \"#e6e1ae\", \"#96907f\", \"#87bc65\", \"#cf7e60\",\n            \"#7b5547\", \"#77d6d8\", \"#4a7f2c\", \"#f589ad\", \"#6a2c5d\", \"#aaabae\", \"#9a7438\", \"#a4d563\", \"#7672a4\", \"#184b81\",\n            \"#7fb6ce\", \"#a7d2c2\", \"#f6ccb0\", \"#d7abad\", \"#dbe3ad\", \"#b1d9d9\", \"#94a7b8\", \"#b9c3ca\", \"#f6e8a8\", \"#deccb9\",\n            \"#b7acca\", \"#b2cab0\", \"#a5b2bf\", \"#e9ddd4\", \"#66c3d0\", \"#aab396\", \"#f3f0d7\", \"#c1bcb3\", \"#b6d7a3\", \"#e1b2a1\",\n            \"#dec4ba\", \"#abe6e8\", \"#91b282\", \"#f8b7ce\", \"#cba3c2\", \"#cccdce\", \"#c3ab89\", \"#c7e6a3\", \"#ada9c8\", \"#a4bbe0\"\n        ];\n\n        ColorCodes.CATEGORICAL_DARK = ColorCodes.CATEGORICAL; // @pwied: for now we use the same colors in dark mode\n\n        ColorCodes.SEMANTIC_BY_NAME = {\n            success: \"#53a051\",\n            info: \"#006d9c\",\n            warning: \"#f8be34\",\n            alert: \"#f1813f\",\n            error: \"#dc4e41\"\n        };\n\n        ColorCodes.SEMANTIC = [\n            ColorCodes.SEMANTIC_BY_NAME.success,\n            ColorCodes.SEMANTIC_BY_NAME.info,\n            ColorCodes.SEMANTIC_BY_NAME.warning,\n            ColorCodes.SEMANTIC_BY_NAME.alert,\n            ColorCodes.SEMANTIC_BY_NAME.error\n        ];\n\n        ColorCodes.SEMANTIC_DARK = ColorCodes.SEMANTIC;\n\n        ColorCodes.SEQUENTIAL = [\n            ColorCodes.SEMANTIC_BY_NAME.success,\n            ColorCodes.SEMANTIC_BY_NAME.error,\n            ColorCodes.SEMANTIC_BY_NAME.info\n        ];\n\n        ColorCodes.DIVERGENT_PAIRS = [\n            [\"#006D9C\", \"#EC9960\"],\n            [\"#62B3B2\", \"#AF575A\"],\n            [\"#AF575A\", \"#F8BE34\"],\n            [\"#F8BE34\", \"#4FA484\"],\n            [\"#708794\", \"#5A4575\"],\n            [\"#294E70\", \"#B6C75A\"]\n        ];\n\n        ColorCodes.DARK_GREY = '#3c444d';\n\n        // Public Static Methods\n\n        ColorCodes.toColors = function(codes) {\n            var colors = [];\n            for (var i = 0, l = codes.length; i < l; i++) {\n                colors.push(Color.fromString(codes[i]));\n            }\n            return colors;\n        };\n\n        ColorCodes.toNumbers = function(codes) {\n            var numbers = [];\n            for (var i = 0, l = codes.length; i < l; i++) {\n                numbers.push(Color.fromString(codes[i]).toNumber());\n            }\n            return numbers;\n        };\n\n        ColorCodes.toArrays = function(codes) {\n            var arrays = [];\n            for (var i = 0, l = codes.length; i < l; i++) {\n                arrays.push(Color.fromString(codes[i]).toArray());\n            }\n            return arrays;\n        };\n\n        ColorCodes.toPrefixed = function(codes, prefix) {\n            var prefixed = [];\n            for (var i = 0, l = codes.length; i < l; i++) {\n                prefixed.push(prefix + codes[i].replace(/^(0x|#)/, \"\"));\n            }\n            return prefixed;\n        };\n\n    });\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NwbHVuay9wYWxldHRlcy9Db2xvckNvZGVzLmpzP2M3ZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImtDQUFBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTCxDQUFDIiwiZmlsZSI6InNwbHVuay9wYWxldHRlcy9Db2xvckNvZGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gICAgdmFyIENsYXNzID0gcmVxdWlyZShcImpnL0NsYXNzXCIpO1xuICAgIHZhciBDb2xvciA9IHJlcXVpcmUoXCJqZy9ncmFwaGljcy9Db2xvclwiKTtcblxuICAgIHJldHVybiBDbGFzcyhtb2R1bGUuaWQsIGZ1bmN0aW9uKENvbG9yQ29kZXMpIHtcblxuICAgICAgICAvLyBQdWJsaWMgU3RhdGljIENvbnN0YW50c1xuXG4gICAgICAgIENvbG9yQ29kZXMuQ0FURUdPUklDQUwgPSBbXG4gICAgICAgICAgICBcIiMwMDZkOWNcIiwgXCIjNGZhNDg0XCIsIFwiI2VjOTk2MFwiLCBcIiNhZjU3NWFcIiwgXCIjYjZjNzVhXCIsIFwiIzYyYjNiMlwiLCBcIiMyOTRlNzBcIiwgXCIjNzM4Nzk1XCIsIFwiI2VkZDA1MVwiLCBcIiNiZDk4NzJcIixcbiAgICAgICAgICAgIFwiIzVhNDU3NVwiLCBcIiM3ZWE3N2JcIiwgXCIjNzA4Nzk0XCIsIFwiI2Q3YzZiN1wiLCBcIiMzMzliYjJcIiwgXCIjNTU2NzJkXCIsIFwiI2U2ZTFhZVwiLCBcIiM5NjkwN2ZcIiwgXCIjODdiYzY1XCIsIFwiI2NmN2U2MFwiLFxuICAgICAgICAgICAgXCIjN2I1NTQ3XCIsIFwiIzc3ZDZkOFwiLCBcIiM0YTdmMmNcIiwgXCIjZjU4OWFkXCIsIFwiIzZhMmM1ZFwiLCBcIiNhYWFiYWVcIiwgXCIjOWE3NDM4XCIsIFwiI2E0ZDU2M1wiLCBcIiM3NjcyYTRcIiwgXCIjMTg0YjgxXCIsXG4gICAgICAgICAgICBcIiM3ZmI2Y2VcIiwgXCIjYTdkMmMyXCIsIFwiI2Y2Y2NiMFwiLCBcIiNkN2FiYWRcIiwgXCIjZGJlM2FkXCIsIFwiI2IxZDlkOVwiLCBcIiM5NGE3YjhcIiwgXCIjYjljM2NhXCIsIFwiI2Y2ZThhOFwiLCBcIiNkZWNjYjlcIixcbiAgICAgICAgICAgIFwiI2I3YWNjYVwiLCBcIiNiMmNhYjBcIiwgXCIjYTViMmJmXCIsIFwiI2U5ZGRkNFwiLCBcIiM2NmMzZDBcIiwgXCIjYWFiMzk2XCIsIFwiI2YzZjBkN1wiLCBcIiNjMWJjYjNcIiwgXCIjYjZkN2EzXCIsIFwiI2UxYjJhMVwiLFxuICAgICAgICAgICAgXCIjZGVjNGJhXCIsIFwiI2FiZTZlOFwiLCBcIiM5MWIyODJcIiwgXCIjZjhiN2NlXCIsIFwiI2NiYTNjMlwiLCBcIiNjY2NkY2VcIiwgXCIjYzNhYjg5XCIsIFwiI2M3ZTZhM1wiLCBcIiNhZGE5YzhcIiwgXCIjYTRiYmUwXCJcbiAgICAgICAgXTtcblxuICAgICAgICBDb2xvckNvZGVzLkNBVEVHT1JJQ0FMX0RBUksgPSBDb2xvckNvZGVzLkNBVEVHT1JJQ0FMOyAvLyBAcHdpZWQ6IGZvciBub3cgd2UgdXNlIHRoZSBzYW1lIGNvbG9ycyBpbiBkYXJrIG1vZGVcblxuICAgICAgICBDb2xvckNvZGVzLlNFTUFOVElDX0JZX05BTUUgPSB7XG4gICAgICAgICAgICBzdWNjZXNzOiBcIiM1M2EwNTFcIixcbiAgICAgICAgICAgIGluZm86IFwiIzAwNmQ5Y1wiLFxuICAgICAgICAgICAgd2FybmluZzogXCIjZjhiZTM0XCIsXG4gICAgICAgICAgICBhbGVydDogXCIjZjE4MTNmXCIsXG4gICAgICAgICAgICBlcnJvcjogXCIjZGM0ZTQxXCJcbiAgICAgICAgfTtcblxuICAgICAgICBDb2xvckNvZGVzLlNFTUFOVElDID0gW1xuICAgICAgICAgICAgQ29sb3JDb2Rlcy5TRU1BTlRJQ19CWV9OQU1FLnN1Y2Nlc3MsXG4gICAgICAgICAgICBDb2xvckNvZGVzLlNFTUFOVElDX0JZX05BTUUuaW5mbyxcbiAgICAgICAgICAgIENvbG9yQ29kZXMuU0VNQU5USUNfQllfTkFNRS53YXJuaW5nLFxuICAgICAgICAgICAgQ29sb3JDb2Rlcy5TRU1BTlRJQ19CWV9OQU1FLmFsZXJ0LFxuICAgICAgICAgICAgQ29sb3JDb2Rlcy5TRU1BTlRJQ19CWV9OQU1FLmVycm9yXG4gICAgICAgIF07XG5cbiAgICAgICAgQ29sb3JDb2Rlcy5TRU1BTlRJQ19EQVJLID0gQ29sb3JDb2Rlcy5TRU1BTlRJQztcblxuICAgICAgICBDb2xvckNvZGVzLlNFUVVFTlRJQUwgPSBbXG4gICAgICAgICAgICBDb2xvckNvZGVzLlNFTUFOVElDX0JZX05BTUUuc3VjY2VzcyxcbiAgICAgICAgICAgIENvbG9yQ29kZXMuU0VNQU5USUNfQllfTkFNRS5lcnJvcixcbiAgICAgICAgICAgIENvbG9yQ29kZXMuU0VNQU5USUNfQllfTkFNRS5pbmZvXG4gICAgICAgIF07XG5cbiAgICAgICAgQ29sb3JDb2Rlcy5ESVZFUkdFTlRfUEFJUlMgPSBbXG4gICAgICAgICAgICBbXCIjMDA2RDlDXCIsIFwiI0VDOTk2MFwiXSxcbiAgICAgICAgICAgIFtcIiM2MkIzQjJcIiwgXCIjQUY1NzVBXCJdLFxuICAgICAgICAgICAgW1wiI0FGNTc1QVwiLCBcIiNGOEJFMzRcIl0sXG4gICAgICAgICAgICBbXCIjRjhCRTM0XCIsIFwiIzRGQTQ4NFwiXSxcbiAgICAgICAgICAgIFtcIiM3MDg3OTRcIiwgXCIjNUE0NTc1XCJdLFxuICAgICAgICAgICAgW1wiIzI5NEU3MFwiLCBcIiNCNkM3NUFcIl1cbiAgICAgICAgXTtcblxuICAgICAgICBDb2xvckNvZGVzLkRBUktfR1JFWSA9ICcjM2M0NDRkJztcblxuICAgICAgICAvLyBQdWJsaWMgU3RhdGljIE1ldGhvZHNcblxuICAgICAgICBDb2xvckNvZGVzLnRvQ29sb3JzID0gZnVuY3Rpb24oY29kZXMpIHtcbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzLnB1c2goQ29sb3IuZnJvbVN0cmluZyhjb2Rlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICAgICAgfTtcblxuICAgICAgICBDb2xvckNvZGVzLnRvTnVtYmVycyA9IGZ1bmN0aW9uKGNvZGVzKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBudW1iZXJzLnB1c2goQ29sb3IuZnJvbVN0cmluZyhjb2Rlc1tpXSkudG9OdW1iZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVycztcbiAgICAgICAgfTtcblxuICAgICAgICBDb2xvckNvZGVzLnRvQXJyYXlzID0gZnVuY3Rpb24oY29kZXMpIHtcbiAgICAgICAgICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlzLnB1c2goQ29sb3IuZnJvbVN0cmluZyhjb2Rlc1tpXSkudG9BcnJheSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgQ29sb3JDb2Rlcy50b1ByZWZpeGVkID0gZnVuY3Rpb24oY29kZXMsIHByZWZpeCkge1xuICAgICAgICAgICAgdmFyIHByZWZpeGVkID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHByZWZpeGVkLnB1c2gocHJlZml4ICsgY29kZXNbaV0ucmVwbGFjZSgvXigweHwjKS8sIFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmVmaXhlZDtcbiAgICAgICAgfTtcblxuICAgIH0pO1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmsvcGFsZXR0ZXMvQ29sb3JDb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gc3BsdW5rL3BhbGV0dGVzL0NvbG9yQ29kZXNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ "contrib/jg_lib/graphics/Color":
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Copyright (c) 2007-2016 Jason Gatt\n * \n * Released under the MIT license:\n * http://opensource.org/licenses/MIT\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module)\n{\n\n\tvar Class = __webpack_require__(\"contrib/jg_lib/Class\");\n\tvar NumberUtil = __webpack_require__(\"contrib/jg_lib/utils/NumberUtil\");\n\n\treturn Class(module.id, Object, function(Color, base)\n\t{\n\n\t\t// Private Static Constants\n\n\t\tvar _R_COLOR = /^\\s*(?:(?:(?:#|0x)([0-9A-F]*))|([^\\(\\)]+)|(?:(?:(?:rgba|(rgb))\\s*)?\\(([^\\(\\)]*)\\)))\\s*$/i;\n\t\tvar _R_PERCENT = /([^%]*)%\\s*$/;\n\n\t\t// Public Static Methods\n\n\t\tColor.interpolate = function(color1, color2, ratio)\n\t\t{\n\t\t\tvar r = NumberUtil.interpolate(color1.r, color2.r, ratio);\n\t\t\tvar g = NumberUtil.interpolate(color1.g, color2.g, ratio);\n\t\t\tvar b = NumberUtil.interpolate(color1.b, color2.b, ratio);\n\t\t\tvar a = NumberUtil.interpolate(color1.a, color2.a, ratio);\n\n\t\t\treturn new Color(r, g, b, a).normalize();\n\t\t};\n\n\t\tColor.fromNumber = function(num)\n\t\t{\n\t\t\tnum = +num;\n\t\t\tnum = (num > 0x000000) ? Math.min(Math.floor(num), 0xFFFFFF) : 0x000000;\n\n\t\t\tvar r = (num >> 16) & 0xFF;\n\t\t\tvar g = (num >> 8) & 0xFF;\n\t\t\tvar b = num & 0xFF;\n\n\t\t\treturn new Color(r, g, b);\n\t\t};\n\n\t\tColor.fromArray = function(arr)\n\t\t{\n\t\t\tvar length = arr.length;\n\t\t\tvar r = (length > 0) ? arr[0] : 0;\n\t\t\tvar g = (length > 1) ? arr[1] : 0;\n\t\t\tvar b = (length > 2) ? arr[2] : 0;\n\t\t\tvar a = (length > 3) ? arr[3] : 1;\n\n\t\t\treturn new Color(r, g, b, a);\n\t\t};\n\n\t\tColor.fromString = function(str)\n\t\t{\n\t\t\tvar match = (\"\" + str).match(_R_COLOR);\n\t\t\tif (!match)\n\t\t\t\treturn new Color();\n\n\t\t\t// #RGB #RRGGBB 0xRGB 0xRRGGBB\n\t\t\tif (match[1] != null)\n\t\t\t\treturn Color.fromNumber(_parseHex(match[1]));\n\n\t\t\t// R,G,B,A\n\t\t\tif (match[2] != null)\n\t\t\t\treturn Color.fromArray(_parseRGBA(match[2]));\n\n\t\t\t// (R,G,B,A) rgba(R,G,B,A) rgb(R,G,B)\n\t\t\tif (match[4] != null)\n\t\t\t\treturn Color.fromArray(_parseRGBA(match[4], (match[3] != null)));\n\n\t\t\treturn new Color();\n\t\t};\n\n\t\t// Private Static Methods\n\n\t\tvar _parseHex = function(str)\n\t\t{\n\t\t\tif (!str)\n\t\t\t\treturn 0x000000;\n\n\t\t\tif (str.length === 3)\n\t\t\t{\n\t\t\t\tvar rgb = str.split(\"\");\n\t\t\t\trgb[0] = rgb[0] + rgb[0];\n\t\t\t\trgb[1] = rgb[1] + rgb[1];\n\t\t\t\trgb[2] = rgb[2] + rgb[2];\n\t\t\t\tstr = rgb.join(\"\");\n\t\t\t}\n\n\t\t\treturn parseInt(str, 16);\n\t\t};\n\n\t\tvar _parseRGBA = function(str, ignoreAlpha)\n\t\t{\n\t\t\tvar arr = str.split(\",\");\n\t\t\tvar length = arr.length;\n\t\t\tvar maxLength = (ignoreAlpha === true) ? 3 : 4;\n\t\t\tvar match;\n\n\t\t\tif (length > maxLength)\n\t\t\t{\n\t\t\t\tarr.splice(maxLength, length - maxLength);\n\t\t\t\tlength = maxLength;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t{\n\t\t\t\tstr = arr[i];\n\t\t\t\tmatch = str.match(_R_PERCENT);\n\t\t\t\tif (match)\n\t\t\t\t\tarr[i] = (i < 3) ? Math.round(255 * (match[1] / 100)) : (match[1] / 100);\n\t\t\t\telse\n\t\t\t\t\tarr[i] = +str;\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t};\n\n\t\t// Public Properties\n\n\t\tthis.r = 0;\n\t\tthis.g = 0;\n\t\tthis.b = 0;\n\t\tthis.a = 1;\n\n\t\t// Constructor\n\n\t\tthis.constructor = function(r, g, b, a)\n\t\t{\n\t\t\tthis.r = (r != null) ? +r : 0;\n\t\t\tthis.g = (g != null) ? +g : 0;\n\t\t\tthis.b = (b != null) ? +b : 0;\n\t\t\tthis.a = (a != null) ? +a : 1;\n\t\t};\n\n\t\t// Public Methods\n\n\t\tthis.lighten = function(ratio)\n\t\t{\n\t\t\tratio = Math.max(ratio, 0);\n\n\t\t\tvar r = NumberUtil.interpolate(this.r, 255, ratio);\n\t\t\tvar g = NumberUtil.interpolate(this.g, 255, ratio);\n\t\t\tvar b = NumberUtil.interpolate(this.b, 255, ratio);\n\n\t\t\tthis.r = (r > 0) ? Math.min(Math.round(r), 255) : 0;\n\t\t\tthis.g = (g > 0) ? Math.min(Math.round(g), 255) : 0;\n\t\t\tthis.b = (b > 0) ? Math.min(Math.round(b), 255) : 0;\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.darken = function(ratio)\n\t\t{\n\t\t\tratio = Math.max(ratio, 0);\n\n\t\t\tvar r = NumberUtil.interpolate(this.r, 0, ratio);\n\t\t\tvar g = NumberUtil.interpolate(this.g, 0, ratio);\n\t\t\tvar b = NumberUtil.interpolate(this.b, 0, ratio);\n\n\t\t\tthis.r = (r > 0) ? Math.min(Math.round(r), 255) : 0;\n\t\t\tthis.g = (g > 0) ? Math.min(Math.round(g), 255) : 0;\n\t\t\tthis.b = (b > 0) ? Math.min(Math.round(b), 255) : 0;\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.invert = function()\n\t\t{\n\t\t\tvar r = 255 - this.r;\n\t\t\tvar g = 255 - this.g;\n\t\t\tvar b = 255 - this.b;\n\n\t\t\tthis.r = (r > 0) ? Math.min(Math.round(r), 255) : 0;\n\t\t\tthis.g = (g > 0) ? Math.min(Math.round(g), 255) : 0;\n\t\t\tthis.b = (b > 0) ? Math.min(Math.round(b), 255) : 0;\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.normalize = function()\n\t\t{\n\t\t\tvar r = +this.r;\n\t\t\tvar g = +this.g;\n\t\t\tvar b = +this.b;\n\t\t\tvar a = +this.a;\n\n\t\t\tthis.r = (r > 0) ? Math.min(Math.round(r), 255) : 0;\n\t\t\tthis.g = (g > 0) ? Math.min(Math.round(g), 255) : 0;\n\t\t\tthis.b = (b > 0) ? Math.min(Math.round(b), 255) : 0;\n\t\t\tthis.a = (a > 0) ? Math.min(a, 1) : 0;\n\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.hasNaN = function()\n\t\t{\n\t\t\treturn (isNaN(this.r) ||\n\t\t\t        isNaN(this.g) ||\n\t\t\t        isNaN(this.b) ||\n\t\t\t        isNaN(this.a));\n\t\t};\n\n\t\tthis.hasInfinity = function()\n\t\t{\n\t\t\treturn ((this.r == Infinity) || (this.r == -Infinity) ||\n\t\t\t        (this.g == Infinity) || (this.g == -Infinity) ||\n\t\t\t        (this.b == Infinity) || (this.b == -Infinity) ||\n\t\t\t        (this.a == Infinity) || (this.a == -Infinity));\n\t\t};\n\n\t\tthis.isFinite = function()\n\t\t{\n\t\t\treturn (((this.r - this.r) === 0) &&\n\t\t\t        ((this.g - this.g) === 0) &&\n\t\t\t        ((this.b - this.b) === 0) &&\n\t\t\t        ((this.a - this.a) === 0));\n\t\t};\n\n\t\tthis.approxEquals = function(color, threshold)\n\t\t{\n\t\t\treturn (NumberUtil.approxEqual(this.r, color.r, threshold) &&\n\t\t\t        NumberUtil.approxEqual(this.g, color.g, threshold) &&\n\t\t\t        NumberUtil.approxEqual(this.b, color.b, threshold) &&\n\t\t\t        NumberUtil.approxEqual(this.a, color.a, threshold));\n\t\t};\n\n\t\tthis.equals = function(color)\n\t\t{\n\t\t\treturn ((this.r == color.r) &&\n\t\t\t        (this.g == color.g) &&\n\t\t\t        (this.b == color.b) &&\n\t\t\t        (this.a == color.a));\n\t\t};\n\n\t\tthis.clone = function()\n\t\t{\n\t\t\treturn new Color(this.r, this.g, this.b, this.a);\n\t\t};\n\n\t\tthis.toNumber = function()\n\t\t{\n\t\t\tvar r = +this.r;\n\t\t\tvar g = +this.g;\n\t\t\tvar b = +this.b;\n\n\t\t\tr = (r > 0) ? Math.min(Math.round(r), 255) : 0;\n\t\t\tg = (g > 0) ? Math.min(Math.round(g), 255) : 0;\n\t\t\tb = (b > 0) ? Math.min(Math.round(b), 255) : 0;\n\n\t\t\treturn ((r << 16) | (g << 8) | b);\n\t\t};\n\n\t\tthis.toArray = function(normalize)\n\t\t{\n\t\t\tvar r = +this.r;\n\t\t\tvar g = +this.g;\n\t\t\tvar b = +this.b;\n\t\t\tvar a = +this.a;\n\n\t\t\tif (normalize === true)\n\t\t\t{\n\t\t\t\tr = (r > 0) ? Math.min(Math.round(r), 255) : 0;\n\t\t\t\tg = (g > 0) ? Math.min(Math.round(g), 255) : 0;\n\t\t\t\tb = (b > 0) ? Math.min(Math.round(b), 255) : 0;\n\t\t\t\ta = (a > 0) ? Math.min(a, 1) : 0;\n\t\t\t}\n\n\t\t\treturn [ r, g, b, a ];\n\t\t};\n\n\t\tthis.toString = function(format, normalize)\n\t\t{\n\t\t\tif (format === \"hex\")\n\t\t\t{\n\t\t\t\tvar hex = this.toNumber().toString(16).toUpperCase();\n\t\t\t\tfor (var i = hex.length; i < 6; i++)\n\t\t\t\t\thex = \"0\" + hex;\n\t\t\t\treturn \"#\" + hex;\n\t\t\t}\n\n\t\t\tvar r = +this.r;\n\t\t\tvar g = +this.g;\n\t\t\tvar b = +this.b;\n\t\t\tvar a = +this.a;\n\n\t\t\tif ((format === true) || (normalize === true))\n\t\t\t{\n\t\t\t\tr = (r > 0) ? Math.min(Math.round(r), 255) : 0;\n\t\t\t\tg = (g > 0) ? Math.min(Math.round(g), 255) : 0;\n\t\t\t\tb = (b > 0) ? Math.min(Math.round(b), 255) : 0;\n\t\t\t\ta = (a > 0) ? Math.min(a, 1) : 0;\n\t\t\t}\n\n\t\t\tif (format === \"rgba\")\n\t\t\t\treturn \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n\n\t\t\tif (format === \"rgb\")\n\t\t\t\treturn \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n\n\t\t\treturn \"(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n\t\t};\n\n\t});\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy93ZWIvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL2NvbnRyaWIvamdfbGliL2dyYXBoaWNzL0NvbG9yLmpzPzBlM2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGLENBQUMiLCJmaWxlIjoiY29udHJpYi9qZ19saWIvZ3JhcGhpY3MvQ29sb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAwNy0yMDE2IEphc29uIEdhdHRcbiAqIFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKVxue1xuXG5cdHZhciBDbGFzcyA9IHJlcXVpcmUoXCIuLi9DbGFzc1wiKTtcblx0dmFyIE51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbHMvTnVtYmVyVXRpbFwiKTtcblxuXHRyZXR1cm4gQ2xhc3MobW9kdWxlLmlkLCBPYmplY3QsIGZ1bmN0aW9uKENvbG9yLCBiYXNlKVxuXHR7XG5cblx0XHQvLyBQcml2YXRlIFN0YXRpYyBDb25zdGFudHNcblxuXHRcdHZhciBfUl9DT0xPUiA9IC9eXFxzKig/Oig/Oig/OiN8MHgpKFswLTlBLUZdKikpfChbXlxcKFxcKV0rKXwoPzooPzooPzpyZ2JhfChyZ2IpKVxccyopP1xcKChbXlxcKFxcKV0qKVxcKSkpXFxzKiQvaTtcblx0XHR2YXIgX1JfUEVSQ0VOVCA9IC8oW14lXSopJVxccyokLztcblxuXHRcdC8vIFB1YmxpYyBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0Q29sb3IuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMiwgcmF0aW8pXG5cdFx0e1xuXHRcdFx0dmFyIHIgPSBOdW1iZXJVdGlsLmludGVycG9sYXRlKGNvbG9yMS5yLCBjb2xvcjIuciwgcmF0aW8pO1xuXHRcdFx0dmFyIGcgPSBOdW1iZXJVdGlsLmludGVycG9sYXRlKGNvbG9yMS5nLCBjb2xvcjIuZywgcmF0aW8pO1xuXHRcdFx0dmFyIGIgPSBOdW1iZXJVdGlsLmludGVycG9sYXRlKGNvbG9yMS5iLCBjb2xvcjIuYiwgcmF0aW8pO1xuXHRcdFx0dmFyIGEgPSBOdW1iZXJVdGlsLmludGVycG9sYXRlKGNvbG9yMS5hLCBjb2xvcjIuYSwgcmF0aW8pO1xuXG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpLm5vcm1hbGl6ZSgpO1xuXHRcdH07XG5cblx0XHRDb2xvci5mcm9tTnVtYmVyID0gZnVuY3Rpb24obnVtKVxuXHRcdHtcblx0XHRcdG51bSA9ICtudW07XG5cdFx0XHRudW0gPSAobnVtID4gMHgwMDAwMDApID8gTWF0aC5taW4oTWF0aC5mbG9vcihudW0pLCAweEZGRkZGRikgOiAweDAwMDAwMDtcblxuXHRcdFx0dmFyIHIgPSAobnVtID4+IDE2KSAmIDB4RkY7XG5cdFx0XHR2YXIgZyA9IChudW0gPj4gOCkgJiAweEZGO1xuXHRcdFx0dmFyIGIgPSBudW0gJiAweEZGO1xuXG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIpO1xuXHRcdH07XG5cblx0XHRDb2xvci5mcm9tQXJyYXkgPSBmdW5jdGlvbihhcnIpXG5cdFx0e1xuXHRcdFx0dmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cdFx0XHR2YXIgciA9IChsZW5ndGggPiAwKSA/IGFyclswXSA6IDA7XG5cdFx0XHR2YXIgZyA9IChsZW5ndGggPiAxKSA/IGFyclsxXSA6IDA7XG5cdFx0XHR2YXIgYiA9IChsZW5ndGggPiAyKSA/IGFyclsyXSA6IDA7XG5cdFx0XHR2YXIgYSA9IChsZW5ndGggPiAzKSA/IGFyclszXSA6IDE7XG5cblx0XHRcdHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XG5cdFx0fTtcblxuXHRcdENvbG9yLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpXG5cdFx0e1xuXHRcdFx0dmFyIG1hdGNoID0gKFwiXCIgKyBzdHIpLm1hdGNoKF9SX0NPTE9SKTtcblx0XHRcdGlmICghbWF0Y2gpXG5cdFx0XHRcdHJldHVybiBuZXcgQ29sb3IoKTtcblxuXHRcdFx0Ly8gI1JHQiAjUlJHR0JCIDB4UkdCIDB4UlJHR0JCXG5cdFx0XHRpZiAobWF0Y2hbMV0gIT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIENvbG9yLmZyb21OdW1iZXIoX3BhcnNlSGV4KG1hdGNoWzFdKSk7XG5cblx0XHRcdC8vIFIsRyxCLEFcblx0XHRcdGlmIChtYXRjaFsyXSAhPSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gQ29sb3IuZnJvbUFycmF5KF9wYXJzZVJHQkEobWF0Y2hbMl0pKTtcblxuXHRcdFx0Ly8gKFIsRyxCLEEpIHJnYmEoUixHLEIsQSkgcmdiKFIsRyxCKVxuXHRcdFx0aWYgKG1hdGNoWzRdICE9IG51bGwpXG5cdFx0XHRcdHJldHVybiBDb2xvci5mcm9tQXJyYXkoX3BhcnNlUkdCQShtYXRjaFs0XSwgKG1hdGNoWzNdICE9IG51bGwpKSk7XG5cblx0XHRcdHJldHVybiBuZXcgQ29sb3IoKTtcblx0XHR9O1xuXG5cdFx0Ly8gUHJpdmF0ZSBTdGF0aWMgTWV0aG9kc1xuXG5cdFx0dmFyIF9wYXJzZUhleCA9IGZ1bmN0aW9uKHN0cilcblx0XHR7XG5cdFx0XHRpZiAoIXN0cilcblx0XHRcdFx0cmV0dXJuIDB4MDAwMDAwO1xuXG5cdFx0XHRpZiAoc3RyLmxlbmd0aCA9PT0gMylcblx0XHRcdHtcblx0XHRcdFx0dmFyIHJnYiA9IHN0ci5zcGxpdChcIlwiKTtcblx0XHRcdFx0cmdiWzBdID0gcmdiWzBdICsgcmdiWzBdO1xuXHRcdFx0XHRyZ2JbMV0gPSByZ2JbMV0gKyByZ2JbMV07XG5cdFx0XHRcdHJnYlsyXSA9IHJnYlsyXSArIHJnYlsyXTtcblx0XHRcdFx0c3RyID0gcmdiLmpvaW4oXCJcIik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXJzZUludChzdHIsIDE2KTtcblx0XHR9O1xuXG5cdFx0dmFyIF9wYXJzZVJHQkEgPSBmdW5jdGlvbihzdHIsIGlnbm9yZUFscGhhKVxuXHRcdHtcblx0XHRcdHZhciBhcnIgPSBzdHIuc3BsaXQoXCIsXCIpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cdFx0XHR2YXIgbWF4TGVuZ3RoID0gKGlnbm9yZUFscGhhID09PSB0cnVlKSA/IDMgOiA0O1xuXHRcdFx0dmFyIG1hdGNoO1xuXG5cdFx0XHRpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKVxuXHRcdFx0e1xuXHRcdFx0XHRhcnIuc3BsaWNlKG1heExlbmd0aCwgbGVuZ3RoIC0gbWF4TGVuZ3RoKTtcblx0XHRcdFx0bGVuZ3RoID0gbWF4TGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRzdHIgPSBhcnJbaV07XG5cdFx0XHRcdG1hdGNoID0gc3RyLm1hdGNoKF9SX1BFUkNFTlQpO1xuXHRcdFx0XHRpZiAobWF0Y2gpXG5cdFx0XHRcdFx0YXJyW2ldID0gKGkgPCAzKSA/IE1hdGgucm91bmQoMjU1ICogKG1hdGNoWzFdIC8gMTAwKSkgOiAobWF0Y2hbMV0gLyAxMDApO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YXJyW2ldID0gK3N0cjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFycjtcblx0XHR9O1xuXG5cdFx0Ly8gUHVibGljIFByb3BlcnRpZXNcblxuXHRcdHRoaXMuciA9IDA7XG5cdFx0dGhpcy5nID0gMDtcblx0XHR0aGlzLmIgPSAwO1xuXHRcdHRoaXMuYSA9IDE7XG5cblx0XHQvLyBDb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHIsIGcsIGIsIGEpXG5cdFx0e1xuXHRcdFx0dGhpcy5yID0gKHIgIT0gbnVsbCkgPyArciA6IDA7XG5cdFx0XHR0aGlzLmcgPSAoZyAhPSBudWxsKSA/ICtnIDogMDtcblx0XHRcdHRoaXMuYiA9IChiICE9IG51bGwpID8gK2IgOiAwO1xuXHRcdFx0dGhpcy5hID0gKGEgIT0gbnVsbCkgPyArYSA6IDE7XG5cdFx0fTtcblxuXHRcdC8vIFB1YmxpYyBNZXRob2RzXG5cblx0XHR0aGlzLmxpZ2h0ZW4gPSBmdW5jdGlvbihyYXRpbylcblx0XHR7XG5cdFx0XHRyYXRpbyA9IE1hdGgubWF4KHJhdGlvLCAwKTtcblxuXHRcdFx0dmFyIHIgPSBOdW1iZXJVdGlsLmludGVycG9sYXRlKHRoaXMuciwgMjU1LCByYXRpbyk7XG5cdFx0XHR2YXIgZyA9IE51bWJlclV0aWwuaW50ZXJwb2xhdGUodGhpcy5nLCAyNTUsIHJhdGlvKTtcblx0XHRcdHZhciBiID0gTnVtYmVyVXRpbC5pbnRlcnBvbGF0ZSh0aGlzLmIsIDI1NSwgcmF0aW8pO1xuXG5cdFx0XHR0aGlzLnIgPSAociA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChyKSwgMjU1KSA6IDA7XG5cdFx0XHR0aGlzLmcgPSAoZyA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChnKSwgMjU1KSA6IDA7XG5cdFx0XHR0aGlzLmIgPSAoYiA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChiKSwgMjU1KSA6IDA7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHR0aGlzLmRhcmtlbiA9IGZ1bmN0aW9uKHJhdGlvKVxuXHRcdHtcblx0XHRcdHJhdGlvID0gTWF0aC5tYXgocmF0aW8sIDApO1xuXG5cdFx0XHR2YXIgciA9IE51bWJlclV0aWwuaW50ZXJwb2xhdGUodGhpcy5yLCAwLCByYXRpbyk7XG5cdFx0XHR2YXIgZyA9IE51bWJlclV0aWwuaW50ZXJwb2xhdGUodGhpcy5nLCAwLCByYXRpbyk7XG5cdFx0XHR2YXIgYiA9IE51bWJlclV0aWwuaW50ZXJwb2xhdGUodGhpcy5iLCAwLCByYXRpbyk7XG5cblx0XHRcdHRoaXMuciA9IChyID4gMCkgPyBNYXRoLm1pbihNYXRoLnJvdW5kKHIpLCAyNTUpIDogMDtcblx0XHRcdHRoaXMuZyA9IChnID4gMCkgPyBNYXRoLm1pbihNYXRoLnJvdW5kKGcpLCAyNTUpIDogMDtcblx0XHRcdHRoaXMuYiA9IChiID4gMCkgPyBNYXRoLm1pbihNYXRoLnJvdW5kKGIpLCAyNTUpIDogMDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHRoaXMuaW52ZXJ0ID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHZhciByID0gMjU1IC0gdGhpcy5yO1xuXHRcdFx0dmFyIGcgPSAyNTUgLSB0aGlzLmc7XG5cdFx0XHR2YXIgYiA9IDI1NSAtIHRoaXMuYjtcblxuXHRcdFx0dGhpcy5yID0gKHIgPiAwKSA/IE1hdGgubWluKE1hdGgucm91bmQociksIDI1NSkgOiAwO1xuXHRcdFx0dGhpcy5nID0gKGcgPiAwKSA/IE1hdGgubWluKE1hdGgucm91bmQoZyksIDI1NSkgOiAwO1xuXHRcdFx0dGhpcy5iID0gKGIgPiAwKSA/IE1hdGgubWluKE1hdGgucm91bmQoYiksIDI1NSkgOiAwO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0dGhpcy5ub3JtYWxpemUgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dmFyIHIgPSArdGhpcy5yO1xuXHRcdFx0dmFyIGcgPSArdGhpcy5nO1xuXHRcdFx0dmFyIGIgPSArdGhpcy5iO1xuXHRcdFx0dmFyIGEgPSArdGhpcy5hO1xuXG5cdFx0XHR0aGlzLnIgPSAociA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChyKSwgMjU1KSA6IDA7XG5cdFx0XHR0aGlzLmcgPSAoZyA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChnKSwgMjU1KSA6IDA7XG5cdFx0XHR0aGlzLmIgPSAoYiA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChiKSwgMjU1KSA6IDA7XG5cdFx0XHR0aGlzLmEgPSAoYSA+IDApID8gTWF0aC5taW4oYSwgMSkgOiAwO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0dGhpcy5oYXNOYU4gPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIChpc05hTih0aGlzLnIpIHx8XG5cdFx0XHQgICAgICAgIGlzTmFOKHRoaXMuZykgfHxcblx0XHRcdCAgICAgICAgaXNOYU4odGhpcy5iKSB8fFxuXHRcdFx0ICAgICAgICBpc05hTih0aGlzLmEpKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5oYXNJbmZpbml0eSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gKCh0aGlzLnIgPT0gSW5maW5pdHkpIHx8ICh0aGlzLnIgPT0gLUluZmluaXR5KSB8fFxuXHRcdFx0ICAgICAgICAodGhpcy5nID09IEluZmluaXR5KSB8fCAodGhpcy5nID09IC1JbmZpbml0eSkgfHxcblx0XHRcdCAgICAgICAgKHRoaXMuYiA9PSBJbmZpbml0eSkgfHwgKHRoaXMuYiA9PSAtSW5maW5pdHkpIHx8XG5cdFx0XHQgICAgICAgICh0aGlzLmEgPT0gSW5maW5pdHkpIHx8ICh0aGlzLmEgPT0gLUluZmluaXR5KSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuaXNGaW5pdGUgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICgoKHRoaXMuciAtIHRoaXMucikgPT09IDApICYmXG5cdFx0XHQgICAgICAgICgodGhpcy5nIC0gdGhpcy5nKSA9PT0gMCkgJiZcblx0XHRcdCAgICAgICAgKCh0aGlzLmIgLSB0aGlzLmIpID09PSAwKSAmJlxuXHRcdFx0ICAgICAgICAoKHRoaXMuYSAtIHRoaXMuYSkgPT09IDApKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5hcHByb3hFcXVhbHMgPSBmdW5jdGlvbihjb2xvciwgdGhyZXNob2xkKVxuXHRcdHtcblx0XHRcdHJldHVybiAoTnVtYmVyVXRpbC5hcHByb3hFcXVhbCh0aGlzLnIsIGNvbG9yLnIsIHRocmVzaG9sZCkgJiZcblx0XHRcdCAgICAgICAgTnVtYmVyVXRpbC5hcHByb3hFcXVhbCh0aGlzLmcsIGNvbG9yLmcsIHRocmVzaG9sZCkgJiZcblx0XHRcdCAgICAgICAgTnVtYmVyVXRpbC5hcHByb3hFcXVhbCh0aGlzLmIsIGNvbG9yLmIsIHRocmVzaG9sZCkgJiZcblx0XHRcdCAgICAgICAgTnVtYmVyVXRpbC5hcHByb3hFcXVhbCh0aGlzLmEsIGNvbG9yLmEsIHRocmVzaG9sZCkpO1xuXHRcdH07XG5cblx0XHR0aGlzLmVxdWFscyA9IGZ1bmN0aW9uKGNvbG9yKVxuXHRcdHtcblx0XHRcdHJldHVybiAoKHRoaXMuciA9PSBjb2xvci5yKSAmJlxuXHRcdFx0ICAgICAgICAodGhpcy5nID09IGNvbG9yLmcpICYmXG5cdFx0XHQgICAgICAgICh0aGlzLmIgPT0gY29sb3IuYikgJiZcblx0XHRcdCAgICAgICAgKHRoaXMuYSA9PSBjb2xvci5hKSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xuXHRcdH07XG5cblx0XHR0aGlzLnRvTnVtYmVyID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHZhciByID0gK3RoaXMucjtcblx0XHRcdHZhciBnID0gK3RoaXMuZztcblx0XHRcdHZhciBiID0gK3RoaXMuYjtcblxuXHRcdFx0ciA9IChyID4gMCkgPyBNYXRoLm1pbihNYXRoLnJvdW5kKHIpLCAyNTUpIDogMDtcblx0XHRcdGcgPSAoZyA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChnKSwgMjU1KSA6IDA7XG5cdFx0XHRiID0gKGIgPiAwKSA/IE1hdGgubWluKE1hdGgucm91bmQoYiksIDI1NSkgOiAwO1xuXG5cdFx0XHRyZXR1cm4gKChyIDw8IDE2KSB8IChnIDw8IDgpIHwgYik7XG5cdFx0fTtcblxuXHRcdHRoaXMudG9BcnJheSA9IGZ1bmN0aW9uKG5vcm1hbGl6ZSlcblx0XHR7XG5cdFx0XHR2YXIgciA9ICt0aGlzLnI7XG5cdFx0XHR2YXIgZyA9ICt0aGlzLmc7XG5cdFx0XHR2YXIgYiA9ICt0aGlzLmI7XG5cdFx0XHR2YXIgYSA9ICt0aGlzLmE7XG5cblx0XHRcdGlmIChub3JtYWxpemUgPT09IHRydWUpXG5cdFx0XHR7XG5cdFx0XHRcdHIgPSAociA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChyKSwgMjU1KSA6IDA7XG5cdFx0XHRcdGcgPSAoZyA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChnKSwgMjU1KSA6IDA7XG5cdFx0XHRcdGIgPSAoYiA+IDApID8gTWF0aC5taW4oTWF0aC5yb3VuZChiKSwgMjU1KSA6IDA7XG5cdFx0XHRcdGEgPSAoYSA+IDApID8gTWF0aC5taW4oYSwgMSkgOiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gWyByLCBnLCBiLCBhIF07XG5cdFx0fTtcblxuXHRcdHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbihmb3JtYXQsIG5vcm1hbGl6ZSlcblx0XHR7XG5cdFx0XHRpZiAoZm9ybWF0ID09PSBcImhleFwiKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgaGV4ID0gdGhpcy50b051bWJlcigpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gaGV4Lmxlbmd0aDsgaSA8IDY7IGkrKylcblx0XHRcdFx0XHRoZXggPSBcIjBcIiArIGhleDtcblx0XHRcdFx0cmV0dXJuIFwiI1wiICsgaGV4O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgciA9ICt0aGlzLnI7XG5cdFx0XHR2YXIgZyA9ICt0aGlzLmc7XG5cdFx0XHR2YXIgYiA9ICt0aGlzLmI7XG5cdFx0XHR2YXIgYSA9ICt0aGlzLmE7XG5cblx0XHRcdGlmICgoZm9ybWF0ID09PSB0cnVlKSB8fCAobm9ybWFsaXplID09PSB0cnVlKSlcblx0XHRcdHtcblx0XHRcdFx0ciA9IChyID4gMCkgPyBNYXRoLm1pbihNYXRoLnJvdW5kKHIpLCAyNTUpIDogMDtcblx0XHRcdFx0ZyA9IChnID4gMCkgPyBNYXRoLm1pbihNYXRoLnJvdW5kKGcpLCAyNTUpIDogMDtcblx0XHRcdFx0YiA9IChiID4gMCkgPyBNYXRoLm1pbihNYXRoLnJvdW5kKGIpLCAyNTUpIDogMDtcblx0XHRcdFx0YSA9IChhID4gMCkgPyBNYXRoLm1pbihhLCAxKSA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmb3JtYXQgPT09IFwicmdiYVwiKVxuXHRcdFx0XHRyZXR1cm4gXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLFwiICsgYSArIFwiKVwiO1xuXG5cdFx0XHRpZiAoZm9ybWF0ID09PSBcInJnYlwiKVxuXHRcdFx0XHRyZXR1cm4gXCJyZ2IoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIpXCI7XG5cblx0XHRcdHJldHVybiBcIihcIiArIHIgKyBcIixcIiArIGcgKyBcIixcIiArIGIgKyBcIixcIiArIGEgKyBcIilcIjtcblx0XHR9O1xuXG5cdH0pO1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZXMvd2ViL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9jb250cmliL2pnX2xpYi9ncmFwaGljcy9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gY29udHJpYi9qZ19saWIvZ3JhcGhpY3MvQ29sb3Jcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 165:
/***/ (function(module, exports, __webpack_require__) {

	eval("var DateProto = Date.prototype;\nvar INVALID_DATE = 'Invalid Date';\nvar TO_STRING = 'toString';\nvar $toString = DateProto[TO_STRING];\nvar getTime = DateProto.getTime;\nif (new Date(NaN) + '' != INVALID_DATE) {\n  __webpack_require__(26)(DateProto, TO_STRING, function toString() {\n    var value = getTime.call(this);\n    // eslint-disable-next-line no-self-compare\n    return value === value ? $toString.call(this) : INVALID_DATE;\n  });\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanM/NTRkNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIxNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGF0ZVByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG52YXIgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSc7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZiAobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSkge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ })

/******/ });