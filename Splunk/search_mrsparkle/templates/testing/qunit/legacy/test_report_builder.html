<%inherit file="//qunit/template.html" />

<%def name="title()">Report Builder -- QUnit tests</%def>

<script type="text/javascript" src="/en-US/static/js/contrib/swfobject.js"></script>
<script type="text/javascript" src="/en-US/static/js/contrib/jquery-ui-1.10.4.min.js"></script>
<script type="text/javascript" src="/en-US/static/js/ja_bridge.js"></script>
<script type="text/javascript" src="/en-US/static/js/jobber.js"></script>
<script type="text/javascript" src="/en-US/static/js/job.js"></script>
<script type="text/javascript" src="/en-US/static/js/context.js"></script>
<script type="text/javascript" src="/en-US/static/js/search.js"></script>
<script type="text/javascript" src="/en-US/static/js/menu_builder.js"></script>
<script type="text/javascript" src="/en-US/static/js/time_range.js"></script>
<script type="text/javascript" src="/en-US/static/js/module_loader.js"></script>
<script type="text/javascript" src="/en-US/static/js/page_status.js"></script>
<script language="javascript">
    // important to disable the chatty debug that the tests spew.
    //Splunk.Logger.mode.Default = Splunk.Logger.mode.None
</script>

<script type="text/javascript" src="/en-US/static/js/test_utils.js"></script>


<script type="text/javascript" src="/en-US/static/js/init.js"></script>


<!--  Now the modules  -->
<script type="text/javascript" src="/en-US/modules/AbstractModule.js"></script>
<script type="text/javascript" src="/en-US/modules/DispatchingModule.js"></script>
<script type="text/javascript" src="/en-US/modules/gandalf/BaseReportBuilderField.js"></script>

<script type="text/javascript" src="/en-US/modules/gandalf/report_type/ReportType.js"></script>
<script type="text/javascript" src="/en-US/modules/gandalf/report_type/ReportSubType.js"></script>

<script type="text/javascript" src="/en-US/modules/gandalf/fields/StatChooser.js"></script>
<script type="text/javascript" src="/en-US/modules/gandalf/fields/SingleFieldChooser.js"></script>
<script type="text/javascript" src="/en-US/modules/gandalf/fields/SplitByChooser.js"></script>
<script type="text/javascript" src="/en-US/modules/gandalf/search_field/ReportBuilderSearchField.js"></script>
<script type="text/javascript" src="/en-US/modules/gandalf/search_field/AdvancedModeToggle.js"></script>
<script type="text/javascript" src="/en-US/modules/gandalf/time_range_binning/TimeRangeBinning.js"></script>


<div id="test_area"></div>


<script language="javascript">
    // VERY IMPORTANT.  In certain cases Jobs will get automatically dispatched
    // whenever addChild is called.  
    // test harness mode short-circuits default behaviour.
    Splunk._testHarnessMode = true;

    Splunk.Globals['Jobber']._getStatus = function() {};


    var logger = Splunk.Logger.getLogger("ReportBuilder", Splunk.Logger.mode.Firebug);

    var moduleTypes = getModuleTypes();
    
    /*
     * template method used by callForEachModule and callForEachCombination. 
     * Until we have mako tests that can run the module's mako templates themselves, 
     * implement this method in your tests to provide matching markup for the 
     * classes you are testing.
     */
    function generateInstance(className) {
        var container = $("<div/>");
        switch (className) {
        case "AdvancedModeToggle" :
            container = $('<div class="SplunkModule AdvancedModeToggle"><h3 style="display: inline;">Search String</h3>���<a class="advancedModeToggle" href="#">advanced</a></div>');
            break;
        case "ReportType" :
            container = $('<div class="SplunkModule ReportType"><fieldset><label for="ReportType_0_2_1_select">Report type</label><select id="ReportType_0_2_1_select"><option selected="selected" value="">Choose...</option><option value="timechart">Values over time</option><option value="top">Top values</option><option value="rare">Rare values</option><option value="chart">DISTRIBUTION (TK)</option></select></fieldset><div/></div>');
            break;
         case "ReportSubType":
            container = $('<div class="SplunkModule ReportSubType"><fieldset><label for="ReportSubType_0_3_0_select">Report will display</label><select id="ReportSubType_0_3_0_select"><option value="none">Single field over time</option><option value="multiple">Multiple fields over time</option><option value="single">Single field split by another field</option></select></fieldset><div/></div>');
            break;
        case "StatChooser" :
            container = $('<div class="SplunkModule StatChooser" style="display: block;"><fieldset class=""><label for="StatChooser_0_5_1_select">Show</label><select id="StatChooser_0_5_1_select"><option value="count">Count</option><option value="dc">Distinct count</option><option value="avg">Average</option><option value="median">Median</option><option value="mode">Mode</option><option value="max">Maximum</option><option value="min">Minimum</option><option value="sum">Sum</option><option value="var">Variance</option><option value="stdev">Standard deviation</option></select><a href="#" class="insertAdditionalSeries">[add series]</a></fieldset>        <div/></div>');
            break;
        case "SingleFieldChooser" :
            container = $('<div class="SplunkModule SingleFieldChooser"><fieldset><label for="SingleFieldChooser_0_5_0_select">of</label><select id="SingleFieldChooser_0_5_0_select"><option value="__events">Events</option><option value="eps" s:isnumeric="true">eps</option><option value="component">component</option></select><a href="#" class="deleteSeries">[remove]</a></fieldset><div/></div>');
            break;
        case "SplitByChooser" : 
            container = $('<div id="SplitByChooser_0_7_0" s:parentmodule="#SingleFieldChooser_0_6_0" class="SplunkModule SplitByChooser" style="display: none;"><fieldset><label for="SplitByChooser_0_7_0_select">by</label><select id="SplitByChooser_0_7_0_select"><option value="">( no split by )</option><option value="eps">eps</option><option value="component">component</option></select></fieldset></div>');
            break;
       
        case "TimeRangeBinning" :
            container = $('<div id="TimeRangeBinning_0_8_0" s:parentmodule="#SplitByChooser_0_7_0" class="SplunkModule TimeRangeBinning" style="display: block;"><fieldset><label for="TimeRangeBinning_0_8_0_input">Time span for each bin (leave blank for it to be determined automatically)</label><input type="text" id="TimeRangeBinning_0_8_0_input"/><select id="TimeRangeBinning_0_8_0_select"><option value="s">second</option><option value="m">minute</option><option value="h">hour</option><option value="d">day</option><option value="w">week</option><option value="mon">month</option></select></fieldset></div>');
            break;

        case "ReportBuilderSearchField" :
            container = $('<div id="ReportBuilderSearchField_0_9_0" s:parentmodule="#TimeRangeBinning_0_8_0" class="SplunkModule ReportBuilderSearchField"><textarea style="width: 100%;" disabled=""></textarea></div>');
            break;

        }
        container.appendTo($('#test_area'));
        return new Splunk.Module[className](container);
    }

    // ******************************************
    // UTILS
    // ******************************************

    function getModuleReferenceFromHierarchy(hierarchyList, moduleName) {
        for (var i=0, lim=hierarchyList.length; i<lim; i++) {
            if (hierarchyList[i].moduleType == "Splunk.Module." + moduleName) return hierarchyList[i];
        }
    }
    

    var hierarchiesUnderTest = {};
    hierarchiesUnderTest["standard"] = ["ReportType", "ReportSubType","StatChooser","SingleFieldChooser", "SplitByChooser"];

    hierarchiesUnderTest["advanced"] = ["AdvancedModeToggle", "ReportType", "ReportSubType","StatChooser","SingleFieldChooser", "SplitByChooser", "ReportBuilderSearchField"];

    
    function buildHierarchy(name) {
        $('#test_area').empty();

        var reportBuilderModules = [];
        var moduleSequence = hierarchiesUnderTest[name];

        for (var i=0,lim=moduleSequence.length; i<lim; i++) {
            reportBuilderModules[i] = generateInstance(moduleSequence[i]);
            reportBuilderModules[i].container.appendTo($('#test_area'));

            if (i>0) {
                reportBuilderModules[i-1].addChild(reportBuilderModules[i]);
            }
        }
        // wire up the async methods that they call directly to their own rendering code to make it blocking
        getModuleReferenceFromHierarchy(reportBuilderModules, "SingleFieldChooser").getResults = function() {
            var bakedOutput = $('<root><summary><field k="component"/><field k="eps"/></summary></root>');
            this.renderResults(bakedOutput);
        }
        getModuleReferenceFromHierarchy(reportBuilderModules, "SplitByChooser").getResults = function() {
            var bakedOutput = $('<root><summary><field k="component"/><field k="eps"/></summary></root>');
            this.renderResults(bakedOutput);
        }
        reportBuilderModules[0].printHierarchy();
        return reportBuilderModules;
    }
    


    function getPlotIntention() {
        var plotIntention = {"name":"plot","arg":{}};
        return plotIntention;
    }
    function wrapIntentionWithContext(intention) {
        var context = new Splunk.Context();
        var search  = new Splunk.Search();
        search.addIntention(intention);
        context.set("search", search);
        return context;
    }
    
    // GENERAL TESTS.
    // ******************************************

    // just a really basic check that when a reportType module has any gandalf child, 
    // they together produce a plot intention of some kind.
    function test_sanityCheck() {
       callForEachModule(
            function (moduleUnderTest) {
                var reportType =  generateInstance("ReportType");
                reportType.onLoadStatusChange(Splunk.util.moduleLoadStates.MAX);
                moduleUnderTest.onLoadStatusChange(Splunk.util.moduleLoadStates.MAX);
                
                reportType._selectElement.val("timechart").change();
                reportType.addChild(moduleUnderTest);
                
                var context = moduleUnderTest.getModifiedContext();
                var search  = context.get("search");
                var plotIntention = search.popIntention("plot");
                var prefix = "When ReportType has a " + moduleUnderTest.moduleType + " child. it should have ";
                assertEquals(prefix + "the right name", "plot", plotIntention["name"]);
                assertTrue(prefix + "an arg", plotIntention.hasOwnProperty("arg"));
                assertTrue(prefix + "a mode", plotIntention["arg"].hasOwnProperty("mode"));
            }
        )
    }

    // ******************************************
    // CONTEXT AND INTENTION TESTS.
    // ******************************************
    function test_getModifiedContext() {
        callForEachModule(
            function (moduleUnderTest) {
                // we put in a foo: bar into the args, to make sure arbitrary preexisting values are preserved.
                var plotIntention = {name: "plot", arg: {foo: "bar"}};
                var serializedPlotIntention = JSON.stringify(plotIntention["arg"]);
                
                moduleUnderTest.baseContext = wrapIntentionWithContext(plotIntention);
                moduleUnderTest.onContextChange();
                $("option", moduleUnderTest.container).each(function(i, optionElement) {
                    $(optionElement).attr("selected", "true");
                
                    logger.debug("testing " + moduleUnderTest.moduleType + ", with value " + $(optionElement).attr("value"));
                    var modifiedContext = moduleUnderTest.getModifiedContext();
                    var modifiedSearch  = modifiedContext.get("search");
                    var modifiedIntention = modifiedSearch.popIntention("plot");
                    assertEquals("should have the right name", "plot", modifiedIntention["name"]);
                    assertEquals("should have the foo bar arg", "bar", modifiedIntention["arg"]["foo"]);
                    if (moduleUnderTest.isCompatibleWithIntention(plotIntention) && $(optionElement).attr("value") && $(optionElement).attr("value")!="none") {
                        logger.debug("intention came out as " + JSON.stringify(modifiedIntention["arg"]));
                        assertNotEquals("if the pulldown option, had a non empty value (" + $(optionElement).attr("value") + "), then it should have done something to our intention", serializedPlotIntention, JSON.stringify(modifiedIntention["arg"]))
                    }
                });
            }
        );
    }
    function test_contextChangesTriggerSearchFieldsLanguageParsing() {
        
        var moduleUnderTest = generateInstance("ReportBuilderSearchField");

        // put together a mock context.
        var workerContext = new Splunk.Context();
        // crazy black magic that ensures that this will be one instance to rule them all
        // even when modules think they have safely cloned the context. 
        workerContext.clone = function() {return this}

        var testString = "if you can read this we must be close to shipping."
        // and we do the same neat trick as search_field.html, whereby we make the 
        // crazy web2.0 code all synchronous again.
        // in a nutshell this wires the code that initiates the request directly up to the code 
        // that receives the response.
        var workerSearch  = new Splunk.Search("*");
        
        workerSearch.absorbIntentions = function(onSuccess, onFailure) {
            this.parserCallback({"search": testString}, onSuccess, onFailure);          
        }
        // more crazy black magic.
        workerSearch.clone = function() {return this}
        workerContext.set("search", workerSearch);

        
        moduleUnderTest.baseContext = workerContext;
        moduleUnderTest.onContextChange();

        assertEquals("the searchfield should have picked up our fake value.", testString, moduleUnderTest.input.val())
    }
    // NOTE - this test provides a great deal of coverage by permuting every possible valid option in the report builder modules.
    function test_standardHierarchyForErrors() {
        
        var EXPECTED_NUMBER_OF_CASES = 186;

        var reportBuilderModules = buildHierarchy("standard");
        // in this test we're not testing resurrection so we need to move them all over to the loaded states
        for (var i=0; i<reportBuilderModules.length; i++) {
            reportBuilderModules[i].markPageLoadComplete();
            reportBuilderModules[i].setLoadState(Splunk.util.moduleLoadStates.HAS_CONTEXT);
        }

        var reportTypeModule = reportBuilderModules[0];
        var reportSubTypeModule = reportBuilderModules[1];
        var statChooserModule   = reportBuilderModules[2];
        var singleFieldChooserModule = reportBuilderModules[3];
        var singleSplitByChooserModule = reportBuilderModules[4];
        var caseIndex = 0;
        
        var MODES_WITH_SPLIT_BY = {"timechart":1, "chart":1};
        var TOP_AND_RARE_MODES = {"top":1, "rare":1};
        
        //ensure 'Choose...' option present
        var firstReportTypeOption = $('.ReportType').find('select option:first');
        assertTrue("first option in report type drop down is \"Choose...\"", firstReportTypeOption.text() == 'Choose...')
        
        // TODO the way this gets called could be generalized to an assertionCallback that is passed through the chain and called by the loops when they determine that it's appropriate.  Might be a bit cleaner and might catch weird corner cases with less explicit effort.
        function assertValuesMatch(module, reportType, reportSubType, statOp, fieldName, splitBy) {
            caseIndex++;
        
            var modifiedIntention = module.getModifiedContext().get("search").popIntention("plot");
        
            // setting up so we can print out our options
            var optionList = [reportType, reportSubType];
            if (statOp && statOp!='') optionList.push(statOp)
            optionList.push(fieldName)
            if (splitBy && splitBy!='') optionList.push(splitBy)
            var prefixStr = "iteration #" + caseIndex + " with " + optionList.join(",");
        
            logger.debug("running testcase " + prefixStr);
                
            // Check that everything is as it should be for this case. 
            assertEquals(prefixStr + " should be a plot intention", "plot", modifiedIntention["name"]);
            assertEquals(prefixStr + " should have correct mode", reportType, modifiedIntention["arg"]["mode"]);
            assertEquals(prefixStr + " should have correct subtype ", reportSubType, modifiedIntention["arg"]["splitType"]);
            if (reportType in {"timechart":1, "chart":1}) {
                assertEquals(prefixStr + " should have correct stat ", statOp, modifiedIntention["arg"]["fields"][0][0]);
                assertEquals(prefixStr + " should have correct field name", fieldName, modifiedIntention["arg"]["fields"][0][1]);
            } 
            else if (reportType in TOP_AND_RARE_MODES) {
                assertEquals(prefixStr + " should have correct field name", fieldName, modifiedIntention["arg"]["fields"][0]);
            }
            else {
                assertEquals("black is white, up is down, a testcase is NOT IMPLEMENTED FOR mode=" + reportType, false, true)
            }
            if (splitBy) {
                assertEquals(prefixStr + " should have correct splitBy ", splitBy, modifiedIntention["arg"]["splitby"]);
            } 
            else {
                assertEquals(prefixStr + " should have no splitBy ", false, modifiedIntention["arg"].hasOwnProperty("splitby"));
            }
        }
                    
        var perSplitByFunction = function(i, pulldownOption, reportType, reportSubType, statOp, fieldName) {
            var splitBy = $(pulldownOption).val();
            // this pulldown has a '(Choose)' value in it that we skip
            if (!splitBy) return false;
            singleSplitByChooserModule._selectElement.val(splitBy).change();
                            
            assertValuesMatch(singleSplitByChooserModule, reportType, reportSubType, statOp, fieldName, splitBy);
        }
        var perFieldChooserFunction = function(k, pulldownOption, reportType, reportSubType, statOp) {
            var fieldName = $(pulldownOption).val();
            singleFieldChooserModule._selectElement.val(fieldName).change()

            if (reportType in MODES_WITH_SPLIT_BY) {
                if (reportSubType == "single") {
                    $("option", singleSplitByChooserModule.container).each(function(l, splitByOption) {
                        perSplitByFunction(l, splitByOption, reportType, reportSubType, statOp, fieldName);
                    });
                } else if (reportSubType == "none"){
                    assertValuesMatch(singleSplitByChooserModule, reportType, reportSubType, statOp, fieldName);
                }
            } else if (reportType in TOP_AND_RARE_MODES) {
                assertValuesMatch(singleSplitByChooserModule, reportType, reportSubType, statOp, fieldName);
            }
            else {
                assertEquals("black is white, up is down, a testcase is NOT IMPLEMENTED FOR mode=" + reportType, false, true)
            }
        }

        var perStatOpFunction = function(j, pulldownOption, reportType,reportSubType) {
            var statOp = $(pulldownOption).val();

            statChooserModule._selectElement.val(statOp).change()

            $("option", singleFieldChooserModule.container).each(function(k,option) {
                perFieldChooserFunction(k,option,reportType,reportSubType, statOp)
                        });
        }
        var perSubTypeFunction = function(i, pulldownOption, reportType) {
            var reportSubType = $(pulldownOption).val();
            reportSubTypeModule._selectElement.val(reportSubType).change()

            $("option", statChooserModule.container).each(function(j,option) {
                perStatOpFunction(j,option,reportType,reportSubType)
            });    
        }

        
        // actually start the combinations -- go through each 'reportType' value.  
        // NOTE - for clarity we could call this anonymous function 'perReportTypeFunction' 
        //        but we dont need to cause it's the outermost one.
        $("option[value]", reportTypeModule.container).each(function(i, reportTypeOption) {
            
            var reportType = $(reportTypeOption).attr("value");
            
            // dont test disabled or empty options
            if ($(reportTypeOption).prop("disabled") || reportType == "" && $(reportTypeOption).text() == "Choose...") return;

            // mimic the user setting the reportType to this value
            reportTypeModule._selectElement.val(reportType).change();
            
            // we proceed slightly differently for different reportTypes
            if (reportType in MODES_WITH_SPLIT_BY) {
                // for these we now permute every subType.
                $("option", reportSubTypeModule.container).each(function(j,option) {
                    perSubTypeFunction(j,option, reportType);
                });            
            } else if (reportType in TOP_AND_RARE_MODES) {
                // for these we skip directly to permuting every field.
                $("option", singleFieldChooserModule.container).each(function(k,option) {
                    perFieldChooserFunction(k,option,reportType)
                });        
                //TODO - we could check that reportSubType is also not visible.
            }
            else {
                assertEquals("black is white, up is down, a testcase is NOT IMPLEMENTED FOR mode=" + reportType, false, true)
            }
        });
        
        assertEquals("we should have gone through a total of exactly " + EXPECTED_NUMBER_OF_CASES + " cases", EXPECTED_NUMBER_OF_CASES, caseIndex);
    }


    // ******************************************
    // RESURRECTION TESTS.
    // ******************************************

    var plotIntentionArgCasesForResurrection = [
        {
            "mode" : "timechart",
            "fields" : [["count", "component"]]
        },
        {
            "mode" : "timechart",
            "fields" : [["c", "component"]]
        },
        {
            "mode" : "timechart",
            "fields" : [["dc", "eps"]]
        },
        {
            "mode" : "timechart",
            "fields" : [["distinct_count", "component"]]
        },
        {
            "mode" : "timechart",
            "fields" : [["varp", "component"]]
        },
        {
            "mode" : "timechart",
            "fields" : [["avg", "eps"]],
            "splitby" : "component"
        }
    ];

    function runReportTypeCases(classNameUnderTest, cases, argName, preConditions) {
        for (var i=0, lim=cases.length; i<lim; i++) {
            var intention = getPlotIntention();
            intention["arg"][argName] = cases[i];
            
            for (key in preConditions) {
                intention["arg"][key] = preConditions[key];
            }

            var context = wrapIntentionWithContext(intention);
            
            //#1 make sure applyContext resurrects the value into the pulldown
            var moduleUnderTest = generateInstance(classNameUnderTest);
            moduleUnderTest.applyContext(context);
            moduleUnderTest.baseContext = context;

            assertEquals("we should have able to restore this " + argName + " as the pulldown value", cases[i], moduleUnderTest._selectElement.val());
            
            // #2 make sure applyContext removes the resurrected value from the context
            var postResurrectionContext = context.clone();
            var postResurrectionSearch  = context.get("search");
            assertEquals("after restoring the " + argName + ", the context should not have ANY value for " + argName, false, postResurrectionSearch.popIntention("plot")["arg"].hasOwnProperty(argName));

            // #3 make sure that subsequent calls to getModifiedContext return a context with the correct intention value.
            var modifiedSearch = moduleUnderTest.getModifiedContext().get("search");
            assertEquals("after restoring the " + argName + ", calls to getModifiedContext should produce that " + argName, cases[i], modifiedSearch.popIntention("plot")["arg"][argName]);
        }
    }
    
    function test_ReportType_resurrection() {
        runReportTypeCases("ReportType", ["timechart", "top", "rare", "chart"],  "mode");
    } 
    function test_ReportSubType_resurrection() {
        runReportTypeCases("ReportSubType", ["none", "single"],  "splitType", {"mode" : "timechart"});
    }

    function test_overallResurrection() {
        
        var cases = plotIntentionArgCasesForResurrection;
        for (var i=0,lim=cases.length; i<lim; i++) {
            // SETUP
            var reportBuilderModules = buildHierarchy("standard");

            var jsonSearch = {"intentions" : [{"name" : "plot", "arg" : cases[i]}]};
            var resurrectedSearch = Splunk.Search.resurrect(jsonSearch);
            var context = new Splunk.Context();

            context.set("search", resurrectedSearch);

            Splunk.Globals['ModuleLoader'].startResurrection(context, [reportBuilderModules[0]]);
            
            // RESURRECT
            logger.debug("testing case " + i);
            reportBuilderModules[0].printHierarchy();
            for (var j=0; j<reportBuilderModules.length; j++) {
                var intentionReference = reportBuilderModules[j].getContext().get("search").getIntentionReference("plot");
                assertTrue('all modules should have gotten the base context resurrected, testing moduleType=' + reportBuilderModules[j].moduleType, intentionReference.hasOwnProperty("name"));
                intentionReference = reportBuilderModules[j].getModifiedContext().get("search").getIntentionReference("plot");
                assertTrue('all modules should have gotten the modified context resurrected, testing moduleType=' + reportBuilderModules[j].moduleType, intentionReference.hasOwnProperty("name"));
            }
            
            
            // check output of the hierarchy matches the intention we wanted to resurrect.
            var deepestModule = reportBuilderModules[reportBuilderModules.length-1];
            
            var context = deepestModule.getModifiedContext();

            var intentionArg = context.get("search").getIntentionReference("plot")["arg"];
            
            var normalizedStatMap = {"distinct_count": "dc", "varp": "var", "c": "count"};

            assertEquals("should have the right mode", "timechart", intentionArg["mode"]);
            if (cases[i].hasOwnProperty("fields")) {
                var expectedStatOp = cases[i]["fields"][0][0]  ;
                if (normalizedStatMap.hasOwnProperty(expectedStatOp)) {
                    expectedStatOp = normalizedStatMap[expectedStatOp];
                }
                assertEquals("statop should be the same", expectedStatOp, intentionArg["fields"][0][0]);
                assertEquals("field name should be the same", cases[i]["fields"][0][1], intentionArg["fields"][0][1]);
                //assertEquals("fields should be the same", true, Splunk.util.objectSimilarity(cases[i].fields, intentionArg.fields));
            } else {
                assert('test case had no fields so the modified context should not either', false, intentionArg.hasOwnProperty("fields"))
            }
            if (cases[i].hasOwnProperty("splitby")) {
                assertEquals("splitby should be the same", cases[i]["splitby"], intentionArg["splitby"]);

            } else {
                assertEquals('test case had no splitby so the modified context should not either', false, intentionArg.hasOwnProperty("splitby"))
            }
            assertEquals("should have the right mode", cases[i]["mode"], intentionArg["mode"]);
            
        }
        
        //Splunk.Module.startResurrection(reportBuilderModules[0], context);

    }

    // ******************************************
    // ADVANCED MODE TESTS
    // ******************************************
    function test_AdvancedModeToggle() {

        var moduleUnderTest = generateInstance("AdvancedModeToggle");
        assertFalse("advanced mode should default to false", moduleUnderTest.getModifiedContext().get("reporting.advancedMode"));

        var link = $('.advancedModeToggle', moduleUnderTest.container);
        link.click();
        assertTrue("advanced mode should now be true", moduleUnderTest.getModifiedContext().get("reporting.advancedMode"));

        link.click();
        assertFalse("advanced mode should now be false again", moduleUnderTest.getModifiedContext().get("reporting.advancedMode"));
    }

    function test_ReportBuilderSearchField() {
        //Splunk.Module.startResurrection(reportBuilderModules[0], context);

        var moduleUnderTest = generateInstance("ReportBuilderSearchField");
        var advancedModeToggle = generateInstance("AdvancedModeToggle");
        
        advancedModeToggle.addChild(moduleUnderTest);
        
        advancedModeToggle.markPageLoadComplete();
        advancedModeToggle.setLoadState(Splunk.util.moduleLoadStates.HAS_CONTEXT);
        
        moduleUnderTest.markPageLoadComplete();
        moduleUnderTest.setLoadState(Splunk.util.moduleLoadStates.HAS_CONTEXT);
        
        assertEquals("searchField should load disabled at first.", true, moduleUnderTest.input.prop("disabled"));
        advancedModeToggle.getModifiedContext = function() { 
            var context = this.getContext();
            context.set("reporting.advancedMode", true);
            return context;
        };
        advancedModeToggle.pushContextToChildren();
        assertEquals("searchField should now be enabled", false, moduleUnderTest.input.prop("disabled"));

        advancedModeToggle.getModifiedContext = function() { 
            var context = this.getContext();
            context.set("reporting.advancedMode", false);
            return context;
        };
        advancedModeToggle.pushContextToChildren();

        assertEquals("searchField should now be disabled again", true, moduleUnderTest.input.prop("disabled"));
    }

    function test_OverallAdvancedMode() {
        
        var advancedModules = buildHierarchy("advanced");
        // in this test we're not testing resurrection so we need to move them all over to the loaded states
        for (var i=0; i<advancedModules.length; i++) {
            advancedModules[i].markPageLoadComplete();
            advancedModules[i].setLoadState(Splunk.util.moduleLoadStates.HAS_CONTEXT);
        }

        var advancedModeSwitcher = advancedModules[0];
        var searchField = getModuleReferenceFromHierarchy(advancedModules, "ReportBuilderSearchField")
        
        assertEquals("searchField should still load disabled at first.", true, searchField.input.prop("disabled"));


        //click the advanced mode link. 
        var link = $('.advancedModeToggle', advancedModeSwitcher.container);
        var basicModeToggleText = link.text();
        link.click();
        assertNotEquals("link text should have changed to something else", basicModeToggleText, link.text());
        assertEquals("searchField should now be enabled", false, searchField.input.prop("disabled"));

        //click the link again
        link.click();
        assertEquals("link text should have changed back to initial value", basicModeToggleText, link.text());
        assertEquals("searchField should now be disabled again", true, searchField.input.prop("disabled"));
    }

    


    // ******************************************
    // MULTIPLE SERIES TESTS
    // ******************************************

    function test_MultipleSeriesMode() {

        function isAddLinkVisible(statOpModule) {
            return $("fieldset", statOpModule.container).hasClass("showAdditional");
        }
        function isDeleteLinkVisible(singleFieldChooserModule) {
            return $("fieldset", singleFieldChooserModule.container).hasClass("showDeleteLinks");
        }

        function checkIntentionCases(module, expectedFieldList) {
            var plotIntention = module.getModifiedContext().get("search").popIntention("plot");
            var fields = plotIntention["arg"]["fields"];
            assertEquals("we should have the right number of fields in the plot intention", expectedFieldList.length, fields.length);
            for (var i=0; i<expectedFieldList.length; i++) {
                assertEquals("checking statop ", expectedFieldList[i][0], fields[i][0]);
                assertEquals("checking field name ", expectedFieldList[i][1], fields[i][1]);
            }
        }

        var reportBuilderModules = buildHierarchy("advanced");
        
        // in this test we're not testing resurrection so we need to move them all over to the loaded states
        for (var i=0; i<reportBuilderModules.length; i++) {
            reportBuilderModules[i].markPageLoadComplete();
            reportBuilderModules[i].setLoadState(Splunk.util.moduleLoadStates.HAS_CONTEXT);
        }

        // misguided attempt to make this test independent of additional modules we might put into the 'advanced' hierarchy.
        var reportType         = getModuleReferenceFromHierarchy(reportBuilderModules, "ReportType");
        var reportSubType      = getModuleReferenceFromHierarchy(reportBuilderModules, "ReportSubType");
        var statOps             = [getModuleReferenceFromHierarchy(reportBuilderModules, "StatChooser")];
        var singleFieldChoosers = [getModuleReferenceFromHierarchy(reportBuilderModules, "SingleFieldChooser")];
        
        // put us in timechart.
        reportType._selectElement.val("timechart").change();

        // we'll pull intentions from the last Module in the chain
        var lastModule = reportBuilderModules[reportBuilderModules.length-1];

        var firstAddSeriesLink = $(".insertAdditionalSeries", statOps[0].container);

        var originalStatOpId = statOps[0].container.attr("id");

        assertEquals("the 'add new' link should be hidden", false, isAddLinkVisible(statOps[0]));
        
        assertEquals("at the very beginning first statop should be visible", true, statOps[0].container.is(":visible"));
        assertEquals("at the very beginning first fieldChooser should be visible", true, singleFieldChoosers[0].container.is(":visible"));
        
        

        
        reportSubType._selectElement.val("multiple").change();
        assertEquals("the 'add new' link should be visible now", true, isAddLinkVisible(statOps[0]));
        
        assertEquals("switching to multiple, first statop should be visible", true, statOps[0].container.is(":visible"));
        assertEquals("switching to multiple, first fieldChooser should be visible", true, singleFieldChoosers[0].container.is(":visible"));
        
        
        reportSubType._selectElement.val("single").change();
        assertEquals("the 'add new' link should be hidden again", false, isAddLinkVisible(statOps[0]));

        reportSubType._selectElement.val("multiple").change();
        assertEquals("the 'add new' link should be visible again", true, isAddLinkVisible(statOps[0]));

        

        

        assertEquals("the additional modules arent there yet", 0, $("#" + originalStatOpId + "_clone").length);
        assertEquals("we should only have one StatChooser", 1, $(".StatChooser").length);
        assertEquals("we should only have one SingleFieldChooser", 1, $(".SingleFieldChooser").length);
        assertEquals("first module should have NO delete link", false, isDeleteLinkVisible(singleFieldChoosers[0]));
        
        // Click to add a second series.
        firstAddSeriesLink.click();
        
        assertEquals("we should have two StatChoosers", 2, $(".StatChooser").length);
        assertEquals("we should have two SingleFieldChoosers", 2, $(".SingleFieldChooser").length);

        assertEquals("our 'add new' link should be hidden again (cause there's now a new one", false, isAddLinkVisible(statOps[0]));

        assertEquals("singleFieldChooser should have 1 child", 1, singleFieldChoosers[0]._children.length);
        assertEquals("singleFieldChooser should have 1 grandchild", 1, singleFieldChoosers[0]._children[0]._children.length);
        
        statOps[1] = singleFieldChoosers[0]._children[0];
        singleFieldChoosers[1] = statOps[1] ._children[0];

       
        assertEquals("first module should have a delete link now", true, isDeleteLinkVisible(singleFieldChoosers[0]));

        assertEquals("we should have a new add link visible", true, isAddLinkVisible(statOps[1]));

        // test that the fields arg come through ok. 
        var expectedVals = [["avg", "eps"], ["dc", "component"]];
        statOps[1]._selectElement.val(expectedVals[1][0]).change();
        singleFieldChoosers[1]._selectElement.val(expectedVals[1][1]).change();
        statOps[0]._selectElement.val(expectedVals[0][0]).change();
        singleFieldChoosers[0]._selectElement.val(expectedVals[0][1]).change();
        checkIntentionCases(lastModule, expectedVals);




        var secondAddSeriesLink = $($(".insertAdditionalSeries", statOps[1].container)[0]);

        secondAddSeriesLink.click();
        
        assertEquals("we should have three StatChoosers", 3, $(".StatChooser").length);
        assertEquals("we should have three SingleFieldChoosers", 3, $(".SingleFieldChooser").length);

        statOps[2] = singleFieldChoosers[1]._children[0];
        singleFieldChoosers[2] = statOps[2]._children[0];


        var firstDeleteLink = $(".deleteSeries", singleFieldChoosers[0].container);
        firstDeleteLink.click();
        assertEquals("we should have gone back to 2 StatChoosers", 2, $(".StatChooser").length);
        assertEquals("we should have gone back to 2 SingleFieldChoosers", 2, $(".SingleFieldChooser").length);

        
        assertEquals("after first delete click, first statop should be visible", true, statOps[0].container.is(":visible"));
        assertEquals("after first delete click, first fieldChooser should be visible", true, singleFieldChoosers[0].container.is(":visible"));
        
        assertEquals("after first delete click, second statop should NOT be visible", false, statOps[1].container.is(":visible"));
        assertEquals("after first delete click, second fieldChooser NOT should be visible", false, singleFieldChoosers[1].container.is(":visible"));
        
        assertEquals("after first delete click, third statop should be visible", true, statOps[2].container.is(":visible"));
        assertEquals("after first delete click, third fieldChooser should be visible", true, singleFieldChoosers[2].container.is(":visible"));

        reportSubType._selectElement.val("single").change();
            
        assertEquals("check that the first statOp is visible now", true, statOps[0].container.is(":visible"));
        assertEquals("check that the first SingleFieldChooser is visible now", true, singleFieldChoosers[0].container.is(":visible"));

        assertEquals("check that the other statops are not visible now", false, statOps[1].container.is(":visible"));
        assertEquals("check that the other ones are not visible now", false, singleFieldChoosers[1].container.is(":visible"));

        assertEquals("check that the other statops are not visible now", false, statOps[2].container.is(":visible"));
        assertEquals("check that the other ones are not visible now", false, singleFieldChoosers[2].container.is(":visible"));
    }

</script>